Thanks -- I've fixed that.  (The funny thing is that just 2-3 days ago I finally changed the url on the plt account, but missed this one.)

Jay merged this.

This was resolved a few days ago.

Merged.

Merged to the tree.

Merged.

Pushed a slightly improved version of these changes.

I think the commit d4a87ef address all of the comments up till now. There is currently one failing unit-test, but the problem is fixed in master. I don't know if I can rebase from master and keep all of these comments on the pull request. Should I continue to add more identifiers to this pull request, or make sure it is good enough to pull to master and start another one for the other identifiers?

You should just fix the one failing test in this pull request, and I'll handle the merging/rebasing/pushing/etc.  

I'm not sure what the fix is, but I'm pretty sure it is included in
the difference between this and HEAD. This is because the commit that
Vincent made yesterday:

https://github.com/plt/racket/commit/26541ffbbdccf7d27db1f1ae439430090fcb4b0b

tests the same thing (and it passes there). So the rebase should fix it.

On Fri, Jun 17, 2011 at 11:44 AM, samth
reply@reply.github.com
wrote:

> You should just fix the one failing test in this pull request, and I'll handle the merging/rebasing/pushing/etc.
> 
> ## 
> 
> Reply to this email directly or view it on GitHub:
> https://github.com/plt/racket/pull/16#issuecomment-1388965

Ok, working on the merge now.  Should push soon.

Other than the comments I've made, it all looks good.

Merged, with some differences -- the ()s are not needed in the regexp (and the test is moved to a slightly better place).

This latest commit should address all of the comments. I know that I have no tests for any of these identifiers, and am wondering what kinds of tests should be included?

Definitely some integration tests for thread cells, threads, etc are needed.  Probably for parameterization stuff too.  The other stuff should be fine with unit tests.

I am trying to understand how I should be writing the unit tests. The tests that I am writing seem to be to just rewriting the type I annotated the identifier with in a different form. Should I be making sure that every identifier has a test, or every type has a couple of tests, or what?

That should address all of the comments. I manually checked for types that should be exported but are not. I didn't find any that were not internal, except maybe Pattern.

Something seems wrong with this pull request.  Why does it have my and Jay's commits in it?

That was because github was not mirrored correctly at the time I made the pull request, I assumed that it would reduce to my commit when github was up to date but it looks like it wasn't. I'll remake it.

On Jun 26, 2011, at 2:22 PM, samth wrote:

> Something seems wrong with this pull request.  Why does it have my and Jay's commits in it?
> 
> ## 
> 
> Reply to this email directly or view it on GitHub:
> https://github.com/plt/racket/pull/25#issuecomment-1442038

Merged in.

This commit should address everything but the duplicated code (which has its own Pull Request now). The changes to make require/typed different in typed/scheme are forthcoming. 

[sent this via email, I don't know why it didn't show up here.]

This problem is bigger than this kind of a change.  It's bigger in
scope: covering more uses of special kind of tansformers like the ones
used by `match`, custom ffi types, for loop iterators, and
require/provide macros.  We've recently discussed a generalized `set!`
form, one that knows how to map accessor identifiers into setters --
and that runs into the same issue too.  Things will get even worse
once these things start colliding -- something that didn't happen so
far using naming conventions.

A proper solution should do more than this -- we've basically talked
about having a kind of micro namespace facility, where an identifier
can come with additional attached bindings, so you can have some
`foo`, and you can attach to it all of these extra things and provide
them in addition to `foo`.

Ok, I'll just duplicate the code in TR and mark it to be cleaned up if this feature is ever created.

Yeah, a FIXME would be good there, with an indication of the original code so it'll be easy to fix it in the same way when the time comes.

Merged.

Merged.

I don't see why this wouldn't be a useful step in the right direction.  Adding this function doesn't make adding the more general solution harder in the future.

Test.

## 

```
      ((lambda (x) (x x)) (lambda (x) (x x)))          Eli Barzilay:
                http://barzilay.org/                   Maze is Life!
```

An hour and a half ago, samth wrote:

> I don't see why this wouldn't be a useful step in the right
> direction.  Adding this function doesn't make adding the more
> general solution harder in the future.

It wouldn't be useful if this code means more core work to adapt later
on.  To make it similar to what I talked about earlier, the interface
should be different: instead of just letting you define applicable
structs to make up your own transformers, make a single such strcut
that can carry arbitrary information with it -- and that information
would be in the form of some hash-table (or hash-table-like) where you
can get the values that are associated with a transformer based on a
given key.

(And what I previously talked about changes this so instead of
querying the transformer, it will query the identifier -- but it will
retain the feature of getting a value for a given key.  These keys
would be these "micro namespace" things, where each extension (eg,
`match') defines its own key value).

## 

```
      ((lambda (x) (x x)) (lambda (x) (x x)))          Eli Barzilay:
                http://barzilay.org/                   Maze is Life!
```

About a minute ago, Eli Barzilay wrote:

> It wouldn't be useful if this code means more core work to adapt
> later on.  To make it similar to what I talked about earlier, the
> interface should be different: instead of just letting you define
> applicable structs to make up your own transformers, make a single
> such strcut that can carry arbitrary information with it -- and that
> information would be in the form of some hash-table (or
> hash-table-like) where you can get the values that are associated
> with a transformer based on a given key.

(And in case it wasn't clear -- if you do this, then it's perfectly
fine to commit, and even better if you use it in `match' too.)

## 

```
      ((lambda (x) (x x)) (lambda (x) (x x)))          Eli Barzilay:
                http://barzilay.org/                   Maze is Life!
```

On Fri, Jul 1, 2011 at 2:03 AM, elibarzilay
reply@reply.github.com
wrote:

> About a minute ago, Eli Barzilay wrote:
> 
> > It wouldn't be useful if this code means more core work to adapt
> > later on.  To make it similar to what I talked about earlier, the
> > interface should be different: instead of just letting you define
> > applicable structs to make up your own transformers, make a single
> > such strcut that can carry arbitrary information with it -- and that
> > information would be in the form of some hash-table (or
> > hash-table-like) where you can get the values that are associated
> > with a transformer based on a given key.
> 
> (And in case it wasn't clear -- if you do this, then it's perfectly
> fine to commit, and even better if you use it in `match' too.)

But this isn't about general applicable structs.  It's about
applicable versions of things that are `struct-info?', which is a much

## more specific desire, and one that belongs where Eric put it.

sam th
samth@ccs.neu.edu

Three hours ago, samth wrote:

> But this isn't about general applicable structs.  It's about
> applicable versions of things that are `struct-info?', which is a
> much more specific desire, and one that belongs where Eric put it.

"replaces uses of itself with the identifier returned by
@racket[id-thunk]."

## 

```
      ((lambda (x) (x x)) (lambda (x) (x x)))          Eli Barzilay:
                http://barzilay.org/                   Maze is Life!
```

On Fri, Jul 1, 2011 at 10:17 AM, elibarzilay
reply@reply.github.com
wrote:

> Three hours ago, samth wrote:
> 
> > But this isn't about general applicable structs.  It's about
> > applicable versions of things that are `struct-info?', which is a
> > much more specific desire, and one that belongs where Eric put it.
> 
> "replaces uses of itself with the identifier returned by
> @racket[id-thunk]."

Certainly, but that doesn't change my point that this is specific to

## struct-info.

sam th
samth@ccs.neu.edu

Merged

This patch reveals a bug in TR, because TR doesn't handle kernel structs correctly. A fix is forthcoming.

Merged.

Merged.

Merged.

Merged.

Merged

Merged.

We intentionally use POINTER_MOTION_HINT_MASK instead of POINTER_MOTION_MASK.
If you want to discuss this further, you're welcome to do so on the dev mailing list. That's the easiest way to reach the people responsible for that part of the code.

Matthew replied and merged.

Merged.

Merged.

bleh 1125

A few seconds ago, elibarzilay wrote:

> testing 1125

Replying from github@plt-scheme.org.

blah

## 

```
      ((lambda (x) (x x)) (lambda (x) (x x)))          Eli Barzilay:
                http://barzilay.org/                   Maze is Life!
```

Added a testbug label

Closing 1133

comment after reopenning.  1136

comment after re-re-open 1137

Merged

Merged.

Thanks, this was due for a while...
Touched up and merged.

I like having the code move out of units into a module, but I think it's better to keep the units (implemented with `unit-from-context') and signatures around for compatibility. With that, I'd also leave SirMail alone as a kind of test for the compatibility layer.

A good reference for this is b207f105, where Jay de-unitized `cookie.rkt` and left a compatibility stub file.  It will also be good to have some notes in the docs about the unit and sig files being a backward compatibility thing that will probably go away at some point.

The backward-compatibility issue occurred to me, but I didn't bring it up, since the project was described, rather unequivocally, as "Get rid of units in the net collect."

Closing request.

There's no need to dump the whole thing -- see how the cookie unit is done, it makes it easy to tweak your commit into something that has the backward compatible files.

d93e466 seems unrelated.
Also, please get rid of the merge commits.

Cleaned up the commit. 

The latest commit adds a tests for the different forms added, along with updated documentation. Should be good for merging now.

At home. Realized the implementation on match-define-values will give a syntax error when there is a similar bound variable across values patterns. Don't currently have a good fix in mind since it requires omitting the nth value in the appended list when n is the position of a second+ occurrence of a bound variable. Do not merge yet.

I think the way to do it is first, to remove the duplicate variables using `bound-identifier=?`, and then use something like `(define-values (x ...) (match/values e [(p ...) (values x ...)]))` as the expansion for `match-define-values`.

Merged all.  (With minor tweaks for whitespaces and some of the comments.)

Merged.

Merged.

Merged.

These are pretty complicated types.  Can you (a) explain a little more about what was wrong, and (b) add a comment in the source giving a bit of description?

So I added a fairly healthy comment to the source. The type was not wrong, just imprecise. Similar to the type of + is not (-> Number Number Number). Subprocess has three arguments which can be ports or #f, there are 3 return types which are also ports or #f. They are linked in that if the argument is #f, the return value is a port and visa-versa. This patch just adds cases so that that fact is now encoded in the type system.

This is actually useful because if I do (subprocess #f #f #f "/bin/bash" ...), I know that the values will be ports and do not have to add in code that won't ever be run to appease the type system.

Ok, that makes sense.  I'll take another look with that in mind.

Merged (into my tree, will be pushed out soon)  -- thanks!

This is now merged.

Merged, thanks!

Merged, thanks.

Merged, thanks!

Nothing to see here, move along.

blah

Merged.

Merged.

Moved to: http://bugs.racket-lang.org/query/?cmd=view&pr=12383

I change `stream-empty` to `empty-stream` and I added some tests.

You should add a version that "splits" the set into an element and a new set -- that's the only way to write proper recursive algorithms on sets.  It should use multiple values to return the two elements.

I created a different pull request which has the desired changes and uses a different naming scheme. 
See: #65 

Matthew merged a modified version of this.

Merged.

Can you describe at a high level what changes you've made?

The changes try to clarify the prose, mostly by making it more
grammatically rigorous.  But please note that they do not improve it
enough, so I'd need to make one or two more passes before I felt reasonably
satisfied.  I've also not been painstaking enough about formatting (e.g.,
linked references), and I've already noticed the inevitable introduction of
a couple of errors of my own (easily corrigible).

On Tue, Dec 20, 2011 at 11:11 AM, Sam Tobin-Hochstadt <
reply@reply.github.com

> wrote:
> 
> Can you describe at a high level what changes you've made?
> 
> ---
> 
> Reply to this email directly or view it on GitHub:
> https://github.com/plt/racket/pull/67#issuecomment-3220887

I should add that the most extensive changes were made to the section on formlets.

Fixed in ae1ca5b91a88e6241b58a3d73c9b5f24263d12e9

Jay merged this.

i found another error.  closing this pull request so i can reopen a future pull request based off the future-current head with a branch that has more all the patches together.

oops, i intended this pull request to go to the release branch.  it's just the last 2 commits.  i could rebase my two commits onto the current master if you want.

sorry about that.

Merged, and will push soon.

Merged, and will be pushed soon.

Thanks -- merged, finally.

Merged, thanks!

Merged, thanks!

Your welcome.

Bit of a github noob, me.
Is it typical behaviour to delete the fork I created?

Tim
On 2 Feb 2012 17:46, "Eli Barzilay" <
reply@reply.github.com>
wrote:

> Merged, thanks!
> 
> ---
> 
> Reply to this email directly or view it on GitHub:
> https://github.com/plt/racket/pull/73#issuecomment-3782531

If you don't plan to do any further changes then it would be fine to remove it.  Otherwise, you can just update it and it should see that the changes were merged and get you to the recent state.

Merged (as a single commit) -- thanks!

I noticed that `collects/scribblings/drracket/extending.scrbl' has a misspell: "indicies".
According to the dictionaries that I have available, the plural form for "index" could be either "indexes" or "indices".
I did not proceed with the change because grep showed me other occurrences of that word, including:
- collects/racket/contract/private/arr-i.rkt
- collects/string-constants/private/russian-string-constants.rkt

Merged -- and I also fixed all of the "indicies" in the tree.  (None were used in a public way.)

Good :)
Thanks.

All merged (as a single commit) -- thanks!

Merged, as a single commit, with the other request -- thanks!

All merged, as a single commit, with the other request -- thanks!

Fixed (using your patch).

Merged -- thanks!

Merged -- thanks!

One note: you had a merge commit that looks like a result of Robby's changes, so I assumed that there was no real change there.

Merged & pushed -- thanks!
(With a slightly revised commit message.)

Ian, can you rebase this on top of HEAD?

Done.
-Ian
----- Original Message -----
From: "Sam Tobin-Hochstadt" reply@reply.github.com
To: "ianj" ianj@ccs.neu.edu
Sent: Friday, March 9, 2012 3:28:48 PM GMT -05:00 US/Canada Eastern
Subject: Re: [racket] Added the ability to disambiguate between citations using autobib. (#85)

Ian, can you rebase this on top of HEAD?

---

Reply to this email directly or view it on GitHub:
https://github.com/plt/racket/pull/85#issuecomment-4424025

Merged, and will be pushed soon.

Merged and will be pushed soon.

@samth -- should this be merged?

Eli, I'll try to review this today.

Ian, I made one small formatting comment, but the important thing to do here is add some tests.  See `collects/tests/scribble/docs/`, where you can add a `.scrbl` file and a corresponding `.txt` file showing the desired rendering.

I have some tests written. How do I actually run them to make sure I made them correctly?
-Ian
----- Original Message -----
From: "Sam Tobin-Hochstadt" reply@reply.github.com
To: "ianj" ianj@ccs.neu.edu
Sent: Monday, March 12, 2012 2:09:53 PM GMT -05:00 US/Canada Eastern
Subject: Re: [racket] Added the ability to disambiguate between citations using autobib. (#85)

Ian, I made one small formatting comment, but the important thing to do here is add some tests.  See `collects/tests/scribble/docs/`, where you can add a `.scrbl` file and a corresponding `.txt` file showing the desired rendering.

---

Reply to this email directly or view it on GitHub:
https://github.com/plt/racket/pull/85#issuecomment-4457972

Ian, this now looks good to me.  If you rebase it again, I'll merge it.

This is now merged.  

test message

another
test
message

Merged, and will be pushed soon -- thanks!

Merged, and will be pushed out soon.

Sorry, I create a pull request instead. Please refer to issue 91. Thanks.

Thanks, I'll pass this along to Robby.

Oops, Excuse my rash pull request. 

Maybe the name for the-splash-bitmap could be also adjust to the-splash-spec, I suggest.

I amended my fork HEAD.

Hi: thanks for sending in a pull request with a fix!

We've already fixed this in a different way, but in case you're interested here are a few comments on your commit.

Lines 141, 144, and 147 are there simply to avoid loading the bitmaps multiple times, so adding read-bitmap there is not a good idea. (Similar reasoning applies to the change on line 172).

As for the change on 107, I ended up just disabling the display of the mars image on Prince Kuhio and King Kamehameha day instead, but it could be better there.

Thanks for your kindly comment. :)

Merged and pushed -- thanks!

Merged and pushed -- thanks!

Merged and pushed -- thanks!

Thanks for generalizing malloc to handle 0; I think that makes sense.

Merged -- thanks.

Thanks Eli.  This is my first time using github and first time contributing to racket.  I'm not sure how to edit an existing pull request commit, so I just made two more commits, one for the newline, and one for the test.  Hope that's ok.

Matthew committed a change that uses `#:fail` now...

Looks like Matthew committed some fix along these lines, right?  (I'm closing it based on this assumption.)

Confirmed; it's in master.  Ok, cool.

Thanks!  -- no problem with the multiple commits, I squashed them all and revised the commit message a bit.  (I also reformatted the code a little.)  It will be pushed shortly.

whoops! sorry for including b988d2c; please ignore that commit. (it's already been fixed)

Merged, slightly tweaked: "screen" and "keyboard" can have a different meaning whether you're in a shell or in DrRacket, for example...

Merged...

Merged, and will be pushed soon -- thanks!

I've not checked this with respect to "some fids cannot be polled" or other subtleties with the racket polling system

Closing.

Could you remove the "typescript" file?

Nevermind, did it myself.

Now merged.

Merged.

Merged.

Also, please include a blank line between the summary and the rest of the commit message.

Merged -- thanks.

@mflatt or @tim-brown, is this pull request fully merged?

Sam,

On 2 Jun 2012 17:52, "Sam Tobin-Hochstadt" <
reply@reply.github.com>
wrote:

> @mflatt or @tim-brown, is this pull request fully merged?

Just checked, and it's still outstanding. It's really up to Matt and Co to
merge. As far a I'm concerned, Solaris has poll(); and there'll be no less
told by configure if this is merged.

Tim

Ok, thanks @tim-brown. 

I've merged it, finally.

I've resubmitted this on the bugs.racket-lang.org tracker: http://bugs.racket-lang.org/query/?cmd=view&pr=12825

Merged, thanks!

Eli, you can close this.

A few quick comments:
- Why isn't this using `prop:dict/contract`?
- What would be not-backwards-compatible about supporting contracts on the keys?
- I think a combinator like this is the correct way to do things.

- Because I didn't fully understand it when starting this patch, I do think it is the way to go. It will require adding two new fields to the external facing structs but that shouldn't be hard.
- The backwards-compatible breakage would be the argument ordering if we want to make it like hash/c since the key contract is the first argument.
- I think this question was confusing since it was supposed to compare the struct/c approach versus prop:dict/contract approach. And your answers contradicted themselves. But I think there was consensus on  the prop:dict/contract approach.

I'll have a commit with these changes shortly (tonight/tomorrow).

So adding fields to the struct does not work because it does not maintain equality, thus we need to create an impersonator/chaperone to hold the information on the id-table.

So my idea was to have the prop:dict/contracts instance keys lookup an impersonator property which would be a contract. This property would be set to a value by the identfier-table/c contract. The problem with that is that we are now adding another contract boundary into the mix and I think the naive way will blame one of those parties. 

So the situation is 

<pre>
    (module a
      (define id-tbl ...) ; {#'a -> 'a, #'long-identifier -> 3}
      (define short-identifier/symbol? ...)
      (provide/contract
        (id-tbl (free-identifier-table/c short-identfier/symbol? number?))))
    (module b
      (require 'a)
      (define id-tbl-b id-tbl)
      (provide id-tbl-b))
    (module c
      (require 'b)
      (dict-ref id-tbl-b #'long-identifer)
      (dict-ref id-tbl-b 'a)
      (dict-ref id-tbl-b #'a))
</pre>


Those should all blame different parties, the first should blame 'b for not following short-identifier/symbol?. The second should blame the dict-ref call site because it is not providing an identifier which is part of the contract on any identifier-table. The third should blame 'a for not following number?. I could not find a breakage scenario that would blame the fourth party (the dictionary implementation), because that would require a bug in that code.

The problem is that if we use the prop:dict/contract then the parties in the blame are the dict-ref call site and the dictionary implementation. And neither of those should be blamed if the contracts provided to free-identifier-table/c are broken. 

Thus prop:dict/contract seems like a bad solution.

I think the solution is something similar to the struct/c mechanism, but slightly different to improve the error messages.

You know you can use markdown in these comments, right?

No I did not, I am use to formatting as plain text and so did that, which it looks like it mangled.

Ok, now I understand, and I think I agree with you, but I'll ask @sstrickl, who knows this stuff better than me.

To be fair, I've never looked deeply into prop:dict/contract.  Ryan explained to me somewhat his ideas about how blame should work for it, about which I've always had lingering doubts, but I've never spent the time to get more familiar with it, make sure I understood him correctly, and propose an alternate solution that worked more like how I thought it should work.

However, @shekari's comments about this resonate with me in similar ways as to the doubts I had.  However, I'm not sure why the call site should be blamed for just passing 'a, as that seems like it should blame module b as well.  After all, module b is the one that allowed this identifier table escape to a context where someone tried to use it with a non-identifier, and there's nothing inherit in dict-ref (like a contract) that assumes that symbols can't be used as keys for dictionaries.

If there were, then that would indeed be on module c, but all module c knows (from a contract story) is that module b handed it a value with no restrictions (there's no contract between b and c) and thus using that value as a dictionary that maps symbols to things is a-okay and c shouldn't be blamed by the contract system.  I think that thinking of module c as a blame party at all here is part of the reason I wasn't happy with the prop:dict/contract blame story, but I'm not 100%.

I'm not sure that what I've just said is clear, but if there's any questions about it, ask and I'll work on clarifying.

Here's an idea that might be half-baked since I just thought about it. Since we recently converted dictionaries to use generic interfaces (i.e., `gen:dict` in this case), we could build contract combinators that work on instances of generic interfaces to use in situations like these. The combinator could look like `(generic-instance/c gen:foo [method-name ctc] ...)` and would apply a struct chaperone that will redirect the method table struct property accessor to attach contracts to each method implementation. Since you'd apply this at module boundaries with `provide/contract`, it should have the right blame story.

Yeah, thinking about these kinds of issues is why I jumped in when I heard you and @stamourv were thinking about contracts for generics.  That sounds like it'd probably be the right thing, though we should discuss it further at some point.  Might be worth going ahead and making a prototype to play around with, though!

I think that Asumu's suggestion is the correct solution for going
forward with dictionaries accessed through the generic interface.

There is still a need for contracting dictionary implementations that
provide access outside of that interface like identifier tables so
that the 'native' interface still is checked. I think I have the
answer for that, and it is just using chaperones instead of contracts
for the layers of implementation that I want to be hidden in the error
messages. I should have a commit soon showing what I mean, but as the
history of this change showed it might be more complicated than I
think.

I am wondering what a dict/c contract guarantees on immutable dicts. If I export a dict with the contract (dict/c number? string?), and then some one else functionally adds the mapping 'a -> 'b, is this a violation? Currently with immutable hashes and (hash/c number? string?) it is not because it makes a copy not a chaperone, and the contracts are now on each individual key/value. This would not be possible by just chaperoning the procedures in the method table, as we wouldn't be able to detect which values were in the dictionary when the contract was applied. 

The copying approach would require a mechanism for a dict-map over key/value pairs. This wouldn't make sense for a network backed dictionary or any other external data source. It would also require dictionaries to support equality (to support contracts not changing the meaning of a program).

So I have pushed a version that implements the contracts for mutable identifier-tables. Immutable ones are still in progress.

Ugh, sorry, I haven't even been paying attention to this because github stopped sending me notification emails about it and I've been busy getting my latest dissertation draft ready.  I plan on taking a look at this RSN, just to give it some code review, but feel free to poke me via email if I don't post back here within a few days.

In any case, hooray for more contracts!

Merged by Matthew.

Vincent merged it.

Fixed by another change a while ago.

Well I finally got around to adding tests, i.e. actually running the contract code (thus fixed the most glaring of mistakes).

I think it is ready to go in if no one else has comments.

Yes, I think a new `book-chapter-location' would be better, since it took me a while to understand the intent of the change (and then I understood why you suggested an alternate procedure).

Sam merged this.

Pulled in in a different pull request based on this one.

This breaks things at head, I'll work on that.

Diagnosed the issue, the change that did it was the switch of free-identifier-for-each and map depending on the dictionary implementation.

The issue is that dict-iterate-first/next are only guaranteed to work if the dictionary is not mutated by adding or removing entries. Supposedly this should allow for mutation of the values. The problem is that id-tables keep an iteration key of the alist that is used internally. Changing the value changes the alist, making the iteration key invalid.

I think the solution is to change the guarantee that dicts provide and make a way to mutate the key through dict-iterate so that a mutative traversal can be done safely.

I think you should bring this up on the dev list, unless @mflatt has feedback here.

Looks nice and useful.
Did you measure the impact on expansion time?

No, but I'd be happy to. Are there existing benchmarks for expansion?

Not really. `collects/tests/racket/syntax.rktl' has a bunch of tests for`case', so that may be a start. Measuring the timing impact on a full Racket build may also be a good idea.

This sounds like it might be useful, but it should really be discussed on the mailing list (lists.racket-lang.org/dev).  The code size can be an issue too, since larger code means more load time, and perhaps the uses that we have don't get the speedup anyway.  So probably another point to check is the existing uses in the full source tree -- which should be easy to get by adding some logging printout to the new macro definition.

Ryan changed id-tables to fix the bug, I rebased my changes on top now, and the tree compiles cleanly.

I didn't mean that you should close it -- keeping it open is a good way to not forget it.  (But perhaps you don't want do that...)

No, I don't want to forget it, but I've changed the code substantially since I issued the request. The changes were all meant to improve the expansion-time performance, and though they don't seem to have had any impact, I think the code is a bit better organized in my latest version.

I really would like to figure out why this seems to slow down the build and whether anything can be done about it. Even if someone could repeat my results that would be useful.

@rmculpepper, any thoughts?

I'll try to take a closer look soonish, but I may not get to it until the release is done.

This has been merged by @stamourv.

I like the simplifications here, and I think the overall direction is right.  A few comments:
1. It would be good to remove the dependence of `subtype.rkt` on `union.rkt` eventually, but I think this pull request isn't the place to do it.  So I'd just add another `lazy-require` to fix the current compilation failure.
2. Once a module just becomes a combination module, as `convenience.rkt` does here, then just remove it entirely.  It's better to make the dependency structure explicit, and it makes it easier to reduce dependencies later on.
3. Make sure this doesn't add any new runtime dependencies for `typed/racket/base`.  I use `check-requires` for this.  

Both changes have been merged.

Made subtype work, by using lazy-require.

Removed convenience.rkt.

No diffs on the deps, I assumed you meant show-dependencies because that got the recursive deps.

Looks good, I'll try to merge it today.

On Tue, Aug 7, 2012 at 2:41 AM, Eric Dobson notifications@github.com wrote:

> I assumed you meant show-dependencies because that got the recursive deps.

`get-dependencies` will also show recursive dependencies, right?  At
least, it does that for me.

This has now been merged.

I wouldn't worry too much that all the tests are integration tests.  Lots of things are like that, and there's not much way around it for TR.

It looks like there's one problem with this patch.  `succeed/struct-exec.rkt` now fails, with the error messages:

```
succeed/struct-exec.rkt:2:0: Type Checker: untyped identifier make-struct-type imported from module <(quote #%kernel)>
  in: (define-typed-struct/exec X ((a : Number) (b : Boolean)) ((lambda: ((x : X)) (+ 3 (X-a x))) : (X -> Number)))
succeed/struct-exec.rkt:2:0: Type Checker: untyped identifier prop:procedure imported from module <racket/base>
  in: (define-typed-struct/exec X ((a : Number) (b : Boolean)) ((lambda: ((x : X)) (+ 3 (X-a x))) : (X -> Number)))
succeed/struct-exec.rkt:2:0: Type Checker: Expression should produce 5 values, but produces 1 values of types Nothing
  in: (define-typed-struct/exec X ((a : Number) (b : Boolean)) ((lambda: ((x : X)) (+ 3 (X-a x))) : (X -> Number)))
succeed/struct-exec.rkt:2:0: Type Checker: untyped identifier make-struct-field-accessor imported from module <(quote #%kernel)>
  in: (define-typed-struct/exec X ((a : Number) (b : Boolean)) ((lambda: ((x : X)) (+ 3 (X-a x))) : (X -> Number)))
succeed/struct-exec.rkt:2:0: Type Checker: untyped identifier make-struct-field-accessor imported from module <(quote #%kernel)>
  in: (define-typed-struct/exec X ((a : Number) (b : Boolean)) ((lambda: ((x : X)) (+ 3 (X-a x))) : (X -> Number)))
Type Checker: Summary: 5 errors encountered
```

I think this means that your first commit, which changes how `ignore-some` works, is the culprit.  I'll try to have a further look later today.

I cannot look right now, but I think the difference is that ignore-some was
meant to be used only on expressions and ignore was meant to be used on top
level definitions. I changed it to enforce that, and some macros might not
be expanding to the right one.

On Tue, Aug 7, 2012 at 1:28 PM, Sam Tobin-Hochstadt <
notifications@github.com> wrote:

> It looks like there's one problem with this patch. succeed/struct-exec.rktnow fails, with the error messages:
> 
> succeed/struct-exec.rkt:2:0: Type Checker: untyped identifier make-struct-type imported from module <(quote #%kernel)>
>   in: (define-typed-struct/exec X ((a : Number) (b : Boolean)) ((lambda: ((x : X)) (+ 3 (X-a x))) : (X -> Number)))
> succeed/struct-exec.rkt:2:0: Type Checker: untyped identifier prop:procedure imported from module <racket/base>
>   in: (define-typed-struct/exec X ((a : Number) (b : Boolean)) ((lambda: ((x : X)) (+ 3 (X-a x))) : (X -> Number)))
> succeed/struct-exec.rkt:2:0: Type Checker: Expression should produce 5 values, but produces 1 values of types Nothing
>   in: (define-typed-struct/exec X ((a : Number) (b : Boolean)) ((lambda: ((x : X)) (+ 3 (X-a x))) : (X -> Number)))
> succeed/struct-exec.rkt:2:0: Type Checker: untyped identifier make-struct-field-accessor imported from module <(quote #%kernel)>
>   in: (define-typed-struct/exec X ((a : Number) (b : Boolean)) ((lambda: ((x : X)) (+ 3 (X-a x))) : (X -> Number)))
> succeed/struct-exec.rkt:2:0: Type Checker: untyped identifier make-struct-field-accessor imported from module <(quote #%kernel)>
>   in: (define-typed-struct/exec X ((a : Number) (b : Boolean)) ((lambda: ((x : X)) (+ 3 (X-a x))) : (X -> Number)))
> Type Checker: Summary: 5 errors encountered
> 
> I think this means that your first commit, which changes how ignore-someworks, is the culprit. I'll try to have a further look later today.
> 
> —
> Reply to this email directly or view it on GitHubhttps://github.com/plt/racket/pull/121#issuecomment-7565719.

That isn't right for `define-typed-struct/exec`, though, because it expands to a top-level declaration (`define-struct`) but we need to check the internal expression that gives the value for `prop:procedure`.  In general, `ignore` is totally ignored, but `ignore-some` searches for subforms that need to be typechecked.

Tests pass now.
The issue is that ignore some can be on expressions as well as definitions and tc-toplevel should only handle definitions, in its case of ignore-some but doesn't check that. My solution was to make cast wrap its code in #%expression so as to hide it from tc-toplevel.

Can you rebase this on top of current master?

Rebased.

@elibarzilay This can be closed, @ianj says that he'll create a new PR for this when revised.

@rmculpepper, Can you take a look now that the release is done?

This looks good, but you should add one more case in between the two you have, because `flvector-copy` is legal with 1, 2, or 3 arguments.

Yes, will adjust.

OK, should be good to go.

Great, I'll merge it soon.

Woo!

@ntoronto, this is for you.

While this is a good idea, I want to keep around the debugging printing code, which is important when parts of the system that affect printing aren't working.  I think that to enable it, you need to change the definition of `defprinter`, and then uncomment the printer.  But I'm not 100% sure.

Looks good. I'll pull it when I figure out how. :D

Neil, I would have put the patch against your ntoronto/racket tree but it
deviates quite a bit from plt/rackets.  So I wasn't sure.

I mention this as I've made several 100's lines progress in TRing Plot.
So things should start coming your way "real soon now" in hunks and chunks.

Please consider if you'd prefer:
A) I submit against some branch TDB in ntoronto/racket.
B) Against plt/racket master.

My git fu is pretty good so I can accommodate to whatever.

On Sun, Aug 12, 2012 at 10:15 AM, Neil Toronto notifications@github.comwrote:

> Looks good. I'll pull it when I figure out how. :D
> 
> —
> Reply to this email directly or view it on GitHubhttps://github.com/plt/racket/pull/127#issuecomment-7676063.

Keep putting them on plt/racket master. Thanks!

I thought you just had to change the #t to #f for custom-printer in utils/utils.rkt, to enable debug printing.

The only place I see that print-convert is used is for writing out to things that need to be evaled later, and those guard their execution in a parameterize of current-print-convert-hook.

There are some instructions on handling pull requests on git.racket-lang.org
.
On Aug 12, 2012 10:15 AM, "Neil Toronto" notifications@github.com wrote:

> Looks good. I'll pull it when I figure out how. :D
> 
> —
> Reply to this email directly or view it on GitHubhttps://github.com/plt/racket/pull/127#issuecomment-7676063.

It looks like the debug printer doesn't work any differently at all, I'll try and fix it before trying to push this through.

Merged, thanks!

I get errors on a full rebuild with this change (plus some minor refactoring of it by me).  In particular, in the `drracket` collection:

```
Internal Typechecker Error: substitute used on ... variable g3939 in type (arr ((g3940 g3941 ... g3941 -> g3939) (Listof g3940) (Listof g3941) ... g3941 -> (Listof g3939)))
while typechecking:
(#%app map (lambda (x) (#%app format (quote ~a~a) x (#%app get-w-size tmp-bdc x))) (#%app get-face-list16))
originally:
(map (λ: ((x : String)) (format ~a~a x (get-w-size tmp-bdc x))) (get-face-list))
```

and similar.  Do you see that as well, or did I break something with my refactoring?

I fixed substitute, but I couldn't replicate the DrRacket issue even with a fully clean build after raco setup -c.

Ok, debug printer is back and working and easy to enable. Only dependency added is racket/generic, should I revert that part of the change?

Does `typed/racket/base` end up depending on `racket/generic`?  If
not, then it's fine.

@elibarzilay This is now merged.

@elibarzilay This is now merged.

Why the change to `rep-utils.rkt`?

Turns out I only see problems when I move the `and/c` out of the `ormap`.  I don't understand why that would be, but I'll leave it until another day.

Because it was dead code containing list-set.

It did, but you cleaned that up.

Now merged.

Merged.

Merged.

Merged.

Merged.

Merged.

Merged.

Merged.

First, thanks a bunch for doing this -- it's definitely an improvement.

However, I'm not sure that this architecture is the direction we should go.  I would rather have something more integrated with `syntax-parse`, where there's a syntax class for each possible kind of application, and the RHS then calls the appropriate function.  

Can you add some documentation for both `make-predicate` and `cast`?

I think I get what you are saying. The issue I see with that is that it would require the parsing to be done twice, once in recognizing the syntax, and the second in handling it. This could be avoided by carefully constructing the function to be called in the rhs. Would an equivalent solution be to have the tc-result be an attribute of the syntax class? Thus each syntax pattern would also do the typechecking of the subparts instead of the RHS.

Done does as a separate pull request as this is already merged. See https://github.com/plt/racket/pull/137.

@rmculpepper, Friendly ping.

Merged by Sam.

It's true that my solution requires parsing twice, but it also gives
`syntax-parse` more control over the whole parsing process, so that the
outer `#%app` doesn't have to be parsed repeatedly, as it is in your
solution.

The solution of having everything be handled by syntax classes would be
very nice.  Unfortunately, I don't think it works, because `syntax-parse`
assumes that it can backtrack, but lots of parts of the typechecker are
stateful, and thus too many side effects happen when they shouldn't.

On Mon, Aug 20, 2012 at 11:52 PM, Eric Dobson notifications@github.comwrote:

> I think I get what you are saying. The issue I see with that is that it
> would require the parsing to be done twice, once in recognizing the syntax,
> and the second in handling it. This could be avoided by carefully
> constructing the function to be called in the rhs. Would an equivalent
> solution be to have the tc-result be an attribute of the syntax class? Thus
> each syntax pattern would also do the typechecking of the subparts instead
> of the RHS.
> 
> ## 
> 
> sam th
> samth@ccs.neu.edu

Merged, with some examples.

I started the attempt for using syntax classes, but ran into the issue that
they don't mesh well with units. The issue is that units do not let you
export syntax bindings.

On Tue, Aug 21, 2012 at 4:33 AM, Sam Tobin-Hochstadt <
notifications@github.com> wrote:

> It's true that my solution requires parsing twice, but it also gives
> `syntax-parse` more control over the whole parsing process, so that the
> outer `#%app` doesn't have to be parsed repeatedly, as it is in your
> solution.
> 
> The solution of having everything be handled by syntax classes would be
> very nice. Unfortunately, I don't think it works, because `syntax-parse`
> assumes that it can backtrack, but lots of parts of the typechecker are
> stateful, and thus too many side effects happen when they shouldn't.
> 
> On Mon, Aug 20, 2012 at 11:52 PM, Eric Dobson <notifications@github.com
> 
> > wrote:
> > 
> > I think I get what you are saying. The issue I see with that is that it
> > would require the parsing to be done twice, once in recognizing the
> > syntax,
> > and the second in handling it. This could be avoided by carefully
> > constructing the function to be called in the rhs. Would an equivalent
> > solution be to have the tc-result be an attribute of the syntax class?
> > Thus
> > each syntax pattern would also do the typechecking of the subparts
> > instead
> > of the RHS.
> > 
> > ## 
> > 
> > sam th
> > samth@ccs.neu.edu
> 
> —
> Reply to this email directly or view it on GitHubhttps://github.com/plt/racket/pull/136#issuecomment-7898365.

I found out about reified syntax-classes, and they seem to work better with units. I pushed a rough draft of what the functions would look like. I think there will eventually be a macro that will hide away the check attribute and the necessary lambda wrapper.

Merged, with the slight change that the `struct`s in the test cases are no longer `#:transparent`, because of this bug: http://bugs.racket-lang.org/query/?cmd=view&pr=13053

I have made all the tc-app special cases use the syntax classes. The main combining form is still messy, but I'm not sure how it can be cleaned up without changes in syntax-parse to allow combinators over the reified syntax classes.

I now get a number of test failures, mostly looking like this:

```
[samth@loki:~/sw/plt/collects/tests/typed-racket ((275d70c...)) plt] r run.rkt --unit 
--------------------
Typed Racket Tests > Unit Tests > Typechecker tests > tc-expr tests > 889 (let: ((x : (U (Vectorof Integer) String) (vector 1 2 3))) (if (vector? x) (vector-ref x 0) (string-length x)))
889 (let: ((x : (U (Vectorof Integer) String) (vector 1 2 3))) (if (vector? x) (vector-ref x 0) (string-length x)))
ERROR
Internal Typechecker Error: unexpected input for check-below: #f #(struct:tc-results (#(struct:tc-result (Vectorof (U 0 1 Byte-Larger-Than-One Positive-Index-Not-Byte Positive-Fixnum-Not-Index Negative-Fixnum Positive-Integer-Not-Fixnum Negative-Integer-Not-Fixnum)) (Top | Top) -)) #f)
while typechecking:
(#%app vector (quote 1) (quote 2) (quote 3))
originally:
(#%app vector (quote 1) (quote 2) (quote 3))

--------------------
--------------------
Typed Racket Tests > Unit Tests > Typechecker tests > tc-expr tests > 1502 (let () (define: x : Any (vector 1 2 3)) (if (vector? x) (vector-ref x 0) #f))
1502 (let () (define: x : Any (vector 1 2 3)) (if (vector? x) (vector-ref x 0) #f))
ERROR
match: no matching clause for #f

--------------------
801 success(es) 0 failure(s) 2 error(s) 803 test(s) run
Typed Racket Tests did not pass.
```

(the other failures are in the integration tests)

I'm not sure what is going on. I run 'raco setup -j 10 -D' and then 'raco
make -j 10 succeed/_.rkt run.rkt ../racket/benchmarks/__/_.rkt' in the
tests directory. And everything works, then I run 'raco setup -j 10 -c
typed/racket', and try again and things fail. I have seen this a reasonable
amount of times, but cannot figure out what is causing setup to not produce
correct libraries.

I'll take a look at the errors tonight.

On Thu, Aug 23, 2012 at 8:45 AM, Sam Tobin-Hochstadt <
notifications@github.com> wrote:

> I now get a number of test failures, mostly looking like this:
> 
> ## [samth@loki:~/sw/plt/collects/tests/typed-racket ((275d70c...)) plt] r run.rkt --unit
> 
> Typed Racket Tests > Unit Tests > Typechecker tests > tc-expr tests > 889 (let: ((x : (U (Vectorof Integer) String) (vector 1 2 3))) (if (vector? x) (vector-ref x 0) (string-length x)))
> 889 (let: ((x : (U (Vectorof Integer) String) (vector 1 2 3))) (if (vector? x) (vector-ref x 0) (string-length x)))
> ERROR
> Internal Typechecker Error: unexpected input for check-below: #f #(struct:tc-results (#(struct:tc-result (Vectorof (U 0 1 Byte-Larger-Than-One Positive-Index-Not-Byte Positive-Fixnum-Not-Index Negative-Fixnum Positive-Integer-Not-Fixnum Negative-Integer-Not-Fixnum)) (Top | Top) -)) #f)
> while typechecking:
> (#%app vector (quote 1) (quote 2) (quote 3))
> originally:
> (#%app vector (quote 1) (quote 2) (quote 3))
> 
> ---
> 
> ---
> 
> Typed Racket Tests > Unit Tests > Typechecker tests > tc-expr tests > 1502 (let () (define: x : Any (vector 1 2 3)) (if (vector? x) (vector-ref x 0) #f))
> 1502 (let () (define: x : Any (vector 1 2 3)) (if (vector? x) (vector-ref x 0) #f))
> ERROR
> match: no matching clause for #f
> 
> ---
> 
> 801 success(es) 0 failure(s) 2 error(s) 803 test(s) run
> Typed Racket Tests did not pass.
> 
> (the other failures are in the integration tests)
> 
> —
> Reply to this email directly or view it on GitHubhttps://github.com/plt/racket/pull/136#issuecomment-7973999.

On Thu, Aug 23, 2012 at 12:15 PM, Eric Dobson notifications@github.comwrote:

> I'm not sure what is going on. I run 'raco setup -j 10 -D' and then 'raco
> make -j 10 succeed/_.rkt run.rkt ../racket/benchmarks/__/_.rkt' in the
> tests directory. And everything works, then I run 'raco setup -j 10 -c
> typed/racket', and try again and things fail.

I'm confused.  None of those command actually _run_ the tests, right?

## 

sam th
samth@ccs.neu.edu

It performs a reasonably thorough check of the integration tests, because
compiling them is the main thing that is being tested. I also run all the
tests through 'racket run.rkt --all', if these pass, which I believe I did
last night, but not this morning.

The real issue is in setup or my understanding of setup, because I don't
believe the commands I said I ran should produce different compiled
versions.

On Thu, Aug 23, 2012 at 9:30 AM, Sam Tobin-Hochstadt <
notifications@github.com> wrote:

> On Thu, Aug 23, 2012 at 12:15 PM, Eric Dobson <notifications@github.com
> 
> > wrote:
> > 
> > I'm not sure what is going on. I run 'raco setup -j 10 -D' and then 'raco
> > make -j 10 succeed/_.rkt run.rkt ../racket/benchmarks/__/_.rkt' in the
> > tests directory. And everything works, then I run 'raco setup -j 10 -c
> > typed/racket', and try again and things fail.
> 
> I'm confused. None of those command actually _run_ the tests, right?
> 
> ## 
> 
> sam th
> samth@ccs.neu.edu
> 
> —
> Reply to this email directly or view it on GitHubhttps://github.com/plt/racket/pull/136#issuecomment-7975462.

On Thu, Aug 23, 2012 at 1:00 PM, Eric Dobson notifications@github.com wrote:

> It performs a reasonably thorough check of the integration tests, because
> compiling them is the main thing that is being tested. I also run all the
> tests through 'racket run.rkt --all', if these pass, which I believe I did
> last night, but not this morning.

Right.  It's quicker to run just the unit tests, though, with 'racket
run.rkt --unit' (take just a few seconds).

> The real issue is in setup or my understanding of setup, because I don't
> believe the commands I said I ran should produce different compiled
> versions.

Yeah, that's weird.  I would guess that it's something not being kept
up to date automatically, and then when you delete the compiled files
with `-c`, then it runs the new code that doesn't work.

## 

sam th
samth@ccs.neu.edu

LGTM

All the tests but submod pass now for me.

On Fri, Aug 24, 2012 at 3:10 AM, Eric Dobson notifications@github.com wrote:

> On a side note, I don't see what any-wrap/c protects against. Why cannot
> it be any/c?

See https://gist.github.com/3449728 for an example.

## 

sam th
samth@ccs.neu.edu

Ok, makes sense. Also it seems to me that if one runs into an error because
they have Any in the type that they are exporting, then it is not a failing
of the contract system but a failing on them for not providing a good type.

On Fri, Aug 24, 2012 at 4:52 AM, Sam Tobin-Hochstadt <
notifications@github.com> wrote:

> On Fri, Aug 24, 2012 at 3:10 AM, Eric Dobson notifications@github.com
> wrote:
> 
> > On a side note, I don't see what any-wrap/c protects against. Why cannot
> > it be any/c?
> 
> See https://gist.github.com/3449728 for an example.
> 
> ## 
> 
> sam th
> samth@ccs.neu.edu
> 
> —
> Reply to this email directly or view it on GitHubhttps://github.com/plt/racket/pull/139#issuecomment-7999232.

Right, the problem is due to a weak type in that case.  But TR can't just let there be a dynamic error in the typed part of the program, even if a weak type is used.

Merged.

@shekari, I've mostly finished going through the commits. I've made some additional changes, which I'll summarize tomorrow. Most of them are minor things, like lifting more code out of the gigantic macros. I think that 'chaperone-immutable-id-table' should not delay the creation of the hash; the promise is not thread-safe and other contracts for immutable data (like listof) don't delay. OTOH 'set/c' does, so I'll ask around tomorrow about that.

The changes:

Key contract must be flat (since there are no interesting non-flat contracts for identifiers)

Value contracts must be chaperone-contracts. I'm still trying to figure out how chaperones and contracts for abstract data types should work, but it seems like wrong to have the operations conspire with the impersonator-property to break the chaperone restriction in spirit (eg, id-table-ref of a chaperoned id-table should return a chaperone of the original result).

The hash creation in chaperone-immutable-id-table is now eager; set/c is probably just wrong in that respect.

I fixed hash-code (need to use identifier->symbol instead of syntax-e).

I've also changed the way chaperones for mutable tables work to be less general but simpler to implement the actual contracts with.

@rmculpepper has already committed this to master with the appropriate changes added, so can someone who has the appropriate github access (@elibarzilay?) close this pull request?

@mflatt, can you take a quick look at this?

Merged - thanks!

I just pushed this.

This is still failing some test cases, but I am pretty sure it is because of pr 13090.

I added a parameter which is the current kind of contract, this is for bottom up restrictions (i.e. -> contracts must be chaperones) versus the argument which is a top down restriction (i.e. key contracts must be a chaperone-contract). This seemed cleaner than adding an extra return value.

This is still broken in a couple cases, but they are smaller than before. And it is just that the error is caught when constructing the contract instead of when constructing the syntax of the contract. The issue is that free variables are not checked to make sure they are used in a valid context. Thus if they are used in a context that requires them to be chaperone contracts, but are bound to a value that requires them to be impersonator contracts the error happens at runtime. Should I fix that in this pull request?

;; tmp.rkt
#lang typed/racket/base

(define-type T (Rec r (-> (U (All (a) (a -> Symbol)) (HashTable r Symbol)))))
(: a T)
(: b T)
(define (b) (plambda: (a) ((x : a)) 'y))
(define (a) (make-hash (list (cons b 'sym))))
(: f (T -> Void))
(define (f x) (void))

(provide a f)

;; tmp2.rkt
#lang racket

(require "tmp.rkt")

(f (hash a 'sym))

The widget images can be produced using GIMP.

Here's a script:
1. Take a widget screen shot
2. Open it with GIMP
3. Cut it to 240 x 73
4. Add a border using Filters/Decor/Add Border... The values should be (Border X size . 1) (Border Y size . 1) (Border color . black) (Delta value on color . 25)
5. Combine all layers
6. Add a drop shadow with Filters/Light and Shadow/Drop Shadow... The values should be (Offset X . 8) (Offset Y . 8) (Blur radius . 9) (Color . black) (Opacity . 80) (Allow resizing . #t)
7. Save as .png

Here are two throw away scripts that might help, although the GIMP script is very fragile and will probably need little tweaks to make it work with setups others than my own:

[widget.rkt](https://gist.github.com/3623910) Creates a "canvas" panel with a border, so it is easier to select the widget area using GIMP's Fuzzy Select Tool

[racket-widget.scm](https://gist.github.com/3623967) GIMP's script which, when invoked, asks for a window to take a screen shot and do the post production to the image. This script should be put inside a specific directory, here being ~/.gimp-2.6/scripts and invoked using File/Create/Racket Widget

Could you add these instructions and scripts to the repository proper?

Done.

Greg merged it.

A quick reminder (since we just had a huge bunch of tiny commits for the frtime work): it's better to edit the commits to make them more useful for people who would look at the changes later rather than be a true reflection of how your worked them in.  I'm specifically suspicious about commits like "WIP" and "More foo work" which are almost always snapshots of your own progress that are later not going to be useful.  (By "edit" I mean what you get with an interactive rebase.)

I'd really prefer that the script would be a Racket script (preferably somewhere in `collects/meta/images`) so that we don't depend on gimp's awful extension language.  (And that's not taking a stab at Scheme -- the thing that gimp uses is just generally horrible.)  My guess is that another advantage for doing this is for other snapshots that are used, eg, in the drracket manual.  (And having a racket script means that people can use it more conveniently on other OSs and without requiring a gimp installation.)

It sounds like everything should be doable in Racket, you could probably ask on the mailing list for details like getting the drop shadow (which people might even object to if it's not in style) and selecting the relevant part of the snapshot.

Is the inclusion of the scripts really necessary for this patch?

I have the feeling that the scripts used to create these screen shots are throw away scripts. The real addition here are the Gallery page and the images. The images could be well be made by hand.

`set-first` and `set-rest`, added in ac5965a1dce, make this redundant. @elibarzilay, you can close this.

Merged, thanks!

Awesome!

My pleasure.

Ok, I'm back on this, trying to figure out what's going on in PR 13090.

And 13090 is now fixed, so I'll get to merging this.

Does this depend on pull request #139? I ask because it regresses `fail/cnt-struct-err.rkt`, which is about the contracts generated for struct accessors.  Unfortunately, this PR doesn't apply cleanly on top of 139, but I'm working on merging that now.

This currently has two genuine errors:

```
--------------------
Typed Racket Tests > Integration tests > succeed > pr10939.rkt > #f
Unnamed test 
FAILURE
message:    "Exception raised"
ssage: "a:empty?: undefined;\n cannot reference an identifier before its definition\n  in module: \"/home/samth/sw/plt/collects/tests/typed-racket/succeed/pr10939.rkt\""
exception:  #(struct:exn:fail:contract "a:empty?: undefined;\n cannot reference an identifier before its definition\n  in module: \"/home/samth/sw/plt/collects/tests/typed-racket/succeed/pr10939.rkt\"" #<continuation-mark-set>)
name:       check-not-exn
location:   main.rkt:81:31
expression: (check-not-exn thnk)
params:     #<procedure:...-racket/main.rkt:73:10>

Check failure
--------------------
--------------------
Typed Racket Tests > Integration tests > succeed > pr11504.rkt > #f
Unnamed test 
FAILURE
message:    "Exception raised"
ssage: "cat?: undefined;\n cannot reference an identifier before its definition\n  in module: \"/home/samth/sw/plt/collects/tests/typed-racket/succeed/pr11504.rkt\""
exception:  #(struct:exn:fail:contract "cat?: undefined;\n cannot reference an identifier before its definition\n  in module: \"/home/samth/sw/plt/collects/tests/typed-racket/succeed/pr11504.rkt\"" #<continuation-mark-set>)
name:       check-not-exn
location:   main.rkt:81:31
expression: (check-not-exn thnk)
params:     #<procedure:...-racket/main.rkt:73:10>

Check failure
--------------------
```

I'm looking into it.

Oh, silly me.  This includes #139.

I think I know what's wrong here.  The `tc-toplevel` traversal no longer records struct procedures as being defined in this module, so it doesn't think it needs to put contracts on them when exported.  This should be easy to fix.

Ok, I think I have a fix.

This is now merged, and can be closed.

This was merged as part of #143.

Now that a bunch of the other pull requests are merged, can you rebase this appropriately so that I can review it?

Yep. It might take me a couple of days to find the time, though.

Sent from a mobile device.
On Sep 28, 2012 8:27 AM, "Sam Tobin-Hochstadt" notifications@github.com
wrote:

> Now that a bunch of the other pull requests are merged, can you rebase
> this appropriately so that I can review it?
> 
> —
> Reply to this email directly or view it on GitHubhttps://github.com/plt/racket/pull/145#issuecomment-8980106.

No problem.

I merged the first two commits, and Jay merged the one for the web server -- so I think that this is all done.  (The two merge commits seem like you updated your repository.)

Merged -- thanks!

Thanks. Should be merged now.

Feel free to cherry-pick if that's easier.

Merged some, these are still left:
- Improve help for "raco setup"'s "--doc-pdf" flag.
- Add "install-html" and "install-pdf" targets to Makefile.
- Hack to keep search.js and search-context.html up-to-date in doc/

Cleaned it up. 15 days is a couple right?

It's a couple something ...

On Sat, Oct 13, 2012 at 11:13 AM, Eric Dobson notifications@github.comwrote:

> Cleaned it up. 15 days is a couple right?
> 
> —
> Reply to this email directly or view it on GitHubhttps://github.com/plt/racket/pull/145#issuecomment-9405120.

## 

sam th
samth@ccs.neu.edu

Pushed, thanks!

Meant to comment on the pull request: Pushed, thanks!

Merged, thanks!

Already merged. Thanks!

The `--doc-pdf` improvement was done & pushed (by Matthew).  It now says:

```
--doc-pdf <dir> : Build doc PDFs, write to <dir>
```

The last two commits are now merged too.

Merged -- thanks!

Yikes, I just wanted 8f9883f in the pull request.  Apologies.

Merged.

This is not the correct fix, but thanks for finding the error. I just pushed a fix.

@dyoo, you should just commit these sorts of changes.

Ok, committed into master.

This was (mostly) merged a while ago along with another pull request.

Merged.

Will recreate the pull request as it was done on my master branch instead of a feature branch :(

I'll do a little cleanup of the code and check it in after making sure it passes web-server tests too.

I'm not certain that this function belongs in `readline/readline`.
That module is intended to provide raw bindings (more or less)
to the readline functions, and `add-history` is already provided.

I note that line-based saving and loading won't work for
multi-entries in a history. Is it important for your purposes that
the file is in plain text, as opposed to S-expression format? 

Finally, it's not clear to me that silence is the right answer if
the file given to `history-load' does not exist. Most functions
that take a filename complain when the file doesn't exist.
Would that be less convenient for your purposes?

Overall, I can see these as useful convenience functions.
If you've needed them more than once, then maybe they
could be in a new library within `readline'. A patch along
those lines that includes documentation would be appreciated.

I put these functions in readline/readline because I use them in this context and thought it was more understandable that they were to be used in this context. That said, I have no problem creating a readline/utils module that would contain these functions, no issue here.

Regarding the line-based saving and loading, I don't think I get what you mean by multi-entries. Would you mind giving me an example ?
As for the output format, no issue either. I just reproduced what is commonly done when using the C version of the readline library. We could also introduce a #:format parameter (oneof/c 'text 'racket) to let people choose what they want.

I agree with you on the non-existent file behavior. It clearly is a bad decision to silence errors at this level. I should handle this in my code instead.

In conclusion, I would be happy to create a new pull request with all the changes discussed above. I just need you to validate the approach (module name and #:format stuff) and give me an example of the multi-entries history you mention.

Thanks in advance.

--philippe

This pull request now fixes next-prime and prev-prime too.

I've applied and pushed all of these commits, except 15f9bbd (the last). I applied 985b1bc manually because I had made enough changes after pulling the others that the patch failed. (I didn't delete the margin notes, though. :D) I didn't apply 15f9bbd because the docs for mangoldt-lambda appear to be a copy of the docs for prime-omega, and I would have had to do that one manually as well.

I'll close this pull request as soon as I figure out how; you can put mangold-lambda in a new one. Please merge from plt's repo before continuing your fine work. Also, please try to make argument types more permissive (functions that accept only Natural can be hard to use in Typed Racket), and use only types for the "contracts" in the documentation.

2012/11/18 Neil Toronto notifications@github.com

> I've applied and pushed all of these commits, except 15f9bbdhttps://github.com/plt/racket/commit/15f9bbd(the last). I applied
> 985b1bc https://github.com/plt/racket/commit/985b1bc manually because I
> had made enough changes after pulling the others that the patch failed. (I
> didn't delete the margin notes, though. :D) I didn't apply 15f9bbdhttps://github.com/plt/racket/commit/15f9bbdbecause the docs for mangoldt-lambda'
> appear to be a copy of the docs forprime-omega', and I would have had to
> do that one manually as well.
> 
> Good catch.
> 
> I'll close this pull request as soon as I figure out how; you can put
> `mangold-lambda' in a new one. Please merge from plt's repo before
> continuing your fine work. Also, please try to make argument types more
> permissive (functions that accept only Natural can be hard to use in Typed
> Racket), and use only types for the "contracts" in the documentation.
> 
> I keep forgetting to make the types permissive - maybe because it is
> counter intuitive to me. I'll fix it.

/Jens Axel

To get `match` to link, all you should need to do is add `(require (for-label racket/match))` in the relevant scrbl file.

Merged now. Thanks!

Committed.

Committed.

Closing. A rebase is needed to fix the history.

Thanks! I've pushed this to our repo.

All of these changes look good to me, except that I'm not sure about the switch to "<!DOCTYPE html>". Was that change because it's a good idea in principle, or have you vetted enough of the generated HTML to be confident that it's likely a good change for all Racket document viewers?

Committed.

Using `<!DOCTYPE html>` is recommended by every browser maker that I know
of.  Using a different DOCTYPE will have one of two likely results (a) the
browser ignores the DOCTYPE and behaves like `<!DOCTYPE html>`, or (b) the
browser switches to a different processing and rendering mode that we don't
want, such as IE quirks mode, aimed at IE 5 and Netscape 4.

Here's what
https://developer.mozilla.org/en-US/docs/Quirks_Mode_and_Standards_Mode has
to say:

"The DOCTYPE shown in the example, <!DOCTYPE html>`, is the simplest
possible, and the one recommended by HTML5. Earlier versions of the HTML
standard recommended other variants, but all existing browsers today will
use full standards mode for this DOCTYPE, even the dated Internet Explorer
6. There are no valid reasons to use a more complicated DOCTYPE. If you do
use another DOCTYPE, you may risk choosing one, which triggers almost
standards mode or quirks mode."

On Tue, Nov 27, 2012 at 6:52 AM, Matthew Flatt notifications@github.comwrote:

> All of these changes look good to me, except that I'm not sure about the
> switch to "<!DOCTYPE html>". Was that change because it's a good idea in
> principle, or have you vetted enough of the generated HTML to be confident
> that it's likely a good change for all Racket document viewers?
> 
> —
> Reply to this email directly or view it on GitHubhttps://github.com/plt/racket/pull/158#issuecomment-10760525.

## 

sam th
samth@ccs.neu.edu

Merged -- thanks!

Merged -- thanks!

Merged -- thanks!

After further investigation, I've discovered the following:

(1) We can, and probably should, switch to "almost standards" mode [1].
I've tested this in both Chrome and Firefox on Linux, and used Adobe
BrowserLab to remotely test on IE 7, 8, and 9 as well as Safari 5.  The
only impact of "almost standards" mode is to set the fonts more correctly
inside some table cells, because quirks mode doesn't inherit CSS font
specification into table cells.

To switch to almost standards mode, we'd just need to change `4.0` to
`4.01` in the DOCTYPE.

(2) The behavior of browser layout engines in the presence of IE 5-style
table layout (which is what "almost standards" mode selects) is very
under-documented, at least as far as I can tell. I've been able to get
close to, but not exact, replicas of the behavior in standards mode in both
Firefox and Chrome with CSS, but not, sadly, with the _same_ CSS for both.

(3) The right fix for this is to move Scribble away from using tables for
layout, and towards more use of CSS for layout.  That will necessarily be a
gradual process, and after it's at least mostly done, we can revisit moving
to full standards mode. @gf3 tells me he has ideas for work along these
lines (and was very helpful in debugging the above).

I'll write up a patch for "almost standards" mode.

[1] https://developer.mozilla.org/en-US/docs/Gecko%27s_Almost_Standards_Mode

@zzkt, that page is part of a Wiki, so you can edit it directly to add a link to your bindings (which would be great).

Should have rebased. I see the changes were applied. Closing and submitting an addition to the recent changes that also specializes the empty set case.

Err, I didn't mean to add all of those commits. Let's try this again.

pulled, thanks!

Pushed, on @rfindler's say-so.

re pygments.rb, see https://github.com/tmm1/pygments.rb/issues/36#issuecomment-11060550

Merged, thanks!

Merged, thanks!

Merged, thanks!

Merged, thanks!

Merged, thanks!

@elibarzilay I pushed another commit with new usage:

```
,log -- show the level(s) currently in effect.
,log <level> <logger> -- set the level for a specific logger.
,log default <logger> -- set the logger to follow the default level.
,log <level> -- set the default level, for all other loggers.
```

How's that?

Merged -- thanks

Ugh, copy-paste error. I'll resubmit.

Merged -- thanks!

Yes, of course, you're welcome. Thanks for your reply. Tell the truth, I don't know how to add a commit to a pull request yet.

After looking in more detail, I'm not comfortable with the API set up for the progress callback. I think it's better to let the client pick the way that threads are created, if any, and I worry that a progress callback could get stuck unexpectedly if the thread talking to the callback is ended by the main thread.

So, I'ved changing the protocol to use less threads implicitly and to better report when the transfer count changes. Please take a look (changes pushed to the main repo) and let me know whether it's ok.

I think this change would break many URLs (in blog posts and online books, for example) that currently point into the documentation.

I notice that the source of the blog post
  http://blog.racket-lang.org/2012/10/the-3n1-problem_4990.html
uses %28 and %29, and both Chrome and Safari (but not Firefox) preserve the % notation when showing or copying the URL. So, maybe using an % encoding for these characters in URLs would be a step forward.

I notice that the source of the blog post

> http://blog.racket-lang.org/2012/10/the-3n1-problem_4990.html
> uses %28 and %29, and both Chrome and Safari (but not Firefox) preserve
> the % notation when showing or copying the URL. So, maybe using an %
> encoding for these characters in URLs would be a step forward.
> 
> Ok, I'll look into escaping hrefs rather than anchor names.  That makes
> more sense.  Thanks!

Great, seems better than my func, I'll checkout and test it. A little slowly perhaps, I'm not familiar basic operation with github yet.

Ok, revised so it doesn't touch anchor names, but works on href URLs only.

It's ok. I test it. Use semaphore is better. Only when download or upload finished, progress-proc will exit, progress-proc
will not process the last one.  The progress will stop at 99...%. But I don't think it's a problem, the last one's handle can be placed at just after download(upload) finished.

Nothing is needed to change. I see you have committed. Should I close it?

Instead of hacking scribble, it seems like it might be better to change `net/url` so that it escapes parens too.  This is only if it becomes a kind of a convention to not leave them unescaped.  But maybe this should be done with an extra parameter or some other way to control when it happens.

whoops, my first commit removes all the trailing whitespace in bitmap.rkt. Sorry, I didn't realize that my editor does that automatically.

Let me know if you want me to resubmit my patch while keeping trailing whitespace intact.

Merged -- thanks!

Merged -- thanks!

Merged -- thanks!

Adding an extra parameter to `net/url' does seem better. I've pushed that change, so please check.

Wouldn't it be better to have `current-url-encode-mode` default to
`'unreserved`?  It sounds like there's no real damage for doing that
other than producing longer URLs, and given the problem of
stackoverflow and other markdown-based tools, it can help in these
contexts too.

(Danny: BTW, thanks for initiating this, I've been annoyed by the
constant need to manually edit URLs for a long time.  Hopefully this
makes things work right in Chrome.)

I don't feel expert enough to go against the RFC recommendation. Discuss on the dev list, where there are more web experts?

This topic branch was supposed to contain only f9e071c95bfcbec1d4c65aca5ebfe3048cdf48cc but it has two more that were part of previously-accepted pull requests.

Argh. I _thought_ I created the topic branch correctly. But this is the first project where I've contributed a series of pull requests over time; I guess I don't understand the exact workflow in that case.

If the extra commits pose a problem or nuisance for you please let me know, and again, I'm sorry.

Wouldn't a footnote be closer to the intended use of margin notes?

That's a good question. But no, I don't think a margin note should be a footnote. I think it should be inline (as it's been all along in the text renderer), just formatted better.
- For HTML and PDF, `margin-note` renders in the margin.
- For text and Markdown, there's no concept of a "margin", so `magin-note` renders inline. (That's been the status quo for the text renderer. The markdown renderer inherited that.)
- For text and Markdown, there's no concept of a "page" or a "foot", either. So unclear what a footnote would be.

Given all that, this commit simply makes a `margin-note` _look like_ a note instead of plain body text. That helps because Scribble authors rarely write `@margin-note{Note: ...}`; when the text instead appears inline it can read strangely. Let's format it to afford, "I'm a note".

> If you view this on the GitHub issue web page instead of via email, there's an example of Markdown blockquote in the original pull request message. This paragraph itself is another example. :)

p.s. A shorter answer would simply be: In HTML/PDF/LaTeX a `@margin-note` ends up immediately next to the main text, to the side. The closest possible equivalent in plain text and Markdown is also to keep it immediately next to its main text, albeit inline. Which was the status quo, prior to this commit. With Markdown, we can at least format it to convey that it's a note, not the main text per se. Which is what this commit proposes.

I have update to `#lang racket/base` as is used in `collects/games/same.rkt`.

OK, all of that makes sense.  Possibly another point for not using footnotes is the fact that there's no good place to put the anchors.  (It would be obvious to point the anchor where the `@margin-note` appeared, but since they're usually not rendered as footnotes it can lead to bad surprises.)

But still, the main thing that bothers me is the potential confusion with a proper blockquote.  Looking through the specs, I don't see anything that looks like a good alternative -- but it seems that everyone respects the rule that you can just have [in-line html](http://daringfireball.net/projects/markdown/syntax#html) in markdown.  So maybe something that would work better than a blockquote is a simple `div` with a `style="float: right;"`?  The extra noise in the raw text is minimal, and the effect should be sufficiently different.  (And I don't really mind such extra noise -- markdown as an attempt to be a "natural" language is something that quickly reveals the illusion when you get to subtle details...)

I know that "GitHub Flavored Markdown" renders basic HTML elements like `<table>`, `<tr>`, `<td>`. I didn't expect it would handle things like `<div style='float:right'>`.

But let's see. This issue comment UI will let me try right here:

> This is using `>` to do the block quote style.

<div style="float: right;">This is using `div` with `style="float: right"`.</div>

The second one using div doesn't seem to work; it's a no-op.

I'm not concerned with using the `>` blockquote to render notes. I think the appearance as for instance rendered in HTML here on GitHub is fine.

Should we go with that?

I just made another pull request for a bug fix: https://github.com/plt/racket/pull/205

As it involves the same files, and I don't want to cause confusion or merge hassles on your end:
1. I based that bug fix pull request off of accepted upstream -- _not_ including this margin-note pull request.
2. I'm going to close this margin-note pull request.

Please let me know if you'd like me to redo and resubmit this margin-note request again later.

OK the topic branch for this pull request is rebased and refreshed here. Now this should work fine (no merge conflict for you) on top of https://github.com/plt/racket/issues/205.

Yeah, I should have thought that they do some kind of paranoid cleaning which makes it impractical...  So it certainly looks like a blockquote is the only practical thing left...

(Matthew merged and pushed it, so I'm closing it now.)

Merged -- thanks!

Merged as well -- thanks!

Thanks! Is there a reason to restrict the URL to numeric addresses?

Oh, no. It is my mistake. May I make two commits per request?

2012/12/24 Matthew Flatt notifications@github.com

> Thanks! Is there a reason to restrict the URL to numeric addresses?
> 
> —
> Reply to this email directly or view it on GitHubhttps://github.com/plt/racket/pull/207#issuecomment-11664323.

## 

With best regards, Michael Filonenko

Sure, multiple commits per request are fine. Thanks again!

Merged

(Bug filed to the usual place too.)

I don't know. I was using a workaround in the OpenBSD port just hardcoding the ulimit command ([bug 13022](http://bugs.racket-lang.org/query/?cmd=view%20audit-trail&database=default&pr=13022)). Yesterday I saw the patches of DragonFly BSD and remembered I had not tried setting a fixed size for the stack. It fixed the problem.

I've saw reports from other projects in the past related to the stack size on OpenBSD. The thing is OpenBSD changed from user-level threads to kernel-level threads in the last release. Probably none of these problems still apply. I guess the initial porter of racket to OpenBSD didn't have this problem because he did use the default thread library at that time (user-level).

Merged

Merged -- thanks!

This actually doesn't need an extra test, if contracts were actually enabled in testing they would have already caught the bug.

Did this pull request just get missed or is there something wrong with it?

This is now just the parts that were not merged with the other pull request.

Now a couple of months later it is synced back to head.

I think that this breaks the `math` collection in contract generation, because the parent identifier as used by `struct/c` seems to end up being the wrong one.  The error messages I get look like:

```
struct/dc: expected an identifier that names a field or a sequence with a field name, the #:parent keyword, and the parent struct
  at: (Array-shape47 #:parent Array56)
  in: (-struct/dc Mutable-Array ((Array-shape47 #:parent Array56) (let ((rec8 (recursive-contract struct-ctc7 #:chaperone))) (vectorof (flat-named-contract (quote Index) t:index?)))) ((Array-size88 #:parent Array56) (let ((rec9 (recursive-contract struct-ctc7...
```

Can you see if you get this error as well?

Oh, sorry, I meant to close this.  Using `Type/c` as a predicate has performance problems, so I only want to use this in contracts.

I like the name `AnyValues` here.

Also, there was a bug where `tc-any-results` wasn't handled in `abstract-results` that I've fixed, I believe.  Having the `math` collection keeps us more on our toes. :)

Unfortunately, I've now run into somewhere where `tc-any-results` is produced as the result of typechecking, which is no good.  Working on it now ...

This is now merged.

Can you fix this now that I've merged #208? 

Would the solution then be to export 'Type/c?' and use that instead?

That sounds like a good idea.
On Jan 14, 2013 11:43 PM, "Eric Dobson" notifications@github.com wrote:

> Would the solution then be to export 'Type/c?' and use that instead?
> 
> —
> Reply to this email directly or view it on GitHubhttps://github.com/plt/racket/pull/142#issuecomment-12253302.

There is another issue. My contract fixing PR also adds a binding with name Values/c with different semantics. We will need to figure out which gets claim to that name.

Rebased.

Updated. PTAL.

I think the mailing list reaction was not to do this, so perhaps this PR should be closed.

I'm closing it then.

Merged.

I'm going to land #213 soon, so that will get the name `Values/c` to start.  Feel free to rename, though.  

Other possibilities: `Range/c`, `Result/c`, `FunctionResult/c`?

Merged.

This is now working for math. But reveals an issues with abort-current-continuation, it only allows the return type of the function argument of the prompt tag to have one value, which means it doesn't work with the default prompt tag. 

This is a actually a larger issue in that we cannot write the type for this function:
(define (f g) (g))
If we define it as (: f (All (a) ((-> a) -> a))), then (f (lambda () (values 2 3))) doesn't work.

@takikawa, can you take a look at this issue wrt `abort-current-continuation`?

For the larger issue, can't we give this function the type `(All (a b ...) (-> a) -> (Values b ...))`?

I think you meant (All (b ...) (-> (Values b ...)) -> (Values b ...)), but yes that would work in the current system. But with my addition it would not work, as there is no set of bs such that (-> AnyValues) is a subtype of it.

I think the solution would be the type:
(case->
  (All (b ...) (-> (Values b ...)) -> (Values b ...))
  ((-> AnyValues) -> AnyValues))

Yes, that's the type I meant.

You're right about the issue with `AnyValues`, and that `case->` type seems fine.

Thinking about it more, `AnyValues` seems to be a lot like `T *` in parameter types, and we allow `(T * -> U)` to be used for a `(A ... A -> U)` parameter.  Unfortunately, I don't think the relationship is in the right direction for `AnyValues`.  @sstrickl, what do you think here?

Right, the problem is that works in the contravariant direction, but not the covariant one.  That is, `(Values A ... A) <: AnyValues`, as we can only lose information moving from subtype to supertype, like the number and order of values, not gain it.  In negative position, we win because if something like a function can handle any number of arguments of type `T`, than it certainly handle a specific number of `T`s.  (It just loses the count information, but it never depended on that information to begin with.)

So yes, I think setting up an alternate branch through an intersection type is probably the best thing to do here, but if anything else comes to mind, I'll let you know.

Yes, `abort-current-continuation` probably needs another polydots-bound type variable for the function argument's return type too.

On Wed, Jan 23, 2013 at 2:37 PM, Asumu Takikawa notifications@github.comwrote:

> Yes, abort-current-continuation probably needs another polydots-bound
> type variable for the function argument's return type too.

Ok, can you address that separately?  I think that's the only remaining
issue with this PR.

Turns out we need to fix `abort/cc`'s type in this PR.  I've done that, but it seems like inference doesn't work quite right.  I'm adding a `case->` type, but the first case shouldn't be necessary.  @shekari, can you have a look at this once I've merged the PR?

Fixed the commit message to have the right pr.

This has been merged and can be closed.  The issue with `AnyValues` and inference can be dealt with separately.

Merged.

@rfindler @sstrickl @takikawa can one of you look at this?

Merged.

It needs a test case.

By otherwise it looks ok.

On Monday, January 28, 2013, Sam Tobin-Hochstadt wrote:

> @rfindler https://github.com/rfindler @sstricklhttps://github.com/sstricklcan one of you look at this?
> 
> —
> Reply to this email directly or view it on GitHubhttps://github.com/plt/racket/pull/217#issuecomment-12804488.

Added the test. I think I put it in the right spot.

Thanks! I've pushed it.

I think another keyword for `tc-e`, probably `#:expected`, is the right choice here.

I think this is ok, even without handling more exotic function types. 

Note that we can use this in somewhat more cases, since sometimes arities overlap but have the same type in a particular location.  

Can you rebase this, so that it doesn't have a merge commit?

I think we probably don't want to change the default 'modern font, though.

I believe the problem is due to a bug in Apple's Courier New font, which doesn't have the right bounding box for its characters. I filed a bug report, which so far has no response. I've been meaning to try the code that I sent to Apple in the bug report to make sure that it has the same behavior in 10.8, and then I'll try pinging Apple.

While changing the 'modern font to Courier makes the output not clipped (since that font' s bounding boxes are ok), Courier looks much worse than Courier New in a lot of situations. We actually tried it before and decided that we shouldn't go that way.

I note that a bitmap created with `make-platform-bitmap' does not have the clipping problem, because it uses a drawing path that does not rely on the fon'ts bounding-box specification.

Thanks, mflatt, you can see the problem's real cause every time.

Ok, added #:expected.

Looks good to me.  I'll merge this soon.

Fixed optional argument stylistic error.

The >= can not be replaced with >. If (length a) = 5 and (syntax-len fml) is 6, then the condition should be true. Following your suggestion (length a) would need to be at least 7 before the condition became true.

Github is annoying and if I do amend commits, which make sense in this context (minor cleanup), then comments on the actual files disappear from the discussion.

+stamourv, This is failing some optimizer tests, but I believe that the expected version of the output is wrong now. Can you give some guidance on how to tell if it is a problem or not?

Merged, thanks!

Merged, thanks!

I'll have a look. If you want to investigate, look at the diffs between the expected and actual optimization logs. If some optimizations are not performed anymore, that may be a problem. If new optimizations are performed, as long as they're safe, we're good and we should update the expected log.

This change kills a lot of optimizations in 5 of the optimizer tests. From a quick look at your commits, it looks like expressions may not typecheck at the most precise type possible anymore, which is a problem for optimization. Can you fix that?

The one case that I looked at, it added an expected type of univ instead of
no expected type. If that changes optimizations then it seems the
optimization machinery has issues and not the change here. I'll be able to
look more closely tonight.

Sent from a mobile device.
On Feb 4, 2013 2:06 PM, "Vincent St-Amour" notifications@github.com wrote:

> This change kills a lot of optimizations in 5 of the optimizer tests. From
> a quick look at your commits, it looks like expressions may not typecheck
> at the most precise type possible anymore, which is a problem for
> optimization. Can you fix that?
> 
> —
> Reply to this email directly or view it on GitHubhttps://github.com/plt/racket/pull/221#issuecomment-13102380.

Also, looking at the PR, it seems like the right solution is to make the type of `real->floating-point-bytes` more permissive.

Huh? As my reduced testcases show it has nothing to do
with real->floating-point-bytes. Just that interesting arities make it so
that TR doesn't propagate expected type info as well as it could.

On Mon, Feb 4, 2013 at 2:16 PM, Vincent St-Amour
notifications@github.comwrote:

> Also, looking at the PR, it seems like the right solution is to make the
> type of real->floating-point-bytes more permissive.
> 
> —
> Reply to this email directly or view it on GitHubhttps://github.com/plt/racket/pull/221#issuecomment-13102904.

Right, your changes would fix the problem, but I think we should also change the type. My comment wasn't about the pull request per se, but more about the PR in general.

Can you explain what the new type would be, and in what situations it would
be easier to use than the current type?

On Mon, Feb 4, 2013 at 2:27 PM, Vincent St-Amour
notifications@github.comwrote:

> Right, your changes would fix the problem, but I think we should also
> change the type. My comment wasn't about the pull request per se, but more
> about the PR in general.
> 
> —
> Reply to this email directly or view it on GitHubhttps://github.com/plt/racket/pull/221#issuecomment-13103467.

`(->opt -Real -Int [Univ -Bytes -Nat] -Bytes)`. Basically, accepting any integer instead of just 4 and 8. In general, I like to follow Postel's law for types (be liberal in what you accept and conservative in what you send (return)). For this case specifically, a more general type would help in cases where the number of bytes is computed, or taken as input.

That would make it so error checking is moved to runtime instead of
typechecking time. I cannot imagine a case where you wouldn't have a
computation returning 4 or 8 and not be able to easily prove that it is one
of 4 or 8.

On Mon, Feb 4, 2013 at 2:36 PM, Vincent St-Amour
notifications@github.comwrote:

> (->opt -Real -Int [Univ -Bytes -Nat] -Bytes). Basically, accepting any
> integer instead of just 4 and 8. In general, I like to follow Postel's law
> for types (be liberal in what you accept and conservative in what you send
> (return)). For this case specifically, a more general type would help in
> cases where the number of bytes is computed, or taken as input.
> 
> —
> Reply to this email directly or view it on GitHubhttps://github.com/plt/racket/pull/221#issuecomment-13103919.

Yes, that error checking would be done at runtime, just like vector bounds checking or division by zero. Proving the right type can by tricky if, say, the number of bytes the result of dividing the length of some buffer by the number of elements, or something.

I don't think anyone ever does that for real->floating-point-bytes. If you
consider that runtime error the same as bounds-checking, then yes that is a
good fix. I just don't think it is that kind of error.

On Mon, Feb 4, 2013 at 2:46 PM, Vincent St-Amour
notifications@github.comwrote:

> Yes, that error checking would be done at runtime, just like vector bounds
> checking or division by zero. Proving the right type can by tricky if, say,
> the number of bytes the result of dividing the length of some buffer by the
> number of elements, or something.
> 
> —
> Reply to this email directly or view it on GitHubhttps://github.com/plt/racket/pull/221#issuecomment-13104337.

I think I agree with @shekari on both issues.  First, a quick grep of the source indicates that `real->floating-point-bytes` is used only in cases where it's easy to use the precise type.  Second, I don't understand why this would reduce optimization opportunities.   Finally, is it possible that some of the other commits this depends on that are part of the PR are causing the errors?

I don't believe it is other commits, changing line 106 to (single-value a)
made the diffs go away for me (on one of the tests). I believe it is the
difference between expected=Univ versus not having an expected type.

On Mon, Feb 4, 2013 at 3:12 PM, Sam Tobin-Hochstadt <
notifications@github.com> wrote:

> I think I agree with @shekari https://github.com/shekari on both
> issues. First, a quick grep of the source indicates that
> real->floating-point-bytes is used only in cases where it's easy to use
> the precise type. Second, I don't understand why this would reduce
> optimization opportunities. Finally, is it possible that some of the other
> commits this depends on that are part of the PR are causing the errors?
> 
> —
> Reply to this email directly or view it on GitHubhttps://github.com/plt/racket/pull/221#issuecomment-13105397.

On Mon, Feb 4, 2013 at 6:14 PM, Eric Dobson notifications@github.com wrote:

> I don't believe it is other commits, changing line 106 to (single-value a)
> made the diffs go away for me (on one of the tests). I believe it is the
> difference between expected=Univ versus not having an expected type.

In that case, we should be all set, because `single-value` is
appropriate there.  Function arguments must return a single value.

But that loses all the work the CL has done to push the expected type down
to the argument. It is not a solution, just a method for testing.

On Mon, Feb 4, 2013 at 3:16 PM, Sam Tobin-Hochstadt <
notifications@github.com> wrote:

> On Mon, Feb 4, 2013 at 6:14 PM, Eric Dobson notifications@github.com
> wrote:
> 
> > I don't believe it is other commits, changing line 106 to (single-value
> > a)
> > made the diffs go away for me (on one of the tests). I believe it is the
> > difference between expected=Univ versus not having an expected type.
> 
> In that case, we should be all set, because `single-value` is
> appropriate there. Function arguments must return a single value.
> 
> —
> Reply to this email directly or view it on GitHubhttps://github.com/plt/racket/pull/221#issuecomment-13105604.

On Mon, Feb 4, 2013 at 6:19 PM, Eric Dobson notifications@github.comwrote:

> But that loses all the work the CL has done to push the expected type down
> to the argument. It is not a solution, just a method for testing.

Oh, right, I see now.  Can we have a version of `single-value` that takes a
second argument, and if that argument is AnyValues, it uses Univ instead,
otherwise it behaves like tc-expr/check?

I'm not sure what you are trying to do. There is something up with the
optimizer which this revealed, changing single-value doesn't fix that.

Also AnyValues is different from #f as expected. AnyValues says that the
context doesn't care what it gets, #f says that it doesn't know what it
wants. single-value is closer to the second (except that it knows it wants
one value).

On Mon, Feb 4, 2013 at 3:26 PM, Sam Tobin-Hochstadt <
notifications@github.com> wrote:

> On Mon, Feb 4, 2013 at 6:19 PM, Eric Dobson <notifications@github.com
> 
> > wrote:
> > 
> > But that loses all the work the CL has done to push the expected type
> > down
> > to the argument. It is not a solution, just a method for testing.
> 
> Oh, right, I see now. Can we have a version of `single-value` that takes a
> second argument, and if that argument is AnyValues, it uses Univ instead,
> otherwise it behaves like tc-expr/check?
> 
> —
> Reply to this email directly or view it on GitHubhttps://github.com/plt/racket/pull/221#issuecomment-13106058.

I think I finally understand what's going on with the optimizer.  Somewhere, the optimizer is checking whether the result type is "appropriate" in some context, and getting `AnyValues` and failing.  That should be fixed.

Can either of you tell me a small bit of code that's failing to be optimized?

The two then branches in `tests/typed-racket/optimizer/tests/dead-else.rkt` should be optimized, but are not.

Ok, I'm pretty stumped.  I don't see how this could possible affect that code.

Here is an example program which demonstrates the issue at HEAD.

#lang typed/racket

(define f (- 3.0 2.0))
(: g Any)
(define g (- 3.0 2.0))

I would want both of these to be optimized in the same exact way, yet only
f is optimized.

endobson@yggdrasil () ~/proj/racket/plt % racket -W
debug@TR-optimizer~/tmp/tmp2.rkt
TR-optimizer: TR opt: tmp2.rkt 3:10 (- 3.0 2.0) -- binary float

I believe this is because add-typeof-expr is called with different
arguments for the different forms:
f:
(add-typeof-expr
  #<syntax:/Users/endobson/tmp/tmp2.rkt:3:10 (#%app - (quote 3.0) (quote
2...>
  (tc-results (list (tc-result Flonum (Top | Top) -)) #f))
g:
(add-typeof-expr
  #<syntax:/Users/endobson/tmp/tmp2.rkt:5:10 (#%app - (quote 3.0) (quote
2...>
  (tc-results (list (tc-result Any (Top | Top) -)) #f))

Line 99 in optimizer/float.rkt has the faulty line:
[safe-to-opt? (subtypeof? this-syntax -Flonum)]

This prevents expressions in positions where the expected type of the
expression is not -Flonum from being optimized. The solution is to remove
this check and check safety in another way as this is too conservative.

On Tue, Feb 5, 2013 at 6:19 AM, Sam Tobin-Hochstadt <
notifications@github.com> wrote:

> Ok, I'm pretty stumped. I don't see how this could possible affect that
> code.
> 
> —
> Reply to this email directly or view it on GitHubhttps://github.com/plt/racket/pull/221#issuecomment-13131068..

Merged, thanks!

Merged, thanks!

Merged, thanks!

Merged, thanks!

Merged.

Don't merge this yet, I just caught a bug. The make-Union call is wrong because it doesn't sort the list first.

Can you have it keep using `Un` so that isn't an issue?

No, because this file is used to implement subtype.rkt which is used to implement union.rkt. I'll need to do the sorting manually.

Already applied.

Merged, thanks!

Could you add some tests that would be broken without this change? Thanks!

Merged, thanks!

This issue was fixed in commit c162657685efd0fca5662e157c438d8c71b99c34. Thanks for the report.

Can you rename `Bottom` to `-Bottom`? The convention helps keep straight what's an internal representation and what's an external name.

What about Univ? Does that need to be changed as well?

Sent from a mobile device.
On Feb 13, 2013 10:37 AM, "Sam Tobin-Hochstadt" notifications@github.com
wrote:

> Can you rename Bottom to -Bottom? The convention helps keep straight
> what's an internal representation and what's an external name.
> 
> —
> Reply to this email directly or view it on GitHubhttps://github.com/plt/racket/pull/241#issuecomment-13509779.

It might be nice to change it eventually, but it's not a big concern now.

On Wed, Feb 13, 2013 at 1:39 PM, Eric Dobson notifications@github.comwrote:

> What about Univ? Does that need to be changed as well?
> 
> Sent from a mobile device.
> On Feb 13, 2013 10:37 AM, "Sam Tobin-Hochstadt" notifications@github.com
> 
> wrote:
> 
> > Can you rename Bottom to -Bottom? The convention helps keep straight
> > what's an internal representation and what's an external name.
> > 
> > —
> > Reply to this email directly or view it on GitHub<
> > https://github.com/plt/racket/pull/241#issuecomment-13509779>.
> 
> —
> Reply to this email directly or view it on GitHubhttps://github.com/plt/racket/pull/241#issuecomment-13509904.

Updated.

This now is putting the elements in the union correctly.

I had trouble making tests that break at the user level since, usually by then the extra elements would be removed. But the added tests breaks in the old code if contracts are turned on.

Merged, thanks!

Merged. thanks! I'll look into the contract issues.

There are no contract issues. The tests catch the old code breaking internal contracts, which the new code doesn't trigger because it is correct and doesn't misuse make-Union.

Great, thanks.

Just updated to do better precision for ranged index types.

Merged -- thanks!

@stamourv, can you review the third commit here?

The others all look good to me.

Can you use `#lang racket/load` and top-level modules rather than submodules in multi-module test cases? I don't totally trust submodules not to introduce some additional level of complexity.

Done.

LGTM

Merged, thanks!

Merged, thanks!

Matthew implemented this better so it works for PDF and HTML.

r+ from me.

Might want to make a comment saying that this should eventually be based on actual understanding of struct properties.

r+

In the future, it's easier to review if the refactoring is in a separate commit.

You can go ahead and merge this.

@stamourv, can you take a look here?

r+

LGTM

This looks good to me -- it would be nice if the rightward drift and correction of the docs were collapsed into a single change so that we could see what meaningfully changed in the docs, but if the racket devs are OK with that, I think this is ready to pull.

Thanks!

On Wed, Feb 20, 2013 at 3:44 PM, David Van Horn notifications@github.comwrote:

> This looks good to me -- it would be nice if the rightward drift and
> correction of the docs were collapsed into a single change so that we could
> see what meaningfully changed in the docs, but if the racket devs are OK
> with that, I think this is ready to pull.

Do you mean split into separate changes? Otherwise I don't understand this
comment.

No, I mean one commit -- the first commit introduces a rightward drift in the Scribble code, the second fixes it.  Consequently, you can't look at the diffs and see what's changed that was important.

20 minutes ago, Patrick Mahoney wrote:

> Ah I apologize about the separate commits-I'm sorry to ask this, but
> my git is weak-how would one go about combining the two commits?

Do you mean that you want the two commits to be squashed into a single
one?  That's easy to do with an interactive rebase.

If David is fine with the overall change, then I can do the squashing
and pushing.  Just tell me what the combined commit log message should
say.

## 

```
      ((lambda (x) (x x)) (lambda (x) (x x)))          Eli Barzilay:
                http://barzilay.org/                   Maze is Life!
```

Yeah, I think this would be better if squashed.  I'll let Patrick decide on the message.  I'm fine with the overall change.

This does point to another problem-using Dr.Racket Reindent All (Ctrl+I) reintroduces the rightward shift. Not sure if that is expected. 
@elibarzilay thank you for doing the squash. I'm trying to figure out an interactive rebase, but not yet going smoothly...I'll ensure any future commits are rebased and squashed. 

Commit msg:
Move eopl to Racket
Notable changes 
-sllgen.rkt-Use begin-for-syntax and define-syntax instead of define-syntax-set. 
-eopl.rkt-Rewrite *threecolumns to work when number of lang forms reprovided 
is not divisible by 3. 
All
-Removal of mzscheme and mzlib requires. 
-Updated docs. 
Signed-off-by: Patrick Mahoney paddy.mahoney@gmail.com

Just now, Patrick Mahoney wrote:

> This does point to another problem-using Dr.Racket Reindent All
> (Ctrl+I) reintroduces the rightward shift. Not sure if that is
> expected.  @elibarzilay thank you for doing the squash. I'm trying
> to figure out an interactive rebase, but not yet going
> smoothly...I'll ensure any future commits are rebased and squashed.

OK, I'll do it.  (For instructions on how to do it google is your
friend, and see the text that I wrote at
http://git.racket-lang.org/intro.html#working_with_git_concurrent_development
)

> Commit msg:
> [...]
> Signed-off-by: Patrick Mahoney paddy.mahoney@gmail.com

There's no need for that, since you'll still be the commit's author.

In any case, I'll probably get to this sometime tonight.

## 

```
      ((lambda (x) (x x)) (lambda (x) (x x)))          Eli Barzilay:
                http://barzilay.org/                   Maze is Life!
```

@dvanhorn @elibarzilay 
There! Fixed the squashing. All in a single commit now. Please merge when able. 

Added comment about why subtyping is done the way it is.

Rebased and squashed. This is a single commit now (like was discussed in PR https://github.com/plt/racket/pull/254) Tests succeed.

I made a small comment on one of the test cases, but as a larger issue I don't think this is the right way to solve this problem.

The problem is that predicates for mutable data such as `vector?` don't have types that behave properly with regard to `restrict`.  I think the right solution here is just to have more smarts in `restrict` for various invariant data types, so that `(restrict (U (Vectorof Integer) (Listof Integer)) VectorTop)` produces `(Vectorof Integer)`, and to do something similar for `Sequenceof`.

Is there a larger reason why this can't work?  Do we need to tie vectors and sequences more closely together?

Another possibility would be to make `(Sequenceof T)` be a union consisting of the base sequences like lists and vectors and a new abstract type that handles the extensible case.

Ok, looks good. r+

I think special cases will do it, but this was an attempt to avoid the special cases. It is mostly an issue with sequences, because it only becomes an issue when overlap returns true, which sequences always do.

Making sequenceof a union will be hard because of non parametric sequences like Natural.

@dvanhorn, @elibarzilay, @paddymahoney, Perhaps I'm missing something obvious, but I think you guys are... um, missing something obvious. In particular, you can click the "files changed" tab at the top of a pull request to see a single diff for the whole pull request. Right?

@jbclements I am definitely aware of that, but I also want to respect the commit hygiene observed for the main branch.

Merged, thanks.

Sounds good to do something like this, but "variable" is a term that is loaded with the wrong meaning...

Yeah, I knew there'd be some objection along those lines.  I don't know
what term would be better.  I originally wrote "very roughly" at the
beginning of the sentence ...

On Sun, Feb 24, 2013 at 2:36 PM, Eli Barzilay notifications@github.comwrote:

> Sounds good to do something like this, but "variable" is a term that is
> loaded with the wrong meaning...
> 
> —
> Reply to this email directly or view it on GitHubhttps://github.com/plt/racket/pull/258#issuecomment-14017860.

Why not just s/variable/parameter/ ?

That's more accurate, but less helpful to the person who is skimming the
documentation, wondering what "parameterize" is for. They're not thinking
"I have this parameter and I'd like to change its value"; instead, they're
thinking "I have this _variable_ and I'd like to change its value".

It's true that they'll have to use a parameter instead of the simple
variable that they are now thinking of, but that's a detail.  In the guide,
I think it's more important to introduce the subject in terms that the user
might understand, than to be precise at all times.

On Sun, Feb 24, 2013 at 6:51 PM, Eli Barzilay notifications@github.comwrote:

> Why not just s/variable/parameter/ ?
> 
> —
> Reply to this email directly or view it on GitHubhttps://github.com/plt/racket/pull/258#issuecomment-14023409.

10 minutes ago, Eric Hanchrow wrote:

> That's more accurate, but less helpful to the person who is skimming
> the documentation, wondering what "parameterize" is for. They're not
> thinking "I have this parameter and I'd like to change its value";
> instead, they're thinking "I have this _variable_ and I'd like to
> change its value".

But that makes me think that I can do this:

```
(let ([x 1])
  (parameterize ([x 2])
    ...blah...))
```

IOW, it's confusing things with the old `fluid-let` thing.

> It's true that they'll have to use a parameter instead of the simple
> variable that they are now thinking of, but that's a detail. In the
> guide, I think it's more important to introduce the subject in terms
> that the user might understand, than to be precise at all times.

You're convincing me more that "parameter" is better -- it makes it
clearer that you should actually _make_ a parameter to use it...

## 

```
      ((lambda (x) (x x)) (lambda (x) (x x)))          Eli Barzilay:
                http://barzilay.org/                   Maze is Life!
```

Then perhaps a longer explanation is required. Say something like "often
one wants to temporarily set a variable. That doesn't work well in
situations .... so in Racket we use parameters".

Robby

On Sun, Feb 24, 2013 at 9:11 PM, Eric Hanchrow notifications@github.comwrote:

> That's more accurate, but less helpful to the person who is skimming the
> documentation, wondering what "parameterize" is for. They're not thinking
> "I have this parameter and I'd like to change its value"; instead, they're
> thinking "I have this _variable_ and I'd like to change its value".
> 
> It's true that they'll have to use a parameter instead of the simple
> variable that they are now thinking of, but that's a detail. In the guide,
> I think it's more important to introduce the subject in terms that the
> user
> might understand, than to be precise at all times.
> 
> On Sun, Feb 24, 2013 at 6:51 PM, Eli Barzilay notifications@github.comwrote:
> 
> > Why not just s/variable/parameter/ ?
> > 
> > —
> > Reply to this email directly or view it on GitHub<
> > https://github.com/plt/racket/pull/258#issuecomment-14023409>.
> 
> —
> Reply to this email directly or view it on GitHubhttps://github.com/plt/racket/pull/258#issuecomment-14023765.

[Shorter version: what Robby said.]

I agree with Eli that the text shouldn't say that 'parameterize' works on variables. Maybe try a larger change to the prose: motivate the idea first, and then introduce the terms "parameter" and the form 'parameterize'.

A few minutes ago, Robby Findler wrote:

> Then perhaps a longer explanation is required. Say something like
> "often one wants to temporarily set a variable. That doesn't work
> well in situations .... so in Racket we use parameters".

Just now, Matthew Flatt wrote:

> I agree with Eli that the text shouldn't say that `parameterize`
> works on variables. Maybe try a larger change to the prose: motivate
> the idea first, and then introduce the terms "parameter" and the
> form `parameterize`.

Sounds like you're suggesting the same thing, which sounds good to me,
though more than what I'd rely on myself to produce constructive
opinions on...

(BTW, github emails use their markdown, so quoted code should be
between two backquotes...)

## 

```
      ((lambda (x) (x x)) (lambda (x) (x x)))          Eli Barzilay:
                http://barzilay.org/                   Maze is Life!
```

My ¥2 as someone with a still-relatively-recent memory of what confused me:

I like the motivation behind Eric's change! It would have helped me, a few years ago.

I like explaining that parameters are an _alternative_ to variables. Parameters are functions you can call one way to set a value, and call another way to retrieve it. Plus the `parameterize` form lets you temporarily change the value, and restore it automatically and reliably.

(For the _Guide_, it's probably fine to gloss over other aspects like threads?)

---

FWIW the _Reference_ also uses parameters for [the `command-line` example](http://docs.racket-lang.org/reference/Command-Line_Parsing.htm). In that case, the motivation seems to be ... an idiom to avoid using `set!`? Made that example a bit confusing for me.

The last commit (aed9343) is causing some issues with the math library. Investigating.

Maybe the right thing to do here is to add examples of use to the Redex docs, which currently only shows an example with prefixes. (much more likely that people will see examples in docs rather than test folders)

All EXTRALIBS are installed always on OpenBSD. The user will never have problems with missing libs.

I don't think the libraries listed in EXTRALIBS should be linked to Racket. Those libraries happen to be used in some collections in the distribution, but some of those collections should move out of the distribution one day, and third-party packages should be on an equal footing anyway.

Instead, I think `ffi-lib' should open foreign libraries in global mode by default on OpenBSD. I'll add that option to the build and enable it for OpenBSD. I'll also get rid of the special handing for OpenBSD in the "openssl" collection when loading "libcrypto".

In the case of "curses", should that be added to the start of `readline/mzrl' along the same lines as "termcap"?

I know EXTRALIB isn't the correct fix but I guessed is a good enough temporal workaround for users compiling their own distro. I remember a mail you sent to mailing list explaining the problem with OpenBSD and FFI. Thanks for fix the issue, I've been discovering each missing lib with trial and error :) .

I need compile racket without curses linked for test readline again. I'll comment you the results tomorrow.

It looks like Robby already merged this in and made these changes.

I've added this before of the line "define libreadline":

``` racket
(define libncurses  (ffi-lib "libcurses" #:global? #t))
```

All works OK.

13:30 stamourv: mithos28: Re 222: What's the problem that this is fixing?

This is making it so that in contexts where we don't care about the return type of an expression ('begin's and such), that it doesn't give a match failure issue. It also adds a bit of machinery to make that more easily testable by adding an #:expected argument to tc-e.

Sounds good.

Merged -- thanks!

Ok this should be ready for review now.

Moved to xfail as @starmourv suggested. The issue is that this hides that the error is now different. The error is now that we cannot type optional arguments correctly, which is tracked in a different bug. The internal error is now gone.

Added a test by @stamourv's request and fixed an issue that it caught.

Added test as @starmourv suggested.

I don't think that this would be a good idea.  On one hand, you're targeting a specific use where the cstruct is passed to foreign code that may keep a pointer to it -- otherwise there is usually no need to have it be immobile.  (Since if it's not passed out then it's fine, and the same for foreign code that won't keep a copy of the pointer.)

On the other hand, it adds machinery that could be layered on top of csrtucts now, and that's (IMO) a step in a bad direction since you're extending cstructs with more such features instead of using the features directly.  In this case it seems that what you want is even worse -- it would make a `_racket` type behave in a truly different way than what it is underneath, which reminds me of the mess that C got into with function pointers.

(But maybe @mflatt will have a different opinion...)

LGTM

LGTM

LGTM

@samth can you have a look?

Ok I fixed the issues that happened this morning because of a bad merge. The vector change was an addition that didn't get fixed up, and the infinities were ones that got lost because of changing the indentation amount.

Could we use the currently unused argument to improve error messages?

Second commit LGTM. I commented on the other in the previous pull request.

LGTM. Please squash the commits if you can.

Will do, but I knew you'd appreciate them separate when reviewing.

On Thu, Mar 7, 2013 at 3:07 PM, Vincent St-Amour
notifications@github.comwrote:

> LGTM. Please squash the commits if you can.
> 
> —
> Reply to this email directly or view it on GitHubhttps://github.com/plt/racket/pull/253#issuecomment-14592505
> .

Do you have any suggestions on where it would be more useful than the current-orig-stx?

No. I was just wondering.
The patch LGTM.

Ping.

This now passes all the optimizer tests because of the just committed work on check-below.

Ping.

LGTM

I'm not sure I understand what this is doing. Based on the commit message, it sounds odd. Could you explain?

Gotta run, but the quick answer is that a function that takes a rest
argument should be able to be typed as taking only one positional argument.

On Fri, Mar 8, 2013 at 10:02 AM, Vincent St-Amour
notifications@github.comwrote:

> I'm not sure I understand what this is doing. Based on the commit message,
> it sounds odd. Could you explain?
> 
> —
> Reply to this email directly or view it on GitHubhttps://github.com/plt/racket/pull/225#issuecomment-14634037
> .

(Closed, since you said that it was merged -- thanks!)

This looks fine. r+

I've left a bunch of notes, mostly requests for more commenting in the code.  With that, r+ from me.

Added comments for in the two places. Will squash commits before submitting.

Looks good. r+

Nice catch. r+ but use [] for `let`.

Looks good.  Is there any way the test can be a unit test? r+

Currently no. The issue is that it is in the expansion of define:, and the unit tests don't check internal definitions correctly, and don't support module level definitions.

Ah well.

@stamourv has pulled and will push the fix for pretty-format at some point.

This is fine. r+

@ntoronto, This also affects some math code as it was abusing the broken behavior but with the changes it should work.

@takikawa, can you take a look at this as well?

In addition to passing tests, this now is not dependent on any other pull requests.

I pushed fixes for the comments.

Could we just enable this static check only when `from-typed?` is false?

No. Thats what the second test case I added is about.

The issue is that free vars don't necessarily imply that they are parametric contracts. And not all parametric contracts appear as free vars, example (All (a b) ((U (All (c) a) b) -> Boolean)).

On Sat, Mar 23, 2013 at 7:09 PM, Eric Dobson notifications@github.com wrote:

> No. Thats what the second test case I added is about.

We could fix that by looking at the tracked recursive vars, right?

> The issue is that free vars don't necessarily imply that they are parametric contracts. And not all parametric contracts appear as free vars, example (All (a b) ((U (All (c) a) b) -> Boolean)).

That's equivalent to (and represented as) `(U a b)`. And even if this
check isn't catching everything, the dynamic failure of contracts we
generate is problematic, because it's totally impossible for the user
to understand.

On Sat, Mar 23, 2013 at 4:13 PM, Sam Tobin-Hochstadt <
notifications@github.com> wrote:

> On Sat, Mar 23, 2013 at 7:09 PM, Eric Dobson notifications@github.com
> wrote:
> 
> > No. Thats what the second test case I added is about.
> 
> We could fix that by looking at the tracked recursive vars, right?
> 
> We would need to annotate the vars with what they are bound to in a way
> that it is understandable, while currently we just put the syntax of the
> contract there. With recursive contracts this is actually impossible to do
> correctly with the current mechanism, as we might not have encountered the
> other parametric part yet,
> (All (a b) (Rec (c) (U (Listof (U a c)) b))).
> 
> > The issue is that free vars don't necessarily imply that they are
> > parametric contracts. And not all parametric contracts appear as free vars,
> > example (All (a b) ((U (All (c) a) b) -> Boolean)).
> 
> That's equivalent to (and represented as) `(U a b)`. And even if this
> check isn't catching everything, the dynamic failure of contracts we
> generate is problematic, because it's totally impossible for the user
> to understand.

It is equivalent to that, but is not represented as that IIRC, which is the
issue.

The current issue is that this check is incorrect in the other direction
which is preventing correct programs from working. This is an actual user
issue not a theoretical one, (Danny brought it up on the list).

> —
> Reply to this email directly or view it on GitHubhttps://github.com/plt/racket/pull/285#issuecomment-15347428
> .

Can you split these two changes? r+ with that.

@plt Can I work with someone to go over the changes in this commit? I am confident that this is ready to be pulled.

Does this change have an impact on performance?
I left some comments on the commit.

How do I measure performance? Is there a loadtest somewhere? I would doubt it has significant changes though. lazy-require is just doing the manual dynamic require behind the scenes, plus a tiny bit of bookkeeping which is the point of switching. 

Running the test suite (with -j 1) would be a start. @samth, do we have programs around to benchmark the typechecker?

That would take on the order of 10-15 minutes, and I believe random noise of other stuff the computer was doing in the interim would be a huge issue between different runs.

For this patch, which only changes when things are loaded, I'd try timing a
tiny program with a type error, and one with a non-type syntax error, both
using `raco make`.

On Sun, Mar 24, 2013 at 12:20 PM, Vincent St-Amour <notifications@github.com

> wrote:
> 
> Running the test suite (with -j 1) would be a start. @samthhttps://github.com/samth,
> do we have programs around to benchmark the typechecker?
> 
> —
> Reply to this email directly or view it on GitHubhttps://github.com/plt/racket/pull/284#issuecomment-15361846
> .

Four hours ago, Patrick Mahoney wrote:

> @plt Can I work with someone to go over the changes in this commit? I am
> confident that this is ready to be pulled.

I hope to get to it some time soon-ish...

## 

```
      ((lambda (x) (x x)) (lambda (x) (x x)))          Eli Barzilay:
                http://barzilay.org/                   Maze is Life!
```

For all three of syntax-error, type-error, and working program the differences were not discernable from noise.

Closing this till type variable scoping is resolved.

LGTM

Could you add more tests, and maybe some comments that explain in which case filter subtyping is needed?

LGTM

Added test cases and fixed -FS which was changing (-FS -bot -bot) to (-FS -bot -top).

Unfortunately, by removing the binding of the type variable here, you can't express something like this:

```
(: g (All (a ...) (a ... a -> (List a ... a))))
(define (g . rst)
  (map (lambda: ([x : a]) x) rst))
```

which used to work, because the following does not work:

```
(: g (All (a ...) (a ... a -> (List a ... a))))
(define (g . rst)
  (map (plambda: (a) ([x : a]) x) rst))
```

unless there's something I'm missing and you can express this with the new changes.

The second one should work as that is what I did for all the fixes, I'll
take a look later tonight.

On Mon, Mar 25, 2013 at 3:35 PM, Asumu Takikawa notifications@github.comwrote:

> Unfortunately, by removing the binding of the type variable here, you
> can't express something like this:
> 
> (: g (All (a ...) (a ... a -> (List a ... a))))
> (define (g . rst)
>   (map (lambda: ([x : a]) x) rst))
> 
> which used to work, because the following does not work:
> 
> (: g (All (a ...) (a ... a -> (List a ... a))))
> (define (g . rst)
>   (map (plambda: (a) ([x : a]) x) rst))
> 
> unless there's something I'm missing and you can express this with the new
> changes.
> 
> —
> Reply to this email directly or view it on GitHubhttps://github.com/plt/racket/pull/283#issuecomment-15430092
> .

That was a preexisting issue, for which there is now a fix. It was typechecking the function with the wrong expected type. The expected type is only used to help inference for polymorphic functions, so it wasn't used in your first example.

This would have failed before.
(: g (All (a ...) (a ... a -> (List a ... a))))
(define (g . rst)
  (map (plambda: (b) ([x : a]) x) rst))

@stamourv, this is for you.

What do you mean by "inference is bad"?

r+

Looks good. Clever use of `#%expression` as the identity. r+

Looking over this, this basically just changes lifting map to require a forall type for its first argument (which it'll then appropriately instantiate) instead of introducing the index variable as a regular variable, right?  That'll ensure that consecutive calls to the function can't assume the argument type is the same within the same lifting operation (or even across multiple lifting operations).  That's a great way of tackling this problem!  Kinda irritated with myself that I didn't see the big lambda approach when we were discussing this over the mailing list.

Changes look correct to me. A couple of things, though:
- Can you run the random tester (`tests/typed-racket/tr-random-testing.rkt`) with 1M+ test cases? Just to be sure.
- That adds quite a few clauses, which can slow down typechecking.
  - Some of these clauses are redundant, since unary cases are covered in the `varop` and `varop-1+` clauses.
  - Ordering of clauses is also an issue. Putting the new clauses at the beginning means that to typecheck, say, a simple `Integer` addition, you need to try all the new clauses first. I think it would be better to put the unary cases with other clauses of that type.

LGTM. That type was too conservative. Can you run the random tester?

The problem was (case-> (Real Zero -> One) (Real (U PosInt NegInt) -> Real)) <: (Real Integer -> Real)) was not inferred.

I wouldn't say this is inference, just subtyping. But I agree that we don't have a complete algorithm for subtyping in the presence of case-> and U.

Well there is also the step of figuring out how to apply it, which is a
different fix than direct subtyping because its different code doing that.
But I agree inference is likely not the right word.

On Tue, Mar 26, 2013 at 9:05 AM, Sam Tobin-Hochstadt <
notifications@github.com> wrote:

> I wouldn't say this is inference, just subtyping. But I agree that we
> don't have a complete algorithm for subtyping in the presence of case-> and
> U.
> 
> —
> Reply to this email directly or view it on GitHubhttps://github.com/plt/racket/pull/295#issuecomment-15467643
> .

LGTM

Reordered clauses ran tr-random testing, and it passed.

Thanks for the explanation and for closing the bug.

LGTM

@samth can you have a look at this one?

LGTM

LGTM

Yes, but not till the weekend probably.

On Wed, Apr 3, 2013 at 11:10 AM, Vincent St-Amour
notifications@github.comwrote:

> @samth https://github.com/samth can you have a look at this one?
> 
> —
> Reply to this email directly or view it on GitHubhttps://github.com/plt/racket/pull/276#issuecomment-15842334
> .

Could you explain what the problem was? Either in comments, or in the commit message.

LGTM

On Thu, Apr 4, 2013 at 10:13 AM, Vincent St-Amour
notifications@github.comwrote:

> Could you explain what the problem was? Either in comments, or in the
> commit message.
> 
> I assume that the problem was creating an explicit filter, instead of using
> the NoFilter placeholder, which then causes a real filter discovered later
> not to be used.

That and fixing my habit of way-too-long lines ... :)

Sam

The issue was that -FS takes a filter/c not null. 

Maybe use `ooo` instead of `...` in some places, like the docs for `match` do.

LGTM

Commit message updated.

Thats a possibility, but where would I document what `ooo` means. Match has it easy because it is all in one defform.

LGTM

Maybe explain it once in section 1.6, and have the docs of binding forms point to that explanation?

How do I get the docs to link back to it?

You can just link to the whole section.

Fixed based on Asumu's comments. Sorry if my scribble knowledge is poor, but 'HOW' do I link the subform in a defform to a section?

I may just be being really dense here, but in what situation can a `lambda:` formal have a `...` with no bound? (oh, I just noticed you explained it in a comment before, but it got wiped out by github... I didn't fully understand it though. How does inference mean you don't need the bound here?)

Nope, I messed up there. It is now fixed.

On Fri, Apr 5, 2013 at 12:23 PM, Asumu Takikawa notifications@github.comwrote:

> I may just be being really dense here, but in what situation can a lambda:formal have a
> ... with no bound?
> 
> —
> Reply to this email directly or view it on GitHubhttps://github.com/plt/racket/pull/305#issuecomment-15975458
> .

Merged -- thanks.

Merged -- thanks.

Merged -- thanks.

Merged -- thanks.

Merged -- thanks.

Merged -- thanks.

This may be incorrect as from-typed? switched on every tc/neg but out did not.

Actually it works because of the and which ensures that they are matching, which means that from-typed was true at the start.

And flipfloping another time, it is safe to not require the pos? check.

LGTM now.

I committed this change and also changed the source `configure.ac` accordingly.

@sstrickl @takikawa I'm leaving review of this up to you.  Is it ok to merge?

Somehow GitHub claims this was updated recently.  Did something change?

I have rebased it, but I don't believe I have gotten around to fixing the underlying issue. I try and send a message saying that I have updated it to address comments so that it is obvious that the ball is in the reveiewers court.

Ah, ok.  I figured it wasn't done, but I wasn't sure why github thought it
changed.

On Thu, Apr 11, 2013 at 12:54 PM, Eric Dobson notifications@github.comwrote:

> I have rebased it, but I don't believe I have gotten around to fixing the
> underlying issue. I try and send a message saying that I have updated it to
> address comments so that it is obvious that the ball is in the reveiewers
> court.
> 
> —
> Reply to this email directly or view it on GitHubhttps://github.com/plt/racket/pull/159#issuecomment-16247209
> .

I've tested the patch in -current. I guess it works also in 5.3 and 5.2.

Essentially I've reverted my former change to the previous behavior but limiting the maximum size to 4096kb (the default limit for non-root users). Some scribble documents increase the size of the stack beyond of the limits due to the default maximum size of 8192kb. I think my previous patch just hided the real problem. Probably the change in STACK_SAFETY_MARGIN isn't necessary but I prefer to be safe.

I guess the only preprocessor test possible here is to include "sys/param.h" and to check the value of "OpenBSD". "201305" for OpenBSD 5.3 and "201211" for OpenBSD 5.2. 

Thanks!

When I run your example on Mac OS X, I get messages like

 2013-04-12 11:13:53.800 racket[4577:403] invalid drawable
 2013-04-12 11:13:53.897 racket[4577:403] invalid drawable

but it usually works, anyway. Sometimes, I get

  OpenGL error in procedure glClear: Error code 1286.

in which case the program doesn't work.

Any idea what might be happening?

The docs for setOpenGLContext: say that you should call
setView: to sync, but setView: seems to be complaining
with "invalid drawable", perhaps because the view doesn't
yet have a parent. Just skipping the call seems to be
ok.

With that change, the 1286 problem remains, though.

This Q/A: http://stackoverflow.com/questions/15936059/how-do-i-detect-invalid-drawable-in-mac-os-x (from yesterday!) suggests that the setView should wait until after the NSOpenGLView has appeared on the screen in some way. I'm not sure where that would be in the code.

I'm not getting the 1286 thing, even after running it a bunch. I see claims floating around the interwebs that it corresponds to a GL_INVALID_FRAMEBUFFER_OPERATION_EXT error, which doesn't seem plausible, or helpful. My only thought is to try doing correctly the one thing I know isn't being done correctly, the setView placement.

Sadly, I just noticed that on OSX I'm ending up with NSOpenGLContexts as the handles for a gl-context% that comes from a canvas, and AGLContexts as the handles that come from a bitmap. You can't go from one to the other, as near as I can tell. :(

I think I could manage to replace the AGL stuff for bitmaps with CGL (which is compatible with NSOpenGLContexts).

It looks like the 1286 error is unrelated to sharing contexts. It can happen even
without context sharing.

I'll push the patch so far and leave it to you to sort out sharing contexts and
bitmaps (where a reasonable choice might be to just not support the mismatch).

Thanks, this has been merged.

Having investigated the AGL vs CGL situation, it looks like AGL is technically deprecated in 10.8, since it is a Carbon API. I believe I can find time in the next couple weeks to redo the AGL stuff to use CGL, which will make the bitmap / sharing context stuff work nicely as a side effect.

I'll try to switch over to using framebuffers with CGL, too, to eliminate all of the dependancies on deprecated functionality. (The PBuffer stuff being used is specifically deprecated.)

This seems obviously right to me.  r+

I looked into the commits. I am mostly convinced that it works, and I haven't been able to find any counterexamples so far. I think it would be helpful if some more comments were added. For example, line 45 of `tc-app-list.rkt` is fairly important since it's the line guaranteeing that `map` can't refer to the type variable.

Thanks --- I'll push the patch with some adjustments: keeping the old configuration
for versions before 5.2, and dropping the adjustment to STACK_SAFETY_MARGIN
(since, whatever the right answer is, I think it should be the same for all Unix variants).

Merged, thanks!

Tested on i386 and amd64, collects/tests/racket/extflonum.rktl:
Performed 390 expression tests (390 value expressions, 0 exn expressions)
and 0 exception field tests.

Passed all tests.

Ping.

Ping.

Ping.

Ping.

I'm not sure what you are referring to, as line 45 doesn't do that, it just computes the element type of the list.

r+.  Whitespace fixes and other stuff like this you can just commit without review.

r+ with that comment.

r+

r+

Well, it's computing the element type notably without the `bound` bound as a type variable right? So this prevents the lambda from using the polydots variable as a normal type variable.

Are you refering to line 45 after the first commit or after the second? I think I understand your point if it is after the first commit.

Sorry, I was unclear. It was line 45 after the first commit. I like the new comment you added.

@takikawa Are you good with this PR now?  @sstrickl Any thoughts?

@samth Yes.

@samth No extra input from me. I'm good with @takikawa's investigation.

Ok, r+
On Apr 24, 2013 8:37 PM, "Stevie Strickland" notifications@github.com
wrote:

> @samth https://github.com/samth No extra input from me. I'm good with
> @takikawa https://github.com/takikawa's investigation.
> 
> —
> Reply to this email directly or view it on GitHubhttps://github.com/plt/racket/pull/283#issuecomment-16985696
> .

I believe I addressed the comments. Some unit tests broke, looks like a bad interaction with other recent changes I have made.

Fixed the issue, moving code did not catch change.

Ping.

Ping.

Ping.

Maybe move the provide/cond-contracts to next to the definitions so it's easy to see the contract.  r+

You may want to fix the commit messages, but other than that LGTM.

Could you add the description of the pull request to the commit message? Other than that LGTM.

On the one hand, that change makes sense from a code organization perspective. On the other hand, that would make it harder to trace the history of changes to that function, since that history would span multiple files. Or maybe my git-fu is weak, and there's actually an easy way to do that?

Same comment as #326.

It has been some time but you were right. After a bit of a struggle it was much easier to create two layers of abstraction: one to deal with the real FFI bindings and another to deal with the memory allocation. So far this setting is working great, no need to add extra features to a define-cstruct indeed.

I've pushed a repair - thanks!

git log --follow should do what you want, supposedly it is a hack. I know how to do this in perforce, but it seems that git doesn't have the same feature set.

Its not actually more correct overall because later stages (refine-struct-variance) fix it, but it makes it so that add-constant-variance! actual is setting them to constant variance and not covariant. I'll fix up the commit message though.

No problem, thanks for the quick fix!

Actually found an infinite loop that was possible in the old code and not in the new.

I redid this and it didn't have the error, so I will go forward with that pull request.

@ntoronto (or maybe @stamourv?) can you review this?

I'm not happy with the change to static struct info here.  Typed modules shouldn't need to have contracts when using `match`, for example, which this would imply.

I recognize that `struct-copy` is problematic, but we should be able to either fix that some other way, or fix `struct-copy` not to be an awful hack. More sensible macros shouldn't pay the price for that.

This doesn't make them have contracts. This makes the static struct info
refer to the protected identifiers, not the contracted identifiers as you
are implying, and the previous implementation expanded them to the original
identifiers. The protected identifiers are the ones that rename themselves
to the original identifiers in typed contexts and the contracted ones when
in an untyped module.

On Mon, Apr 29, 2013 at 5:13 AM, Sam Tobin-Hochstadt <
notifications@github.com> wrote:

> I'm not happy with the change to static struct info here. Typed modules
> shouldn't need to have contracts when using match, for example, which
> this would imply.
> 
> I recognize that struct-copy is problematic, but we should be able to
> either fix that some other way, or fix struct-copy not to be an awful
> hack. More sensible macros shouldn't pay the price for that.
> 
> —
> Reply to this email directly or view it on GitHubhttps://github.com/plt/racket/pull/331#issuecomment-17163139
> .

While I recognize that git is a big pile of hacks, and rename/copy support is sad, it's our version control system, and we can't let it stand in the way of moving code around.  So I don't think this objection should hold up the patch.

@shekari that only works for renames, not code extraction.

@samth I agree that we shouldn't let our tools stand in our way, but since the gains from moving this code are (IMO) pretty small, I'm wondering if they're worth potentially making debugging (specifically, tracking down when and why changes happened) harder down the road.

LGTM

Modulo the fixes I commented on above, it looks good to me. I've run the tests on my end and they all seem to pass.

I believe I have addressed all the comments.

Ping.

Looks good to me. Thanks for the fixes.

Would it make sense to create a package that defines the `xid-start` and `xid-continue` lexer abbreviations, instead?

(What's "r"?)

I naturally object to adding such a huge file to the code, especially not into the parser tools where it seems like something that is more general than just that.

So some changes that I think should be done:
- Find some better place for the functionality.  Maybe a new `racket/unicode`?
- Write a quick script that parses the file and "compiles" it to a racket file that represents it.  IIUC, the file in this case would result in some big-ish `(or (<= N1 c N2) ...)` thing.  Add the resulting file to the code.  (Either as a standalone file, or as part of the new public module.
- Finally, take the script and stash it somewhere as a test.  For example, `tests/racket/unicode.rktl` which would retrieve the unicode file, recompile, and verify that the generated code is updated.  This could even be optimized by adding some kind of hash to the generated code, and have the test compute the hash of the text and see if it changed.  Now when the test fails, anyone can go to the source, and see some comment that clearly explains how to update the code.

Like Matthew says, I think the package system seems like a good alternative
to try here.

Robby

On Friday, May 3, 2013, Eli Barzilay wrote:

> (What's "r"?)
> 
> I naturally object to adding such a huge file to the code, especially not
> into the parser tools where it seems like something that is more general
> than just that.
> 
> So some changes that I think should be done:
> 
>    -
> 
>    Find some better place for the functionality. Maybe a new
>    racket/unicode?
>    -
> 
>    Write a quick script that parses the file and "compiles" it to a
>    racket file that represents it. IIUC, the file in this case would result in
>    some big-ish (or (<= N1 c N2) ...) thing. Add the resulting file to
>    the code. (Either as a standalone file, or as part of the new public module.
>    -
> 
>    Finally, take the script and stash it somewhere as a test. For
>    example, tests/racket/unicode.rktl which would retrieve the unicode
>    file, recompile, and verify that the generated code is updated. This could
>    even be optimized by adding some kind of hash to the generated code, and
>    have the test compute the hash of the text and see if it changed. Now when
>    the test fails, anyone can go to the source, and see some comment that
>    clearly explains how to update the code.
> 
> —
> Reply to this email directly or view it on GitHubhttps://github.com/plt/racket/pull/334#issuecomment-17399046
> .

Two things:
1. IMO what I suggested is applicable for a package too.  (But of
   course it's pushed into an issue between John and his users...)
2. I think that there are various Unicode related properties that are
   good to have -- and having a racket/unicode would be nice for such
   things.  (Something similar that I wanted at some point is a bidi
   thing.)  I think that many of these things, if done the way I
   suggested, should be pretty small.

[And an semi-related comment: the new file itself indicates that it's
generated, so maybe it makes sense to use the master if it's easy
enough.]

A few minutes ago, Robby Findler wrote:

> Like Matthew says, I think the package system seems like a good
> alternative to try here.
> 
> Robby
> 
> On Friday, May 3, 2013, Eli Barzilay wrote:
> 
> > (What's "r"?)
> > 
> > I naturally object to adding such a huge file to the code, especially not
> > into the parser tools where it seems like something that is more general
> > than just that.
> > 
> > So some changes that I think should be done:
> > 
> > ## 
> > 
> > Find some better place for the functionality. Maybe a new
> > 
> > ## racket/unicode?
> > 
> > Write a quick script that parses the file and "compiles" it to a
> > racket file that represents it. IIUC, the file in this case would result in
> > some big-ish (or (<= N1 c N2) ...) thing. Add the resulting file to
> > 
> > ## the code. (Either as a standalone file, or as part of the new public module.
> > 
> > Finally, take the script and stash it somewhere as a test. For
> > example, tests/racket/unicode.rktl which would retrieve the unicode
> > file, recompile, and verify that the generated code is updated. This could
> > even be optimized by adding some kind of hash to the generated code, and
> > have the test compute the hash of the text and see if it changed. Now when
> > the test fails, anyone can go to the source, and see some comment that
> > clearly explains how to update the code.
> > 
> > —
> > Reply to this email directly or view it on GitHub<https://github.com/plt/
> > racket/pull/334#issuecomment-17399046>
> > .
> 
> —
> Reply to this email directly or view it on GitHub.*

## 

```
      ((lambda (x) (x x)) (lambda (x) (x x)))          Eli Barzilay:
                http://barzilay.org/                   Maze is Life!
```

All agreed.

On Fri, May 3, 2013 at 10:45 AM, Eli Barzilay notifications@github.comwrote:

> Two things:
> 1. IMO what I suggested is applicable for a package too. (But of
>    course it's pushed into an issue between John and his users...)
> 2. I think that there are various Unicode related properties that are
>    good to have -- and having a racket/unicode would be nice for such
>    things. (Something similar that I wanted at some point is a bidi
>    thing.) I think that many of these things, if done the way I
>    suggested, should be pretty small.
> 
> [And an semi-related comment: the new file itself indicates that it's
> generated, so maybe it makes sense to use the master if it's easy
> enough.]
> 
> A few minutes ago, Robby Findler wrote:
> 
> > Like Matthew says, I think the package system seems like a good
> > alternative to try here.
> > 
> > Robby
> > 
> > On Friday, May 3, 2013, Eli Barzilay wrote:
> > 
> > > (What's "r"?)
> > > 
> > > I naturally object to adding such a huge file to the code, especially
> > > not
> > > into the parser tools where it seems like something that is more
> > > general
> > > than just that.
> > > 
> > > So some changes that I think should be done:
> > > 
> > > ## 
> > > 
> > > Find some better place for the functionality. Maybe a new
> > > 
> > > ## racket/unicode?
> > > 
> > > Write a quick script that parses the file and "compiles" it to a
> > > racket file that represents it. IIUC, the file in this case would
> > > result in
> > > some big-ish (or (<= N1 c N2) ...) thing. Add the resulting file to
> > > the code. (Either as a standalone file, or as part of the new public
> > > 
> > > ## module.
> > > 
> > > Finally, take the script and stash it somewhere as a test. For
> > > example, tests/racket/unicode.rktl which would retrieve the unicode
> > > file, recompile, and verify that the generated code is updated. This
> > > could
> > > even be optimized by adding some kind of hash to the generated code,
> > > and
> > > have the test compute the hash of the text and see if it changed. Now
> > > when
> > > the test fails, anyone can go to the source, and see some comment that
> > > clearly explains how to update the code.
> > > 
> > > —
> > > Reply to this email directly or view it on GitHub<
> > > https://github.com/plt/
> > > racket/pull/334#issuecomment-17399046>
> > > .
> > 
> > —
> > Reply to this email directly or view it on GitHub.*
> 
> ## 
> 
> ((lambda (x) (x x)) (lambda (x) (x x))) Eli Barzilay:
> http://barzilay.org/ Maze is Life!
> 
> —
> Reply to this email directly or view it on GitHubhttps://github.com/plt/racket/pull/334#issuecomment-17401600
> .

@elibarzilay r? is asking you for review and/or approval for the patch.

tc-expr is way too big, so I'm ok with the minor loss to the tools here. r+

r+

r+

Merged, thanks.

Merged, thanks!

Is there an update here?

@elibarzilay Can you review this?

r+ with the (fairly minor) inline comments addressed.

More than a week ago, Sam Tobin-Hochstadt wrote:

> While I recognize that git is a big pile of hacks, and rename/copy
> support is sad, it's our version control system, and we can't let it
> stand in the way of moving code around. So I don't think this
> objection should hold up the patch.

FWIW, it's generally a good idea to commit a move by itself, and
changes to code in a separate commit -- so the detection of code
movement is maximmized.

More than a week ago, Vincent St-Amour wrote:

> @shekari that only works for renames, not code extraction.

It should work for either case, at least in theory.  And actually, the
point that is usually made in the git circles about the lack of
formalized rename data is relevant for this exact case where you
should also look at the content that moved and not the file names that
happened to have been renamed -- since you're moving only a part of a
file into its own file.  With something like svn you really wouldn't
be able to represent this, since the system has an idea of file
renames which you can't use in this case, in contrast to git that says
"only the contents matters" and you automatically work with that.
(Even if support for that doesn't exist now, or is inconvenient, and
might be added in the future.)

## 

```
      ((lambda (x) (x x)) (lambda (x) (x x)))          Eli Barzilay:
                http://barzilay.org/                   Maze is Life!
```

(_sigh_ for the illusion that markdown is somehow natural enough to use both email and web for these comments.)

This looks good to me overall and I have pushed it to our repo. I changed
the unsupported and unimplemented stuff to delay the error until something
is actually asked for from a corresponding enumeration.

Some requests:

Can you configure emacs/geiser to not insert any tab characters when
indenting?

Also, the 'let' paren convention we use is (let ([x 1]) x) not (let [(x 1)]
x).

Oh, and here's a bug:

#lang racket
(require redex/reduction-semantics)
(define-language L
  (e ::=
     (e e)
     (λ (var) e)
     var)
  (var ::= x y z))

(define e? (redex-match L e))

(for/list ([i (in-range 100)])
  (define an-e (generate-term L e #:i-th i))
  (unless (e? an-e)
    (error 'generate-term-failure
           "item ~s is ~s but e? says #f"
           i
           an-e)))

(the lambda expressions should have parens around them).

I think you should set up test cases for this that just build up
interesting languages and patterns and then do the above.

Robby

On Thu, May 9, 2013 at 4:35 PM, Max New notifications@github.com wrote:

> Ported work from: https://github.com/maxsnew/rack-enum to work in the
> redex source.
> 
> Supports names and recursive patterns.
> 
> ## Limited support for repeats and mismatches.
> 
> You can merge this Pull Request by running
> 
>   git pull https://github.com/maxsnew/racket master
> 
> Or view, comment on, or merge it at:
> 
>   https://github.com/plt/racket/pull/336
> Commit Summary
> - Added Redex enumerators.
> 
> File Changes
> - _M_ collects/redex/private/enum.rkthttps://github.com/plt/racket/pull/336/files#diff-0(522)
> - _A_ collects/redex/private/enumerator.rkthttps://github.com/plt/racket/pull/336/files#diff-1(861)
> 
> Patch Links:
> - https://github.com/plt/racket/pull/336.patch
> - https://github.com/plt/racket/pull/336.diff

The Mac OS X `libtool` is apparently unrelated to usual `libtool`. Use the `--disable-lt` flag to `configure` to avoid it.

Unless you really specifically need `--enable-shared`, though, I recommend dropping it, which will also avoid the problem.

got it, thanks @mflatt 

What's "r?"

On May 10, 2013, at 11:08 AM, Eli Barzilay wrote:

> What's "r?"

It means I'm asking you politely to review and approve it, if you have time.  It may be a Mozilla-ism.

John

> —
> Reply to this email directly or view it on GitHub.

Cleaned up to now match head.

Thanks, pushed.

Robby

On Mon, May 13, 2013 at 9:26 PM, Max New notifications@github.com wrote:

> ---
> 
> You can merge this Pull Request by running
> 
>   git pull https://github.com/maxsnew/racket master
> 
> Or view, comment on, or merge it at:
> 
>   https://github.com/plt/racket/pull/340
> Commit Summary
> - Fixed bad let syntax
> - Hacky fix to only flatten repeats
> - Added Redex enum tests
> - Removed tabs from redex enum code
> 
> File Changes
> - _M_ collects/redex/private/enum.rkthttps://github.com/plt/racket/pull/340/files#diff-0(662)
> - _M_ collects/redex/private/enumerator.rkthttps://github.com/plt/racket/pull/340/files#diff-1(1310)
> - _A_ collects/redex/tests/enum-test.rkthttps://github.com/plt/racket/pull/340/files#diff-2(38)
> 
> Patch Links:
> - https://github.com/plt/racket/pull/340.patch
> - https://github.com/plt/racket/pull/340.diff

r+

Thanks, pushed.

On Mon, May 20, 2013 at 7:53 PM, Max New notifications@github.com wrote:

> ## Also various internal changes and an API contract change.
> 
> You can merge this Pull Request by running
> 
>   git pull https://github.com/maxsnew/racket master
> 
> Or view, comment on, or merge it at:
> 
>   https://github.com/plt/racket/pull/343
> Commit Summary
> - Redex enum supports var-except.
> - Redex enum maintains bijection internally
> - Added holes to redex enumerator.
> - Redex generator supports mismatched names.
> 
> File Changes
> - _M_ collects/redex/private/compiler/redextomatrix.rkthttps://github.com/plt/racket/pull/343/files#diff-0(3)
> - _M_ collects/redex/private/enum.rkthttps://github.com/plt/racket/pull/343/files#diff-1(989)
> - _M_ collects/redex/private/enumerator.rkthttps://github.com/plt/racket/pull/343/files#diff-2(664)
> - _M_ collects/redex/private/lang-struct.rkthttps://github.com/plt/racket/pull/343/files#diff-3(13)
> - _M_ collects/redex/private/matcher.rkthttps://github.com/plt/racket/pull/343/files#diff-4(9)
> - _M_ collects/redex/private/size-snip.rkthttps://github.com/plt/racket/pull/343/files#diff-5(1)
> - _M_ collects/redex/private/term.rkthttps://github.com/plt/racket/pull/343/files#diff-6(1)
> - _M_ collects/redex/tests/compiler/redex-tests.rkthttps://github.com/plt/racket/pull/343/files#diff-7(3)
> - _M_ collects/redex/tests/enum-test.rkthttps://github.com/plt/racket/pull/343/files#diff-8(55)
> - _M_ collects/redex/tests/term-test.rkthttps://github.com/plt/racket/pull/343/files#diff-9(1)
> - _M_ collects/redex/tests/test-util.rkthttps://github.com/plt/racket/pull/343/files#diff-10(1)
> 
> Patch Links:
> - https://github.com/plt/racket/pull/343.patch
> - https://github.com/plt/racket/pull/343.diff

If you use the `time` form explicitly, DrDr will chart the timings.

How can I use the time form around top-level forms?

You could do (time (dynamic-require ...)).

That only times the module instantiating, what I have now also times all of the time which is spent in expanding the modules, which is the expensive part.

On Mon, May 20, 2013 at 11:18 PM, Eric Dobson notifications@github.comwrote:

> That only times the module instantiating, what I have now also times all
> of the time which is spent in expanding the modules, which is the expensive
> part.

Really? I don't think your code times expansion.  To do that, you'd need to
run `current-inexact-milliseconds` in an earlier phase.

Nope, its at the top level, so forms are expanded/evaluated one by one. The language level is #racket/load. 

Ok.

In that case, if you print the data in the same form that `time` does, then
DrDr will DTRT.

On Mon, May 20, 2013 at 11:21 PM, Eric Dobson notifications@github.comwrote:

> Nope, its at the top level, so forms are expanded/evaluated one by one.
> The language level is #racket/load.
> 
> —
> Reply to this email directly or view it on GitHubhttps://github.com/plt/racket/pull/344#issuecomment-18191255
> .

You could also time a dynamic-require of the file in #lang racket/load, I
think.

On Tue, May 21, 2013 at 1:26 AM, Sam Tobin-Hochstadt <
notifications@github.com> wrote:

> Ok.
> 
> In that case, if you print the data in the same form that `time` does,
> then
> DrDr will DTRT.
> 
> On Mon, May 20, 2013 at 11:21 PM, Eric Dobson notifications@github.comwrote:
> 
> > Nope, its at the top level, so forms are expanded/evaluated one by one.
> > The language level is #racket/load.
> > 
> > —
> > Reply to this email directly or view it on GitHub<
> > https://github.com/plt/racket/pull/344#issuecomment-18191255>
> > .
> 
> —
> Reply to this email directly or view it on GitHubhttps://github.com/plt/racket/pull/344#issuecomment-18191380
> .

@rfindler, that won't work if you are creating the module in the same `racket/load` session.

Ok made it use eval and time. How do I hook this up so that DrDr runs it and collects timing info?

You just commit it and DrDr will figure it out and chart the timing.

r+

Merged, thanks!

I thought we figured out how to avoid the "undo" trick. Can we not do that
here? (I ended up having to rewrite those out from last time, iirc.)

Like can't you insert the quote and then check to see what the paren
matcher thinks about the current position before and after that insertion
to help decide whether or not to insert the second quote character?

Robby

On Thu, May 23, 2013 at 4:05 PM, Nadeem Abdul Hamid <
notifications@github.com> wrote:

> ---
> 
> You can merge this Pull Request by running
> 
>   git pull https://github.com/nadeemabdulhamid/racket master
> 
> Or view, comment on, or merge it at:
> 
>   https://github.com/plt/racket/pull/346
> Commit Summary
> - Tweak auto-parens behavior of double quote typed in a string
> 
> File Changes
> - _M_ collects/framework/private/racket.rkthttps://github.com/plt/racket/pull/346/files#diff-0(129)
> - _M_ collects/tests/framework/racket.rkthttps://github.com/plt/racket/pull/346/files#diff-1(57)
> 
> Patch Links:
> - https://github.com/plt/racket/pull/346.patch
> - https://github.com/plt/racket/pull/346.diff

The pull request was accepted; @mflatt committed it about a month ago: https://github.com/plt/racket/commit/c6e28435578b6b8607d4c767ee956f88c8388ff0

He committed on my behalf. I can return the favor and close this GH open item, on your behalf. :)

OK, I went through and reimplemented the whole algorithm to remove the instances of the insert/check/undo pattern that was previously there.

Thanks very much! I'll just have a look and then push your commits.

Robby

On Fri, May 24, 2013 at 3:12 PM, Nadeem Abdul Hamid <
notifications@github.com> wrote:

> OK, I went through and reimplemented the whole algorithm to remove the
> instances of the insert/check/undo pattern that was previously there.
> 
> —
> Reply to this email directly or view it on GitHubhttps://github.com/plt/racket/pull/346#issuecomment-18427292
> .

LGTM. Did you notice/measure a speedup?

Other than that small comment, LGTM.

Hooray! r+

LGTM

r+

r+

r+ with the comment.

@jeapostrophe, can you review these changes?

r+

It looks okay

I'm going to leave a TODO for that. I'm not sure what a good interface for that is given that currently it uses the second argument to determine if the call is a access or a mutation. 

Didn't detect a speedup but not sure that the current test would do all that well at it because it only tests module loading.

@takikawa is working on lots of changes to class/object type checking in https://github.com/takikawa/racket/tree/tr-classes so I'll let him review this, and figure out if it conflicts.

r+

r+

@stamourv, can you look at the optimizer changes?

r+ for my parts of the code.

LGTM

r+ from me. I did some separate cleanup, but it's orthogonal. I'll fix any conflicts on my end on rebase.

Merged -- thanks!

An hour ago, Asumu Takikawa wrote:

> This pull request adds support for implicitly declared recursive
> types and mutually recursive types. That is, you can declare a pair
> of recursive types like:
> 
> (define-type (Even A) (U Null (Pairof A (Odd A))))
> (define-type (Odd A) (Pairof A (Even A)))
> 
> Note that no Rec is needed.
> 
> I'm submitting this as a pull request to get some code review before
> the initial push. I'd appreciate any comments.

Yet another hack that I'll remove from my pl language...

## 

```
      ((lambda (x) (x x)) (lambda (x) (x x)))          Eli Barzilay:
                http://barzilay.org/                   Maze is Life!
```

On Wed, Jun 5, 2013 at 5:29 PM, Eli Barzilay notifications@github.comwrote:

> Yet another hack that I'll remove from my pl language...

Note that this is quite different from the semantics in the PL language ...

I don't really think the feature itself is a hack (the implementation strategy itself may admittedly be hacky), but let's talk about that offline since I'd like to keep this thread to just code review.

This extension should be documented.

Just now, Sam Tobin-Hochstadt wrote:

> On Wed, Jun 5, 2013 at 5:29 PM, Eli Barzilay notifications@github.comwrote:
> 
> > Yet another hack that I'll remove from my pl language...
> 
> Note that this is quite different from the semantics in the PL
> language ...

For what I use it, I think that there's no difference -- do you know
of one?

Just now, Asumu Takikawa wrote:

> I don't really think the feature itself is a hack (the
> implementation strategy itself may admittedly be hacky), but let's
> keep that offline since I'd like to keep this thread to just code
> review.

No, it's my thing which is a hack -- with parens, it adds a `Rec' (and
an`All' with the inputs) to the RHS.

I had a quick glance at my notes, and this is the only thing I could
find where I use it:

```
(define-type VAL = (U Number (VAL -> VAL)))
```

In another place, I have this:

```
(: make-recursive : (All (S T) ((S -> T) -> (S -> T)) -> (S -> T)))
(define-type (Tau S T) = (Rec this (this -> (S -> T))))
(define (make-recursive f)
  ((lambda: ([x : (Tau S T)]) (f (lambda (z) ((x x) z))))
   (lambda: ([x : (Tau S T)]) (f (lambda (z) ((x x) z))))))
```

which is likely to still require the `Rec', but I'd be happy and
surprised if it can turn to

```
(define-type (Tau S T) = ((Tau S T) -> (S -> T)))
```

## 

```
      ((lambda (x) (x x)) (lambda (x) (x x)))          Eli Barzilay:
                http://barzilay.org/                   Maze is Life!
```

Oh, sorry, I understand your comment now. I think you ought to be able to write `(define-type (Tau S T) ((Tau S T) -> (S -> T)))` as is, actually (and hopefully the variance is actually working correctly).

Well, I can promise to still be positively surprised when after I forget this (in 5 minutes) and re-remember it when I go over things next semester.

(Also, _sigh_ at the pathetic "reply to this email" support in GH.)

I'm worried about extra complexity and possibly termination behavior, but I like the exposed API for TR users. Is there a reason we cannot just use Rec behind the scenes instead of introducing this new type?

On Wed, Jun 5, 2013 at 10:59 PM, Eric Dobson notifications@github.comwrote:

> I'm worried about extra complexity and possibly termination behavior, but
> I like the exposed API for TR users. Is there a reason we cannot just use
> Rec behind the scenes instead of introducing this new type?

This introduces general mutual recursion, which is extremely painful to
encode using `Rec` (and probably would require some new type operators).

Also, this isn't very different from how `struct:` types are currently
handled -- it's a similar extra indirection.

I can understand that implementing with Rec would be a pain but why do we need both RecName and Name? I'm not sure I understand the difference between them.

I actually tried to re-use `Name` as a first attempt. It ended up being difficult (though maybe less code redundancy) in a few ways. One is that there's a lot of special-case struct typechecking code that just looks for a `Name`. In these cases, we would have to be careful to make sure recursive type aliases and struct names are not confused.

Another is that recursive type aliases generate very different contracts from structs. Each time a new `RecName` is seen, it starts a recursive contract. We don't want this overhead for struct contracts in general.

It may be possible to implement this with `Rec`, though it'll result in very complicated types, but maybe it's worth trying again. For example, the `Even` and `Odd` example would end up expanding to something like the following:

```
(define-type (T1 A Y1 Y2) (U Null (Pairof A Y2)))
(define-type (T2 A Y1 Y2) (Pairof A Y1))
(define-type (Even A) (Rec Y1 (T1 A Y1 (Rec Y2 (T2 A Y1 Y2)))))
(define-type (Odd A)  (Rec Y2 (T2 A (Rec Y1 (T1 A Y1 Y2)) Y2)))
```

Something seems to have gone wrong with this one. Can you make a simpler
commit, please?

Robby

On Thu, Jun 6, 2013 at 4:09 PM, J. Ian Johnson notifications@github.comwrote:

> any and any_!_ do not match absolutely anything regardless of anything
> else in the pattern. This patch introduces _ as its own pattern as a
> 
> ## non-binding, unnameable pattern that matches anything.
> 
> You can merge this Pull Request by running
> 
>   git pull https://github.com/ianj/racket redex-wildcard
> 
> Or view, comment on, or merge it at:
> 
>   https://github.com/plt/racket/pull/363
> Commit Summary
> - improve tests
> - fixed quasisyntax to work with prefab struct templates
> - Fix re Robby
> - Fixing PR13729
> - add more explaination to #%expression
> - misc improvements to generate-term
> - edito
> - another edito
> - make `scribble' (and`raco scribble') use a `doc' submodule when
>   present
> - add `configure-runtime' submodule support
> - fix `module' non-simplification of syntax during expansion
> - switch `rascket/base' and`scheme/base' to submodule language style
> - allow #:chaperone specification in struct/dc
> - fix tests
> - scribble: fix binding search for phase 1 through initial import
> - bump version
> - add an example use of the #:pp argument to the redex docs
> - Add urls with the info about deps to README.
> - Add comments, purpose statements, and contracts
> - Remove unnecessary prefab struct declaration
> - Style guideline compliance
> - Remove commented code and random line breaks
> - Correct typos in src/README
> - fix error message for applying a non-procedure with keywords
> - Add examples for syntax/stx
> - Move tc-literal to seperate file, as it doesn't belong in tc-expr.
> - Move tc/send to new file because it doesn't belong in tc-expr-unit.
> - Fix type of tanh.
> - scribble: fix `--redirect{-main}' and non-HTML mode
> - add `racket/rerequire'
> - stepper: ignore submodules
> - racket/{require,provide}-syntax: add
>   `syntax-local-{require,provide}-introduce'
> - racket/place: keywords as place messages
> - redex: fix and clean up metafunction expansion
> - raco pkg: fix conflict checking for a collection splice
> - Add a few examples to syntax transformer section
> - remove dead code
> - A kindler, gentler death re: Robby
> - Fix cookie test re version
> - render non-installaction-scoped package docs with an indirection
> - New Racket version 5.3.4.9.
> - share submodules of racket/base and scheme/base
> - Move `explode-path' from`racket/path' to `racket/base'
> - raco pkg: "indices" -> "catalogs" in dependency message
> - avoid a constant folding that can use too much memory
> - fixed (~r 0 #:notation 'exponential ....) bugs
> - some random testing for (~r #:notation 'exponential ....)
> - raco setup: fix subcollection traversal
> - fix place-channel test
> - raco exe: enable on-demand parsing of embedded bytecode
> - v5.3.4 installers info
> - fix `raco exe' test
> - fix estimate of order of magnitude for ~r
> - Adding customization of command-char to web-server/template
> - Remove contract on unit-exported definition.
> - Cleanup tc-lambda-unit.
> - Some style cleanups.
> - Add `permutations' and`in-permutations'.
> - tighten up the contract for get-display-size and
>   get-display-left-top-inset
> - Refactor subtype.rkt not to use exceptions.
> - Make the stop value for `in-producer' optional.
> - add missing guard
> - Add contract for seen parameter.
> - Forgot to commit example
> - New Racket version 5.3.4.10.
> - Temporary hack: avoid `permutations' clash until its renamed in
>   `math'.
> - Fix inclusion of "keep-dirs.rktd".
> - Combine the two zo-size tests into one.
> - Updated sizes of repackaged source distributions.
> - Update links re release
> - Added Redex enumerators.
> - delay the unimplemented/unsupported errors until the enumeration is
>   actually used
> - add immutable hashes to printable/c
> - Fix error based on mis-read contract
> - DrRacket now saves the font size preference on a
>   per-monitor-configuration basis
> - More temporary hacking around the to-be-renamed `permutations'
>   problem.
> - fix typos in example code
> - fix unstable/socket loading in windows
> - Make `in-producer' treat any number of values uniformly.
> - Add tests for commit e53b0858c32b845482
> - Remove debugging instrumentation
> - Doc fixes for ffi/unsafe/atomic
> - racket/gui gtk: catch key events at frame level
> - bitmap-dc% respective alpha channel in get/set-pixel
> - db: temporary workaround for SSL one-record-per-write issue
> - allow #f as the min-width / min-height init arg to area-containers
> - add #:close-button?, #:canvas-min-width, and #:canvas-min-height
> - adjust package manager gui to separate out (and make simpler looking)
> - pkg-info-orig-info seems to also possibly be (cons 'file ...).
> - slideshow/pict: add 'outline style for `text'
> - slideshow/pict: fix `text' angle and superscript/subscript modes
> - racket/generic: fix kw args with #:defaults
> - move the slideshow/pict library to its own collection
> - fix build for Windows
> - disable slideshow's addition (to drracket) of pict value rendering
> - add responsible for collects/pict
> - Fix type of sinh.
> - Limit memory in all sandboxes used by the TR random tester.
> - Make `define-type` work at top-level
> - Log sequence specialization failures in `for' loops.
> - Fixed bad let syntax
> - Hacky fix to only flatten repeats
> - Added Redex enum tests
> - Add more syntax examples to the reference
> - Removed tabs from redex enum code
> - add enum-tests into run-tests.rkt
> - Fix source locations for TR for.
> - Fix test for TR's for source locations.
> - Make `require/typed` work at top-level
> - Fix tc-toplevel-form for ignored syntax
> - Refactor to reduce right-ward drift
> - Whitespace and comment fixes
> - adjust contract test suite to do more provide/contract =>
>   contract-out
> - make contract-out signal more errors in terms of itself
> - fix thread-creation problem
> - Fix framework doc typo
> - support libpng16
> - Massive cleanup of requriements in TR.
> - raco pkg: don't treat "info.rkt" as a conflict
> - raco pkg create: support "source" and "binary" bundling
> - Redex docs edits to be more precise about picts (versus just
>   slideshow)
> - Clean up lam-result.
> - scribble/base: handle special characters in URLs
> - scribble HTML rendering: unreserved-encode "on this page" links
> - adjust generate-term docs a little
> - libpng adjustment
> - Make sure the Redex pattern language's 'boolean' is rendered as a
>   nonterminal
> - Avoid doing the 2nd pass twice at the top-level
> - Redex: fix a small bug in the list-machine example
> - Add examples for `for/lists`
> - Fix regression for (begin) and simplify
> - Fixed in-generator's handling of arity zero.
> - Fixed collects/meta/props so that `props verify' runs without error.
> - fix docs for redex-generator
> - Gave collects/meta/check-dists more time when run by DrDr.
> - Set drdr:random property for files with nondeterministic output.
> - Fixed problems with collects/meta/props.
> - Clean up unit tests
> - fix srcloc-missing-from-exn bug in struct/dc
> - fix call-with-transaction error (disconnected rollback)
> - Adjusted check syntax to properly deal with different identifiers
> - Synch German string constants with latest.
> - Fix racket/draw doc typo
> - Fix parsing of (Struct ...) types.
> - should have been part of 299063d
> - automate some overlapping identifier tests
> - dont draw the lime green bubbles for imported identifiers
> - Fixing error in GC1 found by Mark Engelberg, but fixed in GC2
> - Redex enum supports var-except.
> - Redex enum maintains bijection internally
> - fixups for `pict' and`slideshow' docs
> - Added holes to redex enumerator.
> - Redex generator supports mismatched names.
> - minor doc fixes
> - Cut off type printing with :type at one level
> - Add a #:verbose option to :type.
> - fix problem in `free-identifier=?'
> - Fixing PR13748
> - fix object/c's blame context manipulations
> - Re-enable redex's overlapping arrows src loc information
> - Fixes PR13750
> - indent
> - Cue user about unexpanded type aliases
> - Expend printing fuel in all branches
> - remove now-redundant tests
> - Fix alarm-evt doc typo
> - Use random for changes
> - Don't check name if not given
> - Update the instructions on configuring git's push.default.
> - Misc improvements to `net/uri-codec'.
> - fix `tcp-listen' error-message construction
> - add boolean to the set of things that redex's random generator
> - Document :type better
> - Protect strings from regexps.
> - Typo in error.
> - correct augment/override confusion in docs
> - updated mitpress links
> - Fix minor doc typo for threads
> - fix and export in-dict sequence syntax
> - Make scoped type vars work only for explict Alls and annotations.
> - Add a test which times TR module loading.
> - scriblib/autbib: add `#:note' support
> - scriblib/footnote: adjust environment to make output empty
> - add `setup/collects' and use it for ".dep" file paths
> - raco pkg create --binary: strip ".dep" files, ertain submodules, ~
>   files
> - raco pkg create, raco setup: add support for built (source+binary)
>   packages
> - Tweak auto-parens behavior of double quote typed in a string
> - Improve auto-parens mode implementation and behavior
> - adjust Redex to disallow certain patterns that are guaranteed never
>   to fail
> - fix arity error
> - fix check in memory limit in drr's GUI (and fix
> - adjust DrRacket to offer installation of packages
> - only include --force when the checkbox isn't disabled
> - Minor whitespace fix.
> - adjust DrRacket's online compilation to recognize exn:missing-module?
> - when the package installer has a parent, don't
> - missed a spot for the vector => exn-info change
> - minor clarification to class/c contract spec
> - minor improvement to class/c: generate a little bit less code
> - add GUI support for compile-enforce-module-constants to DrRacket
> - Allow the profiler's sampler to collect user-specified continuation
>   marks.
> - Use submodules instead of marking tricks for identifiers in docs.
> - Fix broken internal error
> - Make resolve actually do all the necessary resolutions.
> - Centralize the definition of the plambda syntax property.
> - Centralized typechecker:ignore properties.
> - Fix doc typo.
> - Don't splice in vector creation when optimizing vector-length.
> - Fix broken test.
> - Added some checks for user errors.
> - add a parameter to adjust random generation methods
> - Fix broken test, again.
> - Register scoped type variables for internal def. annotations.
> - Make for loops in TR use an annotation when applicable.
> - Use in-syntax instead of in-list/syntax->list.
> - Add error checking to in-syntax.
> - Add syntax-length to unstable/syntax.
> - Make TR use syntax-length instead of (length (syntax->list x)).
> - Move from syntax-map to stx-map.
> - Move from syntax->list and map to stx-map.
> - Replace syntax-map with stx-map in unstable/automata
> - Replace syntax-map with stx-map in plai.
> - Use abbreviations for filters.
> - Consolidate the rest of the syntax properties in TR.
> - Cleanup flonum-op check, and contract fixups.
> - Remove syntax-map.
> - Cleanup some syntax->list uses in the optimizer.
> - Remove unused definition and clean up exports.
> - Share definition of erase-filter.
> - Use stx-list? instead of syntax->list.
> - Removed unnecessary require.
> - Make printing complex filters not be on by default.
> - Remove unused code.
> - Reduce duplication in construction of syntax-infos.
> - Remove duplication of type-variable duplicate detection.
> - Make tc-app-object use a real dictionary.
> - Cleanup tc-app-objects a bit.
> - Remove unnecessary loop in tc-app-objects.
> - Make TR's lambda not do datum->syntax.
> - Remove unused code.
> - Remove unused feature.
> - Make tc-toplevel always return a list.
> - Fix documented type, and remove unnecessary or.
> - Add test for duplicate annotations.
> - include source-location in "missing module" exceptions
> - added command-line demo
> - Fix method accessors for inherits and abstracts
> - Restore commented `for` loop
> - New Racket version 5.3.4.11.
> - Added a wildcard construct that absolutely does not bind.
> 
> File Changes
> - _M_ .mailmap https://github.com/plt/racket/pull/363/files#diff-0(25)
> - _M_ README https://github.com/plt/racket/pull/363/files#diff-1 (4)
> - _M_ collects/2htdp/batch-io.rkthttps://github.com/plt/racket/pull/363/files#diff-2(14)
> - _M_ collects/2htdp/private/image-more.rkthttps://github.com/plt/racket/pull/363/files#diff-3(100)
> - _M_ collects/2htdp/private/img-err.rkthttps://github.com/plt/racket/pull/363/files#diff-4(2)
> - _A_ collects/2htdp/tests/batch-io-csv-ho.rkthttps://github.com/plt/racket/pull/363/files#diff-5(6)
> - _A_ collects/2htdp/tests/batch-io-csv-ho.txthttps://github.com/plt/racket/pull/363/files#diff-6(1)
> - _M_ collects/2htdp/tests/batch-io.rkthttps://github.com/plt/racket/pull/363/files#diff-7(2)
> - _M_ collects/2htdp/tests/batch-io2.rkthttps://github.com/plt/racket/pull/363/files#diff-8(2)
> - _M_ collects/2htdp/tests/batch-io3.rkthttps://github.com/plt/racket/pull/363/files#diff-9(2)
> - _A_ collects/2htdp/tests/run-movie.rkthttps://github.com/plt/racket/pull/363/files#diff-10(13)
> - _M_ collects/2htdp/tests/test-image.rkthttps://github.com/plt/racket/pull/363/files#diff-11(37)
> - _M_ collects/2htdp/tests/universe-restart.rkthttps://github.com/plt/racket/pull/363/files#diff-12(2)
> - _M_ collects/2htdp/universe.rkthttps://github.com/plt/racket/pull/363/files#diff-13(2)
> - _M_ collects/2htdp/xtesthttps://github.com/plt/racket/pull/363/files#diff-14(2)
> - _M_ collects/algol60/cfg-parser.rkthttps://github.com/plt/racket/pull/363/files#diff-15(2)
> - _M_ collects/algol60/compile.rkthttps://github.com/plt/racket/pull/363/files#diff-16(8)
> - _M_ collects/algol60/simplify.rkthttps://github.com/plt/racket/pull/363/files#diff-17(18)
> - _M_ collects/compiler/cm-accomplice.rkthttps://github.com/plt/racket/pull/363/files#diff-18(5)
> - _M_ collects/compiler/cm.rkthttps://github.com/plt/racket/pull/363/files#diff-19(39)
> - _M_ collects/compiler/commands/ctool.rkthttps://github.com/plt/racket/pull/363/files#diff-20(2)
> - _M_ collects/compiler/commands/exe.rkthttps://github.com/plt/racket/pull/363/files#diff-21(19)
> - _M_ collects/compiler/commands/info.rkthttps://github.com/plt/racket/pull/363/files#diff-22(2)
> - _M_ collects/compiler/commands/test.rkthttps://github.com/plt/racket/pull/363/files#diff-23(167)
> - _M_ collects/compiler/compiler-unit.rkthttps://github.com/plt/racket/pull/363/files#diff-24(84)
> - _M_ collects/compiler/decompile.rkthttps://github.com/plt/racket/pull/363/files#diff-25(3)
> - _M_ collects/compiler/demodularizer/merge.rkthttps://github.com/plt/racket/pull/363/files#diff-26(20)
> - _M_ collects/compiler/demodularizer/module.rkthttps://github.com/plt/racket/pull/363/files#diff-27(1)
> - _M_ collects/compiler/demodularizer/nodep.rkthttps://github.com/plt/racket/pull/363/files#diff-28(4)
> - _M_ collects/compiler/distribute.rkthttps://github.com/plt/racket/pull/363/files#diff-29(40)
> - _M_ collects/compiler/embed-unit.rkthttps://github.com/plt/racket/pull/363/files#diff-30(48)
> - _M_ collects/compiler/embed.rkthttps://github.com/plt/racket/pull/363/files#diff-31(1)
> - _M_ collects/compiler/find-exe.rkthttps://github.com/plt/racket/pull/363/files#diff-32(4)
> - _M_ collects/compiler/main.rkthttps://github.com/plt/racket/pull/363/files#diff-33(2)
> - _M_ collects/compiler/private/elf.rkthttps://github.com/plt/racket/pull/363/files#diff-34(46)
> - _M_ collects/compiler/zo-marshal.rkthttps://github.com/plt/racket/pull/363/files#diff-35(3)
> - _M_ collects/compiler/zo-parse.rkthttps://github.com/plt/racket/pull/363/files#diff-36(3)
> - _M_ collects/compiler/zo-structs.rkthttps://github.com/plt/racket/pull/363/files#diff-37(1)
> - _M_ collects/data/bit-vector.rkthttps://github.com/plt/racket/pull/363/files#diff-38(1)
> - _M_ collects/data/integer-set.rkthttps://github.com/plt/racket/pull/363/files#diff-39(14)
> - _M_ collects/data/queue.rkthttps://github.com/plt/racket/pull/363/files#diff-40(22)
> - _M_ collects/data/scribblings/union-find.scrblhttps://github.com/plt/racket/pull/363/files#diff-41(4)
> - _M_ collects/datalog/lang/configure-runtime.rkthttps://github.com/plt/racket/pull/363/files#diff-42(22)
> - _M_ collects/db/private/generic/functions.rkthttps://github.com/plt/racket/pull/363/files#diff-43(3)
> - _D_ collects/db/private/generic/socket.rkthttps://github.com/plt/racket/pull/363/files#diff-44(105)
> - _M_ collects/db/private/mysql/main.rkthttps://github.com/plt/racket/pull/363/files#diff-45(2)
> - _M_ collects/db/private/postgresql/connection.rkthttps://github.com/plt/racket/pull/363/files#diff-46(39)
> - _M_ collects/db/private/postgresql/main.rkthttps://github.com/plt/racket/pull/363/files#diff-47(2)
> - _M_ collects/db/scribblings/query.scrblhttps://github.com/plt/racket/pull/363/files#diff-48(2)
> - _M_ collects/deinprogramm/deinprogramm-langs.rkthttps://github.com/plt/racket/pull/363/files#diff-49(6)
> - _M_ collects/deinprogramm/signature/signature-syntax.rkthttps://github.com/plt/racket/pull/363/files#diff-50(6)
> - _M_ collects/deinprogramm/signature/signature.rkthttps://github.com/plt/racket/pull/363/files#diff-51(4)
> - _M_ collects/deinprogramm/turtle.rkthttps://github.com/plt/racket/pull/363/files#diff-52(20)
> - _M_ collects/drracket/acks.rkthttps://github.com/plt/racket/pull/363/files#diff-53(3)
> - _M_ collects/drracket/check-syntax.rkthttps://github.com/plt/racket/pull/363/files#diff-54(3)
> - _M_ collects/drracket/drracket.rkthttps://github.com/plt/racket/pull/363/files#diff-55(13)
> - _M_ collects/drracket/private/debug.rkthttps://github.com/plt/racket/pull/363/files#diff-56(123)
> - _M_ collects/drracket/private/drsig.rkthttps://github.com/plt/racket/pull/363/files#diff-57(6)
> - _M_ collects/drracket/private/embedded-snip-utils.rkthttps://github.com/plt/racket/pull/363/files#diff-58(8)
> - _M_ collects/drracket/private/eval-helpers.rkthttps://github.com/plt/racket/pull/363/files#diff-59(72)
> - _M_ collects/drracket/private/eval.rkthttps://github.com/plt/racket/pull/363/files#diff-60(7)
> - _M_ collects/drracket/private/expanding-place.rkthttps://github.com/plt/racket/pull/363/files#diff-61(293)
> - _M_ collects/drracket/private/font.rkthttps://github.com/plt/racket/pull/363/files#diff-62(12)
> - _M_ collects/drracket/private/frame-icon.rkthttps://github.com/plt/racket/pull/363/files#diff-63(3)
> - _M_ collects/drracket/private/frame.rkthttps://github.com/plt/racket/pull/363/files#diff-64(98)
> - _M_ collects/drracket/private/get-extend.rkthttps://github.com/plt/racket/pull/363/files#diff-65(76)
> - _M_ collects/drracket/private/language-configuration.rkthttps://github.com/plt/racket/pull/363/files#diff-66(14)
> - _M_ collects/drracket/private/language.rkthttps://github.com/plt/racket/pull/363/files#diff-67(8)
> - _M_ collects/drracket/private/local-member-names.rkthttps://github.com/plt/racket/pull/363/files#diff-68(21)
> - _M_ collects/drracket/private/main.rkthttps://github.com/plt/racket/pull/363/files#diff-69(14)
> - _M_ collects/drracket/private/module-language.rkthttps://github.com/plt/racket/pull/363/files#diff-70(527)
> - _M_ collects/drracket/private/profile-drs.rkthttps://github.com/plt/racket/pull/363/files#diff-71(4)
> - _M_ collects/drracket/private/rep.rkthttps://github.com/plt/racket/pull/363/files#diff-72(198)
> - _M_ collects/drracket/private/syncheck/gui.rkthttps://github.com/plt/racket/pull/363/files#diff-73(776)
> - _M_ collects/drracket/private/syncheck/intf.rkthttps://github.com/plt/racket/pull/363/files#diff-74(26)
> - _M_ collects/drracket/private/syncheck/local-member-names.rkthttps://github.com/plt/racket/pull/363/files#diff-75(8)
> - _M_ collects/drracket/private/syncheck/online-comp.rkthttps://github.com/plt/racket/pull/363/files#diff-76(52)
> - _M_ collects/drracket/private/syncheck/traversals.rkthttps://github.com/plt/racket/pull/363/files#diff-77(521)
> - _M_ collects/drracket/private/unit.rkthttps://github.com/plt/racket/pull/363/files#diff-78(154)
> - _M_ collects/drracket/tool-lib.rkthttps://github.com/plt/racket/pull/363/files#diff-79(243)
> - _M_ collects/embedded-gui/embedded-gui.rkthttps://github.com/plt/racket/pull/363/files#diff-80(4)
> - _M_ collects/embedded-gui/private/lines.rkthttps://github.com/plt/racket/pull/363/files#diff-81(10)
> - _M_ collects/embedded-gui/scribblings/dllist.scrblhttps://github.com/plt/racket/pull/363/files#diff-82(2)
> - _M_ collects/eopl/datatype.rkthttps://github.com/plt/racket/pull/363/files#diff-83(577)
> - _M_ collects/eopl/eopl.rkthttps://github.com/plt/racket/pull/363/files#diff-84(14)
> - _M_ collects/eopl/eopl.scrblhttps://github.com/plt/racket/pull/363/files#diff-85(43)
> - _M_ collects/eopl/info.rkthttps://github.com/plt/racket/pull/363/files#diff-86(1)
> - _M_ collects/eopl/private/sllboth.rkthttps://github.com/plt/racket/pull/363/files#diff-87(59)
> - _M_ collects/eopl/private/slldef.rkthttps://github.com/plt/racket/pull/363/files#diff-88(8)
> - _M_ collects/eopl/private/sllgen.rkthttps://github.com/plt/racket/pull/363/files#diff-89(3820)
> - _M_ collects/eopl/private/utils.rkthttps://github.com/plt/racket/pull/363/files#diff-90(30)
> - _M_ collects/ffi/unsafe.rkthttps://github.com/plt/racket/pull/363/files#diff-91(113)
> - _M_ collects/ffi/unsafe/com.rkthttps://github.com/plt/racket/pull/363/files#diff-92(46)
> - _M_ collects/ffi/unsafe/objc.rkthttps://github.com/plt/racket/pull/363/files#diff-93(49)
> - _M_ collects/ffi/vector.rkthttps://github.com/plt/racket/pull/363/files#diff-94(7)
> - _M_ collects/file/gunzip.rkthttps://github.com/plt/racket/pull/363/files#diff-95(24)
> - _M_ collects/file/md5.rkthttps://github.com/plt/racket/pull/363/files#diff-96(2)
> - _M_ collects/file/scribblings/sha1.scrblhttps://github.com/plt/racket/pull/363/files#diff-97(10)
> - _M_ collects/file/scribblings/tar.scrblhttps://github.com/plt/racket/pull/363/files#diff-98(2)
> - _D_ collects/file/tests/sha1.rkthttps://github.com/plt/racket/pull/363/files#diff-99(9)
> - _M_ collects/file/untar.rkthttps://github.com/plt/racket/pull/363/files#diff-100(18)
> - _M_ collects/file/untgz.rkthttps://github.com/plt/racket/pull/363/files#diff-101(29)
> - _M_ collects/file/zip.rkthttps://github.com/plt/racket/pull/363/files#diff-102(2)
> - _M_ collects/framework/main.rkthttps://github.com/plt/racket/pull/363/files#diff-103(85)
> - _M_ collects/framework/preferences.rkthttps://github.com/plt/racket/pull/363/files#diff-104(53)
> - _M_ collects/framework/private/aspell.rkthttps://github.com/plt/racket/pull/363/files#diff-105(3)
> - _M_ collects/framework/private/color.rkthttps://github.com/plt/racket/pull/363/files#diff-106(54)
> - _M_ collects/framework/private/editor.rkthttps://github.com/plt/racket/pull/363/files#diff-107(109)
> - _M_ collects/framework/private/finder.rkthttps://github.com/plt/racket/pull/363/files#diff-108(2)
> - _M_ collects/framework/private/frame.rkthttps://github.com/plt/racket/pull/363/files#diff-109(3)
> - _M_ collects/framework/private/group.rkthttps://github.com/plt/racket/pull/363/files#diff-110(2)
> - _M_ collects/framework/private/icon.rkthttps://github.com/plt/racket/pull/363/files#diff-111(6)
> - _M_ collects/framework/private/keymap.rkthttps://github.com/plt/racket/pull/363/files#diff-112(305)
> - _M_ collects/framework/private/main.rkthttps://github.com/plt/racket/pull/363/files#diff-113(38)
> - _M_ collects/framework/private/number-snip.rkthttps://github.com/plt/racket/pull/363/files#diff-114(11)
> - _M_ collects/framework/private/panel.rkthttps://github.com/plt/racket/pull/363/files#diff-115(12)
> - _M_ collects/framework/private/racket.rkthttps://github.com/plt/racket/pull/363/files#diff-116(591)
> - _M_ collects/framework/private/sig.rkthttps://github.com/plt/racket/pull/363/files#diff-117(7)
> - _M_ collects/framework/private/text.rkthttps://github.com/plt/racket/pull/363/files#diff-118(22)
> - _M_ collects/frtime/demos/pong.rkthttps://github.com/plt/racket/pull/363/files#diff-119(2)
> - _M_ collects/frtime/demos/push-pull-ball.rkthttps://github.com/plt/racket/pull/363/files#diff-120(14)
> - _M_ collects/frtime/frlibs/math.rkthttps://github.com/plt/racket/pull/363/files#diff-121(32)
> - _M_ collects/frtime/gui/mixin-macros.rkthttps://github.com/plt/racket/pull/363/files#diff-122(2)
> - _M_ collects/frtime/opt/frtime-opt.rkthttps://github.com/plt/racket/pull/363/files#diff-123(2)
> - _M_ collects/frtime/scribblings/frtime.scrblhttps://github.com/plt/racket/pull/363/files#diff-124(2)
> - _M_ collects/future-visualizer/main.rkthttps://github.com/plt/racket/pull/363/files#diff-125(2)
> - _M_ collects/future-visualizer/private/drawing-helpers.rkthttps://github.com/plt/racket/pull/363/files#diff-126(2)
> - _M_ collects/future-visualizer/private/graph-drawing.rkthttps://github.com/plt/racket/pull/363/files#diff-127(10)
> - _M_ collects/future-visualizer/private/gui-helpers.rkthttps://github.com/plt/racket/pull/363/files#diff-128(4)
> - _M_ collects/future-visualizer/private/pict-canvas.rkthttps://github.com/plt/racket/pull/363/files#diff-129(2)
> - _M_ collects/future-visualizer/private/visualizer-data.rkthttps://github.com/plt/racket/pull/363/files#diff-130(18)
> - _M_ collects/future-visualizer/private/visualizer-drawing.rkthttps://github.com/plt/racket/pull/363/files#diff-131(9)
> - _R_ collects/games/aces/aces.rkthttps://github.com/plt/racket/pull/363/files#diff-132(182)
> - _M_ collects/games/aces/info.rkthttps://github.com/plt/racket/pull/363/files#diff-133(2)
> - _M_ collects/games/blackjack/blackjack.rkthttps://github.com/plt/racket/pull/363/files#diff-134(4)
> - _M_ collects/games/cards.rkthttps://github.com/plt/racket/pull/363/files#diff-135(4)
> - _M_ collects/games/cards/base.rkthttps://github.com/plt/racket/pull/363/files#diff-136(6)
> - _M_ collects/games/cards/card-class.rkthttps://github.com/plt/racket/pull/363/files#diff-137(2)
> - _M_ collects/games/cards/cards.rkthttps://github.com/plt/racket/pull/363/files#diff-138(4)
> - _M_ collects/games/cards/classes.rkthttps://github.com/plt/racket/pull/363/files#diff-139(3)
> - _M_ collects/games/cards/constants.rkthttps://github.com/plt/racket/pull/363/files#diff-140(6)
> - _M_ collects/games/cards/main.rkthttps://github.com/plt/racket/pull/363/files#diff-141(4)
> - _M_ collects/games/cards/make-cards.rkthttps://github.com/plt/racket/pull/363/files#diff-142(12)
> - _M_ collects/games/cards/region.rkthttps://github.com/plt/racket/pull/363/files#diff-143(2)
> - _M_ collects/games/cards/snipclass.rkthttps://github.com/plt/racket/pull/363/files#diff-144(6)
> - _M_ collects/games/cards/utils.rkthttps://github.com/plt/racket/pull/363/files#diff-145(2)
> - _M_ collects/games/chat-noir/chat-noir-unit.rkthttps://github.com/plt/racket/pull/363/files#diff-146(4)
> - _M_ collects/games/chat-noir/hash.rkthttps://github.com/plt/racket/pull/363/files#diff-147(2)
> - _M_ collects/games/checkers/checkers.rkthttps://github.com/plt/racket/pull/363/files#diff-148(16)
> - _M_ collects/games/checkers/honu-bitmaps.rkthttps://github.com/plt/racket/pull/363/files#diff-149(13)
> - _M_ collects/games/crazy8s/crazy8s.rkthttps://github.com/plt/racket/pull/363/files#diff-150(8)
> - _M_ collects/games/doors/doors.rkthttps://github.com/plt/racket/pull/363/files#diff-151(22)
> - _M_ collects/games/doors/graph.rkthttps://github.com/plt/racket/pull/363/files#diff-152(9)
> - _M_ collects/games/doors/private/utils.rkthttps://github.com/plt/racket/pull/363/files#diff-153(2)
> - _M_ collects/games/doors/utils.rkthttps://github.com/plt/racket/pull/363/files#diff-154(17)
> - _D_ collects/games/gcalc/gcalc-exampleshttps://github.com/plt/racket/pull/363/files#diff-155(9)
> - _A_ collects/games/gcalc/gcalc-examples.rktdhttps://github.com/plt/racket/pull/363/files#diff-156(9)
> - _M_ collects/games/gcalc/gcalc.rkthttps://github.com/plt/racket/pull/363/files#diff-157(778)
> - _M_ collects/games/gl-board-game.rkthttps://github.com/plt/racket/pull/363/files#diff-158(2)
> - _M_ collects/games/gl-board-game/gl-board.rkthttps://github.com/plt/racket/pull/363/files#diff-159(14)
> - _M_ collects/games/gl-board-game/main.rkthttps://github.com/plt/racket/pull/363/files#diff-160(2)
> - _M_ collects/games/gobblet/check.rkthttps://github.com/plt/racket/pull/363/files#diff-161(12)
> - _M_ collects/games/gobblet/explore.rkthttps://github.com/plt/racket/pull/363/files#diff-162(34)
> - _M_ collects/games/gobblet/gobblet.rkthttps://github.com/plt/racket/pull/363/files#diff-163(8)
> - _M_ collects/games/gobblet/gui.rkthttps://github.com/plt/racket/pull/363/files#diff-164(7)
> - _M_ collects/games/gobblet/heuristics.rkthttps://github.com/plt/racket/pull/363/files#diff-165(6)
> - _M_ collects/games/gobblet/model.rkthttps://github.com/plt/racket/pull/363/files#diff-166(78)
> - _M_ collects/games/gobblet/plays-3x3.rkthttps://github.com/plt/racket/pull/363/files#diff-167(2)
> - _M_ collects/games/gobblet/robot.rkthttps://github.com/plt/racket/pull/363/files#diff-168(4)
> - _M_ collects/games/gobblet/sig.rkthttps://github.com/plt/racket/pull/363/files#diff-169(2)
> - _M_ collects/games/gobblet/test-explore.rkthttps://github.com/plt/racket/pull/363/files#diff-170(4)
> - _M_ collects/games/gobblet/test-model.rkthttps://github.com/plt/racket/pull/363/files#diff-171(39)
> - _M_ collects/games/gobblet/test.rkthttps://github.com/plt/racket/pull/363/files#diff-172(2)
> - _M_ collects/games/gofish/gofish.rkthttps://github.com/plt/racket/pull/363/files#diff-173(6)
> - _M_ collects/games/info.rkthttps://github.com/plt/racket/pull/363/files#diff-174(4)
> - _A_ collects/games/jewel/array.rkthttps://github.com/plt/racket/pull/363/files#diff-175(99)
> - _D_ collects/games/jewel/array.scmhttps://github.com/plt/racket/pull/363/files#diff-176(169)
> - _M_ collects/games/jewel/info.rkthttps://github.com/plt/racket/pull/363/files#diff-177(2)
> - _A_ collects/games/jewel/jewel.rkthttps://github.com/plt/racket/pull/363/files#diff-178(1374)
> - _D_ collects/games/jewel/jewel.scmhttps://github.com/plt/racket/pull/363/files#diff-179(1829)
> - _A_ collects/games/jewel/shapes.rkthttps://github.com/plt/racket/pull/363/files#diff-180(658)
> - _D_ collects/games/jewel/shapes.scmhttps://github.com/plt/racket/pull/363/files#diff-181(748)
> - _A_ collects/games/jewel/text.rkthttps://github.com/plt/racket/pull/363/files#diff-182(186)
> - _D_ collects/games/jewel/text.scmhttps://github.com/plt/racket/pull/363/files#diff-183(230)
> - _M_ collects/games/lights-out/board.rkthttps://github.com/plt/racket/pull/363/files#diff-184(7)
> - _M_ collects/games/lights-out/lights-out.rkthttps://github.com/plt/racket/pull/363/files#diff-185(8)
> - _M_ collects/games/main.rkthttps://github.com/plt/racket/pull/363/files#diff-186(2)
> - _M_ collects/games/memory/memory.rkthttps://github.com/plt/racket/pull/363/files#diff-187(4)
> - _M_ collects/games/mines/gen-tiles.rkthttps://github.com/plt/racket/pull/363/files#diff-188(7)
> - _M_ collects/games/mines/images/bomb.pnghttps://github.com/plt/racket/pull/363/files#diff-189(0)
> - _M_ collects/games/mines/images/explode.pnghttps://github.com/plt/racket/pull/363/files#diff-190(0)
> - _M_ collects/games/mines/images/flag.pnghttps://github.com/plt/racket/pull/363/files#diff-191(0)
> - _M_ collects/games/mines/images/lclick-tile.pnghttps://github.com/plt/racket/pull/363/files#diff-192(0)
> - _M_ collects/games/mines/images/local-tile.pnghttps://github.com/plt/racket/pull/363/files#diff-193(0)
> - _M_ collects/games/mines/images/near-tile.pnghttps://github.com/plt/racket/pull/363/files#diff-194(0)
> - _M_ collects/games/mines/images/rclick-tile.pnghttps://github.com/plt/racket/pull/363/files#diff-195(0)
> - _M_ collects/games/mines/images/tile.pnghttps://github.com/plt/racket/pull/363/files#diff-196(0)
> - _M_ collects/games/mines/mines.rkthttps://github.com/plt/racket/pull/363/files#diff-197(11)
> - _M_ collects/games/paint-by-numbers/all-problems.rkthttps://github.com/plt/racket/pull/363/files#diff-198(8)
> - _M_ collects/games/paint-by-numbers/gui.rkthttps://github.com/plt/racket/pull/363/files#diff-199(5)
> - _M_ collects/games/paint-by-numbers/main.rkthttps://github.com/plt/racket/pull/363/files#diff-200(2)
> - _M_ collects/games/paint-by-numbers/paint-by-numbers.rkthttps://github.com/plt/racket/pull/363/files#diff-201(6)
> - _M_ collects/games/paint-by-numbers/problem.rkthttps://github.com/plt/racket/pull/363/files#diff-202(6)
> - _M_ collects/games/paint-by-numbers/raw-problems/build-final.rkthttps://github.com/plt/racket/pull/363/files#diff-203(4)
> - _M_ collects/games/paint-by-numbers/raw-problems/build-hattori.rkthttps://github.com/plt/racket/pull/363/files#diff-204(8)
> - _M_ collects/games/paint-by-numbers/raw-problems/build-rows-cols.rkthttps://github.com/plt/racket/pull/363/files#diff-205(6)
> - _M_
>   collects/games/paint-by-numbers/raw-problems/build-solution-sets.rkthttps://github.com/plt/racket/pull/363/files#diff-206(11)
> - _M_ collects/games/paint-by-numbers/solve.rkthttps://github.com/plt/racket/pull/363/files#diff-207(17)
> - _M_ collects/games/parcheesi/admin-gui.rkthttps://github.com/plt/racket/pull/363/files#diff-208(24)
> - _M_ collects/games/parcheesi/admin.rkthttps://github.com/plt/racket/pull/363/files#diff-209(5)
> - _M_ collects/games/parcheesi/best-players.rkthttps://github.com/plt/racket/pull/363/files#diff-210(24)
> - _M_ collects/games/parcheesi/board.rkthttps://github.com/plt/racket/pull/363/files#diff-211(29)
> - _M_ collects/games/parcheesi/die.rkthttps://github.com/plt/racket/pull/363/files#diff-212(6)
> - _M_ collects/games/parcheesi/gui.rkthttps://github.com/plt/racket/pull/363/files#diff-213(27)
> - _M_ collects/games/parcheesi/interfaces.rkthttps://github.com/plt/racket/pull/363/files#diff-214(6)
> - _M_ collects/games/parcheesi/make-bitmap.rkthttps://github.com/plt/racket/pull/363/files#diff-215(27)
> - _M_ collects/games/parcheesi/moves.rkthttps://github.com/plt/racket/pull/363/files#diff-216(14)
> - _M_ collects/games/parcheesi/parcheesi.rkthttps://github.com/plt/racket/pull/363/files#diff-217(6)
> - _M_ collects/games/parcheesi/play-game.rkthttps://github.com/plt/racket/pull/363/files#diff-218(8)
> - _M_ collects/games/parcheesi/rules.rkthttps://github.com/plt/racket/pull/363/files#diff-219(12)
> - _M_ collects/games/parcheesi/test.rkthttps://github.com/plt/racket/pull/363/files#diff-220(4)
> - _M_ collects/games/pousse/board-size.rkthttps://github.com/plt/racket/pull/363/files#diff-221(2)
> - _M_ collects/games/pousse/board.rkthttps://github.com/plt/racket/pull/363/files#diff-222(4)
> - _M_ collects/games/pousse/counter.rkthttps://github.com/plt/racket/pull/363/files#diff-223(2)
> - _M_ collects/games/pousse/pousse.rkthttps://github.com/plt/racket/pull/363/files#diff-224(4)
> - _M_ collects/games/pousse/robot.rkthttps://github.com/plt/racket/pull/363/files#diff-225(2)
> - _M_ collects/games/pousse/robots.txthttps://github.com/plt/racket/pull/363/files#diff-226(2)
> - _M_ collects/games/pousse/utils.rkthttps://github.com/plt/racket/pull/363/files#diff-227(2)
> - _M_ collects/games/same/same.rkthttps://github.com/plt/racket/pull/363/files#diff-228(2)
> - _M_ collects/games/scribblings/aces.scrblhttps://github.com/plt/racket/pull/363/files#diff-229(2)
> - _M_ collects/games/scribblings/jewel.scrblhttps://github.com/plt/racket/pull/363/files#diff-230(2)
> - _M_ collects/games/scribblings/same.scrblhttps://github.com/plt/racket/pull/363/files#diff-231(2)
> - _M_ collects/games/scribblings/std-games.scrblhttps://github.com/plt/racket/pull/363/files#diff-232(1)
> - _A_ collects/games/scribblings/tally-maze.scrblhttps://github.com/plt/racket/pull/363/files#diff-233(50)
> - _M_ collects/games/show-help.rkthttps://github.com/plt/racket/pull/363/files#diff-234(8)
> - _M_ collects/games/show-scribbling.rkthttps://github.com/plt/racket/pull/363/files#diff-235(4)
> - _M_ collects/games/slidey/slidey.rkthttps://github.com/plt/racket/pull/363/files#diff-236(7)
> - _M_ collects/games/spider/spider.rkthttps://github.com/plt/racket/pull/363/files#diff-237(6)
> - _A_ collects/games/tally-maze/game.rkthttps://github.com/plt/racket/pull/363/files#diff-238(281)
> - _A_ collects/games/tally-maze/godel.rkthttps://github.com/plt/racket/pull/363/files#diff-239(738)
> - _A_ collects/games/tally-maze/images/pumpkin/pumpkin-48x48.pnghttps://github.com/plt/racket/pull/363/files#diff-240(0)
> - _A_ collects/games/tally-maze/images/pumpkin/pumpkin-64x64.pnghttps://github.com/plt/racket/pull/363/files#diff-241(0)
> - _A_ collects/games/tally-maze/images/very-emotional/01.pnghttps://github.com/plt/racket/pull/363/files#diff-242(0)
> - _A_ collects/games/tally-maze/images/very-emotional/19.pnghttps://github.com/plt/racket/pull/363/files#diff-243(0)
> - _A_ collects/games/tally-maze/images/very-emotional/20.pnghttps://github.com/plt/racket/pull/363/files#diff-244(0)
> - _A_ collects/games/tally-maze/images/very-emotional/21.pnghttps://github.com/plt/racket/pull/363/files#diff-245(0)
> - _A_ collects/games/tally-maze/images/very-emotional/35.pnghttps://github.com/plt/racket/pull/363/files#diff-246(0)
> - _A_ collects/games/tally-maze/images/very-emotional/36.pnghttps://github.com/plt/racket/pull/363/files#diff-247(0)
> - _A_ collects/games/tally-maze/images/very-emotional/37.pnghttps://github.com/plt/racket/pull/363/files#diff-248(0)
> - _A_ collects/games/tally-maze/info.rkthttps://github.com/plt/racket/pull/363/files#diff-249(4)
> - _A_ collects/games/tally-maze/maze.rkthttps://github.com/plt/racket/pull/363/files#diff-250(472)
> - _A_ collects/games/tally-maze/tally-maze.pnghttps://github.com/plt/racket/pull/363/files#diff-251(0)
> - _M_ collects/gui-debugger/debug-tool.rkthttps://github.com/plt/racket/pull/363/files#diff-252(18)
> - _D_ collects/handin-client/client-gui.rkthttps://github.com/plt/racket/pull/363/files#diff-253(815)
> - _D_ collects/handin-client/client.rkthttps://github.com/plt/racket/pull/363/files#diff-254(171)
> - _D_ collects/handin-client/handin-multi.rkthttps://github.com/plt/racket/pull/363/files#diff-255(276)
> - _D_ collects/handin-client/icon.pnghttps://github.com/plt/racket/pull/363/files#diff-256(0)
> - _D_ collects/handin-client/info.rkthttps://github.com/plt/racket/pull/363/files#diff-257(41)
> - _D_ collects/handin-client/server-cert.pemhttps://github.com/plt/racket/pull/363/files#diff-258(20)
> - _D_ collects/handin-client/this-collection.rkthttps://github.com/plt/racket/pull/363/files#diff-259(34)
> - _D_ collects/handin-client/updater.rkthttps://github.com/plt/racket/pull/363/files#diff-260(72)
> - _D_ collects/handin-server/checker.rkthttps://github.com/plt/racket/pull/363/files#diff-261(771)
> - _D_ collects/handin-server/info.rkthttps://github.com/plt/racket/pull/363/files#diff-262(3)
> - _D_ collects/handin-server/main.rkthttps://github.com/plt/racket/pull/363/files#diff-263(726)
> - _D_ collects/handin-server/overridden-collects/readme.txthttps://github.com/plt/racket/pull/363/files#diff-264(6)
> - _D_
>   collects/handin-server/overridden-collects/teachpack/htdp/guess.rkthttps://github.com/plt/racket/pull/363/files#diff-265(28)
> - _D_
>   collects/handin-server/overridden-collects/teachpack/htdp/master.rkthttps://github.com/plt/racket/pull/363/files#diff-266(11)
> - _D_ collects/handin-server/private-key.pemhttps://github.com/plt/racket/pull/363/files#diff-267(15)
> - _D_ collects/handin-server/private/config.rkthttps://github.com/plt/racket/pull/363/files#diff-268(131)
> - _D_ collects/handin-server/private/hooker.rkthttps://github.com/plt/racket/pull/363/files#diff-269(17)
> - _D_ collects/handin-server/private/lock.rkthttps://github.com/plt/racket/pull/363/files#diff-270(64)
> - _D_ collects/handin-server/private/logger.rkthttps://github.com/plt/racket/pull/363/files#diff-271(68)
> - _D_ collects/handin-server/private/md5.rkthttps://github.com/plt/racket/pull/363/files#diff-272(5)
> - _D_ collects/handin-server/private/reloadable.rkthttps://github.com/plt/racket/pull/363/files#diff-273(58)
> - _D_ collects/handin-server/private/run-status.rkthttps://github.com/plt/racket/pull/363/files#diff-274(19)
> - _D_ collects/handin-server/run-servlet.rkthttps://github.com/plt/racket/pull/363/files#diff-275(115)
> - _D_ collects/handin-server/sandbox.rkthttps://github.com/plt/racket/pull/363/files#diff-276(26)
> - _D_ collects/handin-server/scribblings/checker-utils.scrblhttps://github.com/plt/racket/pull/363/files#diff-277(34)
> - _D_ collects/handin-server/scribblings/checker.scrblhttps://github.com/plt/racket/pull/363/files#diff-278(411)
> - _D_ collects/handin-server/scribblings/client-customization.scrblhttps://github.com/plt/racket/pull/363/files#diff-279(80)
> - _D_ collects/handin-server/scribblings/common.rkthttps://github.com/plt/racket/pull/363/files#diff-280(19)
> - _D_ collects/handin-server/scribblings/handin-server.scrblhttps://github.com/plt/racket/pull/363/files#diff-281(24)
> - _D_ collects/handin-server/scribblings/hook-dummy.rkthttps://github.com/plt/racket/pull/363/files#diff-282(6)
> - _D_ collects/handin-server/scribblings/info.rkthttps://github.com/plt/racket/pull/363/files#diff-283(3)
> - _D_ collects/handin-server/scribblings/multifile.scrblhttps://github.com/plt/racket/pull/363/files#diff-284(62)
> - _D_ collects/handin-server/scribblings/other-utils.scrblhttps://github.com/plt/racket/pull/363/files#diff-285(10)
> - _D_ collects/handin-server/scribblings/quick-start.scrblhttps://github.com/plt/racket/pull/363/files#diff-286(52)
> - _D_ collects/handin-server/scribblings/sandbox.scrblhttps://github.com/plt/racket/pull/363/files#diff-287(9)
> - _D_ collects/handin-server/scribblings/server-client.scrblhttps://github.com/plt/racket/pull/363/files#diff-288(36)
> - _D_ collects/handin-server/scribblings/server-setup.scrblhttps://github.com/plt/racket/pull/363/files#diff-289(490)
> - _D_ collects/handin-server/scribblings/updater.scrblhttps://github.com/plt/racket/pull/363/files#diff-290(34)
> - _D_ collects/handin-server/scribblings/utils.scrblhttps://github.com/plt/racket/pull/363/files#diff-291(213)
> - _D_ collects/handin-server/scribblings/wheres-the-collection.scrblhttps://github.com/plt/racket/pull/363/files#diff-292(11)
> - _D_ collects/handin-server/utils.rkthttps://github.com/plt/racket/pull/363/files#diff-293(185)
> - _D_ collects/handin-server/web-status-server.rkthttps://github.com/plt/racket/pull/363/files#diff-294(355)
> - _M_ collects/help/bug-report.rkthttps://github.com/plt/racket/pull/363/files#diff-295(121)
> - _M_ collects/help/private/bug-report-controls.rkthttps://github.com/plt/racket/pull/363/files#diff-296(18)
> - _M_ collects/honu/core/main.rkthttps://github.com/plt/racket/pull/363/files#diff-297(1)
> - _M_ collects/honu/core/private/extra.rkthttps://github.com/plt/racket/pull/363/files#diff-298(3)
> - _M_ collects/honu/core/private/honu2.rkthttps://github.com/plt/racket/pull/363/files#diff-299(35)
> - _M_ collects/honu/core/private/macro2.rkthttps://github.com/plt/racket/pull/363/files#diff-300(21)
> - _M_ collects/honu/core/private/parse2.rkthttps://github.com/plt/racket/pull/363/files#diff-301(469)
> - _M_ collects/honu/core/private/template.rkthttps://github.com/plt/racket/pull/363/files#diff-302(5)
> - _M_ collects/honu/core/read.rkthttps://github.com/plt/racket/pull/363/files#diff-303(2)
> - _M_ collects/honu/main.rkthttps://github.com/plt/racket/pull/363/files#diff-304(2)
> - _M_ collects/honu/private/common.rkthttps://github.com/plt/racket/pull/363/files#diff-305(9)
> - _M_ collects/honu/private/with.honuhttps://github.com/plt/racket/pull/363/files#diff-306(2)
> - _R_ collects/icons/r-logo-glass-256x256.pnghttps://github.com/plt/racket/pull/363/files#diff-307(0)
> - _R_ collects/icons/r-logo-plastic-256x256.pnghttps://github.com/plt/racket/pull/363/files#diff-308(0)
> - _M_ collects/images/private/flomap.rkthttps://github.com/plt/racket/pull/363/files#diff-309(2)
> - _M_ collects/images/scribblings/flomap.scrblhttps://github.com/plt/racket/pull/363/files#diff-310(4)
> - _M_ collects/images/scribblings/icons.scrblhttps://github.com/plt/racket/pull/363/files#diff-311(6)
> - _A_ collects/images/tests/other-tests.rkthttps://github.com/plt/racket/pull/363/files#diff-312(20)
> - _M_ collects/json/main.rkthttps://github.com/plt/racket/pull/363/files#diff-313(4)
> - _M_ collects/lang/private/provide-and-scribble.rkthttps://github.com/plt/racket/pull/363/files#diff-314(2)
> - _M_ collects/lang/private/signature-syntax.rkthttps://github.com/plt/racket/pull/363/files#diff-315(6)
> - _M_ collects/lang/private/teachprims.rkthttps://github.com/plt/racket/pull/363/files#diff-316(3)
> - _M_ collects/launcher/launcher-unit.rkthttps://github.com/plt/racket/pull/363/files#diff-317(33)
> - _M_ collects/macro-debugger/analysis/check-requires.rkthttps://github.com/plt/racket/pull/363/files#diff-318(7)
> - _M_ collects/macro-debugger/analysis/private/nom-use-alg.rkthttps://github.com/plt/racket/pull/363/files#diff-319(2)
> - _M_ collects/macro-debugger/analysis/private/util.rkthttps://github.com/plt/racket/pull/363/files#diff-320(76)
> - _M_ collects/macro-debugger/analysis/show-dependencies.rkthttps://github.com/plt/racket/pull/363/files#diff-321(82)
> - _M_ collects/macro-debugger/info.rkthttps://github.com/plt/racket/pull/363/files#diff-322(10)
> - _M_ collects/macro-debugger/macro-debugger.scrblhttps://github.com/plt/racket/pull/363/files#diff-323(17)
> - _M_ collects/macro-debugger/model/deriv-parser.rkthttps://github.com/plt/racket/pull/363/files#diff-324(2)
> - _M_ collects/macro-debugger/syntax-browser/display.rkthttps://github.com/plt/racket/pull/363/files#diff-325(14)
> - _M_ collects/macro-debugger/syntax-browser/widget.rkthttps://github.com/plt/racket/pull/363/files#diff-326(36)
> - _M_ collects/macro-debugger/tool.rkthttps://github.com/plt/racket/pull/363/files#diff-327(3)
> - _M_ collects/macro-debugger/view/frame.rkthttps://github.com/plt/racket/pull/363/files#diff-328(7)
> - _M_ collects/macro-debugger/view/term-record.rkthttps://github.com/plt/racket/pull/363/files#diff-329(2)
> - _M_ collects/math/LICENSE.txthttps://github.com/plt/racket/pull/363/files#diff-330(18)
> - _M_ collects/math/matrix.rkthttps://github.com/plt/racket/pull/363/files#diff-331(2)
> - _M_ collects/math/private/array/array-indexing.rkthttps://github.com/plt/racket/pull/363/files#diff-332(4)
> - _M_ collects/math/private/array/array-struct.rkthttps://github.com/plt/racket/pull/363/files#diff-333(2)
> - _M_ collects/math/private/array/mutable-array.rkthttps://github.com/plt/racket/pull/363/files#diff-334(2)
> - _M_ collects/math/private/array/typed-array-pointwise.rkthttps://github.com/plt/racket/pull/363/files#diff-335(4)
> - _M_ collects/math/private/distributions/exponential-dist.rkthttps://github.com/plt/racket/pull/363/files#diff-336(2)
> - _M_ collects/math/private/matrix/typed-matrix-arithmetic.rkthttps://github.com/plt/racket/pull/363/files#diff-337(2)
> - _M_ collects/math/private/number-theory/number-theory.rkthttps://github.com/plt/racket/pull/363/files#diff-338(2)
> - _M_ collects/math/private/unsafe.rkthttps://github.com/plt/racket/pull/363/files#diff-339(2)
> - _M_ collects/math/scribblings/math-array.scrblhttps://github.com/plt/racket/pull/363/files#diff-340(2)
> - _M_ collects/math/scribblings/math-distributions.scrblhttps://github.com/plt/racket/pull/363/files#diff-341(3)
> - _M_ collects/math/scribblings/math-flonum.scrblhttps://github.com/plt/racket/pull/363/files#diff-342(90)
> - _M_ collects/math/scribblings/math-matrix.scrblhttps://github.com/plt/racket/pull/363/files#diff-343(2)
> - _M_ collects/math/scribblings/math-statistics.scrblhttps://github.com/plt/racket/pull/363/files#diff-344(3)
> - _M_ collects/meta/build/nsis/installer.nsihttps://github.com/plt/racket/pull/363/files#diff-345(2)
> - _M_ collects/meta/build/unix-installer/paths-configure-snapshothttps://github.com/plt/racket/pull/363/files#diff-346(2)
> - _M_ collects/meta/build/unix-installer/test-installerhttps://github.com/plt/racket/pull/363/files#diff-347(2)
> - _M_ collects/meta/contrib/completion/racket-completion.bashhttps://github.com/plt/racket/pull/363/files#diff-348(4)
> - _M_ collects/meta/contrib/completion/racket-completion.zshhttps://github.com/plt/racket/pull/363/files#diff-349(23)
> - _M_ collects/meta/dist-specs.rkthttps://github.com/plt/racket/pull/363/files#diff-350(25)
> - _M_ collects/meta/drdr/analyze.rkthttps://github.com/plt/racket/pull/363/files#diff-351(14)
> - _M_ collects/meta/drdr/run-collect.rkthttps://github.com/plt/racket/pull/363/files#diff-352(5)
> - _R_ collects/meta/pkg-index/basic/main.rkthttps://github.com/plt/racket/pull/363/files#diff-353(9)
> - _A_ collects/meta/pkg-index/info.rkthttps://github.com/plt/racket/pull/363/files#diff-354(4)
> - _R_ collects/meta/pkg-index/official/.gitignorehttps://github.com/plt/racket/pull/363/files#diff-355(0)
> - _R_ collects/meta/pkg-index/official/gravatar.rkthttps://github.com/plt/racket/pull/363/files#diff-356(2)
> - _R_ collects/meta/pkg-index/official/main.rkthttps://github.com/plt/racket/pull/363/files#diff-357(346)
> - _R_ collects/meta/pkg-index/official/static/sorttable.jshttps://github.com/plt/racket/pull/363/files#diff-358(0)
> - _R_ collects/meta/pkg-index/official/static/style.csshttps://github.com/plt/racket/pull/363/files#diff-359(10)
> - _R_ collects/meta/pkg-index/planet-compat/.gitignorehttps://github.com/plt/racket/pull/363/files#diff-360(0)
> - _R_ collects/meta/pkg-index/planet-compat/info.rkthttps://github.com/plt/racket/pull/363/files#diff-361(0)
> - _R_ collects/meta/pkg-index/planet-compat/main.rkthttps://github.com/plt/racket/pull/363/files#diff-362(6)
> - _A_ collects/meta/pkg-index/sync.shhttps://github.com/plt/racket/pull/363/files#diff-363(13)
> - _D_ collects/meta/planet2-index/sync.shhttps://github.com/plt/racket/pull/363/files#diff-364(11)
> - _M_ collects/meta/propshttps://github.com/plt/racket/pull/363/files#diff-365(111)
> - _M_ collects/meta/web/all.rkthttps://github.com/plt/racket/pull/363/files#diff-366(2)
> - _M_ collects/meta/web/common/distribute.rkthttps://github.com/plt/racket/pull/363/files#diff-367(14)
> - _M_ collects/meta/web/common/layout.rkthttps://github.com/plt/racket/pull/363/files#diff-368(2)
> - _M_ collects/meta/web/common/links.rkthttps://github.com/plt/racket/pull/363/files#diff-369(29)
> - _M_ collects/meta/web/config.rkthttps://github.com/plt/racket/pull/363/files#diff-370(9)
> - _M_ collects/meta/web/download/download-pages.rkthttps://github.com/plt/racket/pull/363/files#diff-371(55)
> - _M_ collects/meta/web/download/index.rkthttps://github.com/plt/racket/pull/363/files#diff-372(10)
> - _M_ collects/meta/web/download/installers.txthttps://github.com/plt/racket/pull/363/files#diff-373(48)
> - _A_ collects/meta/web/download/symlinks.rkthttps://github.com/plt/racket/pull/363/files#diff-374(13)
> - _M_ collects/meta/web/stubs/all.rkthttps://github.com/plt/racket/pull/363/files#diff-375(5)
> - _A_ collects/meta/web/stubs/docs.rkthttps://github.com/plt/racket/pull/363/files#diff-376(11)
> - _M_ collects/meta/web/stubs/git.rkthttps://github.com/plt/racket/pull/363/files#diff-377(10)
> - _M_ collects/meta/web/stubs/pre.rkthttps://github.com/plt/racket/pull/363/files#diff-378(13)
> - _M_ collects/meta/web/www/community.rkthttps://github.com/plt/racket/pull/363/files#diff-379(7)
> - _M_ collects/meta/web/www/learning.rkthttps://github.com/plt/racket/pull/363/files#diff-380(2)
> - _M_ collects/meta/web/www/old-techreports.rkthttps://github.com/plt/racket/pull/363/files#diff-381(2)
> - _M_ collects/mred/private/check.rkthttps://github.com/plt/racket/pull/363/files#diff-382(1)
> - _M_ collects/mred/private/mrcanvas.rkthttps://github.com/plt/racket/pull/363/files#diff-383(5)
> - _M_ collects/mred/private/mritem.rkthttps://github.com/plt/racket/pull/363/files#diff-384(2)
> - _M_ collects/mred/private/mrwindow.rkthttps://github.com/plt/racket/pull/363/files#diff-385(21)
> - _M_ collects/mred/private/wx/cocoa/agl.rkthttps://github.com/plt/racket/pull/363/files#diff-386(11)
> - _M_ collects/mred/private/wx/cocoa/button.rkthttps://github.com/plt/racket/pull/363/files#diff-387(6)
> - _M_ collects/mred/private/wx/cocoa/canvas.rkthttps://github.com/plt/racket/pull/363/files#diff-388(65)
> - _M_ collects/mred/private/wx/cocoa/dc.rkthttps://github.com/plt/racket/pull/363/files#diff-389(1)
> - _M_ collects/mred/private/wx/cocoa/frame.rkthttps://github.com/plt/racket/pull/363/files#diff-390(4)
> - _M_ collects/mred/private/wx/cocoa/list-box.rkthttps://github.com/plt/racket/pull/363/files#diff-391(28)
> - _M_ collects/mred/private/wx/cocoa/menu-bar.rkthttps://github.com/plt/racket/pull/363/files#diff-392(8)
> - _M_ collects/mred/private/wx/cocoa/panel.rkthttps://github.com/plt/racket/pull/363/files#diff-393(3)
> - _M_ collects/mred/private/wx/cocoa/window.rkthttps://github.com/plt/racket/pull/363/files#diff-394(12)
> - _M_ collects/mred/private/wx/common/canvas-mixin.rkthttps://github.com/plt/racket/pull/363/files#diff-395(10)
> - _M_ collects/mred/private/wx/gtk/button.rkthttps://github.com/plt/racket/pull/363/files#diff-396(4)
> - _M_ collects/mred/private/wx/gtk/canvas.rkthttps://github.com/plt/racket/pull/363/files#diff-397(3)
> - _M_ collects/mred/private/wx/gtk/frame.rkthttps://github.com/plt/racket/pull/363/files#diff-398(20)
> - _M_ collects/mred/private/wx/gtk/gl-context.rkthttps://github.com/plt/racket/pull/363/files#diff-399(30)
> - _M_ collects/mred/private/wx/gtk/list-box.rkthttps://github.com/plt/racket/pull/363/files#diff-400(1)
> - _M_ collects/mred/private/wx/gtk/window.rkthttps://github.com/plt/racket/pull/363/files#diff-401(124)
> - _M_ collects/mred/private/wx/win32/canvas.rkthttps://github.com/plt/racket/pull/363/files#diff-402(3)
> - _M_ collects/mred/private/wx/win32/gl-context.rkthttps://github.com/plt/racket/pull/363/files#diff-403(73)
> - _M_ collects/mred/private/wx/win32/window.rkthttps://github.com/plt/racket/pull/363/files#diff-404(16)
> - _M_ collects/mred/private/wxme/editor-canvas.rkthttps://github.com/plt/racket/pull/363/files#diff-405(43)
> - _M_ collects/mred/private/wxme/text.rkthttps://github.com/plt/racket/pull/363/files#diff-406(192)
> - _M_ collects/mrlib/gif.rkthttps://github.com/plt/racket/pull/363/files#diff-407(179)
> - _M_ collects/mrlib/image-core.rkthttps://github.com/plt/racket/pull/363/files#diff-408(4)
> - _M_ collects/mrlib/scribblings/gif.scrblhttps://github.com/plt/racket/pull/363/files#diff-409(6)
> - _M_ collects/mrlib/scribblings/mrlib.scrblhttps://github.com/plt/racket/pull/363/files#diff-410(1)
> - _M_ collects/mrlib/scribblings/path-dialog.scrblhttps://github.com/plt/racket/pull/363/files#diff-411(2)
> - _A_ collects/mrlib/scribblings/terminal.scrblhttps://github.com/plt/racket/pull/363/files#diff-412(99)
> - _M_ collects/mrlib/switchable-button.rkthttps://github.com/plt/racket/pull/363/files#diff-413(5)
> - _M_ collects/mrlib/syntax-browser.rkthttps://github.com/plt/racket/pull/363/files#diff-414(44)
> - _A_ collects/mrlib/terminal.rkthttps://github.com/plt/racket/pull/363/files#diff-415(253)
> - _M_ collects/mrlib/tex-table.rkthttps://github.com/plt/racket/pull/363/files#diff-416(8)
> - _M_ collects/mysterx/mysterx.rkthttps://github.com/plt/racket/pull/363/files#diff-417(8)
> - _M_ collects/mysterx/scribblings/methprop.scrblhttps://github.com/plt/racket/pull/363/files#diff-418(24)
> - _M_ collects/mzlib/include.rkthttps://github.com/plt/racket/pull/363/files#diff-419(12)
> - _M_ collects/mzlib/scribblings/pconvert.scrblhttps://github.com/plt/racket/pull/363/files#diff-420(8)
> - _M_ collects/net/cookie.rkthttps://github.com/plt/racket/pull/363/files#diff-421(18)
> - _M_ collects/net/dns.rkthttps://github.com/plt/racket/pull/363/files#diff-422(495)
> - _M_ collects/net/ftp.rkthttps://github.com/plt/racket/pull/363/files#diff-423(6)
> - _M_ collects/net/imap.rkthttps://github.com/plt/racket/pull/363/files#diff-424(37)
> - _A_ collects/net/private/ip.rkthttps://github.com/plt/racket/pull/363/files#diff-425(219)
> - _M_ collects/net/scribblings/cookie.scrblhttps://github.com/plt/racket/pull/363/files#diff-426(6)
> - _M_ collects/net/scribblings/dns.scrblhttps://github.com/plt/racket/pull/363/files#diff-427(10)
> - _M_ collects/net/scribblings/ftp.scrblhttps://github.com/plt/racket/pull/363/files#diff-428(2)
> - _M_ collects/net/scribblings/head.scrblhttps://github.com/plt/racket/pull/363/files#diff-429(6)
> - _M_ collects/net/scribblings/imap.scrblhttps://github.com/plt/racket/pull/363/files#diff-430(23)
> - _M_ collects/net/scribblings/url.scrblhttps://github.com/plt/racket/pull/363/files#diff-431(44)
> - _M_ collects/net/uri-codec.rkthttps://github.com/plt/racket/pull/363/files#diff-432(256)
> - _M_ collects/net/url.rkthttps://github.com/plt/racket/pull/363/files#diff-433(209)
> - _M_ collects/openssl/libcrypto.rkthttps://github.com/plt/racket/pull/363/files#diff-434(7)
> - _M_ collects/openssl/mzssl.rkthttps://github.com/plt/racket/pull/363/files#diff-435(4)
> - _M_ collects/openssl/openssl.scrblhttps://github.com/plt/racket/pull/363/files#diff-436(4)
> - _M_ collects/parser-tools/parser-tools.scrblhttps://github.com/plt/racket/pull/363/files#diff-437(6)
> - _M_ collects/parser-tools/private-yacc/input-file-parser.rkthttps://github.com/plt/racket/pull/363/files#diff-438(10)
> - _M_ collects/parser-tools/private-yacc/lr0.rkthttps://github.com/plt/racket/pull/363/files#diff-439(8)
> - _M_ collects/parser-tools/private-yacc/parser-builder.rkthttps://github.com/plt/racket/pull/363/files#diff-440(5)
> - _M_ collects/parser-tools/yacc.rkthttps://github.com/plt/racket/pull/363/files#diff-441(16)
> - _A_ collects/pict/balloon.rkthttps://github.com/plt/racket/pull/363/files#diff-442(5)
> - _A_ collects/pict/code.rkthttps://github.com/plt/racket/pull/363/files#diff-443(126)
> - _A_ collects/pict/convert.rkthttps://github.com/plt/racket/pull/363/files#diff-444(9)
> - _A_ collects/pict/face.rkthttps://github.com/plt/racket/pull/363/files#diff-445(3)
> - _A_ collects/pict/flash.rkthttps://github.com/plt/racket/pull/363/files#diff-446(4)
> - _A_ collects/pict/info.rkthttps://github.com/plt/racket/pull/363/files#diff-447(4)
> - _A_ collects/pict/main.rkthttps://github.com/plt/racket/pull/363/files#diff-448(288)
> - _A_ collects/pict/scribblings/code.scrblhttps://github.com/plt/racket/pull/363/files#diff-449(394)
> - _A_ collects/pict/scribblings/more.scrblhttps://github.com/plt/racket/pull/363/files#diff-450(431)
> - _R_ collects/pict/scribblings/pict-diagram.rkthttps://github.com/plt/racket/pull/363/files#diff-451(2)
> - _R_ collects/pict/scribblings/pict.scrblhttps://github.com/plt/racket/pull/363/files#diff-452(458)
> - _M_ collects/picturing-programs/main.rkthttps://github.com/plt/racket/pull/363/files#diff-453(2)
> - _M_ collects/picturing-programs/private/map-image.rkthttps://github.com/plt/racket/pull/363/files#diff-454(339)
> - _M_ collects/picturing-programs/private/tiles.rkthttps://github.com/plt/racket/pull/363/files#diff-455(42)
> - _M_ collects/picturing-programs/tests/map-image-bsl-tests.rkthttps://github.com/plt/racket/pull/363/files#diff-456(36)
> - _D_ collects/picturing-programs/tests/tiles-error-tests.rkthttps://github.com/plt/racket/pull/363/files#diff-457(37)
> - _R_ collects/pkg/.gitignorehttps://github.com/plt/racket/pull/363/files#diff-458(0)
> - _R_ collects/pkg/commands.rkthttps://github.com/plt/racket/pull/363/files#diff-459(0)
> - _A_ collects/pkg/db.rkthttps://github.com/plt/racket/pull/363/files#diff-460(661)
> - _A_ collects/pkg/gui/by-installed.rkthttps://github.com/plt/racket/pull/363/files#diff-461(169)
> - _A_ collects/pkg/gui/by-list.rkthttps://github.com/plt/racket/pull/363/files#diff-462(509)
> - _A_ collects/pkg/gui/by-source.rkthttps://github.com/plt/racket/pull/363/files#diff-463(400)
> - _A_ collects/pkg/gui/common.rkthttps://github.com/plt/racket/pull/363/files#diff-464(32)
> - _A_ collects/pkg/gui/main.rkthttps://github.com/plt/racket/pull/363/files#diff-465(163)
> - _A_ collects/pkg/info.rkthttps://github.com/plt/racket/pull/363/files#diff-466(6)
> - _A_ collects/pkg/lib.rkthttps://github.com/plt/racket/pull/363/files#diff-467(2096)
> - _R_ collects/pkg/main.rkthttps://github.com/plt/racket/pull/363/files#diff-468(191)
> - _R_ collects/pkg/name.rkthttps://github.com/plt/racket/pull/363/files#diff-469(26)
> - _R_ collects/pkg/raco.rkthttps://github.com/plt/racket/pull/363/files#diff-470(0)
> - _A_ collects/pkg/scribblings/apis.scrblhttps://github.com/plt/racket/pull/363/files#diff-471(17)
> - _A_ collects/pkg/scribblings/catalog-protocol.scrblhttps://github.com/plt/racket/pull/363/files#diff-472(196)
> - _A_ collects/pkg/scribblings/common.rkthttps://github.com/plt/racket/pull/363/files#diff-473(15)
> - _A_ collects/pkg/scribblings/db.scrblhttps://github.com/plt/racket/pull/363/files#diff-474(171)
> - _A_ collects/pkg/scribblings/lib.scrblhttps://github.com/plt/racket/pull/363/files#diff-475(325)
> - _R_ collects/pkg/scribblings/pkg.scrblhttps://github.com/plt/racket/pull/363/files#diff-476(379)
> - _A_ collects/pkg/scribblings/strip.scrblhttps://github.com/plt/racket/pull/363/files#diff-477(161)
> - _A_ collects/pkg/strip.rkthttps://github.com/plt/racket/pull/363/files#diff-478(224)
> - _A_ collects/pkg/util.rkthttps://github.com/plt/racket/pull/363/files#diff-479(138)
> - _M_ collects/plai/datatype.rkthttps://github.com/plt/racket/pull/363/files#diff-480(64)
> - _M_ collects/plai/gc2/collector.rkthttps://github.com/plt/racket/pull/363/files#diff-481(4)
> - _M_ collects/plai/gc2/mutator.rkthttps://github.com/plt/racket/pull/363/files#diff-482(297)
> - _M_ collects/plai/gc2/private/collector-exports.rkthttps://github.com/plt/racket/pull/363/files#diff-483(10)
> - _M_ collects/plai/gc2/private/gc-core.rkthttps://github.com/plt/racket/pull/363/files#diff-484(70)
> - _M_ collects/plai/gc2/private/gc-transformer.rkthttps://github.com/plt/racket/pull/363/files#diff-485(49)
> - _M_ collects/plai/mutator.rkthttps://github.com/plt/racket/pull/363/files#diff-486(22)
> - _M_ collects/plai/private/gc-core.rkthttps://github.com/plt/racket/pull/363/files#diff-487(38)
> - _M_ collects/plai/private/gc-transformer.rkt<https://github

rebased, sorry.
-Ian
----- Original Message -----
From: Robby Findler notifications@github.com
To: plt/racket racket@noreply.github.com
Cc: J. Ian Johnson ianj@ccs.neu.edu
Sent: Thu, 6 Jun 2013 17:13:51 -0400 (EDT)
Subject: Re: [racket] Redex wildcard (#363)

Something seems to have gone wrong with this one. Can you make a simpler
commit, please?

Robby

On Thu, Jun 6, 2013 at 4:09 PM, J. Ian Johnson notifications@github.comwrote:

> any and any_!_ do not match absolutely anything regardless of anything
> else in the pattern. This patch introduces _ as its own pattern as a
> 
> ## non-binding, unnameable pattern that matches anything.
> 
> You can merge this Pull Request by running
> 
>   git pull https://github.com/ianj/racket redex-wildcard
> 
> Or view, comment on, or merge it at:
> 
>   https://github.com/plt/racket/pull/363
> Commit Summary
> - improve tests
> - fixed quasisyntax to work with prefab struct templates
> - Fix re Robby
> - Fixing PR13729
> - add more explaination to #%expression
> - misc improvements to generate-term
> - edito
> - another edito
> - make `scribble' (and`raco scribble') use a `doc' submodule when
>   present
> - add `configure-runtime' submodule support
> - fix `module' non-simplification of syntax during expansion
> - switch `rascket/base' and`scheme/base' to submodule language style
> - allow #:chaperone specification in struct/dc
> - fix tests
> - scribble: fix binding search for phase 1 through initial import
> - bump version
> - add an example use of the #:pp argument to the redex docs
> - Add urls with the info about deps to README.
> - Add comments, purpose statements, and contracts
> - Remove unnecessary prefab struct declaration
> - Style guideline compliance
> - Remove commented code and random line breaks
> - Correct typos in src/README
> - fix error message for applying a non-procedure with keywords
> - Add examples for syntax/stx
> - Move tc-literal to seperate file, as it doesn't belong in tc-expr.
> - Move tc/send to new file because it doesn't belong in tc-expr-unit.
> - Fix type of tanh.
> - scribble: fix `--redirect{-main}' and non-HTML mode
> - add `racket/rerequire'
> - stepper: ignore submodules
> - racket/{require,provide}-syntax: add
>   `syntax-local-{require,provide}-introduce'
> - racket/place: keywords as place messages
> - redex: fix and clean up metafunction expansion
> - raco pkg: fix conflict checking for a collection splice
> - Add a few examples to syntax transformer section
> - remove dead code
> - A kindler, gentler death re: Robby
> - Fix cookie test re version
> - render non-installaction-scoped package docs with an indirection
> - New Racket version 5.3.4.9.
> - share submodules of racket/base and scheme/base
> - Move `explode-path' from`racket/path' to `racket/base'
> - raco pkg: "indices" -> "catalogs" in dependency message
> - avoid a constant folding that can use too much memory
> - fixed (~r 0 #:notation 'exponential ....) bugs
> - some random testing for (~r #:notation 'exponential ....)
> - raco setup: fix subcollection traversal
> - fix place-channel test
> - raco exe: enable on-demand parsing of embedded bytecode
> - v5.3.4 installers info
> - fix `raco exe' test
> - fix estimate of order of magnitude for ~r
> - Adding customization of command-char to web-server/template
> - Remove contract on unit-exported definition.
> - Cleanup tc-lambda-unit.
> - Some style cleanups.
> - Add `permutations' and`in-permutations'.
> - tighten up the contract for get-display-size and
>   get-display-left-top-inset
> - Refactor subtype.rkt not to use exceptions.
> - Make the stop value for `in-producer' optional.
> - add missing guard
> - Add contract for seen parameter.
> - Forgot to commit example
> - New Racket version 5.3.4.10.
> - Temporary hack: avoid `permutations' clash until its renamed in
>   `math'.
> - Fix inclusion of "keep-dirs.rktd".
> - Combine the two zo-size tests into one.
> - Updated sizes of repackaged source distributions.
> - Update links re release
> - Added Redex enumerators.
> - delay the unimplemented/unsupported errors until the enumeration is
>   actually used
> - add immutable hashes to printable/c
> - Fix error based on mis-read contract
> - DrRacket now saves the font size preference on a
>   per-monitor-configuration basis
> - More temporary hacking around the to-be-renamed `permutations'
>   problem.
> - fix typos in example code
> - fix unstable/socket loading in windows
> - Make `in-producer' treat any number of values uniformly.
> - Add tests for commit e53b0858c32b845482
> - Remove debugging instrumentation
> - Doc fixes for ffi/unsafe/atomic
> - racket/gui gtk: catch key events at frame level
> - bitmap-dc% respective alpha channel in get/set-pixel
> - db: temporary workaround for SSL one-record-per-write issue
> - allow #f as the min-width / min-height init arg to area-containers
> - add #:close-button?, #:canvas-min-width, and #:canvas-min-height
> - adjust package manager gui to separate out (and make simpler looking)
> - pkg-info-orig-info seems to also possibly be (cons 'file ...).
> - slideshow/pict: add 'outline style for `text'
> - slideshow/pict: fix `text' angle and superscript/subscript modes
> - racket/generic: fix kw args with #:defaults
> - move the slideshow/pict library to its own collection
> - fix build for Windows
> - disable slideshow's addition (to drracket) of pict value rendering
> - add responsible for collects/pict
> - Fix type of sinh.
> - Limit memory in all sandboxes used by the TR random tester.
> - Make `define-type` work at top-level
> - Log sequence specialization failures in `for' loops.
> - Fixed bad let syntax
> - Hacky fix to only flatten repeats
> - Added Redex enum tests
> - Add more syntax examples to the reference
> - Removed tabs from redex enum code
> - add enum-tests into run-tests.rkt
> - Fix source locations for TR for.
> - Fix test for TR's for source locations.
> - Make `require/typed` work at top-level
> - Fix tc-toplevel-form for ignored syntax
> - Refactor to reduce right-ward drift
> - Whitespace and comment fixes
> - adjust contract test suite to do more provide/contract =>
>   contract-out
> - make contract-out signal more errors in terms of itself
> - fix thread-creation problem
> - Fix framework doc typo
> - support libpng16
> - Massive cleanup of requriements in TR.
> - raco pkg: don't treat "info.rkt" as a conflict
> - raco pkg create: support "source" and "binary" bundling
> - Redex docs edits to be more precise about picts (versus just
>   slideshow)
> - Clean up lam-result.
> - scribble/base: handle special characters in URLs
> - scribble HTML rendering: unreserved-encode "on this page" links
> - adjust generate-term docs a little
> - libpng adjustment
> - Make sure the Redex pattern language's 'boolean' is rendered as a
>   nonterminal
> - Avoid doing the 2nd pass twice at the top-level
> - Redex: fix a small bug in the list-machine example
> - Add examples for `for/lists`
> - Fix regression for (begin) and simplify
> - Fixed in-generator's handling of arity zero.
> - Fixed collects/meta/props so that `props verify' runs without error.
> - fix docs for redex-generator
> - Gave collects/meta/check-dists more time when run by DrDr.
> - Set drdr:random property for files with nondeterministic output.
> - Fixed problems with collects/meta/props.
> - Clean up unit tests
> - fix srcloc-missing-from-exn bug in struct/dc
> - fix call-with-transaction error (disconnected rollback)
> - Adjusted check syntax to properly deal with different identifiers
> - Synch German string constants with latest.
> - Fix racket/draw doc typo
> - Fix parsing of (Struct ...) types.
> - should have been part of 299063d
> - automate some overlapping identifier tests
> - dont draw the lime green bubbles for imported identifiers
> - Fixing error in GC1 found by Mark Engelberg, but fixed in GC2
> - Redex enum supports var-except.
> - Redex enum maintains bijection internally
> - fixups for `pict' and`slideshow' docs
> - Added holes to redex enumerator.
> - Redex generator supports mismatched names.
> - minor doc fixes
> - Cut off type printing with :type at one level
> - Add a #:verbose option to :type.
> - fix problem in `free-identifier=?'
> - Fixing PR13748
> - fix object/c's blame context manipulations
> - Re-enable redex's overlapping arrows src loc information
> - Fixes PR13750
> - indent
> - Cue user about unexpanded type aliases
> - Expend printing fuel in all branches
> - remove now-redundant tests
> - Fix alarm-evt doc typo
> - Use random for changes
> - Don't check name if not given
> - Update the instructions on configuring git's push.default.
> - Misc improvements to `net/uri-codec'.
> - fix `tcp-listen' error-message construction
> - add boolean to the set of things that redex's random generator
> - Document :type better
> - Protect strings from regexps.
> - Typo in error.
> - correct augment/override confusion in docs
> - updated mitpress links
> - Fix minor doc typo for threads
> - fix and export in-dict sequence syntax
> - Make scoped type vars work only for explict Alls and annotations.
> - Add a test which times TR module loading.
> - scriblib/autbib: add `#:note' support
> - scriblib/footnote: adjust environment to make output empty
> - add `setup/collects' and use it for ".dep" file paths
> - raco pkg create --binary: strip ".dep" files, ertain submodules, ~
>   files
> - raco pkg create, raco setup: add support for built (source+binary)
>   packages
> - Tweak auto-parens behavior of double quote typed in a string
> - Improve auto-parens mode implementation and behavior
> - adjust Redex to disallow certain patterns that are guaranteed never
>   to fail
> - fix arity error
> - fix check in memory limit in drr's GUI (and fix
> - adjust DrRacket to offer installation of packages
> - only include --force when the checkbox isn't disabled
> - Minor whitespace fix.
> - adjust DrRacket's online compilation to recognize exn:missing-module?
> - when the package installer has a parent, don't
> - missed a spot for the vector => exn-info change
> - minor clarification to class/c contract spec
> - minor improvement to class/c: generate a little bit less code
> - add GUI support for compile-enforce-module-constants to DrRacket
> - Allow the profiler's sampler to collect user-specified continuation
>   marks.
> - Use submodules instead of marking tricks for identifiers in docs.
> - Fix broken internal error
> - Make resolve actually do all the necessary resolutions.
> - Centralize the definition of the plambda syntax property.
> - Centralized typechecker:ignore properties.
> - Fix doc typo.
> - Don't splice in vector creation when optimizing vector-length.
> - Fix broken test.
> - Added some checks for user errors.
> - add a parameter to adjust random generation methods
> - Fix broken test, again.
> - Register scoped type variables for internal def. annotations.
> - Make for loops in TR use an annotation when applicable.
> - Use in-syntax instead of in-list/syntax->list.
> - Add error checking to in-syntax.
> - Add syntax-length to unstable/syntax.
> - Make TR use syntax-length instead of (length (syntax->list x)).
> - Move from syntax-map to stx-map.
> - Move from syntax->list and map to stx-map.
> - Replace syntax-map with stx-map in unstable/automata
> - Replace syntax-map with stx-map in plai.
> - Use abbreviations for filters.
> - Consolidate the rest of the syntax properties in TR.
> - Cleanup flonum-op check, and contract fixups.
> - Remove syntax-map.
> - Cleanup some syntax->list uses in the optimizer.
> - Remove unused definition and clean up exports.
> - Share definition of erase-filter.
> - Use stx-list? instead of syntax->list.
> - Removed unnecessary require.
> - Make printing complex filters not be on by default.
> - Remove unused code.
> - Reduce duplication in construction of syntax-infos.
> - Remove duplication of type-variable duplicate detection.
> - Make tc-app-object use a real dictionary.
> - Cleanup tc-app-objects a bit.
> - Remove unnecessary loop in tc-app-objects.
> - Make TR's lambda not do datum->syntax.
> - Remove unused code.
> - Remove unused feature.
> - Make tc-toplevel always return a list.
> - Fix documented type, and remove unnecessary or.
> - Add test for duplicate annotations.
> - include source-location in "missing module" exceptions
> - added command-line demo
> - Fix method accessors for inherits and abstracts
> - Restore commented `for` loop
> - New Racket version 5.3.4.11.
> - Added a wildcard construct that absolutely does not bind.
> 
> File Changes
> - _M_ .mailmap https://github.com/plt/racket/pull/363/files#diff-0(25)
> - _M_ README https://github.com/plt/racket/pull/363/files#diff-1 (4)
> - _M_ collects/2htdp/batch-io.rkthttps://github.com/plt/racket/pull/363/files#diff-2(14)
> - _M_ collects/2htdp/private/image-more.rkthttps://github.com/plt/racket/pull/363/files#diff-3(100)
> - _M_ collects/2htdp/private/img-err.rkthttps://github.com/plt/racket/pull/363/files#diff-4(2)
> - _A_ collects/2htdp/tests/batch-io-csv-ho.rkthttps://github.com/plt/racket/pull/363/files#diff-5(6)
> - _A_ collects/2htdp/tests/batch-io-csv-ho.txthttps://github.com/plt/racket/pull/363/files#diff-6(1)
> - _M_ collects/2htdp/tests/batch-io.rkthttps://github.com/plt/racket/pull/363/files#diff-7(2)
> - _M_ collects/2htdp/tests/batch-io2.rkthttps://github.com/plt/racket/pull/363/files#diff-8(2)
> - _M_ collects/2htdp/tests/batch-io3.rkthttps://github.com/plt/racket/pull/363/files#diff-9(2)
> - _A_ collects/2htdp/tests/run-movie.rkthttps://github.com/plt/racket/pull/363/files#diff-10(13)
> - _M_ collects/2htdp/tests/test-image.rkthttps://github.com/plt/racket/pull/363/files#diff-11(37)
> - _M_ collects/2htdp/tests/universe-restart.rkthttps://github.com/plt/racket/pull/363/files#diff-12(2)
> - _M_ collects/2htdp/universe.rkthttps://github.com/plt/racket/pull/363/files#diff-13(2)
> - _M_ collects/2htdp/xtesthttps://github.com/plt/racket/pull/363/files#diff-14(2)
> - _M_ collects/algol60/cfg-parser.rkthttps://github.com/plt/racket/pull/363/files#diff-15(2)
> - _M_ collects/algol60/compile.rkthttps://github.com/plt/racket/pull/363/files#diff-16(8)
> - _M_ collects/algol60/simplify.rkthttps://github.com/plt/racket/pull/363/files#diff-17(18)
> - _M_ collects/compiler/cm-accomplice.rkthttps://github.com/plt/racket/pull/363/files#diff-18(5)
> - _M_ collects/compiler/cm.rkthttps://github.com/plt/racket/pull/363/files#diff-19(39)
> - _M_ collects/compiler/commands/ctool.rkthttps://github.com/plt/racket/pull/363/files#diff-20(2)
> - _M_ collects/compiler/commands/exe.rkthttps://github.com/plt/racket/pull/363/files#diff-21(19)
> - _M_ collects/compiler/commands/info.rkthttps://github.com/plt/racket/pull/363/files#diff-22(2)
> - _M_ collects/compiler/commands/test.rkthttps://github.com/plt/racket/pull/363/files#diff-23(167)
> - _M_ collects/compiler/compiler-unit.rkthttps://github.com/plt/racket/pull/363/files#diff-24(84)
> - _M_ collects/compiler/decompile.rkthttps://github.com/plt/racket/pull/363/files#diff-25(3)
> - _M_ collects/compiler/demodularizer/merge.rkthttps://github.com/plt/racket/pull/363/files#diff-26(20)
> - _M_ collects/compiler/demodularizer/module.rkthttps://github.com/plt/racket/pull/363/files#diff-27(1)
> - _M_ collects/compiler/demodularizer/nodep.rkthttps://github.com/plt/racket/pull/363/files#diff-28(4)
> - _M_ collects/compiler/distribute.rkthttps://github.com/plt/racket/pull/363/files#diff-29(40)
> - _M_ collects/compiler/embed-unit.rkthttps://github.com/plt/racket/pull/363/files#diff-30(48)
> - _M_ collects/compiler/embed.rkthttps://github.com/plt/racket/pull/363/files#diff-31(1)
> - _M_ collects/compiler/find-exe.rkthttps://github.com/plt/racket/pull/363/files#diff-32(4)
> - _M_ collects/compiler/main.rkthttps://github.com/plt/racket/pull/363/files#diff-33(2)
> - _M_ collects/compiler/private/elf.rkthttps://github.com/plt/racket/pull/363/files#diff-34(46)
> - _M_ collects/compiler/zo-marshal.rkthttps://github.com/plt/racket/pull/363/files#diff-35(3)
> - _M_ collects/compiler/zo-parse.rkthttps://github.com/plt/racket/pull/363/files#diff-36(3)
> - _M_ collects/compiler/zo-structs.rkthttps://github.com/plt/racket/pull/363/files#diff-37(1)
> - _M_ collects/data/bit-vector.rkthttps://github.com/plt/racket/pull/363/files#diff-38(1)
> - _M_ collects/data/integer-set.rkthttps://github.com/plt/racket/pull/363/files#diff-39(14)
> - _M_ collects/data/queue.rkthttps://github.com/plt/racket/pull/363/files#diff-40(22)
> - _M_ collects/data/scribblings/union-find.scrblhttps://github.com/plt/racket/pull/363/files#diff-41(4)
> - _M_ collects/datalog/lang/configure-runtime.rkthttps://github.com/plt/racket/pull/363/files#diff-42(22)
> - _M_ collects/db/private/generic/functions.rkthttps://github.com/plt/racket/pull/363/files#diff-43(3)
> - _D_ collects/db/private/generic/socket.rkthttps://github.com/plt/racket/pull/363/files#diff-44(105)
> - _M_ collects/db/private/mysql/main.rkthttps://github.com/plt/racket/pull/363/files#diff-45(2)
> - _M_ collects/db/private/postgresql/connection.rkthttps://github.com/plt/racket/pull/363/files#diff-46(39)
> - _M_ collects/db/private/postgresql/main.rkthttps://github.com/plt/racket/pull/363/files#diff-47(2)
> - _M_ collects/db/scribblings/query.scrblhttps://github.com/plt/racket/pull/363/files#diff-48(2)
> - _M_ collects/deinprogramm/deinprogramm-langs.rkthttps://github.com/plt/racket/pull/363/files#diff-49(6)
> - _M_ collects/deinprogramm/signature/signature-syntax.rkthttps://github.com/plt/racket/pull/363/files#diff-50(6)
> - _M_ collects/deinprogramm/signature/signature.rkthttps://github.com/plt/racket/pull/363/files#diff-51(4)
> - _M_ collects/deinprogramm/turtle.rkthttps://github.com/plt/racket/pull/363/files#diff-52(20)
> - _M_ collects/drracket/acks.rkthttps://github.com/plt/racket/pull/363/files#diff-53(3)
> - _M_ collects/drracket/check-syntax.rkthttps://github.com/plt/racket/pull/363/files#diff-54(3)
> - _M_ collects/drracket/drracket.rkthttps://github.com/plt/racket/pull/363/files#diff-55(13)
> - _M_ collects/drracket/private/debug.rkthttps://github.com/plt/racket/pull/363/files#diff-56(123)
> - _M_ collects/drracket/private/drsig.rkthttps://github.com/plt/racket/pull/363/files#diff-57(6)
> - _M_ collects/drracket/private/embedded-snip-utils.rkthttps://github.com/plt/racket/pull/363/files#diff-58(8)
> - _M_ collects/drracket/private/eval-helpers.rkthttps://github.com/plt/racket/pull/363/files#diff-59(72)
> - _M_ collects/drracket/private/eval.rkthttps://github.com/plt/racket/pull/363/files#diff-60(7)
> - _M_ collects/drracket/private/expanding-place.rkthttps://github.com/plt/racket/pull/363/files#diff-61(293)
> - _M_ collects/drracket/private/font.rkthttps://github.com/plt/racket/pull/363/files#diff-62(12)
> - _M_ collects/drracket/private/frame-icon.rkthttps://github.com/plt/racket/pull/363/files#diff-63(3)
> - _M_ collects/drracket/private/frame.rkthttps://github.com/plt/racket/pull/363/files#diff-64(98)
> - _M_ collects/drracket/private/get-extend.rkthttps://github.com/plt/racket/pull/363/files#diff-65(76)
> - _M_ collects/drracket/private/language-configuration.rkthttps://github.com/plt/racket/pull/363/files#diff-66(14)
> - _M_ collects/drracket/private/language.rkthttps://github.com/plt/racket/pull/363/files#diff-67(8)
> - _M_ collects/drracket/private/local-member-names.rkthttps://github.com/plt/racket/pull/363/files#diff-68(21)
> - _M_ collects/drracket/private/main.rkthttps://github.com/plt/racket/pull/363/files#diff-69(14)
> - _M_ collects/drracket/private/module-language.rkthttps://github.com/plt/racket/pull/363/files#diff-70(527)
> - _M_ collects/drracket/private/profile-drs.rkthttps://github.com/plt/racket/pull/363/files#diff-71(4)
> - _M_ collects/drracket/private/rep.rkthttps://github.com/plt/racket/pull/363/files#diff-72(198)
> - _M_ collects/drracket/private/syncheck/gui.rkthttps://github.com/plt/racket/pull/363/files#diff-73(776)
> - _M_ collects/drracket/private/syncheck/intf.rkthttps://github.com/plt/racket/pull/363/files#diff-74(26)
> - _M_ collects/drracket/private/syncheck/local-member-names.rkthttps://github.com/plt/racket/pull/363/files#diff-75(8)
> - _M_ collects/drracket/private/syncheck/online-comp.rkthttps://github.com/plt/racket/pull/363/files#diff-76(52)
> - _M_ collects/drracket/private/syncheck/traversals.rkthttps://github.com/plt/racket/pull/363/files#diff-77(521)
> - _M_ collects/drracket/private/unit.rkthttps://github.com/plt/racket/pull/363/files#diff-78(154)
> - _M_ collects/drracket/tool-lib.rkthttps://github.com/plt/racket/pull/363/files#diff-79(243)
> - _M_ collects/embedded-gui/embedded-gui.rkthttps://github.com/plt/racket/pull/363/files#diff-80(4)
> - _M_ collects/embedded-gui/private/lines.rkthttps://github.com/plt/racket/pull/363/files#diff-81(10)
> - _M_ collects/embedded-gui/scribblings/dllist.scrblhttps://github.com/plt/racket/pull/363/files#diff-82(2)
> - _M_ collects/eopl/datatype.rkthttps://github.com/plt/racket/pull/363/files#diff-83(577)
> - _M_ collects/eopl/eopl.rkthttps://github.com/plt/racket/pull/363/files#diff-84(14)
> - _M_ collects/eopl/eopl.scrblhttps://github.com/plt/racket/pull/363/files#diff-85(43)
> - _M_ collects/eopl/info.rkthttps://github.com/plt/racket/pull/363/files#diff-86(1)
> - _M_ collects/eopl/private/sllboth.rkthttps://github.com/plt/racket/pull/363/files#diff-87(59)
> - _M_ collects/eopl/private/slldef.rkthttps://github.com/plt/racket/pull/363/files#diff-88(8)
> - _M_ collects/eopl/private/sllgen.rkthttps://github.com/plt/racket/pull/363/files#diff-89(3820)
> - _M_ collects/eopl/private/utils.rkthttps://github.com/plt/racket/pull/363/files#diff-90(30)
> - _M_ collects/ffi/unsafe.rkthttps://github.com/plt/racket/pull/363/files#diff-91(113)
> - _M_ collects/ffi/unsafe/com.rkthttps://github.com/plt/racket/pull/363/files#diff-92(46)
> - _M_ collects/ffi/unsafe/objc.rkthttps://github.com/plt/racket/pull/363/files#diff-93(49)
> - _M_ collects/ffi/vector.rkthttps://github.com/plt/racket/pull/363/files#diff-94(7)
> - _M_ collects/file/gunzip.rkthttps://github.com/plt/racket/pull/363/files#diff-95(24)
> - _M_ collects/file/md5.rkthttps://github.com/plt/racket/pull/363/files#diff-96(2)
> - _M_ collects/file/scribblings/sha1.scrblhttps://github.com/plt/racket/pull/363/files#diff-97(10)
> - _M_ collects/file/scribblings/tar.scrblhttps://github.com/plt/racket/pull/363/files#diff-98(2)
> - _D_ collects/file/tests/sha1.rkthttps://github.com/plt/racket/pull/363/files#diff-99(9)
> - _M_ collects/file/untar.rkthttps://github.com/plt/racket/pull/363/files#diff-100(18)
> - _M_ collects/file/untgz.rkthttps://github.com/plt/racket/pull/363/files#diff-101(29)
> - _M_ collects/file/zip.rkthttps://github.com/plt/racket/pull/363/files#diff-102(2)
> - _M_ collects/framework/main.rkthttps://github.com/plt/racket/pull/363/files#diff-103(85)
> - _M_ collects/framework/preferences.rkthttps://github.com/plt/racket/pull/363/files#diff-104(53)
> - _M_ collects/framework/private/aspell.rkthttps://github.com/plt/racket/pull/363/files#diff-105(3)
> - _M_ collects/framework/private/color.rkthttps://github.com/plt/racket/pull/363/files#diff-106(54)
> - _M_ collects/framework/private/editor.rkthttps://github.com/plt/racket/pull/363/files#diff-107(109)
> - _M_ collects/framework/private/finder.rkthttps://github.com/plt/racket/pull/363/files#diff-108(2)
> - _M_ collects/framework/private/frame.rkthttps://github.com/plt/racket/pull/363/files#diff-109(3)
> - _M_ collects/framework/private/group.rkthttps://github.com/plt/racket/pull/363/files#diff-110(2)
> - _M_ collects/framework/private/icon.rkthttps://github.com/plt/racket/pull/363/files#diff-111(6)
> - _M_ collects/framework/private/keymap.rkthttps://github.com/plt/racket/pull/363/files#diff-112(305)
> - _M_ collects/framework/private/main.rkthttps://github.com/plt/racket/pull/363/files#diff-113(38)
> - _M_ collects/framework/private/number-snip.rkthttps://github.com/plt/racket/pull/363/files#diff-114(11)
> - _M_ collects/framework/private/panel.rkthttps://github.com/plt/racket/pull/363/files#diff-115(12)
> - _M_ collects/framework/private/racket.rkthttps://github.com/plt/racket/pull/363/files#diff-116(591)
> - _M_ collects/framework/private/sig.rkthttps://github.com/plt/racket/pull/363/files#diff-117(7)
> - _M_ collects/framework/private/text.rkthttps://github.com/plt/racket/pull/363/files#diff-118(22)
> - _M_ collects/frtime/demos/pong.rkthttps://github.com/plt/racket/pull/363/files#diff-119(2)
> - _M_ collects/frtime/demos/push-pull-ball.rkthttps://github.com/plt/racket/pull/363/files#diff-120(14)
> - _M_ collects/frtime/frlibs/math.rkthttps://github.com/plt/racket/pull/363/files#diff-121(32)
> - _M_ collects/frtime/gui/mixin-macros.rkthttps://github.com/plt/racket/pull/363/files#diff-122(2)
> - _M_ collects/frtime/opt/frtime-opt.rkthttps://github.com/plt/racket/pull/363/files#diff-123(2)
> - _M_ collects/frtime/scribblings/frtime.scrblhttps://github.com/plt/racket/pull/363/files#diff-124(2)
> - _M_ collects/future-visualizer/main.rkthttps://github.com/plt/racket/pull/363/files#diff-125(2)
> - _M_ collects/future-visualizer/private/drawing-helpers.rkthttps://github.com/plt/racket/pull/363/files#diff-126(2)
> - _M_ collects/future-visualizer/private/graph-drawing.rkthttps://github.com/plt/racket/pull/363/files#diff-127(10)
> - _M_ collects/future-visualizer/private/gui-helpers.rkthttps://github.com/plt/racket/pull/363/files#diff-128(4)
> - _M_ collects/future-visualizer/private/pict-canvas.rkthttps://github.com/plt/racket/pull/363/files#diff-129(2)
> - _M_ collects/future-visualizer/private/visualizer-data.rkthttps://github.com/plt/racket/pull/363/files#diff-130(18)
> - _M_ collects/future-visualizer/private/visualizer-drawing.rkthttps://github.com/plt/racket/pull/363/files#diff-131(9)
> - _R_ collects/games/aces/aces.rkthttps://github.com/plt/racket/pull/363/files#diff-132(182)
> - _M_ collects/games/aces/info.rkthttps://github.com/plt/racket/pull/363/files#diff-133(2)
> - _M_ collects/games/blackjack/blackjack.rkthttps://github.com/plt/racket/pull/363/files#diff-134(4)
> - _M_ collects/games/cards.rkthttps://github.com/plt/racket/pull/363/files#diff-135(4)
> - _M_ collects/games/cards/base.rkthttps://github.com/plt/racket/pull/363/files#diff-136(6)
> - _M_ collects/games/cards/card-class.rkthttps://github.com/plt/racket/pull/363/files#diff-137(2)
> - _M_ collects/games/cards/cards.rkthttps://github.com/plt/racket/pull/363/files#diff-138(4)
> - _M_ collects/games/cards/classes.rkthttps://github.com/plt/racket/pull/363/files#diff-139(3)
> - _M_ collects/games/cards/constants.rkthttps://github.com/plt/racket/pull/363/files#diff-140(6)
> - _M_ collects/games/cards/main.rkthttps://github.com/plt/racket/pull/363/files#diff-141(4)
> - _M_ collects/games/cards/make-cards.rkthttps://github.com/plt/racket/pull/363/files#diff-142(12)
> - _M_ collects/games/cards/region.rkthttps://github.com/plt/racket/pull/363/files#diff-143(2)
> - _M_ collects/games/cards/snipclass.rkthttps://github.com/plt/racket/pull/363/files#diff-144(6)
> - _M_ collects/games/cards/utils.rkthttps://github.com/plt/racket/pull/363/files#diff-145(2)
> - _M_ collects/games/chat-noir/chat-noir-unit.rkthttps://github.com/plt/racket/pull/363/files#diff-146(4)
> - _M_ collects/games/chat-noir/hash.rkthttps://github.com/plt/racket/pull/363/files#diff-147(2)
> - _M_ collects/games/checkers/checkers.rkthttps://github.com/plt/racket/pull/363/files#diff-148(16)
> - _M_ collects/games/checkers/honu-bitmaps.rkthttps://github.com/plt/racket/pull/363/files#diff-149(13)
> - _M_ collects/games/crazy8s/crazy8s.rkthttps://github.com/plt/racket/pull/363/files#diff-150(8)
> - _M_ collects/games/doors/doors.rkthttps://github.com/plt/racket/pull/363/files#diff-151(22)
> - _M_ collects/games/doors/graph.rkthttps://github.com/plt/racket/pull/363/files#diff-152(9)
> - _M_ collects/games/doors/private/utils.rkthttps://github.com/plt/racket/pull/363/files#diff-153(2)
> - _M_ collects/games/doors/utils.rkthttps://github.com/plt/racket/pull/363/files#diff-154(17)
> - _D_ collects/games/gcalc/gcalc-exampleshttps://github.com/plt/racket/pull/363/files#diff-155(9)
> - _A_ collects/games/gcalc/gcalc-examples.rktdhttps://github.com/plt/racket/pull/363/files#diff-156(9)
> - _M_ collects/games/gcalc/gcalc.rkthttps://github.com/plt/racket/pull/363/files#diff-157(778)
> - _M_ collects/games/gl-board-game.rkthttps://github.com/plt/racket/pull/363/files#diff-158(2)
> - _M_ collects/games/gl-board-game/gl-board.rkthttps://github.com/plt/racket/pull/363/files#diff-159(14)
> - _M_ collects/games/gl-board-game/main.rkthttps://github.com/plt/racket/pull/363/files#diff-160(2)
> - _M_ collects/games/gobblet/check.rkthttps://github.com/plt/racket/pull/363/files#diff-161(12)
> - _M_ collects/games/gobblet/explore.rkthttps://github.com/plt/racket/pull/363/files#diff-162(34)
> - _M_ collects/games/gobblet/gobblet.rkthttps://github.com/plt/racket/pull/363/files#diff-163(8)
> - _M_ collects/games/gobblet/gui.rkthttps://github.com/plt/racket/pull/363/files#diff-164(7)
> - _M_ collects/games/gobblet/heuristics.rkthttps://github.com/plt/racket/pull/363/files#diff-165(6)
> - _M_ collects/games/gobblet/model.rkthttps://github.com/plt/racket/pull/363/files#diff-166(78)
> - _M_ collects/games/gobblet/plays-3x3.rkthttps://github.com/plt/racket/pull/363/files#diff-167(2)
> - _M_ collects/games/gobblet/robot.rkthttps://github.com/plt/racket/pull/363/files#diff-168(4)
> - _M_ collects/games/gobblet/sig.rkthttps://github.com/plt/racket/pull/363/files#diff-169(2)
> - _M_ collects/games/gobblet/test-explore.rkthttps://github.com/plt/racket/pull/363/files#diff-170(4)
> - _M_ collects/games/gobblet/test-model.rkthttps://github.com/plt/racket/pull/363/files#diff-171(39)
> - _M_ collects/games/gobblet/test.rkthttps://github.com/plt/racket/pull/363/files#diff-172(2)
> - _M_ collects/games/gofish/gofish.rkthttps://github.com/plt/racket/pull/363/files#diff-173(6)
> - _M_ collects/games/info.rkthttps://github.com/plt/racket/pull/363/files#diff-174(4)
> - _A_ collects/games/jewel/array.rkthttps://github.com/plt/racket/pull/363/files#diff-175(99)
> - _D_ collects/games/jewel/array.scmhttps://github.com/plt/racket/pull/363/files#diff-176(169)
> - _M_ collects/games/jewel/info.rkthttps://github.com/plt/racket/pull/363/files#diff-177(2)
> - _A_ collects/games/jewel/jewel.rkthttps://github.com/plt/racket/pull/363/files#diff-178(1374)
> - _D_ collects/games/jewel/jewel.scmhttps://github.com/plt/racket/pull/363/files#diff-179(1829)
> - _A_ collects/games/jewel/shapes.rkthttps://github.com/plt/racket/pull/363/files#diff-180(658)
> - _D_ collects/games/jewel/shapes.scmhttps://github.com/plt/racket/pull/363/files#diff-181(748)
> - _A_ collects/games/jewel/text.rkthttps://github.com/plt/racket/pull/363/files#diff-182(186)
> - _D_ collects/games/jewel/text.scmhttps://github.com/plt/racket/pull/363/files#diff-183(230)
> - _M_ collects/games/lights-out/board.rkthttps://github.com/plt/racket/pull/363/files#diff-184(7)
> - _M_ collects/games/lights-out/lights-out.rkthttps://github.com/plt/racket/pull/363/files#diff-185(8)
> - _M_ collects/games/main.rkthttps://github.com/plt/racket/pull/363/files#diff-186(2)
> - _M_ collects/games/memory/memory.rkthttps://github.com/plt/racket/pull/363/files#diff-187(4)
> - _M_ collects/games/mines/gen-tiles.rkthttps://github.com/plt/racket/pull/363/files#diff-188(7)
> - _M_ collects/games/mines/images/bomb.pnghttps://github.com/plt/racket/pull/363/files#diff-189(0)
> - _M_ collects/games/mines/images/explode.pnghttps://github.com/plt/racket/pull/363/files#diff-190(0)
> - _M_ collects/games/mines/images/flag.pnghttps://github.com/plt/racket/pull/363/files#diff-191(0)
> - _M_ collects/games/mines/images/lclick-tile.pnghttps://github.com/plt/racket/pull/363/files#diff-192(0)
> - _M_ collects/games/mines/images/local-tile.pnghttps://github.com/plt/racket/pull/363/files#diff-193(0)
> - _M_ collects/games/mines/images/near-tile.pnghttps://github.com/plt/racket/pull/363/files#diff-194(0)
> - _M_ collects/games/mines/images/rclick-tile.pnghttps://github.com/plt/racket/pull/363/files#diff-195(0)
> - _M_ collects/games/mines/images/tile.pnghttps://github.com/plt/racket/pull/363/files#diff-196(0)
> - _M_ collects/games/mines/mines.rkthttps://github.com/plt/racket/pull/363/files#diff-197(11)
> - _M_ collects/games/paint-by-numbers/all-problems.rkthttps://github.com/plt/racket/pull/363/files#diff-198(8)
> - _M_ collects/games/paint-by-numbers/gui.rkthttps://github.com/plt/racket/pull/363/files#diff-199(5)
> - _M_ collects/games/paint-by-numbers/main.rkthttps://github.com/plt/racket/pull/363/files#diff-200(2)
> - _M_ collects/games/paint-by-numbers/paint-by-numbers.rkthttps://github.com/plt/racket/pull/363/files#diff-201(6)
> - _M_ collects/games/paint-by-numbers/problem.rkthttps://github.com/plt/racket/pull/363/files#diff-202(6)
> - _M_ collects/games/paint-by-numbers/raw-problems/build-final.rkthttps://github.com/plt/racket/pull/363/files#diff-203(4)
> - _M_ collects/games/paint-by-numbers/raw-problems/build-hattori.rkthttps://github.com/plt/racket/pull/363/files#diff-204(8)
> - _M_ collects/games/paint-by-numbers/raw-problems/build-rows-cols.rkthttps://github.com/plt/racket/pull/363/files#diff-205(6)
> - _M_
>   collects/games/paint-by-numbers/raw-problems/build-solution-sets.rkthttps://github.com/plt/racket/pull/363/files#diff-206(11)
> - _M_ collects/games/paint-by-numbers/solve.rkthttps://github.com/plt/racket/pull/363/files#diff-207(17)
> - _M_ collects/games/parcheesi/admin-gui.rkthttps://github.com/plt/racket/pull/363/files#diff-208(24)
> - _M_ collects/games/parcheesi/admin.rkthttps://github.com/plt/racket/pull/363/files#diff-209(5)
> - _M_ collects/games/parcheesi/best-players.rkthttps://github.com/plt/racket/pull/363/files#diff-210(24)
> - _M_ collects/games/parcheesi/board.rkthttps://github.com/plt/racket/pull/363/files#diff-211(29)
> - _M_ collects/games/parcheesi/die.rkthttps://github.com/plt/racket/pull/363/files#diff-212(6)
> - _M_ collects/games/parcheesi/gui.rkthttps://github.com/plt/racket/pull/363/files#diff-213(27)
> - _M_ collects/games/parcheesi/interfaces.rkthttps://github.com/plt/racket/pull/363/files#diff-214(6)
> - _M_ collects/games/parcheesi/make-bitmap.rkthttps://github.com/plt/racket/pull/363/files#diff-215(27)
> - _M_ collects/games/parcheesi/moves.rkthttps://github.com/plt/racket/pull/363/files#diff-216(14)
> - _M_ collects/games/parcheesi/parcheesi.rkthttps://github.com/plt/racket/pull/363/files#diff-217(6)
> - _M_ collects/games/parcheesi/play-game.rkthttps://github.com/plt/racket/pull/363/files#diff-218(8)
> - _M_ collects/games/parcheesi/rules.rkthttps://github.com/plt/racket/pull/363/files#diff-219(12)
> - _M_ collects/games/parcheesi/test.rkthttps://github.com/plt/racket/pull/363/files#diff-220(4)
> - _M_ collects/games/pousse/board-size.rkthttps://github.com/plt/racket/pull/363/files#diff-221(2)
> - _M_ collects/games/pousse/board.rkthttps://github.com/plt/racket/pull/363/files#diff-222(4)
> - _M_ collects/games/pousse/counter.rkthttps://github.com/plt/racket/pull/363/files#diff-223(2)
> - _M_ collects/games/pousse/pousse.rkthttps://github.com/plt/racket/pull/363/files#diff-224(4)
> - _M_ collects/games/pousse/robot.rkthttps://github.com/plt/racket/pull/363/files#diff-225(2)
> - _M_ collects/games/pousse/robots.txthttps://github.com/plt/racket/pull/363/files#diff-226(2)
> - _M_ collects/games/pousse/utils.rkthttps://github.com/plt/racket/pull/363/files#diff-227(2)
> - _M_ collects/games/same/same.rkthttps://github.com/plt/racket/pull/363/files#diff-228(2)
> - _M_ collects/games/scribblings/aces.scrblhttps://github.com/plt/racket/pull/363/files#diff-229(2)
> - _M_ collects/games/scribblings/jewel.scrblhttps://github.com/plt/racket/pull/363/files#diff-230(2)
> - _M_ collects/games/scribblings/same.scrblhttps://github.com/plt/racket/pull/363/files#diff-231(2)
> - _M_ collects/games/scribblings/std-games.scrblhttps://github.com/plt/racket/pull/363/files#diff-232(1)
> - _A_ collects/games/scribblings/tally-maze.scrblhttps://github.com/plt/racket/pull/363/files#diff-233(50)
> - _M_ collects/games/show-help.rkthttps://github.com/plt/racket/pull/363/files#diff-234(8)
> - _M_ collects/games/show-scribbling.rkthttps://github.com/plt/racket/pull/363/files#diff-235(4)
> - _M_ collects/games/slidey/slidey.rkthttps://github.com/plt/racket/pull/363/files#diff-236(7)
> - _M_ collects/games/spider/spider.rkthttps://github.com/plt/racket/pull/363/files#diff-237(6)
> - _A_ collects/games/tally-maze/game.rkthttps://github.com/plt/racket/pull/363/files#diff-238(281)
> - _A_ collects/games/tally-maze/godel.rkthttps://github.com/plt/racket/pull/363/files#diff-239(738)
> - _A_ collects/games/tally-maze/images/pumpkin/pumpkin-48x48.pnghttps://github.com/plt/racket/pull/363/files#diff-240(0)
> - _A_ collects/games/tally-maze/images/pumpkin/pumpkin-64x64.pnghttps://github.com/plt/racket/pull/363/files#diff-241(0)
> - _A_ collects/games/tally-maze/images/very-emotional/01.pnghttps://github.com/plt/racket/pull/363/files#diff-242(0)
> - _A_ collects/games/tally-maze/images/very-emotional/19.pnghttps://github.com/plt/racket/pull/363/files#diff-243(0)
> - _A_ collects/games/tally-maze/images/very-emotional/20.pnghttps://github.com/plt/racket/pull/363/files#diff-244(0)
> - _A_ collects/games/tally-maze/images/very-emotional/21.pnghttps://github.com/plt/racket/pull/363/files#diff-245(0)
> - _A_ collects/games/tally-maze/images/very-emotional/35.pnghttps://github.com/plt/racket/pull/363/files#diff-246(0)
> - _A_ collects/games/tally-maze/images/very-emotional/36.pnghttps://github.com/plt/racket/pull/363/files#diff-247(0)
> - _A_ collects/games/tally-maze/images/very-emotional/37.pnghttps://github.com/plt/racket/pull/363/files#diff-248(0)
> - _A_ collects/games/tally-maze/info.rkthttps://github.com/plt/racket/pull/363/files#diff-249(4)
> - _A_ collects/games/tally-maze/maze.rkthttps://github.com/plt/racket/pull/363/files#diff-250(472)
> - _A_ collects/games/tally-maze/tally-maze.pnghttps://github.com/plt/racket/pull/363/files#diff-251(0)
> - _M_ collects/gui-debugger/debug-tool.rkthttps://github.com/plt/racket/pull/363/files#diff-252(18)
> - _D_ collects/handin-client/client-gui.rkthttps://github.com/plt/racket/pull/363/files#diff-253(815)
> - _D_ collects/handin-client/client.rkthttps://github.com/plt/racket/pull/363/files#diff-254(171)
> - _D_ collects/handin-client/handin-multi.rkthttps://github.com/plt/racket/pull/363/files#diff-255(276)
> - _D_ collects/handin-client/icon.pnghttps://github.com/plt/racket/pull/363/files#diff-256(0)
> - _D_ collects/handin-client/info.rkthttps://github.com/plt/racket/pull/363/files#diff-257(41)
> - _D_ collects/handin-client/server-cert.pemhttps://github.com/plt/racket/pull/363/files#diff-258(20)
> - _D_ collects/handin-client/this-collection.rkthttps://github.com/plt/racket/pull/363/files#diff-259(34)
> - _D_ collects/handin-client/updater.rkthttps://github.com/plt/racket/pull/363/files#diff-260(72)
> - _D_ collects/handin-server/checker.rkthttps://github.com/plt/racket/pull/363/files#diff-261(771)
> - _D_ collects/handin-server/info.rkthttps://github.com/plt/racket/pull/363/files#diff-262(3)
> - _D_ collects/handin-server/main.rkthttps://github.com/plt/racket/pull/363/files#diff-263(726)
> - _D_ collects/handin-server/overridden-collects/readme.txthttps://github.com/plt/racket/pull/363/files#diff-264(6)
> - _D_
>   collects/handin-server/overridden-collects/teachpack/htdp/guess.rkthttps://github.com/plt/racket/pull/363/files#diff-265(28)
> - _D_
>   collects/handin-server/overridden-collects/teachpack/htdp/master.rkthttps://github.com/plt/racket/pull/363/files#diff-266(11)
> - _D_ collects/handin-server/private-key.pemhttps://github.com/plt/racket/pull/363/files#diff-267(15)
> - _D_ collects/handin-server/private/config.rkthttps://github.com/plt/racket/pull/363/files#diff-268(131)
> - _D_ collects/handin-server/private/hooker.rkthttps://github.com/plt/racket/pull/363/files#diff-269(17)
> - _D_ collects/handin-server/private/lock.rkthttps://github.com/plt/racket/pull/363/files#diff-270(64)
> - _D_ collects/handin-server/private/logger.rkthttps://github.com/plt/racket/pull/363/files#diff-271(68)
> - _D_ collects/handin-server/private/md5.rkthttps://github.com/plt/racket/pull/363/files#diff-272(5)
> - _D_ collects/handin-server/private/reloadable.rkthttps://github.com/plt/racket/pull/363/files#diff-273(58)
> - _D_ collects/handin-server/private/run-status.rkthttps://github.com/plt/racket/pull/363/files#diff-274(19)
> - _D_ collects/handin-server/run-servlet.rkthttps://github.com/plt/racket/pull/363/files#diff-275(115)
> - _D_ collects/handin-server/sandbox.rkthttps://github.com/plt/racket/pull/363/files#diff-276(26)
> - _D_ collects/handin-server/scribblings/checker-utils.scrblhttps://github.com/plt/racket/pull/363/files#diff-277(34)
> - _D_ collects/handin-server/scribblings/checker.scrblhttps://github.com/plt/racket/pull/363/files#diff-278(411)
> - _D_ collects/handin-server/scribblings/client-customization.scrblhttps://github.com/plt/racket/pull/363/files#diff-279(80)
> - _D_ collects/handin-server/scribblings/common.rkthttps://github.com/plt/racket/pull/363/files#diff-280(19)
> - _D_ collects/handin-server/scribblings/handin-server.scrblhttps://github.com/plt/racket/pull/363/files#diff-281(24)
> - _D_ collects/handin-server/scribblings/hook-dummy.rkthttps://github.com/plt/racket/pull/363/files#diff-282(6)
> - _D_ collects/handin-server/scribblings/info.rkthttps://github.com/plt/racket/pull/363/files#diff-283(3)
> - _D_ collects/handin-server/scribblings/multifile.scrblhttps://github.com/plt/racket/pull/363/files#diff-284(62)
> - _D_ collects/handin-server/scribblings/other-utils.scrblhttps://github.com/plt/racket/pull/363/files#diff-285(10)
> - _D_ collects/handin-server/scribblings/quick-start.scrblhttps://github.com/plt/racket/pull/363/files#diff-286(52)
> - _D_ collects/handin-server/scribblings/sandbox.scrblhttps://github.com/plt/racket/pull/363/files#diff-287(9)
> - _D_ collects/handin-server/scribblings/server-client.scrblhttps://github.com/plt/racket/pull/363/files#diff-288(36)
> - _D_ collects/handin-server/scribblings/server-setup.scrblhttps://github.com/plt/racket/pull/363/files#diff-289(490)
> - _D_ collects/handin-server/scribblings/updater.scrblhttps://github.com/plt/racket/pull/363/files#diff-290(34)
> - _D_ collects/handin-server/scribblings/utils.scrblhttps://github.com/plt/racket/pull/363/files#diff-291(213)
> - _D_ collects/handin-server/scribblings/wheres-the-collection.scrblhttps://github.com/plt/racket/pull/363/files#diff-292(11)
> - _D_ collects/handin-server/utils.rkthttps://github.com/plt/racket/pull/363/files#diff-293(185)
> - _D_ collects/handin-server/web-status-server.rkthttps://github.com/plt/racket/pull/363/files#diff-294(355)
> - _M_ collects/help/bug-report.rkthttps://github.com/plt/racket/pull/363/files#diff-295(121)
> - _M_ collects/help/private/bug-report-controls.rkthttps://github.com/plt/racket/pull/363/files#diff-296(18)
> - _M_ collects/honu/core/main.rkthttps://github.com/plt/racket/pull/363/files#diff-297(1)
> - _M_ collects/honu/core/private/extra.rkthttps://github.com/plt/racket/pull/363/files#diff-298(3)
> - _M_ collects/honu/core/private/honu2.rkthttps://github.com/plt/racket/pull/363/files#diff-299(35)
> - _M_ collects/honu/core/private/macro2.rkthttps://github.com/plt/racket/pull/363/files#diff-300(21)
> - _M_ collects/honu/core/private/parse2.rkthttps://github.com/plt/racket/pull/363/files#diff-301(469)
> - _M_ collects/honu/core/private/template.rkthttps://github.com/plt/racket/pull/363/files#diff-302(5)
> - _M_ collects/honu/core/read.rkthttps://github.com/plt/racket/pull/363/files#diff-303(2)
> - _M_ collects/honu/main.rkthttps://github.com/plt/racket/pull/363/files#diff-304(2)
> - _M_ collects/honu/private/common.rkthttps://github.com/plt/racket/pull/363/files#diff-305(9)
> - _M_ collects/honu/private/with.honuhttps://github.com/plt/racket/pull/363/files#diff-306(2)
> - _R_ collects/icons/r-logo-glass-256x256.pnghttps://github.com/plt/racket/pull/363/files#diff-307(0)
> - _R_ collects/icons/r-logo-plastic-256x256.pnghttps://github.com/plt/racket/pull/363/files#diff-308(0)
> - _M_ collects/images/private/flomap.rkthttps://github.com/plt/racket/pull/363/files#diff-309(2)
> - _M_ collects/images/scribblings/flomap.scrblhttps://github.com/plt/racket/pull/363/files#diff-310(4)
> - _M_ collects/images/scribblings/icons.scrblhttps://github.com/plt/racket/pull/363/files#diff-311(6)
> - _A_ collects/images/tests/other-tests.rkthttps://github.com/plt/racket/pull/363/files#diff-312(20)
> - _M_ collects/json/main.rkthttps://github.com/plt/racket/pull/363/files#diff-313(4)
> - _M_ collects/lang/private/provide-and-scribble.rkthttps://github.com/plt/racket/pull/363/files#diff-314(2)
> - _M_ collects/lang/private/signature-syntax.rkthttps://github.com/plt/racket/pull/363/files#diff-315(6)
> - _M_ collects/lang/private/teachprims.rkthttps://github.com/plt/racket/pull/363/files#diff-316(3)
> - _M_ collects/launcher/launcher-unit.rkthttps://github.com/plt/racket/pull/363/files#diff-317(33)
> - _M_ collects/macro-debugger/analysis/check-requires.rkthttps://github.com/plt/racket/pull/363/files#diff-318(7)
> - _M_ collects/macro-debugger/analysis/private/nom-use-alg.rkthttps://github.com/plt/racket/pull/363/files#diff-319(2)
> - _M_ collects/macro-debugger/analysis/private/util.rkthttps://github.com/plt/racket/pull/363/files#diff-320(76)
> - _M_ collects/macro-debugger/analysis/show-dependencies.rkthttps://github.com/plt/racket/pull/363/files#diff-321(82)
> - _M_ collects/macro-debugger/info.rkthttps://github.com/plt/racket/pull/363/files#diff-322(10)
> - _M_ collects/macro-debugger/macro-debugger.scrblhttps://github.com/plt/racket/pull/363/files#diff-323(17)
> - _M_ collects/macro-debugger/model/deriv-parser.rkthttps://github.com/plt/racket/pull/363/files#diff-324(2)
> - _M_ collects/macro-debugger/syntax-browser/display.rkthttps://github.com/plt/racket/pull/363/files#diff-325(14)
> - _M_ collects/macro-debugger/syntax-browser/widget.rkthttps://github.com/plt/racket/pull/363/files#diff-326(36)
> - _M_ collects/macro-debugger/tool.rkthttps://github.com/plt/racket/pull/363/files#diff-327(3)
> - _M_ collects/macro-debugger/view/frame.rkthttps://github.com/plt/racket/pull/363/files#diff-328(7)
> - _M_ collects/macro-debugger/view/term-record.rkthttps://github.com/plt/racket/pull/363/files#diff-329(2)
> - _M_ collects/math/LICENSE.txthttps://github.com/plt/racket/pull/363/files#diff-330(18)
> - _M_ collects/math/matrix.rkthttps://github.com/plt/racket/pull/363/files#diff-331(2)
> - _M_ collects/math/private/array/array-indexing.rkthttps://github.com/plt/racket/pull/363/files#diff-332(4)
> - _M_ collects/math/private/array/array-struct.rkthttps://github.com/plt/racket/pull/363/files#diff-333(2)
> - _M_ collects/math/private/array/mutable-array.rkthttps://github.com/plt/racket/pull/363/files#diff-334(2)
> - _M_ collects/math/private/array/typed-array-pointwise.rkthttps://github.com/plt/racket/pull/363/files#diff-335(4)
> - _M_ collects/math/private/distributions/exponential-dist.rkthttps://github.com/plt/racket/pull/363/files#diff-336(2)
> - _M_ collects/math/private/matrix/typed-matrix-arithmetic.rkthttps://github.com/plt/racket/pull/363/files#diff-337(2)
> - _M_ collects/math/private/number-theory/number-theory.rkthttps://github.com/plt/racket/pull/363/files#diff-338(2)
> - _M_ collects/math/private/unsafe.rkthttps://github.com/plt/racket/pull/363/files#diff-339(2)
> - _M_ collects/math/scribblings/math-array.scrblhttps://github.com/plt/racket/pull/363/files#diff-340(2)
> - _M_ collects/math/scribblings/math-distributions.scrblhttps://github.com/plt/racket/pull/363/files#diff-341(3)
> - _M_ collects/math/scribblings/math-flonum.scrblhttps://github.com/plt/racket/pull/363/files#diff-342(90)
> - _M_ collects/math/scribblings/math-matrix.scrblhttps://github.com/plt/racket/pull/363/files#diff-343(2)
> - _M_ collects/math/scribblings/math-statistics.scrblhttps://github.com/plt/racket/pull/363/files#diff-344(3)
> - _M_ collects/meta/build/nsis/installer.nsihttps://github.com/plt/racket/pull/363/files#diff-345(2)
> - _M_ collects/meta/build/unix-installer/paths-configure-snapshothttps://github.com/plt/racket/pull/363/files#diff-346(2)
> - _M_ collects/meta/build/unix-installer/test-installerhttps://github.com/plt/racket/pull/363/files#diff-347(2)
> - _M_ collects/meta/contrib/completion/racket-completion.bashhttps://github.com/plt/racket/pull/363/files#diff-348(4)
> - _M_ collects/meta/contrib/completion/racket-completion.zshhttps://github.com/plt/racket/pull/363/files#diff-349(23)
> - _M_ collects/meta/dist-specs.rkthttps://github.com/plt/racket/pull/363/files#diff-350(25)
> - _M_ collects/meta/drdr/analyze.rkthttps://github.com/plt/racket/pull/363/files#diff-351(14)
> - _M_ collects/meta/drdr/run-collect.rkthttps://github.com/plt/racket/pull/363/files#diff-352(5)
> - _R_ collects/meta/pkg-index/basic/main.rkthttps://github.com/plt/racket/pull/363/files#diff-353(9)
> - _A_ collects/meta/pkg-index/info.rkthttps://github.com/plt/racket/pull/363/files#diff-354(4)
> - _R_ collects/meta/pkg-index/official/.gitignorehttps://github.com/plt/racket/pull/363/files#diff-355(0)
> - _R_ collects/meta/pkg-index/official/gravatar.rkthttps://github.com/plt/racket/pull/363/files#diff-356(2)
> - _R_ collects/meta/pkg-index/official/main.rkthttps://github.com/plt/racket/pull/363/files#diff-357(346)
> - _R_ collects/meta/pkg-index/official/static/sorttable.jshttps://github.com/plt/racket/pull/363/files#diff-358(0)
> - _R_ collects/meta/pkg-index/official/static/style.csshttps://github.com/plt/racket/pull/363/files#diff-359(10)
> - _R_ collects/meta/pkg-index/planet-compat/.gitignorehttps://github.com/plt/racket/pull/363/files#diff-360(0)
> - _R_ collects/meta/pkg-index/planet-compat/info.rkthttps://github.com/plt/racket/pull/363/files#diff-361(0)
> - _R_ collects/meta/pkg-index/planet-compat/main.rkthttps://github.com/plt/racket/pull/363/files#diff-362(6)
> - _A_ collects/meta/pkg-index/sync.shhttps://github.com/plt/racket/pull/363/files#diff-363(13)
> - _D_ collects/meta/planet2-index/sync.shhttps://github.com/plt/racket/pull/363/files#diff-364(11)
> - _M_ collects/meta/propshttps://github.com/plt/racket/pull/363/files#diff-365(111)
> - _M_ collects/meta/web/all.rkthttps://github.com/plt/racket/pull/363/files#diff-366(2)
> - _M_ collects/meta/web/common/distribute.rkthttps://github.com/plt/racket/pull/363/files#diff-367(14)
> - _M_ collects/meta/web/common/layout.rkthttps://github.com/plt/racket/pull/363/files#diff-368(2)
> - _M_ collects/meta/web/common/links.rkthttps://github.com/plt/racket/pull/363/files#diff-369(29)
> - _M_ collects/meta/web/config.rkthttps://github.com/plt/racket/pull/363/files#diff-370(9)
> - _M_ collects/meta/web/download/download-pages.rkthttps://github.com/plt/racket/pull/363/files#diff-371(55)
> - _M_ collects/meta/web/download/index.rkthttps://github.com/plt/racket/pull/363/files#diff-372(10)
> - _M_ collects/meta/web/download/installers.txthttps://github.com/plt/racket/pull/363/files#diff-373(48)
> - _A_ collects/meta/web/download/symlinks.rkthttps://github.com/plt/racket/pull/363/files#diff-374(13)
> - _M_ collects/meta/web/stubs/all.rkthttps://github.com/plt/racket/pull/363/files#diff-375(5)
> - _A_ collects/meta/web/stubs/docs.rkthttps://github.com/plt/racket/pull/363/files#diff-376(11)
> - _M_ collects/meta/web/stubs/git.rkthttps://github.com/plt/racket/pull/363/files#diff-377(10)
> - _M_ collects/meta/web/stubs/pre.rkthttps://github.com/plt/racket/pull/363/files#diff-378(13)
> - _M_ collects/meta/web/www/community.rkthttps://github.com/plt/racket/pull/363/files#diff-379(7)
> - _M_ collects/meta/web/www/learning.rkthttps://github.com/plt/racket/pull/363/files#diff-380(2)
> - _M_ collects/meta/web/www/old-techreports.rkthttps://github.com/plt/racket/pull/363/files#diff-381(2)
> - _M_ collects/mred/private/check.rkthttps://github.com/plt/racket/pull/363/files#diff-382(1)
> - _M_ collects/mred/private/mrcanvas.rkthttps://github.com/plt/racket/pull/363/files#diff-383(5)
> - _M_ collects/mred/private/mritem.rkthttps://github.com/plt/racket/pull/363/files#diff-384(2)
> - _M_ collects/mred/private/mrwindow.rkthttps://github.com/plt/racket/pull/363/files#diff-385(21)
> - _M_ collects/mred/private/wx/cocoa/agl.rkthttps://github.com/plt/racket/pull/363/files#diff-386(11)
> - _M_ collects/mred/private/wx/cocoa/button.rkthttps://github.com/plt/racket/pull/363/files#diff-387(6)
> - _M_ collects/mred/private/wx/cocoa/canvas.rkthttps://github.com/plt/racket/pull/363/files#diff-388(65)
> - _M_ collects/mred/private/wx/cocoa/dc.rkthttps://github.com/plt/racket/pull/363/files#diff-389(1)
> - _M_ collects/mred/private/wx/cocoa/frame.rkthttps://github.com/plt/racket/pull/363/files#diff-390(4)
> - _M_ collects/mred/private/wx/cocoa/list-box.rkthttps://github.com/plt/racket/pull/363/files#diff-391(28)
> - _M_ collects/mred/private/wx/cocoa/menu-bar.rkthttps://github.com/plt/racket/pull/363/files#diff-392(8)
> - _M_ collects/mred/private/wx/cocoa/panel.rkthttps://github.com/plt/racket/pull/363/files#diff-393(3)
> - _M_ collects/mred/private/wx/cocoa/window.rkthttps://github.com/plt/racket/pull/363/files#diff-394(12)
> - _M_ collects/mred/private/wx/common/canvas-mixin.rkthttps://github.com/plt/racket/pull/363/files#diff-395(10)
> - _M_ collects/mred/private/wx/gtk/button.rkthttps://github.com/plt/racket/pull/363/files#diff-396(4)
> - _M_ collects/mred/private/wx/gtk/canvas.rkthttps://github.com/plt/racket/pull/363/files#diff-397(3)
> - _M_ collects/mred/private/wx/gtk/frame.rkthttps://github.com/plt/racket/pull/363/files#diff-398(20)
> - _M_ collects/mred/private/wx/gtk/gl-context.rkthttps://github.com/plt/racket/pull/363/files#diff-399(30)
> - _M_ collects/mred/private/wx/gtk/list-box.rkthttps://github.com/plt/racket/pull/363/files#diff-400(1)
> - _M_ collects/mred/private/wx/gtk/window.rkthttps://github.com/plt/racket/pull/363/files#diff-401(124)
> - _M_ collects/mred/private/wx/win32/canvas.rkthttps://github.com/plt/racket/pull/363/files#diff-402(3)
> - _M_ collects/mred/private/wx/win32/gl-context.rkthttps://github.com/plt/racket/pull/363/files#diff-403(73)
> - _M_ collects/mred/private/wx/win32/window.rkthttps://github.com/plt/racket/pull/363/files#diff-404(16)
> - _M_ collects/mred/private/wxme/editor-canvas.rkthttps://github.com/plt/racket/pull/363/files#diff-405(43)
> - _M_ collects/mred/private/wxme/text.rkthttps://github.com/plt/racket/pull/363/files#diff-406(192)
> - _M_ collects/mrlib/gif.rkthttps://github.com/plt/racket/pull/363/files#diff-407(179)
> - _M_ collects/mrlib/image-core.rkthttps://github.com/plt/racket/pull/363/files#diff-408(4)
> - _M_ collects/mrlib/scribblings/gif.scrblhttps://github.com/plt/racket/pull/363/files#diff-409(6)
> - _M_ collects/mrlib/scribblings/mrlib.scrblhttps://github.com/plt/racket/pull/363/files#diff-410(1)
> - _M_ collects/mrlib/scribblings/path-dialog.scrblhttps://github.com/plt/racket/pull/363/files#diff-411(2)
> - _A_ collects/mrlib/scribblings/terminal.scrblhttps://github.com/plt/racket/pull/363/files#diff-412(99)
> - _M_ collects/mrlib/switchable-button.rkthttps://github.com/plt/racket/pull/363/files#diff-413(5)
> - _M_ collects/mrlib/syntax-browser.rkthttps://github.com/plt/racket/pull/363/files#diff-414(44)
> - _A_ collects/mrlib/terminal.rkthttps://github.com/plt/racket/pull/363/files#diff-415(253)
> - _M_ collects/mrlib/tex-table.rkthttps://github.com/plt/racket/pull/363/files#diff-416(8)
> - _M_ collects/mysterx/mysterx.rkthttps://github.com/plt/racket/pull/363/files#diff-417(8)
> - _M_ collects/mysterx/scribblings/methprop.scrblhttps://github.com/plt/racket/pull/363/files#diff-418(24)
> - _M_ collects/mzlib/include.rkthttps://github.com/plt/racket/pull/363/files#diff-419(12)
> - _M_ collects/mzlib/scribblings/pconvert.scrblhttps://github.com/plt/racket/pull/363/files#diff-420(8)
> - _M_ collects/net/cookie.rkthttps://github.com/plt/racket/pull/363/files#diff-421(18)
> - _M_ collects/net/dns.rkthttps://github.com/plt/racket/pull/363/files#diff-422(495)
> - _M_ collects/net/ftp.rkthttps://github.com/plt/racket/pull/363/files#diff-423(6)
> - _M_ collects/net/imap.rkthttps://github.com/plt/racket/pull/363/files#diff-424(37)
> - _A_ collects/net/private/ip.rkthttps://github.com/plt/racket/pull/363/files#diff-425(219)
> - _M_ collects/net/scribblings/cookie.scrblhttps://github.com/plt/racket/pull/363/files#diff-426(6)
> - _M_ collects/net/scribblings/dns.scrblhttps://github.com/plt/racket/pull/363/files#diff-427(10)
> - _M_ collects/net/scribblings/ftp.scrblhttps://github.com/plt/racket/pull/363/files#diff-428(2)
> - _M_ collects/net/scribblings/head.scrblhttps://github.com/plt/racket/pull/363/files#diff-429(6)
> - _M_ collects/net/scribblings/imap.scrblhttps://github.com/plt/racket/pull/363/files#diff-430(23)
> - _M_ collects/net/scribblings/url.scrblhttps://github.com/plt/racket/pull/363/files#diff-431(44)
> - _M_ collects/net/uri-codec.rkthttps://github.com/plt/racket/pull/363/files#diff-432(256)
> - _M_ collects/net/url.rkthttps://github.com/plt/racket/pull/363/files#diff-433(209)
> - _M_ collects/openssl/libcrypto.rkthttps://github.com/plt/racket/pull/363/files#diff-434(7)
> - _M_ collects/openssl/mzssl.rkthttps://github.com/plt/racket/pull/363/files#diff-435(4)
> - _M_ collects/openssl/openssl.scrblhttps://github.com/plt/racket/pull/363/files#diff-436(4)
> - _M_ collects/parser-tools/parser-tools.scrblhttps://github.com/plt/racket/pull/363/files#diff-437(6)
> - _M_ collects/parser-tools/private-yacc/input-file-parser.rkthttps://github.com/plt/racket/pull/363/files#diff-438(10)
> - _M_ collects/parser-tools/private-yacc/lr0.rkthttps://github.com/plt/racket/pull/363/files#diff-439(8)
> - _M_ collects/parser-tools/private-yacc/parser-builder.rkthttps://github.com/plt/racket/pull/363/files#diff-440(5)
> - _M_ collects/parser-tools/yacc.rkthttps://github.com/plt/racket/pull/363/files#diff-441(16)
> - _A_ collects/pict/balloon.rkthttps://github.com/plt/racket/pull/363/files#diff-442(5)
> - _A_ collects/pict/code.rkthttps://github.com/plt/racket/pull/363/files#diff-443(126)
> - _A_ collects/pict/convert.rkthttps://github.com/plt/racket/pull/363/files#diff-444(9)
> - _A_ collects/pict/face.rkthttps://github.com/plt/racket/pull/363/files#diff-445(3)
> - _A_ collects/pict/flash.rkthttps://github.com/plt/racket/pull/363/files#diff-446(4)
> - _A_ collects/pict/info.rkthttps://github.com/plt/racket/pull/363/files#diff-447(4)
> - _A_ collects/pict/main.rkthttps://github.com/plt/racket/pull/363/files#diff-448(288)
> - _A_ collects/pict/scribblings/code.scrblhttps://github.com/plt/racket/pull/363/files#diff-449(394)
> - _A_ collects/pict/scribblings/more.scrblhttps://github.com/plt/racket/pull/363/files#diff-450(431)
> - _R_ collects/pict/scribblings/pict-diagram.rkthttps://github.com/plt/racket/pull/363/files#diff-451(2)
> - _R_ collects/pict/scribblings/pict.scrblhttps://github.com/plt/racket/pull/363/files#diff-452(458)
> - _M_ collects/picturing-programs/main.rkthttps://github.com/plt/racket/pull/363/files#diff-453(2)
> - _M_ collects/picturing-programs/private/map-image.rkthttps://github.com/plt/racket/pull/363/files#diff-454(339)
> - _M_ collects/picturing-programs/private/tiles.rkthttps://github.com/plt/racket/pull/363/files#diff-455(42)
> - _M_ collects/picturing-programs/tests/map-image-bsl-tests.rkthttps://github.com/plt/racket/pull/363/files#diff-456(36)
> - _D_ collects/picturing-programs/tests/tiles-error-tests.rkthttps://github.com/plt/racket/pull/363/files#diff-457(37)
> - _R_ collects/pkg/.gitignorehttps://github.com/plt/racket/pull/363/files#diff-458(0)
> - _R_ collects/pkg/commands.rkthttps://github.com/plt/racket/pull/363/files#diff-459(0)
> - _A_ collects/pkg/db.rkthttps://github.com/plt/racket/pull/363/files#diff-460(661)
> - _A_ collects/pkg/gui/by-installed.rkthttps://github.com/plt/racket/pull/363/files#diff-461(169)
> - _A_ collects/pkg/gui/by-list.rkthttps://github.com/plt/racket/pull/363/files#diff-462(509)
> - _A_ collects/pkg/gui/by-source.rkthttps://github.com/plt/racket/pull/363/files#diff-463(400)
> - _A_ collects/pkg/gui/common.rkthttps://github.com/plt/racket/pull/363/files#diff-464(32)
> - _A_ collects/pkg/gui/main.rkthttps://github.com/plt/racket/pull/363/files#diff-465(163)
> - _A_ collects/pkg/info.rkthttps://github.com/plt/racket/pull/363/files#diff-466(6)
> - _A_ collects/pkg/lib.rkthttps://github.com/plt/racket/pull/363/files#diff-467(2096)
> - _R_ collects/pkg/main.rkthttps://github.com/plt/racket/pull/363/files#diff-468(191)
> - _R_ collects/pkg/name.rkthttps://github.com/plt/racket/pull/363/files#diff-469(26)
> - _R_ collects/pkg/raco.rkthttps://github.com/plt/racket/pull/363/files#diff-470(0)
> - _A_ collects/pkg/scribblings/apis.scrblhttps://github.com/plt/racket/pull/363/files#diff-471(17)
> - _A_ collects/pkg/scribblings/catalog-protocol.scrblhttps://github.com/plt/racket/pull/363/files#diff-472(196)
> - _A_ collects/pkg/scribblings/common.rkthttps://github.com/plt/racket/pull/363/files#diff-473(15)
> - _A_ collects/pkg/scribblings/db.scrblhttps://github.com/plt/racket/pull/363/files#diff-474(171)
> - _A_ collects/pkg/scribblings/lib.scrblhttps://github.com/plt/racket/pull/363/files#diff-475(325)
> - _R_ collects/pkg/scribblings/pkg.scrblhttps://github.com/plt/racket/pull/363/files#diff-476(379)
> - _A_ collects/pkg/scribblings/strip.scrblhttps://github.com/plt/racket/pull/363/files#diff-477(161)
> - _A_ collects/pkg/strip.rkthttps://github.com/plt/racket/pull/363/files#diff-478(224)
> - _A_ collects/pkg/util.rkthttps://github.com/plt/racket/pull/363/files#diff-479(138)
> - _M_ collects/plai/datatype.rkthttps://github.com/plt/racket/pull/363/files#diff-480(64)
> - _M_ collects/plai/gc2/collector.rkthttps://github.com/plt/racket/pull/363/files#diff-481(4)
> - _M_ collects/plai/gc2/mutator.rkthttps://github.com/plt/racket/pull/363/files#diff-482(297)
> - _M_ collects/plai/gc2/private/collector-exports.rkthttps://github.com/plt/racket/pull/363/files#diff-483(10)
> - _M_ collects/plai/gc2/private/gc-core.rkthttps://github.com/plt/racket/pull/363/files#diff-484(70)
> - _M_ collects/plai/gc2/private/gc-transformer.rkthttps://github.com/plt/racket/pull/363/files#diff-485(49)

I don't think this looks right.

First thing: if you're going to add something to the pattern language, then
match-a-pattern needs to change to force everything else to change; that's
it's job.

But this, it seems to me, should instead be implemented in
rewrite-side-conditions to just avoid putting a 'name' pattern in and you
don't need to change the core pattern language.

Robby

Hi: here are the problems I see with this commit.
- there are no test cases in this commit.
- there is no documentation
- one of the diff hunks appears to be just changing the whitespace
  (please only include changes that actually change something so that git
  blame and other such things are more useful).

Robby

On Fri, Jun 7, 2013 at 1:55 AM, Philip Nguyen notifications@github.comwrote:

> ---
> 
> You can merge this Pull Request by running
> 
>   git pull https://github.com/philnguyen/racket master
> 
> Or view, comment on, or merge it at:
> 
>   https://github.com/plt/racket/pull/364
> Commit Summary
> - add wildcard
> 
> File Changes
> - _M_ collects/redex/private/rewrite-side-conditions.rkthttps://github.com/plt/racket/pull/364/files#diff-0(4)
> - _M_ collects/redex/private/term.rkthttps://github.com/plt/racket/pull/364/files#diff-1(5)
> 
> Patch Links:
> - https://github.com/plt/racket/pull/364.patch
> - https://github.com/plt/racket/pull/364.diff

Closing. Started a much simpler PR. 

This is very much like Phil's PR, but I'm working on adding tests now. The matcher is below the rewrite-side-conditions pass, so _ is not a recognized pattern. Looking for the right entry point still.

rewrite it into `any.

Just don't add a 'name' around it.

On Fri, Jun 7, 2013 at 11:33 AM, J. Ian Johnson notifications@github.comwrote:

> This is very much like Phil's PR, but I'm working on adding tests now. The
> matcher is below the rewrite-side-conditions pass, so _ is not a recognized
> pattern. Looking for the right entry point still.
> 
> —
> Reply to this email directly or view it on GitHubhttps://github.com/plt/racket/pull/365#issuecomment-19117929
> .

Closed. Ian's one has tests.

I'm not sure which, if any, of these you want me to look at. I think I've
replied to them all, but I'm confused by this comment below. Please let me
know if you think that there are commits that I shoudl still be looking at.

On Fri, Jun 7, 2013 at 12:11 PM, Philip Nguyen notifications@github.comwrote:

> Closed. Ian's one has tests.
> 
> —
> Reply to this email directly or view it on GitHubhttps://github.com/plt/racket/pull/364#issuecomment-19120100
> .

Hi Robby. I had a look at Ian's PR (#365) and it was similar and also had updates to documentation and test cases, so I closed my PR to avoid confusion.

This looks okay; please make one commit. 

I pushed a few more commits that should address the comments so far and fixes some bugs.

One thing that I know is still broken is variance. I don't actually understand the `free-variance.rkt` code and how it hooks up to inference though, so if someone who understands that could suggest how to get that working, that would be great.

In particular, I'm not sure if line 128 of `type-rep.rkt` is correct (the `instantiate-frees` bit). I also think that I need to (1) register variances for the type aliases with `register-type-variance!` and (2) probably refine these variances somewhere later. (I have a cargo culted commit that just sets the variance to constant, which is probably wrong)

Is there a reason to change the C code, rather than just implementing this in `list.rkt`?

I could see keeping the C implementation or implementing always in Racket the path where a comparison function is provided.

If the C code is kept, use _scheme_apply() instead of scheme_apply() (i..e, with a leading underscore) to apply comp.

Otherwise, this looks fine to me.

In non-JIT mode, I think the C implementation is faster regardless of if the extra argument is provided and between 1.5x and 2x faster. So I'll just keep it after making the `_scheme_apply` fix.

On Mon, Jun 10, 2013 at 10:01 AM, Asumu Takikawa
notifications@github.comwrote:

> In non-JIT mode, I think the C implementation is faster regardless of if
> the extra argument is provided and between 1.5x and 2x faster. So I'll just
> keep it after making the _scheme_apply fix.

Which one is faster in JIT mode?

I haven't measured that directly, but I think the JIT vs. non-JIT is the same as measuring that (since it always uses Racket in JIT, C in non-JIT). In the dev e-mails, Racket/JIT was usually faster but in some cases C was faster.

FWIW, there are a number of reasons to prefer moving code out of the C
portions of the runtime system (futures work better with Racket code, for
one, but also analyses will have an easier time with Racket code than C
code) so I'd say that, if the JIT version isn't bad (which your numbers
indicate it isn't) then putting the new code into Racket is better.

And since we're here, and if you have energy (and if it hasn't been done
before), maybe we should try putting member itself into Racket and see how
that looks.

Robby

On Monday, June 10, 2013, Asumu Takikawa wrote:

> In non-JIT mode, I think the C implementation is faster regardless of if
> the extra argument is provided and between 1.5x and 2x faster. So I'll just
> keep it after making the _scheme_apply fix.
> 
> —
> Reply to this email directly or view it on GitHubhttps://github.com/plt/racket/pull/366#issuecomment-19200172
> .

I can go ahead and remove the C implementation of `member` and friends for the non-JIT path too (it should be easy unless stuff in `racket/private` depends on the primitive version), but that means some performance cost for non-JIT platforms. If that's ok, I can try it.

Edit: `member` has few uses in `racket/private`, but the `memq` primitive is popular.

Thanks for your willingness!

I think non-JIT platforms are less of a concern than a significant slowdown
for just moving to racket. But I don't know for sure and I'm not sure how
best to find out, either. Sorry.

Robby

On Mon, Jun 10, 2013 at 9:28 AM, Asumu Takikawa notifications@github.comwrote:

> I can go ahead and remove the C implementation of member and friends for
> the non-JIT path too (it should be easy unless stuff in racket/privatedepends on the primitive version), but that means some performance cost for
> non-JIT platforms. If that's ok, I can try it.
> 
> —
> Reply to this email directly or view it on GitHubhttps://github.com/plt/racket/pull/366#issuecomment-19201838
> .

On Mon, Jun 10, 2013 at 11:35 AM, Robby Findler notifications@github.comwrote:

> I think non-JIT platforms are less of a concern than a significant
> slowdown
> for just moving to racket. But I don't know for sure and I'm not sure how
> best to find out, either. Sorry.

The last time this was [discussed](http://lists.racket-lang.org/dev/archive/2011-April/006177.html) Matthew said that the major non-jit
platforms were Sparc and ARM, and that Sparc would probably die out, and
we'd get a JIT for ARM. We now have a JIT for ARM, and I think Sparc is
pretty dead.

Done.

In my last commit, I removed `memq`, `memv`, and `member` from the runtime primitives and pushed the implementations lower in the implementation of `racket/base`. We could potentially do the same with `assoc` and related functions too.

Here are some numbers on the microbenchmarks from before:

```
$ racket member-benchmark.rkt 
cpu time: 1768 real time: 1771 gc time: 0
$ racket member-benchmark-2.rkt 
cpu time: 2448 real time: 2456 gc time: 0
$ racket member-benchmark-3.rkt 
cpu time: 1704 real time: 1709 gc time: 0
$ racket member-benchmark-4.rkt 
cpu time: 1488 real time: 1494 gc time: 0

$ racket --no-jit member-benchmark.rkt 
cpu time: 12280 real time: 12311 gc time: 0
$ racket --no-jit member-benchmark-2.rkt 
cpu time: 16389 real time: 16433 gc time: 0
$ racket --no-jit member-benchmark-3.rkt 
cpu time: 12332 real time: 12366 gc time: 0
$ racket --no-jit member-benchmark-4.rkt 
cpu time: 12696 real time: 12729 gc time: 0
```

@elibarzilay, can you review this?

@mflatt or @rfindler, can you see if this ok?

Do you get the same numbers if you run those command-lines over and over?
(I usually see the first one or two being slower than subsequent ones.)

Those numbers look okay to me. For #1 it looks like a 4-5% slowdown and for
#4 a 7-8% slowdown (right?).

The speed of the non-jit member-benchmark.rkt file is still surprising,
tho. It would be good to look into that at some point (but that should not
hold us up here I would say). I would have guessed it is a problem of going
back and forth between JIT and non-JIT code, but that doesn't add up since
that's going to be relatively infrequent I would guess (the loop itself in
JIT code and the member function not, and the member function should take
way more time than the loop itself).

Thanks again for doing this!

Robby

On Mon, Jun 10, 2013 at 2:22 PM, Asumu Takikawa notifications@github.comwrote:

> In my last commit, I removed memq, memv, and member from the runtime
> primitives and pushed the implementations lower in the implementation of
> racket/base.
> 
> Here are some numbers on the microbenchmarks from before:
> 
> $ racket member-benchmark.rkt
> cpu time: 1768 real time: 1771 gc time: 0
> $ racket member-benchmark-2.rkt
> cpu time: 2448 real time: 2456 gc time: 0
> $ racket member-benchmark-3.rkt
> cpu time: 1704 real time: 1709 gc time: 0
> $ racket member-benchmark-4.rkt
> cpu time: 1488 real time: 1494 gc time: 0
> 
> $ racket --no-jit member-benchmark.rkt
> cpu time: 12280 real time: 12311 gc time: 0
> $ racket --no-jit member-benchmark-2.rkt
> cpu time: 16389 real time: 16433 gc time: 0
> $ racket --no-jit member-benchmark-3.rkt
> cpu time: 12332 real time: 12366 gc time: 0
> $ racket --no-jit member-benchmark-4.rkt
> cpu time: 12696 real time: 12729 gc time: 0
> 
> —
> Reply to this email directly or view it on GitHubhttps://github.com/plt/racket/pull/366#issuecomment-19220278
> .

@rfinder, does this look ok?

@elibarzilay will you be able to review this soon? and/or @mflatt as maintainer of algol60.

I don't see anything obviously wrong (the string constants change certainly
seems fine). We don't have a good test suite for the browser collection,
tho.

Patrick: what do you do to test it?

Robby

On Mon, Jun 10, 2013 at 2:59 PM, Sam Tobin-Hochstadt <
notifications@github.com> wrote:

> @rfinder, does this look ok?
> 
> —
> Reply to this email directly or view it on GitHubhttps://github.com/plt/racket/pull/264#issuecomment-19222408
> .

I get similar numbers on subsequent runs, but the spread is about 50ms (e.g., the first benchmark ranges from about 1700-1750ms when I run it multiple times) so I think the difference between master and this branch is small.

Thanks.

On Mon, Jun 10, 2013 at 3:10 PM, Asumu Takikawa notifications@github.comwrote:

> I get similar numbers on subsequent runs, but the spread is about 50ms
> (e.g., the first benchmark ranges from about 1700-1750ms when I run it
> multiple times) so I think the difference between master and this branch is
> small.
> 
> —
> Reply to this email directly or view it on GitHubhttps://github.com/plt/racket/pull/366#issuecomment-19223122
> .

Should I go ahead and merge this? I'm also planning to try removing `assoc` in another pass, which should be easier since the `#%kernel` version is only used by internal code in `racket/base` (and won't affect non-JIT builds for performance).

I think so. Probably best to get Matthew to confirm since this is his code
originally.

On Monday, June 10, 2013, Asumu Takikawa wrote:

> Should I go ahead and merge this? I'm also planning to try removing associn another pass, which should be easier since the
> #%kernel version is only used by internal code in racket/base (and won't
> affect non-JIT builds for performance).
> 
> —
> Reply to this email directly or view it on GitHubhttps://github.com/plt/racket/pull/366#issuecomment-19232569
> .

Eli/Samth, can you merge this and/or give me permission to merge stuff?

We don't ever merge things directly with the pull request interface.
Instead, just push the changes and either we or Kimball can close the PR.

(For other reasons, you'll have access to the GH repo soon, but using the
big green button will still not be allowed.)

On Mon, Jun 10, 2013 at 8:50 PM, Jay McCarthy notifications@github.comwrote:

> Eli/Samth, can you merge this and/or give me permission to merge stuff?
> 
> —
> Reply to this email directly or view it on GitHubhttps://github.com/plt/racket/pull/368#issuecomment-19235398
> .

Sounds fine to me, but when we last considered removing the C implementation of `assoc`, Neil V. had reservations, so maybe see what he thinks these days.

Also cannot this be a unit test instead of a full test case?

Thanks, I added unit tests as well. I think it's useful to also have an integration test, but if the consensus is that it's redundant I can remove it.

This doesn't handle structures with `prop:procedure`.  Also, can you squash these commits?

We don't appear to handle any kind of contract generation for structs with `prop:procedure` anyway though. Also, I'll squash them when I push them (keeping them separate so I don't have to force push to github).

Any thoughts on this? Should I just merge it?

I'm at low bandwidth due to travel, so I haven't taken a good look, but I expect that you should just merge (if you haven't already).

On Jun 12, 2013, at 9:30 AM, Asumu Takikawa notifications@github.com wrote:

> Any thoughts on this? Should I just merge it?
> 
> —
> Reply to this email directly or view it on GitHub.

Thanks Matthew. I went ahead and merged this just now.

This looks fine to me.

@jeapostrophe is this now merged?

I think I'm done reviewing here.  @shekari, can you comment on @takikawa's last comment about `free-variance.rkt`?

This has been merged.

Yes

On Monday, June 17, 2013, Sam Tobin-Hochstadt wrote:

> @jeapostrophe https://github.com/jeapostrophe is this now merged?
> 
> —
> Reply to this email directly or view it on GitHubhttps://github.com/plt/racket/pull/368#issuecomment-19560393
> .

## 

Jay McCarthy jay@cs.byu.edu
Assistant Professor / Brigham Young University
http://faculty.cs.byu.edu/~jay

"The glory of God is Intelligence" - D&C 93

@rfindler So, from what I recall, I checked that each file syntax checked within Dr. Racket. Recompiled multiple times. Built the scribble documentation. I checked that under a fresh compile and install that the tool hooked correctly into Dr. Racket and that there were no errors. I checked for tests, don't believe that this collection had them. That is pretty much it-I can't guarantee the correctness of the code, or even that my changes didn't break some code path (no tests), but I strongly believe that this codebase is in better shape than when I first touched it. However, I understand if the changes don't pass muster. 

I don't mean to say that they don't pass muster! Indeed, my flipping thru
them suggests that they are all good and I'd like to take this commit. I'm
sorry for my poor tone.

My basic issue is that I'd like to test something that runs basic aspects
of the code before pushing it. I have a vague memory of some example that
shows how this code is supposed to be used somewhere; I'll try to find it
and run it.

But if you'd run enough to load some random webpage, then I'd also be
satisfied.

Robby

Robby

On Mon, Jun 17, 2013 at 5:24 PM, Patrick Mahoney
notifications@github.comwrote:

> @rfindler https://github.com/rfindler So, from what I recall, I checked
> that each file syntax checked within Dr. Racket. Recompiled multiple times.
> Built the scribble documentation. I checked that under a fresh compile and
> install that the tool hooked correctly into Dr. Racket and that there were
> no errors. I checked for tests, don't believe that this collection had
> them. That is pretty much it-I can't guarantee the correctness of the code,
> or even that my changes didn't break some code path (no tests), but I
> strongly believe that this codebase is in better shape than when I first
> touched it. However, I understand if the changes don't pass muster.
> 
> —
> Reply to this email directly or view it on GitHubhttps://github.com/plt/racket/pull/264#issuecomment-19579203
> .

This does also raise the question of what we're using the browser collection _for_, these days.  But that's not relevant for this PR.

Yes. Not much, I think.

(It used to be used for the docs, as you probably recall.)

Robby

On Mon, Jun 17, 2013 at 5:38 PM, Sam Tobin-Hochstadt <
notifications@github.com> wrote:

> This does also raise the question of what we're using the browser
> collection _for_, these days. But that's not relevant for this PR.
> 
> —
> Reply to this email directly or view it on GitHubhttps://github.com/plt/racket/pull/264#issuecomment-19579836
> .

On Mon, Jun 17, 2013 at 6:50 PM, Robby Findler notifications@github.comwrote:

> Yes. Not much, I think.

A quick grep indicates: the bug report dialog, and some other random places
that I didn't understand.

>  (It used to be used for the docs, as you probably recall.)

Yep.

The point of free-variance is to define the method of computing the variance in the data structure. All (structure) type constructors are initially assumed to be constant in their arguments and then the variances flow through the definitions, and if a variable is used (co/contra/in)variantly, then the structure is updated to correctly represent that. This step is repeated until it is stable.

This code is here: https://github.com/plt/racket/blob/05524114323cad6229d1b785fdcbb512179c4afe/collects/typed-racket/typecheck/tc-structs.rkt#L221

You will need to make that work over all type constructors instead of just struct constructors now. The instantiate part looks correct. register-type-variance is the refining part (as it is repeated).

Racket now should support `libpng16`.  If you still have problems, let us know.

@rfindler What's the status on this pull request? It looks like it was merged.

1. Keep the integration test as well as the unit test.
2. I agree with @shekari about `(match (resolve ty) ...)`.
3. I'm fine with not handling `prop:procedure` here.

After that, I think this is good to go.

@elibarzilay Any updates here?  Otherwise, seems ok to just merge this.

Have we come to a conclusion here? Should I just close this PR?

This was merged.

@mflatt or @elibarzilay, are you the right people to review this PR?  If not, who is?

Hello Robby @rfindler,
Not to worry wrt tone-I didn't take it that way.

"My basic issue is that I'd like to test something that runs basic aspects
of the code before pushing it. I have a vague memory of some example that
shows how this code is supposed to be used somewhere; I'll try to find it
and run it."

> Understood. It has been a bit since I played with this code, but I'll try
> in the next few days to work with it again and run it through these paces.
> I believe I recall running a page through it, and that it was functional,
> just can't recall for sure.

-Patrick

On 17 June 2013 18:37, Robby Findler notifications@github.com wrote:

> I don't mean to say that they don't pass muster! Indeed, my flipping thru
> them suggests that they are all good and I'd like to take this commit. I'm
> sorry for my poor tone.
> 
> My basic issue is that I'd like to test something that runs basic aspects
> of the code before pushing it. I have a vague memory of some example that
> shows how this code is supposed to be used somewhere; I'll try to find it
> and run it.
> 
> But if you'd run enough to load some random webpage, then I'd also be
> satisfied.
> 
> Robby
> 
> Robby
> 
> On Mon, Jun 17, 2013 at 5:24 PM, Patrick Mahoney
> notifications@github.comwrote:
> 
> > @rfindler https://github.com/rfindler So, from what I recall, I
> > checked
> > that each file syntax checked within Dr. Racket. Recompiled multiple
> > times.
> > Built the scribble documentation. I checked that under a fresh compile
> > and
> > install that the tool hooked correctly into Dr. Racket and that there
> > were
> > no errors. I checked for tests, don't believe that this collection had
> > them. That is pretty much it-I can't guarantee the correctness of the
> > code,
> > or even that my changes didn't break some code path (no tests), but I
> > strongly believe that this codebase is in better shape than when I first
> > touched it. However, I understand if the changes don't pass muster.
> > 
> > —
> > Reply to this email directly or view it on GitHub<
> > https://github.com/plt/racket/pull/264#issuecomment-19579203>
> > .
> 
> —
> Reply to this email directly or view it on GitHubhttps://github.com/plt/racket/pull/264#issuecomment-19579752
> .

The commit no longer applies, since I removed the attempt at doing something with multiple values.

References:
- [I asked about the multiple values](http://lists.racket-lang.org/dev/archive//2012-June/009612.html), nobody had a reply...
- [@danking asks about it too](http://lists.racket-lang.org/dev/archive//2012-July/009882.html).
- [Another attempt to do it](http://lists.racket-lang.org/dev/archive/2012-November/010712.html), and I tried generalizing it and gave up.  It's still in my mailbox, though, so theoretically I'll get there sometimes.

Thanks for the comments. This has been merged.

I intended to look at it because @jbclements wanted, though I have no real relation to the parser tools (even as a user, I think that I didn't use it more than once or twice), but never got to it.  Given my expertise, you can review it just as well as I would, and John can probably review it better than both of us...

Yes, I believe it was.

On Tue, Jun 18, 2013 at 8:50 AM, Sam Tobin-Hochstadt <
notifications@github.com> wrote:

> @rfindler https://github.com/rfindler What's the status on this pull
> request? It looks like it was merged.
> 
> —
> Reply to this email directly or view it on GitHubhttps://github.com/plt/racket/pull/346#issuecomment-19612167
> .

I've just pushed a few more commits to this pull request that do the following:
-  Switch `RecName` to just `Name`. I agree with Eric that reducing duplication is better here.
   To make it work, I needed to make all `Name` types go through an initial type alias. This
   shouldn't be a problem since this type alias is resolved at parse time to the `Name`. `Name` also
   has an extra field to indicate whether it points to a struct or not.
- Fixed variance code for recursive type aliases
- Addressed most other pull request comments

The switch from `RecName` to `Name` is also motivated by another issue with Typed Racket.
Large type aliases can result in zo bloat in extreme cases. I have an example zo file that is
3.2MB due to large class type aliases. One solution to this is to make _all_ type aliases go
through the environment.

All the TR tests still seem to pass. As usual, I'll fixup commits and rebase before actually merging.

Why is this the right fix? Doesn't this just make the problematic code path not get triggered? I.e. the undefined getting added to the type still happens in the complicated cases.

This PR doesn't intend to reduce the conservative-ness of the typechecker with regard to `#<undefined>` (that's also a futile thing to do anyway; at some point in the future TR won't need to deal with `#<undefined>`s).

The bug that it's addressing is that the typechecker already looks for clauses where the RHS doesn't refer to a bound variable and checks those even without an annotation. This only works for certain orderings of clauses, however, and the attached commit makes annotations unnecessary no matter the order.

I agree that you are fixing a bug, I'm just not sure that it is fixing the bug reported as pr 13124. I believe that the following program

```
#lang typed/racket

(: foo (-> Integer))
(define (foo)
  (: bn (Integer -> Integer))
  (define (bn n) (if (= n 0) 1 (bn (- n 1))))
  (define v (bn 0))
  0)
```

Is the same bug as PR 13124, and your change doesn't fix this program. I also think that a fix to that will obsolete the change that you are introducing here.

I agree that the typechecker could be even smarter. In particular, it can use Tarjan's algorithm to see which variables don't create cycles and type-check those in reverse topological order (that would make your example typecheck). This PR just solves a subset of the more general problem because I don't have more time to spend on it ATM, but I could add a TODO comment outlining how to do better.

How much of this would go away if we didn't have `undefined`?

This particular code is still relevant after removing `#<undefined>`. The point of this first pass is to find clauses that aren't recursive or mutually recursive for sure. Recursive clauses require a type annotation in order to close the loop (type synthesis doesn't work). The non-recursive clauses can be type-checked without an annotation.

I cannot figure out how to get git to apply this patch to the current tree.

If no one else knows either, I can just down load the files one at a time
and put them in the right places and make a new commit.

Robby

I think you want to apply something like the command Carl describes here:
http://lists.racket-lang.org/dev/archive/2013-June/012654.html

On Mon, Jun 24, 2013 at 8:57 PM, Robby Findler notifications@github.comwrote:

> I cannot figure out how to get git to apply this patch to the current tree.
> 
> If no one else knows either, I can just down load the files one at a time
> and put them in the right places and make a new commit.
> 
> Robby
> 
> —
> Reply to this email directly or view it on GitHubhttps://github.com/plt/racket/pull/264#issuecomment-19946662
> .

Thanks. That seemed to work.

Robby

On Mon, Jun 24, 2013 at 9:25 PM, Sam Tobin-Hochstadt <
notifications@github.com> wrote:

> I think you want to apply something like the command Carl describes here:
> http://lists.racket-lang.org/dev/archive/2013-June/012654.html
> 
> On Mon, Jun 24, 2013 at 8:57 PM, Robby Findler notifications@github.comwrote:
> 
> > I cannot figure out how to get git to apply this patch to the current
> > tree.
> > 
> > If no one else knows either, I can just down load the files one at a
> > time
> > and put them in the right places and make a new commit.
> > 
> > Robby
> > 
> > —
> > Reply to this email directly or view it on GitHub<
> > https://github.com/plt/racket/pull/264#issuecomment-19946662>
> > .
> 
> —
> Reply to this email directly or view it on GitHubhttps://github.com/plt/racket/pull/264#issuecomment-19949314
> .

So how about we factor the algorithm into two parts, one to type check them
the staments in some order and with some environment. And another section
to find the order/environments. Then your change is just moving it from the
simplistic in order to a slightly more complicated way, and then any more
advanced ordering is just changing the part that generates the order and
not the checking part.

On Mon, Jun 24, 2013 at 3:54 PM, Asumu Takikawa notifications@github.comwrote:

> This particular code is still relevant after removing #<undefined>. The
> point of this first pass is to find clauses that aren't recursive or
> mutually recursive for sure. Recursive clauses require a type annotation in
> order to close the loop (type synthesis doesn't work). The non-recursive
> clauses can be type-checked without an annotation.
> 
> —
> Reply to this email directly or view it on GitHubhttps://github.com/plt/racket/pull/372#issuecomment-19941961
> .

Overall, this is fine after addressing the small comments I've made, plus a big rebase. @stamourv, can you look quickly at the optimizer changes?

LGTM

Merged.

I added the definitions to a separate package, per matthew's suggestion. So: yes, closing.

I think I've now addressed all the comments. There's still some code duplication, but I think we can address that later (this code will change once we merge more type alias changes anyway).

This looked good to me. I tried running the tests and those looked fine (assuming it rebases without problem). @samth?

Looks good to me as well. r+

Thanks. I've pushed this.

Robby

On Sat, Jun 29, 2013 at 10:45 PM, Max New notifications@github.com wrote:

> Redex enumerators using unsupported or unimplemented patterns won't raise
> 
> ## exceptions when defined, only when run.
> 
> You can merge this Pull Request by running
> 
>   git pull https://github.com/maxsnew/racket master
> 
> Or view, comment on, or merge it at:
> 
>   https://github.com/plt/racket/pull/378
> Commit Summary
> - Simplified redex unsupported/unimplemented handling.
> 
> File Changes
> - _M_ pkgs/redex/private/enum.rkthttps://github.com/plt/racket/pull/378/files#diff-0(77)
> - _M_ pkgs/redex/private/enumerator.rkthttps://github.com/plt/racket/pull/378/files#diff-1(12)
> 
> Patch Links:
> - https://github.com/plt/racket/pull/378.patch
> - https://github.com/plt/racket/pull/378.diff

Generally looks good to me.

The "windll.rkt" module has a `with-output-to-file` that's missing the `#:exists` keyword. You might want to double-check for more (that's what I usually get wrong when porting from `mzscheme` to `racket/base`), but I didn't find other cases by just looking at random files.

The Racket version number should be incremented. If I understand correctly, that's enough to avoid any compatibility issues in `xform`.

For me, the less common but far more confusing one is pretty-print =>
pretty-write. FWIW.

Robby

On Sun, Jun 30, 2013 at 6:58 PM, Matthew Flatt notifications@github.comwrote:

> Generally looks good to me.
> 
> The "windll.rkt" module has a with-output-to-file that's missing the
> #:exists keyword. You might want to double-check for more (that's what I
> usually get wrong when porting from mzscheme to racket/base), but I
> didn't find other cases by just looking at random files.
> 
> The Racket version number should be incremented. If I understand
> correctly, that's enough to avoid any compatibility issues in xform.
> 
> —
> Reply to this email directly or view it on GitHubhttps://github.com/plt/racket/pull/377#issuecomment-20258190
> .

@rfindler The `pretty-print` -> `pretty-write` thing is about `scheme` -> `racket`, fortunately.  However, that suggests that I need to be careful about using `racket/base` without checking for the things different between `scheme` and `racket`.

Yes, it is. mzscheme is like scheme/base in this regard, however.

On Mon, Jul 1, 2013 at 8:49 AM, Sam Tobin-Hochstadt <
notifications@github.com> wrote:

> @rfindler https://github.com/rfindler The pretty-print -> pretty-writething is about
> scheme -> racket, fortunately. However, that suggests that I need to be
> careful about using racket/base without checking for the things different
> between scheme and racket.
> 
> —
> Reply to this email directly or view it on GitHubhttps://github.com/plt/racket/pull/377#issuecomment-20282668
> .

Closed in commit ebc6a6618e95f6d919f3e0ac1783da6564e69f7c.

I think that the handle-evt versus wrap-evt is different than the car example because in the car example you can at least write the type that protects your use of car from bad things but you cannot do that without splitting out handle events as a separate type. 

The problem with splitting it out as a separate type is that you want a (hypothetical) `Handle-Evtof` type to be a subtype of `Evtof`, but if you allow that subtyping you can now lose the fact that you really have a `Handle-Evtof`. Then you can't enforce the `wrap-evt` precondition on its argument. I guess we could make disjoint types `Non-Handle-Evtof` and `Handle-Evtof` and the union could be `Evtof`, though the types of event functions now need a case for each kind of event (to make sure the result inherits the right kind).

Turns out that some other changes had already gotten these fixes in, so I'm just going to add the test cases and close the bug.

I think commit b3ce8b9 is already part of PR #287.  The other two commits look fine to merge.

I think I've now addressed all or most of the comments so far. Note: I wish Github wouldn't just delete comments on "oudated" diffs.

r+ with the minor comments addressed.

For me, it can "show outdated diff". 

Is this now merged?

@rmculpepper, can you review this?

@mflatt can you answer @pmechai's questions?

@elibarzilay ping.

@rfindler I think this got merged, right?

Yes, I think so.

On Thu, Jul 11, 2013 at 10:12 AM, Sam Tobin-Hochstadt <
notifications@github.com> wrote:

> @rfindler https://github.com/rfindler I think this got merged, right?
> 
> —
> Reply to this email directly or view it on GitHubhttps://github.com/plt/racket/pull/264#issuecomment-20818403
> .

Yes, I just went to bed before deleting it on github.

On Thu, Jul 11, 2013 at 8:08 AM, Sam Tobin-Hochstadt <
notifications@github.com> wrote:

> Is this now merged?
> 
> —
> Reply to this email directly or view it on GitHubhttps://github.com/plt/racket/pull/310#issuecomment-20818057
> .

Merged, thanks!

Closing this one out for a rebased and cleaned up pull request.

Great, thanks for doing this. I'm moving halfway across the country a week from today, so I may not review this immediately, but I'll try to get to it soon.

Sorry that I lost track of this one long ago...

As an example of multi-line input, if you start `racket`, use `(require readline)`,
and then type an expression that span lines (such as `(+ 1`, return, then `2)`),
then the up-arrow key will restore the full, two-line S-expression.

Using an S-expression format would take care of the multi-line issue, since an
S-expression string can contain a newline character.

Can you squash these down into one commit?

Oh wow, this doesn't work at all. Yeah, my knowledge about git is limited to clone, pull, push, commit, checkout and branch. Do I just remove this pull request, do a new clone of this repo and do it again?

Ok, I'll take care of it.  Thanks for the patch.

I've squashed and pushed this.

Thank you very much :)

No, thank you! :)

On Thu, Jul 18, 2013 at 4:29 PM, tkoehlmann notifications@github.comwrote:

> Thank you very much :)
> 
> —
> Reply to this email directly or view it on GitHubhttps://github.com/plt/racket/pull/383#issuecomment-21212366
> .

Is there a reason to prefer the integration test/drop the unit tests?

The unit tests just check the called method which is really just subtype. https://github.com/plt/racket/blob/master/pkgs/typed-racket-pkgs/typed-racket-lib/typed-racket/private/type-annotation.rkt#L139

The integration test tests the code that calls check-type which was untested before.

Also I had issues moving the check type test over to code that was using local-expand/running at phase1 which I will be sending for review shortly.

LGTM

LGTM

LGTM

LGTM

LGTM

LGTM

LGTM

Thanks! I've pushed it.

Robby

On Sun, Jul 21, 2013 at 10:54 PM, Max New notifications@github.com wrote:

> Now memoizes the sizes in a dependent enumeration. I didn't do extensive
> performance comparison, but the enumeration tests took about 1/4 the time
> after the fix.
> 
> ## Also reorganized a bit of the other enumeration code.
> 
> You can merge this Pull Request by running
> 
>   git pull https://github.com/maxsnew/racket master
> 
> Or view, comment on, or merge it at:
> 
>   https://github.com/plt/racket/pull/398
> Commit Summary
> - Split redex enumeration code into multiple files.
> - Memoized redex dependent enumeration.
> 
> File Changes
> - _M_ pkgs/redex-pkgs/redex-lib/redex/private/enum.rkthttps://github.com/plt/racket/pull/398/files#diff-0(8)
> - _M_ pkgs/redex-pkgs/redex-lib/redex/private/enumerator.rkthttps://github.com/plt/racket/pull/398/files#diff-1(219)
> - _A_ pkgs/redex-pkgs/redex-lib/redex/private/recursive-lang.rkthttps://github.com/plt/racket/pull/398/files#diff-2(207)
> 
> Patch Links:
> - https://github.com/plt/racket/pull/398.patch
> - https://github.com/plt/racket/pull/398.diff

Incidentally, `(if (evt? some-imported-struct) #t #f)` doesn't get dead code eliminated and the same with an example with the `sequence?` predicate. This is because both types have a `#f` type key.

I just added support for distinguishing between handle and non-handle events. It seems to work for the tests I've written, but it is admittedly a little bit awkward because there is a `HandleEvtof` and `NonHandleEvtof` and they are not related by subtyping. `Evtof` is an abbreviation for the union of the two.

Occurrence typing for `evt?` recovers the union type and `handle-evt?` just gives `HandleEvtof`.

Can anyone think of a better name for `NonHandleEvtof`? Vincent suggested something like `BasicEvtof`.

Asumu, as I recall you were going to ask @mflatt and/or the list about the
rationale here. Can you do that?
On Jul 25, 2013 12:23 PM, "Asumu Takikawa" notifications@github.com wrote:

> I just added support for distinguishing between handle and non-handle
> events. It seems to work for the tests I've written, but it is admittedly a
> little bit awkward because there is a HandleEvtof and NonHandleEvtof and
> they are not related by subtyping. Evtof is an abbreviation for the union
> of the two.
> 
> Can anyone think of a better name for NonHandleEvtof? Vincent suggested
> something like BasicEvtof.
> 
> —
> Reply to this email directly or view it on GitHubhttps://github.com/plt/racket/pull/379#issuecomment-21566198
> .

My opinion based on the mailing list discussion is that we should just ignore the distinction between kinds of events in TR and leave it as an allowed dynamic error. (since it's primarily for performance debugging and is not a safety concern) I can revert the last commit, add types for `handle-evt` and `wrap-evt` with the old types, and merge the PR. Does that sound reasonable?

Yes, I think so.  I kind of think that we should just drop the distinction,
but I don't think that will happen now.

Sam

On Thu, Jul 25, 2013 at 2:47 PM, Asumu Takikawa notifications@github.comwrote:

> My opinion based on the mailing list discussion is that we should just
> ignore the distinction between kinds of events in TR and leave it as an
> allowed dynamic error. (since it's primarily for performance debugging and
> is not a safety concern) I can revert the last commit, add types for
> handle-evt and wrap-evt with the old types, and merge the PR. Does that
> sound reasonable?
> 
> —
> Reply to this email directly or view it on GitHubhttps://github.com/plt/racket/pull/379#issuecomment-21575733
> .

This was closed by commit 6c88814

Merged, thanks!

That's a bug introduced in the `racket/gui` rewrite of v5.1. I'll change the result to `'press` to match the docs and older version.

Thanks!

It's possible that putting `START_XFORM_SKIP;` before the include and `END_XFORM_SKIP;` after the include will let you make progress. Or maybe you can isolate the code that needs to work with Racket in a different file that does not include `istream`?

I know. Thank you. I maybe become a contributer someday. I love racket. You can close this!

close.. 2 minutes ago...I try again, but #include<vector> is not work too... And START_XFORM_SKIP can only make progress in mingw, vs2008 is not good. Some error in yvals.h too. I can use cpp file raco ctool --3m --cc 1.cpp, but may have gc internal error without 3m xform. And I use boost and vc(microsoft mfc) libs too. 3m may be not support? 

The way I match field name with accessor identifier feels a bit heavy-handed, but I don't know a better way to do it. Review?

Can you provide an example illustrating the problem with hashes and underscores in URLs?

I've worked on the problem a couple of times already. Certain URL-formatting Latex macros are supposed to take care of those characters, and escaping them makes the URL not work as a hyperlink. But things are not always well defined, and/or I may have gotten it wrong still in my previous attempts.

Thanks!

This seems fine -- I think that we just don't need this anymore given the move to taints. 

@mflatt or @rmculpepper, is there something we could test to determine if Typed Racket is working "appropriately" with taints?

r+

This is a great idea! Annoyed that I didn't think of this originally. r+

Seems reasonable. r+

This is fine by me too.

Thanks!

Looks good on first impression.

I don't understand the special handling of cpointers for serialization, though. There are many kinds of values that can be `equal?` without being `eq?`. Is there some problem that's specific to cpointers, or does the problem that you're seeing point to a similar issue with other kinds of values?

A small example: https://gist.github.com/bluephoenix47/efed66b584a10ac4c1bd

I think most of the time only values that are really the same in the eq? sense should share an instance after serialize/deserialize cycle, at least if they are mutable its essential. Otherwise e.g two mutable vectors that are equal? will be eq? afterwards. For immutable data its only a trade-off between time (to serialize) and space (of the serialized data).
cpointers on the other hand must be the same after serialization if they were equal before. Otherwise a diamond-shaped pointer-structure might end up as a tree (see L687 ff in the tests for an example of this case).

Or can you give me an example of what kind of values you mean?

I can't seem to reproduce this now. I was using the example posted here: https://gist.github.com/bluephoenix47/0ddd7235211ab3214478

I initially noticed this in Racket 5.3.6 and then tried using a version built from git. However, doing a fresh checkout and build of 8a685777ff86, this example renders fine. Perhaps I left my previous build in a strange state while I was testing.

Yes, I see the problem with v5.3.6, too. It looks like the last time I worked on the problem was May 14, which was after the fork that led to v5.3.6.

For better or worse, cpointers are mutable, too --- so that's a potential problem with treating `equal?` cpointers as `eq?`.

I think I now understand the motivation for the change, though, thanks to your example. I'll look at it more.

The confusing thing is that cpointers have a shifted semantic compared to normal racket values:
datum eq? = cpointer equal? (or ptr-equal?)
datum equal? = nothing comparable in cpointer (except memcmp)

I see what you mean, but I think that `equal?` cpointers are like two boxes that `equal?` because they contain `eq?` values. The confusing thing is more that `ptr-set!` doesn't change the cpointer, but instead changes the thing that the cpointer refers to --- analogous to `(lambda (b) (set-...! (unbox b)))`.

This seems to work in windows and is used in com.rkt. Must be fixed on the c side i guess. Investigating ...

I have a repair --- will push soon.

Would it make sense to move the `equal?`-cpointer hashing into `define-serializable-cstruct` (maybe with a weak hash table) instead of into `serialize`?

If that works out, I think a "serialize-cstruct-lib" package might be the right home for `ffi/serialize-cstruct`, and the "racket-doc" and "racket-test" packages could depend on it.

That might be possible, at least currently i See No problems. I will try that and give you Feedback.

----- Reply message -----
Von: "Matthew Flatt" notifications@github.com
An: "plt/racket" racket@noreply.github.com
Cc: "Tobias Hammer" tobias.hammer@dlr.de
Betreff: [racket] Add cpointer serialization support to serialize and add define-serializa... (#409)
Datum: Di., Aug. 27, 2013 18:12

Would it make sense to move the `equal?`-cpointer hashing into `define-serializable-cstruct` (maybe with a weak hash table) instead of into `serialize`?

If that works out, I think a "serialize-cstruct-lib" package might be the right home for `ffi/serialize-cstruct`, and the "racket-doc" and "racket-test" packages could depend on it.

---

Reply to this email directly or view it on GitHub:
https://github.com/plt/racket/pull/409#issuecomment-23349156

The solution with a weak hash works, thanks for the suggestion. I reverted the changes to rackets serialize.rkt. I updated the API a bit to make it (IMO) far less confusing and fix a few bugs.
I tried to put the code into serialize-cstruct-lib package and update the dependencies. But this is my first package and i am not sure if the package, info.rkt or deps are correct.

I haven't reviewed this yet, but getting this merged is worth disabling two unit tests.  Thanks a ton for doing this! 

Merged to one combined commit

Any update on this? Should I go ahead and merge?

LGTM

This is good.  For future reference, you don't need to ask for review for stuff this simple.

This one I was just making sure that some else thought that this was the correct solution for generic sets.

LGTM

Technically, the whole unboxed-gensym machinery is not necessary anymore since the tests don't check against the expansion directly anymore (and haven't for a long time). On the other hand, it makes the generated code more readable, which is useful when debugging.

What do you think?

On Fri, Aug 30, 2013 at 11:43 AM, Vincent St-Amour <notifications@github.com

> wrote:
> 
> Technically, the whole unboxed-gensym machinery is not necessary anymore
> since the tests don't check against the expansion directly anymore (and
> haven't for a long time). On the other hand, it makes the generated code
> more readable, which is useful when debugging.
> 
> What do you think?

I think readable expanded code is worth it, in general.  We have to stare
at it, and making it unreadable is very painful.

Sam

The current version keeps the readability, it just loses the
reproducibility and low number indices on the identifiers.

Sent from a mobile device.
On Aug 30, 2013 12:17 PM, "Sam Tobin-Hochstadt" notifications@github.com
wrote:

> On Fri, Aug 30, 2013 at 11:43 AM, Vincent St-Amour <
> notifications@github.com
> 
> > wrote:
> > 
> > Technically, the whole unboxed-gensym machinery is not necessary anymore
> > since the tests don't check against the expansion directly anymore (and
> > haven't for a long time). On the other hand, it makes the generated code
> > more readable, which is useful when debugging.
> > 
> > What do you think?
> 
> I think readable expanded code is worth it, in general. We have to stare
> at it, and making it unreadable is very painful.
> 
> Sam
> 
> —
> Reply to this email directly or view it on GitHubhttps://github.com/plt/racket/pull/418#issuecomment-23583510
> .

Neither of those properties seem that important to me, esp. if Vincent is
ok with dropping them.

On Fri, Aug 30, 2013 at 3:22 PM, Eric Dobson notifications@github.comwrote:

> The current version keeps the readability, it just loses the
> reproducibility and low number indices on the identifiers.
> 
> Sent from a mobile device.
> On Aug 30, 2013 12:17 PM, "Sam Tobin-Hochstadt" notifications@github.com
> 
> wrote:
> 
> > On Fri, Aug 30, 2013 at 11:43 AM, Vincent St-Amour <
> > notifications@github.com
> > 
> > > wrote:
> > > 
> > > Technically, the whole unboxed-gensym machinery is not necessary
> > > anymore
> > > since the tests don't check against the expansion directly anymore
> > > (and
> > > haven't for a long time). On the other hand, it makes the generated
> > > code
> > > more readable, which is useful when debugging.
> > > 
> > > What do you think?
> > 
> > I think readable expanded code is worth it, in general. We have to stare
> > at it, and making it unreadable is very painful.
> > 
> > Sam
> > 
> > —
> > Reply to this email directly or view it on GitHub<
> > https://github.com/plt/racket/pull/418#issuecomment-23583510>
> > .
> 
> —
> Reply to this email directly or view it on GitHubhttps://github.com/plt/racket/pull/418#issuecomment-23583783
> .

Yes, that's fine.

r+

Addressed comments.

Addressed comments.

You should ask questions about using Racket on the Racket `users` mailing list.  You can find information about that here: http://lists.racket-lang.org/

r+ once that comment is dealt with.

This is awesome! 

One other thought -- there are lots of `require`s in the base environment definitions that may no longer be needed with this.  

I will get those in a later change, otherwise merging/rebasing becomes a lot more difficult as it touches a bunch more files.

Yeah, that doesn't need to be done in this commit. It's just something that we should remember can now be done.

Although, having looked at `base-env.rkt` now, I don't see much of that duplication.  There is still some in `base-env-numeric.rkt`, though.

@elibarzilay are you still the person to review this?

r+

LGTM

LGTM

Fixed cond, and rebased so that files in are now in typed-racket-test.

LGTM

Fixed the buggy optimizations now everything should be optimizing correctly, the missing optimizations lines were not supposed to be there in the first place.

At Tue, 03 Sep 2013 04:25:41 -0700, gggin wrote:

> When I use raco exe and ctool compile my rkt files.
> If I don't change any source code, the exe that raco make is not same with 
> before raco make.
> I mean. when I run raco make exe, exe's md5 is changed, I want to make a 
> update in a big project. And I have a md5 check,but I don't want to update 
> racket's exe every time. 
> 
> Do you have any way?　Thank you very much!

Unfortunately, Racket's compiler is not currently deterministic at the
level generated bytes. The obstacles are related to the use of hash
tables and generated symbols. We hope to fix this, eventually, but I
doubt that it will get fixed soon.

To partly address the problem, `raco make` tracks the checksum of a
source file and the checksums of dependencies. When a ".zo" timestamp
is older than its source but the checksums haven't changed, then `raco
make` simply updates the ".zo" file's timestamp. If you have a way to
keep ".dep" and ".zo" files, then you may be able to get `raco make` to
issue a stamp of approval on an old ".zo" file instead of creating a
new one. Of course, that's not as nice as being able to create the same
".zo" file every time.

Thanks for the report! This problem has been fixed in the development version.

Did you try running the random tester overnight? In the past, it's been pretty good at finding optimizer bugs.

Did not run the random tester, will do so tonight.

Merged - thanks!

Merged - thanks!

I think this is covered by repairs in v5.90.x, so I'm closing the request. Thanks!

Merged - thanks!

The new known bugs are all about mistreating 0 as 0.0. My changes have made these bugs worse because before where it was statically knowable the optimizer treated them correctly, but the bugs still existed in cases where it wasn't statically knowable.

This all looks good.

Ok, so how about we push the changes that don't affect float-complex optimizations, and try to figure out a solution for those?

Sgtm, I'll try to do that tonight /tomorrow.

Sent from a mobile device.
On Sep 10, 2013 1:39 PM, "Vincent St-Amour" notifications@github.com
wrote:

> Ok, so how about we push the changes that don't affect float-complex
> optimizations, and try to figure out a solution for those?
> 
> —
> Reply to this email directly or view it on GitHubhttps://github.com/plt/racket/pull/429#issuecomment-24192474
> .

r+ with comments addressed.

r+ with comments addressed.

This seems like an improvement on the current awfulness of `struct-copy`, although it isn't a full solution.  @mflatt, any thoughts?

It looks like this has just minor revisions remaining before merging? @shekari @stamourv are you both ok here?

This seems like a good strategy to me.

Two smaller thoughts: you can probably avoid the O(n^2) loop and you
probably want to cover the case where one field name is a hyphen-ending
suffix of another one. And probably, just for good measure make sure there
aren't two that match (define-struct can't do that (if you cover the suffix
thing) I think, but anyone can make a struct-info). Probably signal a
syntax error when you do that. Something about ambiguous fields or
something. And maybe add some legalese to the docs to explain this.
Speaking of the docs, I guess this strategy should be put into a technical
section and its ramifications explained for people that might be making up
struct-info records.

Also, do the contract tests still pass?

Robby

thank you^_^，you always help me.

 iPad

在 2013-9-6，上午8:45，Matthew Flatt notifications@github.com 写道：

> At Tue, 03 Sep 2013 04:25:41 -0700, gggin wrote: 
> 
> > When I use raco exe and ctool compile my rkt files. 
> > If I don't change any source code, the exe that raco make is not same with 
> > before raco make. 
> > I mean. when I run raco make exe, exe's md5 is changed, I want to make a 
> > update in a big project. And I have a md5 check,but I don't want to update 
> > racket's exe every time. 
> > 
> > Do you have any way?　Thank you very much! 
> 
> Unfortunately, Racket's compiler is not currently deterministic at the 
> level generated bytes. The obstacles are related to the use of hash 
> tables and generated symbols. We hope to fix this, eventually, but I 
> doubt that it will get fixed soon. 
> 
> To partly address the problem, `raco make` tracks the checksum of a 
> source file and the checksums of dependencies. When a ".zo" timestamp 
> is older than its source but the checksums haven't changed, then `raco 
> make` simply updates the ".zo" file's timestamp. If you have a way to 
> keep ".dep" and ".zo" files, then you may be able to get `raco make` to 
> issue a stamp of approval on an old ".zo" file instead of creating a 
> new one. Of course, that's not as nice as being able to create the same 
> ".zo" file every time.
> —
> Reply to this email directly or view it on GitHub.

On Tue, Sep 10, 2013 at 8:23 PM, Robby Findler notifications@github.comwrote:

> This seems like a good strategy to me.
> 
> Two smaller thoughts: you can probably avoid the O(n^2) loop and you
> probably want to cover the case where one field name is a hyphen-ending
> suffix of another one. And probably, just for good measure make sure there
> aren't two that match (define-struct can't do that (if you cover the suffix
> thing) I think, but anyone can make a struct-info). Probably signal a
> syntax error when you do that. Something about ambiguous fields or
> something. And maybe add some legalese to the docs to explain this.
> Speaking of the docs, I guess this strategy should be put into a technical
> section and its ramifications explained for people that might be making up
> struct-info records.

Notes that you can use `checked-struct-info?` to be sure you're getting
something from `struct`.

> Also, do the contract tests still pass?

Nicely, the little green bar from Travis tells us that the tests it runs,
which include the contract tests, pass.

@jeapostrophe Are you the right person to review this?

On Tue, Sep 10, 2013 at 7:29 PM, Sam Tobin-Hochstadt <
notifications@github.com> wrote:

> On Tue, Sep 10, 2013 at 8:23 PM, Robby Findler <notifications@github.com
> 
> > wrote:
> > 
> > This seems like a good strategy to me.
> > 
> > Two smaller thoughts: you can probably avoid the O(n^2) loop and you
> > probably want to cover the case where one field name is a hyphen-ending
> > suffix of another one. And probably, just for good measure make sure
> > there
> > aren't two that match (define-struct can't do that (if you cover the
> > suffix
> > thing) I think, but anyone can make a struct-info). Probably signal a
> > syntax error when you do that. Something about ambiguous fields or
> > something. And maybe add some legalese to the docs to explain this.
> > Speaking of the docs, I guess this strategy should be put into a
> > technical
> > section and its ramifications explained for people that might be making
> > up
> > struct-info records.
> 
> Notes that you can use `checked-struct-info?` to be sure you're getting
> something from `struct`.
> 
> Perhaps that's for the best.
> 
> > Also, do the contract tests still pass?
> 
> Nicely, the little green bar from Travis tells us that the tests it runs,
> which include the contract tests, pass.

Sweet! I actually did see that, duh.

Robby

Coming back to this after a while, I'd like to get this merged, but I'd also like to understand @shekari's last suggestion better. Can you explain it further?

Yep, sounds good.

@elibarzilay ping

@juanfra684 can you rebase this onto the now-split-up tree? 
@rmculpepper ping.

@jbclements I think no one really owns this code and you should just merge this.

SGTM

Sent from a mobile device.
On Sep 10, 2013 5:58 PM, "Vincent St-Amour" notifications@github.com
wrote:

> Yep, sounds good.
> 
> —
> Reply to this email directly or view it on GitHubhttps://github.com/plt/racket/pull/361#issuecomment-24206251
> .

No need to rebase. I'll see if I can create an OpenBSD VM tomorrow to test the change.

I have reworked the patch to expose the generic `(input)` formlet instead of moving the code to `(text-input)`. It seems better this way.

Just FYI, I didn't test the change. Maybe it's wrong in the values used 
but I'm sure we only support iodbc.

If you need help with the installation of OpenBSD, just ping me. Here a 
quick list of steps:
- Install OpenBSD -current, don't use the stable version. Grab the 
  install54.iso file from 
  http://ftp.fr.openbsd.org/pub/OpenBSD/snapshots/amd64. Don't deselect 
  the X sets in the last step of the installer.
- Login as root.
- cd /usr && cvs -danoncvs@anoncvs.fr.openbsd.org:/cvs get -P ports 
- cd /usr/ports/devel/git && make install
- cd /usr/ports && git clone https://github.com/jasperla/openbsd-wip.git
- echo 'PORTSDIR_PATH=${PORTSDIR}:$(PORTSDIR)/openbsd-wip' >/etc/mk.conf
- cd /usr/ports/openbsd-wip/lang/racket && make install

It will take a few hours but is a fully automated process. The version 
of racket is 5.3.6.

This patch is good and should be merged. Do I do it @samth?

Yes, but don't use the green button -- that generates an ugly merge
commit.  Just pull and rebase, and then push. Eli also has helpful hints
for dealing with PRs here:
http://git.racket-lang.org/intro.html#collaborating_with_others_merging_github_pull_requests

On Wed, Sep 11, 2013 at 10:14 AM, Jay McCarthy notifications@github.comwrote:

> This patch is good and should be merged. Do I do it @samthhttps://github.com/samth
> ?
> 
> —
> Reply to this email directly or view it on GitHubhttps://github.com/plt/racket/pull/435#issuecomment-24242877
> .

Done

I pushed two new commits that implements objects for functions that can refer to outer lambdas. This allows occurrence typing to work on curried predicates.

The new filter syntax is `(Type @ 1 0)`, for example, to refer to the first argument of the surrounding lambda. The actual objects are now all represented as pairs (though the `-filter` syntax used internally will work unchanged; if you supply `n` it'll be converted to `(0 n)`.).

I added more comments. Also, I now realize my commit message with the type examples is slightly wrong. I'll fix that when I do commit surgery before pushing.

So, I have pushed the first part. So I have already added slightly more complicated examples to known bugs which show that the existing code already has issues with 'exp' and '-' which were the two regressions found. This is because the treatment of floats became more regular and thus the bad treatment of floats cropped up in more places. I don't think that this should wait till those get fixed because fixing those issues will likely require changing the code in this file and it would be much easier if it was cleaner.

Sounds good. Let's push this for now, and then fix the bugs.

LGTM

My point was that the algorithim as currently written is fairly complicated and I saw a way of cleaning it up.

@takikawa is not changing the actual checking code, just the order in which bindings are being looked at, and I had shown an example where the new order is still not sufficient. I'm suggesting we have two parts one to determine the order and one to check in that order. That makes it so that changing to tarjan's algorithm or something doesn't need to touch the checking code.

Merged, thanks.

Merged, thanks.

Awesome - thank you so much for reviewing and merging it!

On 09/13/2013 07:30 PM, Ryan Culpepper wrote:

> Merged, thanks.
> 
> —
> Reply to this email directly or view it on GitHub 
> https://github.com/plt/racket/pull/426#issuecomment-24431318.

Merged - thanks!

Merged already.

Looks like, with your change, all calls to `type->contract` have a call to `type->contract-fail` as their failure argument. Why not have `type->contract` take the first set of arguments of `type->contract-fail` directly? That would simplify its interface.

Other than that, LGTM.

There are three uses total that don't use `type->contract-fail`, though only one of them really matters. In `provide-handling.rkt`, there's a use that provides a failure thunk that doesn't throw an error and returns `#f`.

This looks good to me with comments as in-line.

What if there is some code out that requires, say, setup/option-unit or
launcher/launcher-unit?

Robby

On Tue, Sep 17, 2013 at 4:29 PM, Sam Tobin-Hochstadt <
notifications@github.com> wrote:

> ## This removes some units that I _think_ are unnecessary from the core.
> 
> You can merge this Pull Request by running
> 
>   git pull https://github.com/samth/racket master
> 
> Or view, comment on, or merge it at:
> 
>   https://github.com/plt/racket/pull/441
> Commit Summary
> - Fix some stale comments from unit removal.
> - Remove units in parts of `compiler`, `dynext`, `setup`.
> 
> File Changes
> - _A_ pkgs/compiler-lib/compiler/option-unit.rkthttps://github.com/plt/racket/pull/441/files#diff-0(7)
> - _R_ pkgs/compiler-lib/dynext/file-sig.rkthttps://github.com/plt/racket/pull/441/files#diff-1(0)
> - _A_ pkgs/compiler-lib/dynext/file-unit.rkthttps://github.com/plt/racket/pull/441/files#diff-2(7)
> - _R_ pkgs/compiler-lib/launcher/launcher-sig.rkthttps://github.com/plt/racket/pull/441/files#diff-3(0)
> - _A_ pkgs/compiler-lib/launcher/launcher-unit.rkthttps://github.com/plt/racket/pull/441/files#diff-4(7)
> - _R_ pkgs/compiler-lib/setup/option-sig.rkthttps://github.com/plt/racket/pull/441/files#diff-5(0)
> - _A_ pkgs/compiler-lib/setup/option-unit.rkthttps://github.com/plt/racket/pull/441/files#diff-6(6)
> - _M_ racket/collects/compiler/compiler-unit.rkthttps://github.com/plt/racket/pull/441/files#diff-7(11)
> - _A_ racket/collects/compiler/option.rkthttps://github.com/plt/racket/pull/441/files#diff-8(32)
> - _M_ racket/collects/dynext/dynext-sig.rkthttps://github.com/plt/racket/pull/441/files#diff-9(5)
> - _M_ racket/collects/dynext/dynext-unit.rkthttps://github.com/plt/racket/pull/441/files#diff-10(5)
> - _D_ racket/collects/dynext/file-unit.rkthttps://github.com/plt/racket/pull/441/files#diff-11(64)
> - _M_ racket/collects/dynext/file.rkthttps://github.com/plt/racket/pull/441/files#diff-12(71)
> - _M_ racket/collects/file/gzip.rkthttps://github.com/plt/racket/pull/441/files#diff-13(11)
> - _D_ racket/collects/launcher/launcher-unit.rkthttps://github.com/plt/racket/pull/441/files#diff-14(945)
> - _M_ racket/collects/launcher/launcher.rkthttps://github.com/plt/racket/pull/441/files#diff-15(998)
> - _D_ racket/collects/setup/option-unit.rkthttps://github.com/plt/racket/pull/441/files#diff-16(67)
> - _A_ racket/collects/setup/option.rkthttps://github.com/plt/racket/pull/441/files#diff-17(71)
> - _M_ racket/collects/setup/setup-go.rkthttps://github.com/plt/racket/pull/441/files#diff-18(31)
> - _M_ racket/collects/setup/setup-unit.rkthttps://github.com/plt/racket/pull/441/files#diff-19(12)
> - _M_ racket/collects/setup/setup.rkthttps://github.com/plt/racket/pull/441/files#diff-20(13)
> 
> Patch Links:
> - https://github.com/plt/racket/pull/441.patch
> - https://github.com/plt/racket/pull/441.diff

On Tue, Sep 17, 2013 at 5:35 PM, Robby Findler notifications@github.comwrote:

> What if there is some code out that requires, say, setup/option-unit or
> launcher/launcher-unit?

I put those in `compiler-lib`, for lack of a more obvious place.

Sam

Oh, I see. I misread things.

Robby

On Tue, Sep 17, 2013 at 4:37 PM, Sam Tobin-Hochstadt <
notifications@github.com> wrote:

> On Tue, Sep 17, 2013 at 5:35 PM, Robby Findler <notifications@github.com
> 
> > wrote:
> > 
> > What if there is some code out that requires, say, setup/option-unit or
> > launcher/launcher-unit?
> 
> I put those in `compiler-lib`, for lack of a more obvious place.
> 
> Sam
> 
> —
> Reply to this email directly or view it on GitHubhttps://github.com/plt/racket/pull/441#issuecomment-24624644
> .

On Tue, Sep 17, 2013 at 5:41 PM, Robby Findler notifications@github.comwrote:

> Oh, I see. I misread things.

Unfortunately, git doesn't make it easy on you by doing a terrible job with
rename tracking here.

I worry about moving the body of `setup:option@` into a module. Those parameters are sometimes set imperatively, as in `setup/setup`, with the expectation that the settings go away along with the unit instance.

It's also worth nothing that units like `compiler@` are documented as having certain imports. How much do we care about that incompatibility?

On Tue, Sep 17, 2013 at 5:53 PM, Matthew Flatt notifications@github.com wrote:

> I worry about moving the body of setup:option@ into a module. Those parameters are sometimes set imperatively, as in setup/setup, with the expectation that the settings go away along with the unit instance.

Could we just change `setup/setup` here? `setup-go` seems like a
different case, since I think it's intended to be the only thing run,
although I certainly don't know this code that well.

> It's also worth nothing that units like compiler@ are documented as having certain imports. How much do we care about that incompatibility?

I don't know.  Do we think that other people have used this code? Is
there a way we could make `compiler@` do something
backwards-compatible?

Finally, I started on this because I hope to remove more of the units
in this part of the code base, with an eye to a 'base2' package that
doesn't need to ship `racket/unit` at all. But if you think that's
unlikely to ever happen, then I may not bother. Alternatively, if that
happening would allow us to do something better with `compiler@` etc,
then maybe that's the right solution.

Sam

Merged (see commit 0b78356be72274c07553047f5f95614e329617c3)

I've just updated this to remove significantly more units.  It appears that the dynext units were not actually used by setup or compiler. That allowed me to turn `compiler-unit` into just a module, since its sole bit of state is a gensym. If this seems reasonable, I think I can make `setup-unit` just a module as well, which gets `dynamic-require`d by `setup.rkt` and `setup-go.rkt`. At that point, there wouldn't be any more units in 'base'.  Additionally, it would let us do better on the backwards compat front, b/c we'd be free to provide units with arbitrary imports in the `compiler-lib` pkg.

Yes, I can imagine `setup-unit` turning into a big function instead of a unit. I think the state in `setup-unit` should be confined to a function call, though, as opposed to a module instantiation.

I've updated this PR so that all the units are now gone from `racket/collects`.  There's now a to-do list in the description of the PR.

Thoughts on backwards compat.  There are a few things we could want to preserve:
1. That, say, `setup/setup-unit` provides a unit called `setup@`.  
2. That `setup@` runs something like `raco setup` when invoked. 
3.  That the unit has imports with the appropriate signatures. Note that this isn't required for linking it with other units that provided the old signatures, at least with new style inferred unit linking. Not sure about older-style.
4. That `setup@` actually _uses_ the settings provided by the other units.

(0) is what this PR currently does. (1) seems like the minimum acceptable level. (2) would be easy to implement. 

(3) would be hard to implement -- it would have to re-implement much of the file now called `setup-core.rkt`. 

Based on what we decide to do here, the other units that have non-trival import sets could be handled similarly.

Depending on what the state actually is, it sure seems like 4 would be the
default thing you'd want to do, since that doesn't break backwards
compatibility (and I'd put backwards compatibility over a small base, all
else being equal).

If the units are simple enough, you could probably make a simple set of
macros that just turned things into functions.

Robby

On Wed, Sep 18, 2013 at 3:10 PM, Sam Tobin-Hochstadt <
notifications@github.com> wrote:

> Thoughts on backwards compat. There are a few things we could want to
> preserve:
> 1. That, say, setup/setup-unit provides a unit called setup@.
>    1. That setup@ runs something like raco setup when invoked.
> 2. That the unit has imports with the appropriate signatures. Note
>    that this isn't required for linking it with other units that provided the
>    old signatures, at least with new style inferred unit linking. Not sure
>    about older-style.
> 3. That setup@ actually uses the settings provided by the other units.
> 
> (0) is what this PR currently does. (1) seems like the minimum acceptable
> level. (2) would be easy to implement.
> 
> (3) would be hard to implement -- it would have to re-implement much of
> the file now called setup-core.rkt.
> 
> Based on what we decide to do here, the other units that have non-trival
> import sets could be handled similarly.
> 
> —
> Reply to this email directly or view it on GitHubhttps://github.com/plt/racket/pull/441#issuecomment-24695223
> .

Considering the `setup@` unit, there are a few kinds of imports:
- `compiler^`: this is a bunch of functions, with basically no state. Theoretically, a different implementation of this can be provided, but I'd be surprised if that's ever happened.
- `dynext:file^`: theoretically, you might want to configure this stuff, but again, I doubt it.
- `setup-options^`: these are actual options, which someone might have set.

We could, I think, implement a version that used the imports that are options, without using the imports that are implementations of core components (and which probably have never had multiple implementations).  That would avoid having two implementations of 'raco setup' without breaking backwards compatibility.

I don't have a good sense of where to draw the line here.

Could you do some horrible namespace-based hacking in the unitized version
of programs and put that code into the compatibility lib with appropriate
warnings in the docs? That way, some old code would still be likely to
work, at least, if it does that stuff?

Robby

On Wed, Sep 18, 2013 at 3:26 PM, Sam Tobin-Hochstadt <
notifications@github.com> wrote:

> Considering the setup@ unit, there are a few kinds of imports:
> - compiler^: this is a bunch of functions, with basically no state.
>   Theoretically, a different implementation of this can be provided, but I'd
>   be surprised if that's ever happened.
> - dynext:file^: theoretically, you might want to configure this stuff,
>   but again, I doubt it.
> - setup-options^: these are actual options, which someone might have
>   set.
> 
> We could, I think, implement a version that used the imports that are
> options, without using the imports that are implementations of core
> components (and which probably have never had multiple implementations).
> That would avoid having two implementations of 'raco setup' without
> breaking backwards compatibility.
> 
> —
> Reply to this email directly or view it on GitHubhttps://github.com/plt/racket/pull/441#issuecomment-24696456
> .

On Wed, Sep 18, 2013 at 4:29 PM, Robby Findler notifications@github.comwrote:

> Could you do some horrible namespace-based hacking in the unitized version
> of programs and put that code into the compatibility lib with appropriate
> warnings in the docs? That way, some old code would still be likely to
> work, at least, if it does that stuff?

I don't know what kind of hacking you're suggesting. I'm happy to try all
sorts of horrible hacks if you can be a little more concrete, though.

Sam

I'm thinking of something where the original code had a unit with imports
x,y, and z (variables). Then you set up some private module somewhere with
a require that pulls in x,y, and z via some well-known name. Then, in the
compatibility-lib code you know that this private module exists and so you
carefully craft a namespace that has the well-known name'd module with the
x,y, and z exports but actually defined via the unit's imports (so the
carefully crafted namespace is built inside some unit somewhere).

To make this work in the most easy way, it might be best to actually 'read'
the code in and eval it, after munging the require line. That would make
the careful construction of the namespace easier going, I think.

Robby

On Wed, Sep 18, 2013 at 3:36 PM, Sam Tobin-Hochstadt <
notifications@github.com> wrote:

> On Wed, Sep 18, 2013 at 4:29 PM, Robby Findler <notifications@github.com
> 
> > wrote:
> > 
> > Could you do some horrible namespace-based hacking in the unitized
> > version
> > of programs and put that code into the compatibility lib with appropriate
> > warnings in the docs? That way, some old code would still be likely to
> > work, at least, if it does that stuff?
> 
> I don't know what kind of hacking you're suggesting. I'm happy to try all
> sorts of horrible hacks if you can be a little more concrete, though.
> 
> Sam
> 
> —
> Reply to this email directly or view it on GitHubhttps://github.com/plt/racket/pull/441#issuecomment-24697156
> .

Ah, ok.  I think I see how that could work.

The solution of just copying all the code might be easier than that,
though. :)

Option 2 sounds likely to be a good compromise between providing good compatibility and going too far out of our way to provide compatibility that no one uses.

Ok, I implemented option 2. Any thoughts on what tests I should run, other than the basic racket tests?

This is now basically done. @mflatt, do you have any further thoughts on `setup-options`? Should I change something to dynamically create the state it uses?

Also, is there anything else that I should do before merging this?

Thanks!

I think that places that imperatively set options should be changed to use `parameterize`, and that should be good enough.

If you can make that change, then I'll double-check the packages tests and that installers build, and then we can merge.

This is now done.  Sadly, there's not a good way to do conditional parameterization, so I did it the hard way.

I'm happy to test the snapshot build as well.  I'll let you know how that goes.

I sucessfully built both a minimal and a regular installer with this patch. 

I'll take a close look today, but everything looks good so far.

Still looks good. I think you should merge it.

I like the semantics here, but why not just make the `App` representation always use a list?

Single app patterns are much more common. I wanted to avoid some allocation. If you don't think that's a big deal, I can go change it.
-Ian
----- Original Message -----
From: Sam Tobin-Hochstadt notifications@github.com
To: plt/racket racket@noreply.github.com
Cc: J. Ian Johnson ianj@ccs.neu.edu
Sent: Sun, 29 Sep 2013 01:47:35 -0400 (EDT)
Subject: Re: [racket] Conservative extension to match so that app patterns may produce and con... (#447)

I like the semantics here, but why not just make the `App` representation always use a list?

---

Reply to this email directly or view it on GitHub:
https://github.com/plt/racket/pull/447#issuecomment-25314912

That amount of allocation is pretty trivial in comparison to what the rest
of 'match' does.
On Sep 29, 2013 8:10 AM, "J. Ian Johnson" notifications@github.com wrote:

> Single app patterns are much more common. I wanted to avoid some
> allocation. If you don't think that's a big deal, I can go change it.
> -Ian
> ----- Original Message -----
> From: Sam Tobin-Hochstadt notifications@github.com
> To: plt/racket racket@noreply.github.com
> Cc: J. Ian Johnson ianj@ccs.neu.edu
> Sent: Sun, 29 Sep 2013 01:47:35 -0400 (EDT)
> Subject: Re: [racket] Conservative extension to match so that app patterns
> may produce and con... (#447)
> 
> I like the semantics here, but why not just make the `App` representation
> always use a list?
> 
> ---
> 
> Reply to this email directly or view it on GitHub:
> https://github.com/plt/racket/pull/447#issuecomment-25314912
> 
> —
> Reply to this email directly or view it on GitHubhttps://github.com/plt/racket/pull/447#issuecomment-25319178
> .

Change pushed.
-Ian
----- Original Message -----
From: "Sam Tobin-Hochstadt" notifications@github.com
To: "plt/racket" racket@noreply.github.com
Cc: "J. Ian Johnson" ianj@ccs.neu.edu
Sent: Sunday, September 29, 2013 8:36:35 AM GMT -05:00 US/Canada Eastern
Subject: Re: [racket] Conservative extension to match so that app patterns may produce and con... (#447)

That amount of allocation is pretty trivial in comparison to what the rest 
of 'match' does. 
On Sep 29, 2013 8:10 AM, "J. Ian Johnson" notifications@github.com wrote: 

> Single app patterns are much more common. I wanted to avoid some 
> allocation. If you don't think that's a big deal, I can go change it. 
> -Ian 
> ----- Original Message ----- 
> From: Sam Tobin-Hochstadt notifications@github.com 
> To: plt/racket racket@noreply.github.com 
> Cc: J. Ian Johnson ianj@ccs.neu.edu 
> Sent: Sun, 29 Sep 2013 01:47:35 -0400 (EDT) 
> Subject: Re: [racket] Conservative extension to match so that app patterns 
> may produce and con... (#447) 
> 
> I like the semantics here, but why not just make the `App` representation 
> always use a list? 
> 
> ---
> 
> Reply to this email directly or view it on GitHub: 
> https://github.com/plt/racket/pull/447#issuecomment-25314912 
> 
> — 
> Reply to this email directly or view it on GitHubhttps://github.com/plt/racket/pull/447#issuecomment-25319178 
> . 

— 
Reply to this email directly or view it on GitHub .

One little comment, then I'll merge it.

Merged.

I'm sorry: I'd meant to take a careful look at this today but I didn't have
time. The first few questions I have tho, are:
- Can you please add some more documentation on what cache-poison does?
  (An English explanation is the minimum, but you could also add a little
  discussion of why it is useful and an example if you were so inclined.)
- Have you tested to see if there are any performance issues with this?
  Not that I expect there to be, but how does, say, five metafunctions that
  call each other (in a loop) with cache-poisioning compare to the current
  git version of Redex where metafunction caching is just disabled upfront
  for all metafunctions?

Thanks!

Robby

On Tue, Oct 1, 2013 at 11:40 AM, Justin Slepak notifications@github.comwrote:

> A metafunction with the #:cache-poison keyword will not have its results
> cached. Other metafunction results which depend on an uncached
> metafunction are also not cached. Some of the parsing logic in
> split-out-contract is changed to allow the keyword to be checked more
> easily. The metafunction structure has an additional boolean field
> 
> ## indicating whether its results should be cached.
> 
> You can merge this Pull Request by running
> 
>   git pull https://github.com/jrslepak/racket master
> 
> Or view, comment on, or merge it at:
> 
>   https://github.com/plt/racket/pull/449
> Commit Summary
> - Allow caching to be disabled for individual metafunctions.
> 
> File Changes
> - _M_ pkgs/redex-pkgs/redex-doc/redex/scribblings/ref.scrblhttps://github.com/plt/racket/pull/449/files#diff-0(5)
> - _M_ pkgs/redex-pkgs/redex-lib/redex/private/judgment-form.rkthttps://github.com/plt/racket/pull/449/files#diff-1(99)
> - _M_ pkgs/redex-pkgs/redex-lib/redex/private/reduction-semantics.rkthttps://github.com/plt/racket/pull/449/files#diff-2(26)
> - _M_ pkgs/redex-pkgs/redex-lib/redex/private/term-fn.rkthttps://github.com/plt/racket/pull/449/files#diff-3(4)
> - _M_ pkgs/redex-pkgs/redex-lib/redex/private/term.rkthttps://github.com/plt/racket/pull/449/files#diff-4(33)
> - _A_ pkgs/redex-pkgs/redex-test/redex/tests/cache-poisoning-test.rkthttps://github.com/plt/racket/pull/449/files#diff-5(50)
> - _M_ pkgs/redex-pkgs/redex-test/redex/tests/run-tests.rkthttps://github.com/plt/racket/pull/449/files#diff-6(3)
> 
> Patch Links:
> - https://github.com/plt/racket/pull/449.patch
> - https://github.com/plt/racket/pull/449.diff

On 5.2, the "deep.rktl" test fails for me, which indicates that the stack size is not being handled correctly. My configuration has the stack size set to 4MB, but I guess that the initial stack has a smaller size.

If I change `# if OpenBSD < 201211` in "sconfig.h" to `# if 1`, then the test passes.

If the current code is right for 5.3, then maybe we should change the test to `OpenBSD < 201305`, but I'm not clear on the right change.

OpenBSD 5.4-current (GENERIC.MP) 47: Wed Oct  2 19:43:41 CEST 2013 and Racket 5.3.6.

There is a problem with the config of racket. With the stack size of my shell set to 4320, I ran the test in a loop for hours without problems. So, something is using more than 4096, I don't know if the culprit is Racket or OpenBSD.

I could to test racket again increasing STACK_SAFETY_MARGIN or decreasing UNIX_STACK_MAXIMUM. Let me know if you have a better idea.

With STACK_SAFETY_MARGIN 300000, the test works OK.

I ran the test on debian testing i386 (I changed the stack size to 4096) and openbsd -current amd64, both with racket 6.

I've found something interesting. The second line of the test on debian is: `non-tail loop overflows at 409600`. The same line on openbsd is: `non-tail loop overflows at 204800`. 

BTW, the test also crashes on racket 6 on openbsd -current amd64.

Merged.

Also very interested in this.  The problem seems to lie with the components depending on cairo, and specifically the quartz surface backing them.  As far as I can tell, wxWidgets are no longer used.   

Racket's cocoa components (this doesn't include the editor) can be made to render correctly with this following patch (same idea as suggested by @dignati ).  

https://developer.apple.com/library/mac/documentation/GraphicsAnimation/Conceptual/HighResolutionOSX/Explained/Explained.html#//apple_ref/doc/uid/TP40012302-CH4-SW1

```
--- a/racket/src/mac/osx_appl.rkt
+++ b/racket/src/mac/osx_appl.rkt
@@ -101,7 +101,9 @@
           (assoc-pair "CFBundleVersion"
                       ,(version))
           (assoc-pair "CFBundleShortVersionString"
-                      ,(version))))
+                      ,(version))
+          (assoc-pair "NSPrincipalClass" "NSApplicationMain")
+          (assoc-pair "NSHighResolutionCapable" (true))))

     (create-app (build-path (current-directory) (if for-3m? 'up 'same))
                 (string-append "GRacket" suffix)
```

Any thoughts on this? In particular, @mflatt, do you have any feedback?

This is obviously a crude hack, but I was able to get better text rendering scaling by 0.5, and doubling the canvas area and font sizes.  Mouse clicks won't work though, so the hit test code will need fixing.

OSX will fire off 'NSWindowDidChangeBackingPropertiesNotification' notifications when the resolution changes, so the general solution should use this to set a common scaling factor to be applied to all affected parts. 

![screen shot 2013-10-07 at 1 08 29 pm](https://f.cloud.github.com/assets/1326784/1283481/f5950004-2f84-11e3-9ffb-d3f58420bd1a.png)

```
diff --git a/native-pkgs b/native-pkgs
--- a/native-pkgs
+++ b/native-pkgs
@@ -1 +1 @@
-Subproject commit 5f391155f276da25df85081cf8c80a9760a404b0
+Subproject commit 5f391155f276da25df85081cf8c80a9760a404b0-dirty
diff --git a/pkgs/gui-pkgs/gui-lib/mred/private/wx/cocoa/canvas.rkt b/pkgs/gui-pkgs/gui-lib/mred/private/wx/cocoa/canvas.rkt
index 6613d6c..63d477e 100644
--- a/pkgs/gui-pkgs/gui-lib/mred/private/wx/cocoa/canvas.rkt
+++ b/pkgs/gui-pkgs/gui-lib/mred/private/wx/cocoa/canvas.rkt
@@ -435,7 +435,7 @@
      (define/public (on-paint) (void))

      (define/override (set-size x y w h)
-       (do-set-size x y w h))
+       (do-set-size x y (* 2 w) (* 2 h)))

      (define tr 0)

diff --git a/pkgs/gui-pkgs/gui-lib/mred/private/wx/cocoa/dc.rkt b/pkgs/gui-pkgs/gui-lib/mred/private/wx/cocoa/dc.rkt
index 94c4632..d441a6a 100644
--- a/pkgs/gui-pkgs/gui-lib/mred/private/wx/cocoa/dc.rkt
+++ b/pkgs/gui-pkgs/gui-lib/mred/private/wx/cocoa/dc.rkt
@@ -96,7 +96,7 @@
              (let ([cg (tell #:type _CGContextRef ctx graphicsPort)])
                (unless (send canvas is-flipped?)
                  (CGContextTranslateCTM cg 0 (unbox h))
-                 (CGContextScaleCTM cg 1 -1))
+                 (CGContextScaleCTM cg 0.5 -0.5))
                (CGContextTranslateCTM cg dx dy)
                (let* ([surface (cairo_quartz_surface_create_for_cg_context cg (unbox w) (unbox h))]
                       [cr (cairo_create surface)])
```

I am just dropping the links below in the hope, that they are useful. If I
understand correctly Apple has separated the concepts of "point in users
pace" and "pixel". Now a point corresponds to 4 pixels. Is there a
rationale anywhere? /Jens Axel APIs for Supporting High Resolution
https://developer.apple.com/library/mac/documentation/GraphicsAnimation/Conceptual/HighResolutionOSX/APIs/APIs.html#//apple_ref/doc/uid/TP40012302-CH5-SW2

https://developer.apple.com/high-resolution/

2013/10/7 Tom McNulty notifications@github.com

> This is obviously a crude hack, but I was able to get better text
> rendering scaling by 0.5, and doubling the canvas area and font sizes.
> Mouse clicks won't work though, so the hit test code will need fixing.
> 
> OSX will fire off 'NSWindowDidChangeBackingPropertiesNotification'
> notifications when the resolution changes, so the general solution should
> use this to set a common scaling factor to be applied to all affected
> parts.
> 
> [image: screen shot 2013-10-07 at 1 08 29 pm]https://f.cloud.github.com/assets/1326784/1283481/f5950004-2f84-11e3-9ffb-d3f58420bd1a.png
> 
> diff --git a/native-pkgs b/native-pkgs
> --- a/native-pkgs
> +++ b/native-pkgs
> @@ -1 +1 @@
> -Subproject commit 5f391155f276da25df85081cf8c80a9760a404b0
> +Subproject commit 5f391155f276da25df85081cf8c80a9760a404b0-dirty
> diff --git a/pkgs/gui-pkgs/gui-lib/mred/private/wx/cocoa/canvas.rkt b/pkgs/gui-pkgs/gui-lib/mred/private/wx/cocoa/canvas.rkt
> index 6613d6c..63d477e 100644
> --- a/pkgs/gui-pkgs/gui-lib/mred/private/wx/cocoa/canvas.rkt
> +++ b/pkgs/gui-pkgs/gui-lib/mred/private/wx/cocoa/canvas.rkt
> @@ -435,7 +435,7 @@
>       (define/public (on-paint) (void))
> 
> ```
>   (define/override (set-size x y w h)
> ```
> -       (do-set-size x y w h))
> - ```
>     (do-set-size x y (* 2 w) (* 2 h)))
>   ```
>   
>     (define tr 0)
> 
> diff --git a/pkgs/gui-pkgs/gui-lib/mred/private/wx/cocoa/dc.rkt b/pkgs/gui-pkgs/gui-lib/mred/private/wx/cocoa/dc.rkt
> index 94c4632..d441a6a 100644
> --- a/pkgs/gui-pkgs/gui-lib/mred/private/wx/cocoa/dc.rkt
> +++ b/pkgs/gui-pkgs/gui-lib/mred/private/wx/cocoa/dc.rkt
> @@ -96,7 +96,7 @@
>               (let ([cg (tell #:type _CGContextRef ctx graphicsPort)])
>                 (unless (send canvas is-flipped?)
>                   (CGContextTranslateCTM cg 0 (unbox h))
> -                 (CGContextScaleCTM cg 1 -1))
> -                 (CGContextScaleCTM cg 0.5 -0.5))
>               (CGContextTranslateCTM cg dx dy)
>               (let\* ([surface (cairo_quartz_surface_create_for_cg_context cg (unbox w) (unbox h))]
>                      [cr (cairo_create surface)])
> 
> —
> Reply to this email directly or view it on GitHubhttps://github.com/plt/racket/issues/371#issuecomment-25836828
> .

## 

## 

Jens Axel Søgaard

Commas make the output much more readable, so I prefer the approach of 31ec8aa. Either way, use `intptr_t` instead of `long long`, and format with `PRIdPTR` instead of `"%lld"`.

What about `pin-label-line`?

Could you also add documentation for the `#:solid?` arguments?

Done.
-Ian
----- Original Message -----
From: "Vincent St-Amour" notifications@github.com
To: "plt/racket" racket@noreply.github.com
Cc: "J. Ian Johnson" ianj@ccs.neu.edu
Sent: Monday, October 7, 2013 6:16:31 PM GMT -05:00 US/Canada Eastern
Subject: Re: [racket] Unstable arrow interface update (#451)

Could you also add documentation for the #:solid? arguments? 

— 
Reply to this email directly or view it on GitHub .

Merged, thanks!

This was merged.

Can you split the rackunit changes out into a separate PR?

Since this is a really big pile of code, is it possible to either (a) split some of it out, like the test case changes, or (b) provide a summary of what's going on? Or maybe both :)

I meant to say that I would do that in the initial message but somehow a not got in there. Right now this is just a code dump of what I've done so far, I will be cleaning it up and splitting into multiple PRs before expecting you to actually review it. But I wanted to put it up so that you could make high level comments if you wanted.

Ok, sounds good.  Personally, I recently used the markdown checkboxes for marking progress on a PR recently (#441) and it was quite helpful.

Merged.

This seems to have some test failures; see here: https://travis-ci.org/plt/racket/jobs/12278562#L1669

I'll take the steps needed to apply the "startup.rktl" change (which makes the tests pass) and then merge.

Thanks!

@jeapostrophe I'd particularly like your feedback on the implementation here.

I think it is acceptable and should be merged.

But please also check uses of `raco pkg install` that might need to add the `--pkgs` flag. I think all of the uses in the top-level `Makefile` probably need it, and the one on line 433 could specifically go wrong if `PKGS` is empty.

This is great, thanks! I've pushed it.

Robby

On Sat, Oct 12, 2013 at 8:21 AM, Laurent Orseau notifications@github.comwrote:

> Adds two menu items in DrRacket/Windows: Move Tab Left and Move Tab Right,
> that swap the currently active tab in DrRacket with its left-hand or
> right-hand neighbor.
> Adds also a more generic method in drracket/private/unit.rkt to allow for
> 
> ## arbitrary reordering of the tabs.
> 
> You can merge this Pull Request by running
> 
>   git pull https://github.com/Metaxal/racket reorder-tabs
> 
> Or view, comment on, or merge it at:
> 
>   https://github.com/plt/racket/pull/455
> Commit Summary
> - Add reorder tabs facility in DrRacket
> 
> File Changes
> - _A_ pkgs/drracket-pkgs/drracket-test/tests/drracket/reorder-tabs.rkthttps://github.com/plt/racket/pull/455/files#diff-0(21)
> - _M_ pkgs/drracket-pkgs/drracket/drracket/private/main.rkthttps://github.com/plt/racket/pull/455/files#diff-1(18)
> - _M_ pkgs/drracket-pkgs/drracket/drracket/private/unit.rkthttps://github.com/plt/racket/pull/455/files#diff-2(47)
> - _M_ pkgs/drracket-pkgs/drracket/scribblings/tools/unit.scrblhttps://github.com/plt/racket/pull/455/files#diff-3(20)
> - _M_
>   pkgs/string-constants/string-constants-lib/string-constants/private/english-string-constants.rkthttps://github.com/plt/racket/pull/455/files#diff-4(2)
> - _M_
>   pkgs/string-constants/string-constants-lib/string-constants/private/french-string-constants.rkthttps://github.com/plt/racket/pull/455/files#diff-5(2)
> 
> Patch Links:
> - https://github.com/plt/racket/pull/455.patch
> - https://github.com/plt/racket/pull/455.diff

I've now audited all the uses of 'raco pkg install' in the tree.

Looking again, I think adding `--pkgs` to `X_AUTO_OPTIONS` is probably the right change in `Makefile`. Besides being simpler to main, the flag would get propagated to a `raco pkg install` hidden in `distro-build\install-pkgs`.

And one last request: the docs for command-line flags in "pkg.scrbl" need updating.

Thanks!

Both done.  Somehow I had thought that the flag docs were autogenerated,
but maybe that's just the command line help text.

On Sun, Oct 13, 2013 at 8:52 AM, Matthew Flatt notifications@github.comwrote:

> Looking again, I think adding --pkgs to X_AUTO_OPTIONS is probably the
> right change in Makefile. Besides being simpler to main, the flag would
> get propagated to a raco pkg install hidden in distro-build\install-pkgs.
> 
> And one last request: the docs for command-line flags in "pkg.scrbl" need
> updating.
> 
> Thanks!
> 
> —
> Reply to this email directly or view it on GitHubhttps://github.com/plt/racket/pull/454#issuecomment-26218184
> .

Yes. Looks ready to merge to me.

I just tried to run the pkg system tests, and I got this error:

```
# Starting... local file fails due to mismatch with specified checksum
$ raco pkg install --checksum zzz test-pkgs/pkg-a-first.plt
raco pkg install: no such file
  path: test-pkgs/pkg-a-first.plt
Check failure
  context...:
   check-regexp-match1663011
   /home/samth/sw/plt/racket/collects/racket/private/map.rkt:53:19: loop
   /home/samth/tmp/plt/pkgs/racket-pkgs/racket-test/tests/pkg/test.rkt: [running body]
```

I don't think this is caused by my changes -- it happens on master too.  @jeapostrophe, is this expected? Is it safe to just merge anyway?

You ran all the tests? You need to run create before the others will work.

On Sun, Oct 13, 2013 at 8:25 AM, Sam Tobin-Hochstadt <
notifications@github.com> wrote:

> I just tried to run the pkg system tests, and I got this error:
> 
> # Starting... local file fails due to mismatch with specified checksum
> 
> $ raco pkg install --checksum zzz test-pkgs/pkg-a-first.plt
> raco pkg install: no such file
>   path: test-pkgs/pkg-a-first.plt
> Check failure
>   context...:
>    check-regexp-match1663011
>    /home/samth/sw/plt/racket/collects/racket/private/map.rkt:53:19: loop
>    /home/samth/tmp/plt/pkgs/racket-pkgs/racket-test/tests/pkg/test.rkt: [running body]
> 
> I don't think this is caused by my changes -- it happens on master too.
> @jeapostrophe https://github.com/jeapostrophe, is this expected? Is it
> safe to just merge anyway?
> 
> —
> Reply to this email directly or view it on GitHubhttps://github.com/plt/racket/pull/454#issuecomment-26218839
> .

## 

Jay McCarthy jay@cs.byu.edu
Assistant Professor / Brigham Young University
http://faculty.cs.byu.edu/~jay

"The glory of God is Intelligence" - D&C 93

I got this from `racket test.rkt`.  This also happens with `racket
test-create.rkt` and then `racket test-install.rkt`. on master.

On Sun, Oct 13, 2013 at 9:29 AM, Jay McCarthy notifications@github.comwrote:

> You ran all the tests? You need to run create before the others will work.
> 
> On Sun, Oct 13, 2013 at 8:25 AM, Sam Tobin-Hochstadt <
> notifications@github.com> wrote:
> 
> > I just tried to run the pkg system tests, and I got this error:
> > 
> > # Starting... local file fails due to mismatch with specified checksum
> > 
> > $ raco pkg install --checksum zzz test-pkgs/pkg-a-first.plt
> > raco pkg install: no such file
> > path: test-pkgs/pkg-a-first.plt
> > Check failure
> > context...:
> > check-regexp-match1663011
> > /home/samth/sw/plt/racket/collects/racket/private/map.rkt:53:19: loop
> > /home/samth/tmp/plt/pkgs/racket-pkgs/racket-test/tests/pkg/test.rkt:
> > [running body]
> > 
> > I don't think this is caused by my changes -- it happens on master too.
> > @jeapostrophe https://github.com/jeapostrophe, is this expected? Is
> > it
> > safe to just merge anyway?
> > 
> > —
> > Reply to this email directly or view it on GitHub<
> > https://github.com/plt/racket/pull/454#issuecomment-26218839>
> > .
> 
> ## 
> 
> Jay McCarthy jay@cs.byu.edu
> Assistant Professor / Brigham Young University
> http://faculty.cs.byu.edu/~jay
> 
> "The glory of God is Intelligence" - D&C 93
> 
> —
> Reply to this email directly or view it on GitHubhttps://github.com/plt/racket/pull/454#issuecomment-26218920
> .

This looks like an ordering problem in the tests. I'll fix it.

I continue to be unable to run the package tests successfully on `master`.  I've merged this in the meantime, and I'll follow up separately about the tests.

Is it possible to bind the reordering to other keys?

It is standard in web browser that cmd+{ and cmd+} switch between tabs.
The current bindings are therefore somewhat confusing.

Perhaps alt+cmd+{ could move the tab?

/Jens Axel

2013/10/13 Robby Findler notifications@github.com

> This is great, thanks! I've pushed it.
> 
> Robby
> 
> On Sat, Oct 12, 2013 at 8:21 AM, Laurent Orseau <notifications@github.com
> 
> > wrote:
> > 
> > Adds two menu items in DrRacket/Windows: Move Tab Left and Move Tab
> > Right,
> > that swap the currently active tab in DrRacket with its left-hand or
> > right-hand neighbor.
> > Adds also a more generic method in drracket/private/unit.rkt to allow for
> > 
> > ## arbitrary reordering of the tabs.
> > 
> > You can merge this Pull Request by running
> > 
> > git pull https://github.com/Metaxal/racket reorder-tabs
> > 
> > Or view, comment on, or merge it at:
> > 
> > https://github.com/plt/racket/pull/455
> > Commit Summary
> > - Add reorder tabs facility in DrRacket
> > 
> > File Changes
> > - _A_ pkgs/drracket-pkgs/drracket-test/tests/drracket/reorder-tabs.rkt<
> >   https://github.com/plt/racket/pull/455/files#diff-0>(21)
> > - _M_ pkgs/drracket-pkgs/drracket/drracket/private/main.rkt<
> >   https://github.com/plt/racket/pull/455/files#diff-1>(18)
> > - _M_ pkgs/drracket-pkgs/drracket/drracket/private/unit.rkt<
> >   https://github.com/plt/racket/pull/455/files#diff-2>(47)
> > - _M_ pkgs/drracket-pkgs/drracket/scribblings/tools/unit.scrbl<
> >   https://github.com/plt/racket/pull/455/files#diff-3>(20)
> > - _M_
> > 
> > pkgs/string-constants/string-constants-lib/string-constants/private/english-string-constants.rkt<
> > https://github.com/plt/racket/pull/455/files#diff-4>(2)
> > - _M_
> > 
> > pkgs/string-constants/string-constants-lib/string-constants/private/french-string-constants.rkt<
> > https://github.com/plt/racket/pull/455/files#diff-5>(2)
> > 
> > Patch Links:
> > - https://github.com/plt/racket/pull/455.patch
> > - https://github.com/plt/racket/pull/455.diff
> 
> —
> Reply to this email directly or view it on GitHubhttps://github.com/plt/racket/pull/455#issuecomment-26208454
> .

## 

## 

Jens Axel Søgaard

Oh, sure. I've pushed that.

Better unix/windows keybinding suggestions welcome....

Robby

On Mon, Oct 14, 2013 at 1:50 PM, Jens Axel Søgaard <notifications@github.com

> wrote:
> 
> Is it possible to bind the reordering to other keys?
> 
> It is standard in web browser that cmd+{ and cmd+} switch between tabs.
> The current bindings are therefore somewhat confusing.
> 
> Perhaps alt+cmd+{ could move the tab?
> 
> /Jens Axel
> 
> 2013/10/13 Robby Findler notifications@github.com
> 
> > This is great, thanks! I've pushed it.
> > 
> > Robby
> > 
> > On Sat, Oct 12, 2013 at 8:21 AM, Laurent Orseau <
> > notifications@github.com
> > 
> > > wrote:
> > > 
> > > Adds two menu items in DrRacket/Windows: Move Tab Left and Move Tab
> > > Right,
> > > that swap the currently active tab in DrRacket with its left-hand or
> > > right-hand neighbor.
> > > Adds also a more generic method in drracket/private/unit.rkt to allow
> > > for
> > > 
> > > ## arbitrary reordering of the tabs.
> > > 
> > > You can merge this Pull Request by running
> > > 
> > > git pull https://github.com/Metaxal/racket reorder-tabs
> > > 
> > > Or view, comment on, or merge it at:
> > > 
> > > https://github.com/plt/racket/pull/455
> > > Commit Summary
> > > - Add reorder tabs facility in DrRacket
> > > 
> > > File Changes
> > > - _A_
> > >   pkgs/drracket-pkgs/drracket-test/tests/drracket/reorder-tabs.rkt<
> > >   https://github.com/plt/racket/pull/455/files#diff-0>(21)
> > > - _M_ pkgs/drracket-pkgs/drracket/drracket/private/main.rkt<
> > >   https://github.com/plt/racket/pull/455/files#diff-1>(18)
> > > - _M_ pkgs/drracket-pkgs/drracket/drracket/private/unit.rkt<
> > >   https://github.com/plt/racket/pull/455/files#diff-2>(47)
> > > - _M_ pkgs/drracket-pkgs/drracket/scribblings/tools/unit.scrbl<
> > >   https://github.com/plt/racket/pull/455/files#diff-3>(20)
> > > - _M_
> > 
> > pkgs/string-constants/string-constants-lib/string-constants/private/english-string-constants.rkt<
> > 
> > https://github.com/plt/racket/pull/455/files#diff-4>(2)
> > 
> > > - _M_
> > 
> > pkgs/string-constants/string-constants-lib/string-constants/private/french-string-constants.rkt<
> > 
> > https://github.com/plt/racket/pull/455/files#diff-5>(2)
> > 
> > > Patch Links:
> > > - https://github.com/plt/racket/pull/455.patch
> > > - https://github.com/plt/racket/pull/455.diff
> > 
> > —
> > Reply to this email directly or view it on GitHub<
> > https://github.com/plt/racket/pull/455#issuecomment-26208454>
> > .
> 
> ## 
> 
> ## 
> 
> Jens Axel Søgaard
> 
> —
> Reply to this email directly or view it on GitHubhttps://github.com/plt/racket/pull/455#issuecomment-26279124
> .

Thanks.

/Jens Axel

2013/10/14 Robby Findler notifications@github.com

> Oh, sure. I've pushed that.
> 
> Better unix/windows keybinding suggestions welcome....
> 
> Robby
> 
> On Mon, Oct 14, 2013 at 1:50 PM, Jens Axel Søgaard <
> notifications@github.com
> 
> > wrote:
> > 
> > Is it possible to bind the reordering to other keys?
> > 
> > It is standard in web browser that cmd+{ and cmd+} switch between tabs.
> > The current bindings are therefore somewhat confusing.
> > 
> > Perhaps alt+cmd+{ could move the tab?
> > 
> > /Jens Axel
> > 
> > 2013/10/13 Robby Findler notifications@github.com
> > 
> > > This is great, thanks! I've pushed it.
> > > 
> > > Robby
> > > 
> > > On Sat, Oct 12, 2013 at 8:21 AM, Laurent Orseau <
> > > notifications@github.com
> > > 
> > > > wrote:
> > > > 
> > > > Adds two menu items in DrRacket/Windows: Move Tab Left and Move Tab
> > > > Right,
> > > > that swap the currently active tab in DrRacket with its left-hand or
> > > > right-hand neighbor.
> > > > Adds also a more generic method in drracket/private/unit.rkt to
> > > > allow
> > > > for
> > > > 
> > > > ## arbitrary reordering of the tabs.
> > > > 
> > > > You can merge this Pull Request by running
> > > > 
> > > > git pull https://github.com/Metaxal/racket reorder-tabs
> > > > 
> > > > Or view, comment on, or merge it at:
> > > > 
> > > > https://github.com/plt/racket/pull/455
> > > > Commit Summary
> > > > - Add reorder tabs facility in DrRacket
> > > > 
> > > > File Changes
> > > > - _A_
> > > >   pkgs/drracket-pkgs/drracket-test/tests/drracket/reorder-tabs.rkt<
> > > >   https://github.com/plt/racket/pull/455/files#diff-0>(21)
> > > > - _M_ pkgs/drracket-pkgs/drracket/drracket/private/main.rkt<
> > > >   https://github.com/plt/racket/pull/455/files#diff-1>(18)
> > > > - _M_ pkgs/drracket-pkgs/drracket/drracket/private/unit.rkt<
> > > >   https://github.com/plt/racket/pull/455/files#diff-2>(47)
> > > > - _M_ pkgs/drracket-pkgs/drracket/scribblings/tools/unit.scrbl<
> > > >   https://github.com/plt/racket/pull/455/files#diff-3>(20)
> > > > - _M_
> > 
> > pkgs/string-constants/string-constants-lib/string-constants/private/english-string-constants.rkt<
> > 
> > > https://github.com/plt/racket/pull/455/files#diff-4>(2)
> > > 
> > > > - _M_
> > 
> > pkgs/string-constants/string-constants-lib/string-constants/private/french-string-constants.rkt<
> > 
> > > https://github.com/plt/racket/pull/455/files#diff-5>(2)
> > > 
> > > > Patch Links:
> > > > - https://github.com/plt/racket/pull/455.patch
> > > > - https://github.com/plt/racket/pull/455.diff
> > > 
> > > —
> > > Reply to this email directly or view it on GitHub<
> > > https://github.com/plt/racket/pull/455#issuecomment-26208454>
> > > .
> > 
> > ## 
> > 
> > ## 
> > 
> > Jens Axel Søgaard
> > 
> > —
> > Reply to this email directly or view it on GitHub<
> > https://github.com/plt/racket/pull/455#issuecomment-26279124>
> > .
> 
> —
> Reply to this email directly or view it on GitHubhttps://github.com/plt/racket/pull/455#issuecomment-26281068
> .

## 

## 

Jens Axel Søgaard

Ctrl+[ has never been very intuitive for this task.
Maybe Ctrl+PageDown/Up for selecting the next/previous tab, and
Ctrl+Shift+PageDown/Up for moving tabs?

Laurent

On Mon, Oct 14, 2013 at 9:23 PM, Jens Axel Søgaard <notifications@github.com

> wrote:
> 
> Thanks.
> 
> /Jens Axel
> 
> 2013/10/14 Robby Findler notifications@github.com
> 
> > Oh, sure. I've pushed that.
> > 
> > Better unix/windows keybinding suggestions welcome....
> > 
> > Robby
> > 
> > On Mon, Oct 14, 2013 at 1:50 PM, Jens Axel Søgaard <
> > notifications@github.com
> > 
> > > wrote:
> > > 
> > > Is it possible to bind the reordering to other keys?
> > > 
> > > It is standard in web browser that cmd+{ and cmd+} switch between
> > > tabs.
> > > The current bindings are therefore somewhat confusing.
> > > 
> > > Perhaps alt+cmd+{ could move the tab?
> > > 
> > > /Jens Axel
> > > 
> > > 2013/10/13 Robby Findler notifications@github.com
> > > 
> > > > This is great, thanks! I've pushed it.
> > > > 
> > > > Robby
> > > > 
> > > > On Sat, Oct 12, 2013 at 8:21 AM, Laurent Orseau <
> > > > notifications@github.com
> > > > 
> > > > > wrote:
> > > > > 
> > > > > Adds two menu items in DrRacket/Windows: Move Tab Left and Move
> > > > > Tab
> > > > > Right,
> > > > > that swap the currently active tab in DrRacket with its left-hand
> > > > > or
> > > > > right-hand neighbor.
> > > > > Adds also a more generic method in drracket/private/unit.rkt to
> > > > > allow
> > > > > for
> > > > > 
> > > > > ## arbitrary reordering of the tabs.
> > > > > 
> > > > > You can merge this Pull Request by running
> > > > > 
> > > > > git pull https://github.com/Metaxal/racket reorder-tabs
> > > > > 
> > > > > Or view, comment on, or merge it at:
> > > > > 
> > > > > https://github.com/plt/racket/pull/455
> > > > > Commit Summary
> > > > > - Add reorder tabs facility in DrRacket
> > > > > 
> > > > > File Changes
> > > > > - _A_
> > > > >   pkgs/drracket-pkgs/drracket-test/tests/drracket/reorder-tabs.rkt<
> > > > >   https://github.com/plt/racket/pull/455/files#diff-0>(21)
> > > > > - _M_ pkgs/drracket-pkgs/drracket/drracket/private/main.rkt<
> > > > >   https://github.com/plt/racket/pull/455/files#diff-1>(18)
> > > > > - _M_ pkgs/drracket-pkgs/drracket/drracket/private/unit.rkt<
> > > > >   https://github.com/plt/racket/pull/455/files#diff-2>(47)
> > > > > - _M_ pkgs/drracket-pkgs/drracket/scribblings/tools/unit.scrbl<
> > > > >   https://github.com/plt/racket/pull/455/files#diff-3>(20)
> > > > > - _M_
> > 
> > pkgs/string-constants/string-constants-lib/string-constants/private/english-string-constants.rkt<
> > 
> > > > https://github.com/plt/racket/pull/455/files#diff-4>(2)
> > > > 
> > > > > - _M_
> > 
> > pkgs/string-constants/string-constants-lib/string-constants/private/french-string-constants.rkt<
> > 
> > > > https://github.com/plt/racket/pull/455/files#diff-5>(2)
> > > > 
> > > > > Patch Links:
> > > > > - https://github.com/plt/racket/pull/455.patch
> > > > > - https://github.com/plt/racket/pull/455.diff
> > > > 
> > > > —
> > > > Reply to this email directly or view it on GitHub<
> > > > https://github.com/plt/racket/pull/455#issuecomment-26208454>
> > > > .
> > > 
> > > ## 
> > > 
> > > ## 
> > > 
> > > Jens Axel Søgaard
> > > 
> > > —
> > > Reply to this email directly or view it on GitHub<
> > > https://github.com/plt/racket/pull/455#issuecomment-26279124>
> > > .
> > 
> > —
> > Reply to this email directly or view it on GitHub<
> > https://github.com/plt/racket/pull/455#issuecomment-26281068>
> > .
> 
> ## 
> 
> ## 
> 
> Jens Axel Søgaard
> 
> —
> Reply to this email directly or view it on GitHubhttps://github.com/plt/racket/pull/455#issuecomment-26281521
> .

What do common browsers do, do you know?

Robby

On Mon, Oct 14, 2013 at 2:34 PM, Laurent Orseau notifications@github.comwrote:

> Ctrl+[ has never been very intuitive for this task.
> Maybe Ctrl+PageDown/Up for selecting the next/previous tab, and
> Ctrl+Shift+PageDown/Up for moving tabs?
> 
> Laurent
> 
> On Mon, Oct 14, 2013 at 9:23 PM, Jens Axel Søgaard <
> notifications@github.com
> 
> > wrote:
> > 
> > Thanks.
> > 
> > /Jens Axel
> > 
> > 2013/10/14 Robby Findler notifications@github.com
> > 
> > > Oh, sure. I've pushed that.
> > > 
> > > Better unix/windows keybinding suggestions welcome....
> > > 
> > > Robby
> > > 
> > > On Mon, Oct 14, 2013 at 1:50 PM, Jens Axel Søgaard <
> > > notifications@github.com
> > > 
> > > > wrote:
> > > > 
> > > > Is it possible to bind the reordering to other keys?
> > > > 
> > > > It is standard in web browser that cmd+{ and cmd+} switch between
> > > > tabs.
> > > > The current bindings are therefore somewhat confusing.
> > > > 
> > > > Perhaps alt+cmd+{ could move the tab?
> > > > 
> > > > /Jens Axel
> > > > 
> > > > 2013/10/13 Robby Findler notifications@github.com
> > > > 
> > > > > This is great, thanks! I've pushed it.
> > > > > 
> > > > > Robby
> > > > > 
> > > > > On Sat, Oct 12, 2013 at 8:21 AM, Laurent Orseau <
> > > > > notifications@github.com
> > > > > 
> > > > > > wrote:
> > > > > > 
> > > > > > Adds two menu items in DrRacket/Windows: Move Tab Left and Move
> > > > > > Tab
> > > > > > Right,
> > > > > > that swap the currently active tab in DrRacket with its
> > > > > > left-hand
> > > > > > or
> > > > > > right-hand neighbor.
> > > > > > Adds also a more generic method in drracket/private/unit.rkt to
> > > > > > allow
> > > > > > for
> > > > > > 
> > > > > > ## arbitrary reordering of the tabs.
> > > > > > 
> > > > > > You can merge this Pull Request by running
> > > > > > 
> > > > > > git pull https://github.com/Metaxal/racket reorder-tabs
> > > > > > 
> > > > > > Or view, comment on, or merge it at:
> > > > > > 
> > > > > > https://github.com/plt/racket/pull/455
> > > > > > Commit Summary
> > > > > > - Add reorder tabs facility in DrRacket
> > > > > > 
> > > > > > File Changes
> > > > > > - _A_
> > > > > >   pkgs/drracket-pkgs/drracket-test/tests/drracket/reorder-tabs.rkt<
> > > > > >   https://github.com/plt/racket/pull/455/files#diff-0>(21)
> > > > > > - _M_ pkgs/drracket-pkgs/drracket/drracket/private/main.rkt<
> > > > > >   https://github.com/plt/racket/pull/455/files#diff-1>(18)
> > > > > > - _M_ pkgs/drracket-pkgs/drracket/drracket/private/unit.rkt<
> > > > > >   https://github.com/plt/racket/pull/455/files#diff-2>(47)
> > > > > > - _M_ pkgs/drracket-pkgs/drracket/scribblings/tools/unit.scrbl<
> > > > > >   https://github.com/plt/racket/pull/455/files#diff-3>(20)
> > > > > > - _M_
> > 
> > pkgs/string-constants/string-constants-lib/string-constants/private/english-string-constants.rkt<
> > 
> > > > > https://github.com/plt/racket/pull/455/files#diff-4>(2)
> > > > > 
> > > > > > - _M_
> > 
> > pkgs/string-constants/string-constants-lib/string-constants/private/french-string-constants.rkt<
> > 
> > > > > https://github.com/plt/racket/pull/455/files#diff-5>(2)
> > > > > 
> > > > > > Patch Links:
> > > > > > - https://github.com/plt/racket/pull/455.patch
> > > > > > - https://github.com/plt/racket/pull/455.diff
> > > > > 
> > > > > —
> > > > > Reply to this email directly or view it on GitHub<
> > > > > https://github.com/plt/racket/pull/455#issuecomment-26208454>
> > > > > .
> > > > 
> > > > ## 
> > > > 
> > > > ## 
> > > > 
> > > > Jens Axel Søgaard
> > > > 
> > > > —
> > > > Reply to this email directly or view it on GitHub<
> > > > https://github.com/plt/racket/pull/455#issuecomment-26279124>
> > > > .
> > > 
> > > —
> > > Reply to this email directly or view it on GitHub<
> > > https://github.com/plt/racket/pull/455#issuecomment-26281068>
> > > .
> > 
> > ## 
> > 
> > ## 
> > 
> > Jens Axel Søgaard
> > 
> > —
> > Reply to this email directly or view it on GitHub<
> > https://github.com/plt/racket/pull/455#issuecomment-26281521>
> > .
> 
> —
> Reply to this email directly or view it on GitHubhttps://github.com/plt/racket/pull/455#issuecomment-26282297
> .

This setup works in Firefox and Chrome at least (both for next/previous and
move tabs).

Laurent

On Mon, Oct 14, 2013 at 9:40 PM, Robby Findler notifications@github.comwrote:

> What do common browsers do, do you know?
> 
> Robby
> 
> On Mon, Oct 14, 2013 at 2:34 PM, Laurent Orseau notifications@github.comwrote:
> 
> > Ctrl+[ has never been very intuitive for this task.
> > Maybe Ctrl+PageDown/Up for selecting the next/previous tab, and
> > Ctrl+Shift+PageDown/Up for moving tabs?
> > 
> > Laurent
> > 
> > On Mon, Oct 14, 2013 at 9:23 PM, Jens Axel Søgaard <
> > notifications@github.com
> > 
> > > wrote:
> > > 
> > > Thanks.
> > > 
> > > /Jens Axel
> > > 
> > > 2013/10/14 Robby Findler notifications@github.com
> > > 
> > > > Oh, sure. I've pushed that.
> > > > 
> > > > Better unix/windows keybinding suggestions welcome....
> > > > 
> > > > Robby
> > > > 
> > > > On Mon, Oct 14, 2013 at 1:50 PM, Jens Axel Søgaard <
> > > > notifications@github.com
> > > > 
> > > > > wrote:
> > > > > 
> > > > > Is it possible to bind the reordering to other keys?
> > > > > 
> > > > > It is standard in web browser that cmd+{ and cmd+} switch between
> > > > > tabs.
> > > > > The current bindings are therefore somewhat confusing.
> > > > > 
> > > > > Perhaps alt+cmd+{ could move the tab?
> > > > > 
> > > > > /Jens Axel
> > > > > 
> > > > > 2013/10/13 Robby Findler notifications@github.com
> > > > > 
> > > > > > This is great, thanks! I've pushed it.
> > > > > > 
> > > > > > Robby
> > > > > > 
> > > > > > On Sat, Oct 12, 2013 at 8:21 AM, Laurent Orseau <
> > > > > > notifications@github.com
> > > > > > 
> > > > > > > wrote:
> > > > > > > 
> > > > > > > Adds two menu items in DrRacket/Windows: Move Tab Left and
> > > > > > > Move
> > > > > > > Tab
> > > > > > > Right,
> > > > > > > that swap the currently active tab in DrRacket with its
> > > > > > > left-hand
> > > > > > > or
> > > > > > > right-hand neighbor.
> > > > > > > Adds also a more generic method in drracket/private/unit.rkt
> > > > > > > to
> > > > > > > allow
> > > > > > > for
> > > > > > > 
> > > > > > > ## arbitrary reordering of the tabs.
> > > > > > > 
> > > > > > > You can merge this Pull Request by running
> > > > > > > 
> > > > > > > git pull https://github.com/Metaxal/racket reorder-tabs
> > > > > > > 
> > > > > > > Or view, comment on, or merge it at:
> > > > > > > 
> > > > > > > https://github.com/plt/racket/pull/455
> > > > > > > Commit Summary
> > > > > > > - Add reorder tabs facility in DrRacket
> > > > > > > 
> > > > > > > File Changes
> > > > > > > - _A_
> > > > > > >   pkgs/drracket-pkgs/drracket-test/tests/drracket/reorder-tabs.rkt<
> > > > > > >   https://github.com/plt/racket/pull/455/files#diff-0>(21)
> > > > > > > - _M_ pkgs/drracket-pkgs/drracket/drracket/private/main.rkt<
> > > > > > >   https://github.com/plt/racket/pull/455/files#diff-1>(18)
> > > > > > > - _M_ pkgs/drracket-pkgs/drracket/drracket/private/unit.rkt<
> > > > > > >   https://github.com/plt/racket/pull/455/files#diff-2>(47)
> > > > > > > - _M_
> > > > > > >   pkgs/drracket-pkgs/drracket/scribblings/tools/unit.scrbl<
> > > > > > >   https://github.com/plt/racket/pull/455/files#diff-3>(20)
> > > > > > > - _M_
> > 
> > pkgs/string-constants/string-constants-lib/string-constants/private/english-string-constants.rkt<
> > 
> > > > > > https://github.com/plt/racket/pull/455/files#diff-4>(2)
> > > > > > 
> > > > > > > - _M_
> > 
> > pkgs/string-constants/string-constants-lib/string-constants/private/french-string-constants.rkt<
> > 
> > > > > > https://github.com/plt/racket/pull/455/files#diff-5>(2)
> > > > > > 
> > > > > > > Patch Links:
> > > > > > > - https://github.com/plt/racket/pull/455.patch
> > > > > > > - https://github.com/plt/racket/pull/455.diff
> > > > > > 
> > > > > > —
> > > > > > Reply to this email directly or view it on GitHub<
> > > > > > https://github.com/plt/racket/pull/455#issuecomment-26208454>
> > > > > > .
> > > > > 
> > > > > ## 
> > > > > 
> > > > > ## 
> > > > > 
> > > > > Jens Axel Søgaard
> > > > > 
> > > > > —
> > > > > Reply to this email directly or view it on GitHub<
> > > > > https://github.com/plt/racket/pull/455#issuecomment-26279124>
> > > > > .
> > > > 
> > > > —
> > > > Reply to this email directly or view it on GitHub<
> > > > https://github.com/plt/racket/pull/455#issuecomment-26281068>
> > > > .
> > > 
> > > ## 
> > > 
> > > ## 
> > > 
> > > Jens Axel Søgaard
> > > 
> > > —
> > > Reply to this email directly or view it on GitHub<
> > > https://github.com/plt/racket/pull/455#issuecomment-26281521>
> > > .
> > 
> > —
> > Reply to this email directly or view it on GitHub<
> > https://github.com/plt/racket/pull/455#issuecomment-26282297>
> > .
> 
> —
> Reply to this email directly or view it on GitHubhttps://github.com/plt/racket/pull/455#issuecomment-26282680
> .

I've added a patch to the port to increase the margin to 300kb. I know this isn't the correct fix but I don't know another better.

If you need help with some problem related to threads on openbsd, feel free to ask in our tech@ mailing list.

I think a 300K margin was needed because the stack starts out (in main) with a significant chunk already used --- more than 100k in experiments on my 32-bit OpenBSD 5.2 installation.

Instead of changing the margin, I've pushed a change to use pthread_stackseg_np(), which is OpenBSD-specific, to reliably and precisely calculate the stack bounds. With that change, the regular margin configuration seems to work.

Can you check that change on your machine?

Thanks!

You forgot to remove "# include sys/param.h " in your commit.

I've tested your changes on 5.3.6/amd64 and 6/amd64. Both work perfectly. Thanks a lot for your work.

Ok, it is now separated out. The changes that add the static contracts are all at the end now.

Kind of.  It seems to me like a bad idea to add this, since `send-url/mac` is supposed to be an internal helper that gets invoked when we're on a mac, so it's not really intended to be exposed.  And when it _is_ exposed, there's another issue of this being a completely different mechanism than what happens on Unix.  More than that, using the keyword is a thin wrapper around a run of `osascript` anyway.

If this is really needed, then I think that a much better solution would be to somehow unify this with the unix thing, but I think that it's best to avoid it if possible, since the idea on mac/windows is that the OS is left with the decision of what browser to run.

Ok, thanks, that helps.  I'd still like some comments that explain what "static contracts" are, how this new architecture works, what it gives us, etc.  Preferably in the source, actually. Which file is the definition of the static-contract generic in?

Can you split the rackunit changes out into a separate PR?  If that's hard, I'll just get @rmculpepper to review them here.

The rackunit changes are separate, but I don't know how to send a PR based off of another PR.

https://github.com/plt/racket/pull/458

Whether browser selection is needed depends on everyone's personal needs. I can't live with a single browser on the Mac because there is none that handles all sites correctly and conveniently. I think many Mac power users share this point of view, though others are perfectly happy with a single browser.

Unifying the Mac and Unix approaches is fine with me, though it would probably look alien to most Mac users. I'd say that my `send-url/mac` is as close in spirit to `osascript` as is possible, but that's of course a matter of taste.

If I split out the changes to substring and fail-check, are they good to go in?

Yes.

Ctrl-PageUp/PageDown is what switches tabs for me on both Chrome and Firefox, and Ctrl-Shift-PageUp/PageDown reorders tabs.  So those keybindings would be great for me.

@mflatt This appears to have no problems when building, but I wanted to check with you since I know you're working on splitting up tests.

Pushed the simple changes, deleted the param code, and changed it to still call the error display handler but just not print a stack trace. DrRacket still includes a stack trace and link to the source.

Added a rough README. Will add more stuff soon, but not tonight.

Looks like a good move to me, and it doesn't conflict with anything I'm doing at the moment.

Merged.

Thanks for looking into this!

I think the redex-gui-lib package should not include the pict stuff; that
should be in redex-lib (or a redex-pict-lib if you think a finer-grained
distinction is warranted). "things that use gui-lib" seems like a good
criterion for redex-gui-lib, in other words and the pict stuff shouldn't.

I'd say that ideally mrlib/tex-table should not depend on gui-lib, but I
don't know how hard that is to change. Looks like it doesn't actually
depend on racket/gui/base so maybe it can be moved into draw-lib?

Robby

On Fri, Oct 18, 2013 at 10:19 AM, Sam Tobin-Hochstadt <
notifications@github.com> wrote:

> There are two questions I still have about this pull request:
> 
>    1.
> 
>    What should I do about the generation of math identifiers. Right now,
>    it uses mrlib/tex-table, which is in the gui-lib package. I could
>    either split that out into a new package, change redex not to use these
>    names, or dynamically load the relevant module.
>    @rfindler https://github.com/rfindler, what do you say?
>    2.
> 
>    Is this the right place to split? Everything that uses picts is in
>    redex-gui-lib. Perhaps the line should be "things that use gui-lib".
>    Or somewhere else. Or there should be a third package?
> 
> ---
> 
> You can merge this Pull Request by running
> 
>   git pull https://github.com/samth/racket redex-split
> 
> Or view, comment on, or merge it at:
> 
>   https://github.com/plt/racket/pull/463
> Commit Summary
> - Split out `redex-gui-lib` package.
> 
> File Changes
> - _A_ pkgs/redex-pkgs/redex-gui-lib/COPYING.txthttps://github.com/plt/racket/pull/463/files#diff-0(676)
> - _A_ pkgs/redex-pkgs/redex-gui-lib/COPYING_LESSER.txthttps://github.com/plt/racket/pull/463/files#diff-1(165)
> - _A_ pkgs/redex-pkgs/redex-gui-lib/LICENSE.txthttps://github.com/plt/racket/pull/463/files#diff-2(10)
> - _A_ pkgs/redex-pkgs/redex-gui-lib/info.rkthttps://github.com/plt/racket/pull/463/files#diff-3(18)
> - _R_ pkgs/redex-pkgs/redex-gui-lib/redex/gui.rkthttps://github.com/plt/racket/pull/463/files#diff-4(6)
> - _R_ pkgs/redex-pkgs/redex-gui-lib/redex/main.rkthttps://github.com/plt/racket/pull/463/files#diff-5(4)
> - _R_ pkgs/redex-pkgs/redex-gui-lib/redex/pict.rkthttps://github.com/plt/racket/pull/463/files#diff-6(4)
> - _R_ pkgs/redex-pkgs/redex-gui-lib/redex/private/arrow.rkthttps://github.com/plt/racket/pull/463/files#diff-7(0)
> - _R_ pkgs/redex-pkgs/redex-gui-lib/redex/private/core-layout.rkthttps://github.com/plt/racket/pull/463/files#diff-8(8)
> - _R_ pkgs/redex-pkgs/redex-gui-lib/redex/private/dot.rkthttps://github.com/plt/racket/pull/463/files#diff-9(0)
> - _R_ pkgs/redex-pkgs/redex-gui-lib/redex/private/gen-trace.rkthttps://github.com/plt/racket/pull/463/files#diff-10(10)
> - _R_ pkgs/redex-pkgs/redex-gui-lib/redex/private/pict.rkthttps://github.com/plt/racket/pull/463/files#diff-11(18)
> - _R_ pkgs/redex-pkgs/redex-gui-lib/redex/private/sexp-diffs.rkthttps://github.com/plt/racket/pull/463/files#diff-12(0)
> - _R_ pkgs/redex-pkgs/redex-gui-lib/redex/private/show-derivations.rkthttps://github.com/plt/racket/pull/463/files#diff-13(2)
> - _R_ pkgs/redex-pkgs/redex-gui-lib/redex/private/size-snip.rkthttps://github.com/plt/racket/pull/463/files#diff-14(4)
> - _R_ pkgs/redex-pkgs/redex-gui-lib/redex/private/stepper.rkthttps://github.com/plt/racket/pull/463/files#diff-15(2)
> - _R_ pkgs/redex-pkgs/redex-gui-lib/redex/private/traces.rkthttps://github.com/plt/racket/pull/463/files#diff-16(4)
> - _M_ pkgs/redex-pkgs/redex-lib/info.rkthttps://github.com/plt/racket/pull/463/files#diff-17(5)
> - _M_ pkgs/redex-pkgs/redex-lib/redex/private/compiler/match.rkthttps://github.com/plt/racket/pull/463/files#diff-18(2)
> - _M_
>   pkgs/redex-pkgs/redex-lib/redex/private/compiler/redextomatrix.rkthttps://github.com/plt/racket/pull/463/files#diff-19(2)
> - _M_ pkgs/redex-pkgs/redex-lib/redex/private/rg.rkthttps://github.com/plt/racket/pull/463/files#diff-20(4)
> - _M_ pkgs/redex-pkgs/redex/info.rkthttps://github.com/plt/racket/pull/463/files#diff-21(4)
> 
> Patch Links:
> - https://github.com/plt/racket/pull/463.patch
> - https://github.com/plt/racket/pull/463.diff

Does it work to add `__builtin_choose_expr` and `__builtin_types_compatible_p` to the `non-functions` list in "collects/compiler/private/xform.rkt" (around line 896), and then try a clean build directory?

It does help but it then fails quickly afterwards:

```
/usr/bin/make xobjects
env XFORM_USE_PRECOMP=xsrc/precomp.h ../racketcgc -cqu ../.././../racket/gc2/xform.rkt --setup . --cpp "cpp -I./.. -I../.././../racket/gc2/../include -I/usr/local/include -pthread     -DMZ_USES_SHARED_LIB"  --keep-lines -o xsrc/salloc.c ../.././../racket/gc2/../src/salloc.c
/usr/local/bin/libtool --mode=compile --tag=CC cc -I./.. -I../.././../racket/gc2/../include -pipe -O2 -fno-strict-aliasing -I/usr/local/include -pthread     -DMZ_USES_SHARED_LIB -c xsrc/salloc.c -o salloc.lo
libtool: compile:  cc -I./.. -I../.././../racket/gc2/../include -pipe -O2 -fno-strict-aliasing -I/usr/local/include -pthread -DMZ_USES_SHARED_LIB -c xsrc/salloc.c  -fPIC -DPIC -o .libs/salloc.o
libtool: compile:  cc -I./.. -I../.././../racket/gc2/../include -pipe -O2 -fno-strict-aliasing -I/usr/local/include -pthread -DMZ_USES_SHARED_LIB -c xsrc/salloc.c -o salloc.o >/dev/null 2>&1
env XFORM_USE_PRECOMP=xsrc/precomp.h ../racketcgc -cqu ../.././../racket/gc2/xform.rkt --setup . --cpp "cpp -I./.. -I../.././../racket/gc2/../include -I/usr/local/include -pthread     -DMZ_USES_SHARED_LIB"  --keep-lines -o xsrc/bignum.c ../.././../racket/gc2/../src/bignum.c
/usr/local/bin/libtool --mode=compile --tag=CC cc -I./.. -I../.././../racket/gc2/../include -pipe -O2 -fno-strict-aliasing -I/usr/local/include -pthread     -DMZ_USES_SHARED_LIB -c xsrc/bignum.c -o bignum.lo
libtool: compile:  cc -I./.. -I../.././../racket/gc2/../include -pipe -O2 -fno-strict-aliasing -I/usr/local/include -pthread -DMZ_USES_SHARED_LIB -c xsrc/bignum.c  -fPIC -DPIC -o .libs/bignum.o
libtool: compile:  cc -I./.. -I../.././../racket/gc2/../include -pipe -O2 -fno-strict-aliasing -I/usr/local/include -pthread -DMZ_USES_SHARED_LIB -c xsrc/bignum.c -o bignum.o >/dev/null 2>&1
env XFORM_USE_PRECOMP=xsrc/precomp.h ../racketcgc -cqu ../.././../racket/gc2/xform.rkt --setup . --cpp "cpp -I./.. -I../.././../racket/gc2/../include -I/usr/local/include -pthread     -DMZ_USES_SHARED_LIB"  --keep-lines -o xsrc/bool.c ../.././../racket/gc2/../src/bool.c
Error [GCING] 243 in ../.././../racket/gc2/../src/bool.c: Function double_eqv declared __xform_nongcing__, but includes a function call.
xform: Errors converting
*** Error code 1

Stop.
make: stopped in /usr/obj/dports/lang/racket/work/racket-5.3.6/src/build/racket/gc2
*** Error code 1
```

Looks like a similar problem, but the error doesn't give us a good hint about the next name to add.

I'll work a better solution, but for now, you should be able to work around the problem by adding `XFORM_SKIP_PROC` right after `XFORM_NONGCING static MZ_INLINE int double_eqv(double a, double b)`.

With the above change, I was able to build and install racket. :)
I quickly tried the interactive interpreter and it seems to be fine.

I've updated this so that there's now a `redex-pict-lib` -- have a look and see what you think.

I think I'm going to move `mrlib/tex-table` into its own package -- it doesn't even need `racket/draw`.

This is now done -- there's a new package called `tex-table`, which I put in gui-pkgs for lack of a better place.  Everything else seems good to go here.

Is there a way to get an overview of which files moved where somehow? I get
loooong diffs on the webpage.

Robby

On Sat, Oct 19, 2013 at 4:49 PM, Sam Tobin-Hochstadt <
notifications@github.com> wrote:

> This is now done -- there's a new package called tex-table, which I put
> in gui-pkgs for lack of a better place. Everything else seems good to go
> here.
> 
> —
> Reply to this email directly or view it on GitHubhttps://github.com/plt/racket/pull/463#issuecomment-26659636
> .

I think `git log --stat` is probably your best bet.

On Sat, Oct 19, 2013 at 5:26 PM, Robby Findler notifications@github.comwrote:

> Is there a way to get an overview of which files moved where somehow? I
> get
> loooong diffs on the webpage.
> 
> Robby
> 
> On Sat, Oct 19, 2013 at 4:49 PM, Sam Tobin-Hochstadt <
> notifications@github.com> wrote:
> 
> > This is now done -- there's a new package called tex-table, which I put
> > in gui-pkgs for lack of a better place. Everything else seems good to go
> > here.
> > 
> > —
> > Reply to this email directly or view it on GitHub<
> > https://github.com/plt/racket/pull/463#issuecomment-26659636>
> > .
> 
> —
> Reply to this email directly or view it on GitHubhttps://github.com/plt/racket/pull/463#issuecomment-26660273
> .

Yeah, I ended up just checking it out.

It looks great.

Thanks,
Robby

On Sat, Oct 19, 2013 at 5:37 PM, Sam Tobin-Hochstadt <
notifications@github.com> wrote:

> I think `git log --stat` is probably your best bet.
> 
> On Sat, Oct 19, 2013 at 5:26 PM, Robby Findler notifications@github.comwrote:
> 
> > Is there a way to get an overview of which files moved where somehow? I
> > get
> > loooong diffs on the webpage.
> > 
> > Robby
> > 
> > On Sat, Oct 19, 2013 at 4:49 PM, Sam Tobin-Hochstadt <
> > notifications@github.com> wrote:
> > 
> > > This is now done -- there's a new package called tex-table, which I
> > > put
> > > in gui-pkgs for lack of a better place. Everything else seems good to
> > > go
> > > here.
> > > 
> > > —
> > > Reply to this email directly or view it on GitHub<
> > > https://github.com/plt/racket/pull/463#issuecomment-26659636>
> > > .
> > 
> > —
> > Reply to this email directly or view it on GitHub<
> > https://github.com/plt/racket/pull/463#issuecomment-26660273>
> > .
> 
> —
> Reply to this email directly or view it on GitHubhttps://github.com/plt/racket/pull/463#issuecomment-26660448
> .

I've merged this now.

Ping.

Do we have a good load test for subtype?

Sent from a mobile device.
On Oct 20, 2013 7:37 PM, "Sam Tobin-Hochstadt" notifications@github.com
wrote:

> ---
> 
> You can merge this Pull Request by running
> 
>   git pull https://github.com/samth/racket better-subtype
> 
> Or view, comment on, or merge it at:
> 
>   https://github.com/plt/racket/pull/466
> Commit Summary
> - progress
> 
> File Changes
> - _M_
>   pkgs/typed-racket-pkgs/typed-racket-lib/typed-racket/types/current-seen.rkthttps://github.com/plt/racket/pull/466/files#diff-0(9)
> - _M_
>   pkgs/typed-racket-pkgs/typed-racket-lib/typed-racket/types/subtype.rkthttps://github.com/plt/racket/pull/466/files#diff-1(33)
> 
> Patch Links:
> - https://github.com/plt/racket/pull/466.patch
> - https://github.com/plt/racket/pull/466.diff

On Sun, Oct 20, 2013 at 10:34 PM, Eric Dobson notifications@github.comwrote:

> Do we have a good load test for subtype?

Currently, this speeds up new-metrics.rkt by about 1 sec out 6. It sped it
up by 3 seconds before some fixes to make the optimization more
conservative.  We can recover some of this by distinguishing `App`, `Name`,
and `Struct` nodes that can be recursive.

Oh, and just for reference, new-metrics calls `subtype` about 150k times, and that calls subtype\* 150k times.

Is `known-bugs.rkt` up to date? I saw you removed one bug from it, but was it the only one you fixed?

@shekari This now speeds up new-metrics to under 3.5 sec. I've substantially reduced the number of places where caching gets done.

A bunch of other speedups happened too: not using `(=> unmatch)`, not using parameters, open-coding some functions.

This has an infinite loop because there aren't enough places where we're parameterizing `current-seen`. But I haven't figured out where yet.

Most of the changes look good. A few comments:
- I think it might be better to use a bytes instead of a string for a Linux abstract path (eg `#"\0abc"` instead of `"\0abc"`). That would distinguish them more sharply from path-strings and it would avoid the issue of string encodings. If you'd really prefer strings, though, I can live with that.
- Use provide with contract-out, not define/contract.
- Testing: The current tests (test, singular, really) are in /pkgs/unstable-pkgs/unstable-test/tests/unstable/socket.rkt. It uses netcat (nc) to create a little server. Do you know of a way to convince netcat to listen on a Linux-abstract-named socket? I suspect it's impossible, but I wanted to check. If that won't work, I found some perl code that I can adapt for testing.
- There are a few other issues, like missing elses in cases, requires and comments I'd like to preserve, etc. I can fix those when I merge your commits and run the tests on a Mac.

I'm guessing that anywhere resolve could be called needs to be parameterized correctly. If that has to recompute a union then we need to call subtype.

I do not know if known bugs is up to date. I'm working on making it executable so that it will stay so.

Awesome.
-  I will rewrite it to require a `path-string?` or `#"\0..."` bytes, since it seems that there are no rules on encoding and `'\0'` bytes are perfectly valid.
-  Ah, sorry, I forgot about this part of the official coding style. Will fix it.
-  I don't think `nc` can do that. `socat` can and since there are not 3 different versions of it, I would suggest to prefer it over the `nc` in general. I have no idea about Racket test suite dependencies, however.
- Ah, silly me. Will fix the cases.

This is good to merge.

Thanks, I had forgotten about `socat`. It seems less commonly installed than `nc`, so I'll just use it for the new tests when it's available.

LGTM

Anything else?

Merged.

Awesome!

Is there a plan to move unix sockets outside of `unstable/` in order get some guarantees of API stability? If more work is required on that field, I might find some time to do that. In any case, thank you!

It looks like to me like c:pageup and c:pagedown already move around
between tabs.

Do you not see that?

Robby

On Wed, Oct 16, 2013 at 3:25 PM, Sam Tobin-Hochstadt <
notifications@github.com> wrote:

> Ctrl-PageUp/PageDown is what switches tabs for me on both Chrome and
> Firefox, and Ctrl-Shift-PageUp/PageDown reorders tabs. So those keybindings
> would be great for me.
> 
> —
> Reply to this email directly or view it on GitHubhttps://github.com/plt/racket/pull/455#issuecomment-26454198
> .

Sorry, I was very unclear.  What I meant was that C-pgup/dn move between
tabs in browsers, as the do in DrRacket, and C-S-pgup/dn move the tabs in
browsers, and thus it seems like a good idea to emulate that as well in
DrRracket.

On Fri, Oct 25, 2013 at 2:00 PM, Robby Findler notifications@github.comwrote:

> It looks like to me like c:pageup and c:pagedown already move around
> between tabs.
> 
> Do you not see that?
> 
> Robby
> 
> On Wed, Oct 16, 2013 at 3:25 PM, Sam Tobin-Hochstadt <
> notifications@github.com> wrote:
> 
> > Ctrl-PageUp/PageDown is what switches tabs for me on both Chrome and
> > Firefox, and Ctrl-Shift-PageUp/PageDown reorders tabs. So those
> > keybindings
> > would be great for me.
> > 
> > —
> > Reply to this email directly or view it on GitHub<
> > https://github.com/plt/racket/pull/455#issuecomment-26454198>
> > .
> 
> —
> Reply to this email directly or view it on GitHubhttps://github.com/plt/racket/pull/455#issuecomment-27113117
> .

With `$PLT_SETUP_OPTIONS` set to `--workers 1 compiler data db dynext ffi file json launcher net openssl pkg planet racket race reader s-exp setup syntax unstable version xml` (note that the `-l` is not yet present), I get the following error:

```
env CFLAGS="-g -O2   -DOS_X -D_DARWIN_UNLIMITED_SELECT -DXONX  -pthread" LDFLAGS="-pthread"  racket/racket3m -X "/usr/local/Cellar/plt-racket/5.3.6/lib/racket/collects" -N "raco setup" -l- setup --workers 1 compiler data db dynext ffi file json launcher net openssl pkg planet racket raco reader s-exp setup syntax unstable version xml   --no-user --no-docs
raco setup: bootstrapping from source...
open-input-file: cannot open input file
  path: /private/tmp/plt-racket-biba/racket-5.3.6/src/compiler
  system error: No such file or directory; errno=2
  context...:
   /usr/local/Cellar/plt-racket/5.3.6/lib/racket/collects/setup/unpack.rkt:262:2: unpack12
   /usr/local/Cellar/plt-racket/5.3.6/lib/racket/collects/setup/setup-go.rkt: [running body]
   /usr/local/Cellar/plt-racket/5.3.6/lib/racket/collects/setup/main.rkt: [running body]
make[1]: *** [install-3m] Error 1
make: *** [install] Error 2
```

with the `-l` added to `$PLT_SETUP_OPTIONS`, I get a different error:

```
env CFLAGS="-g -O2   -DOS_X -D_DARWIN_UNLIMITED_SELECT -DXONX  -pthread" LDFLAGS="-pthread"  racket/racket3m -X "/usr/local/Cellar/plt-racket/5.3.6/lib/racket/collects" -N "raco setup" -l- setup --workers 1 -l compiler data db dynext ffi file json launcher net openssl pkg planet racket raco reader s-exp setup syntax unstable version xml   --no-user --no-docs
raco setup: bootstrapping from source...
collection-path: collection not found
  collection: "--no-user"
  in collection directories:
   /Users/joshua.tilles/.racket/5.3.6/collects
   /usr/local/Cellar/plt-racket/5.3.6/lib/racket/collects
make[1]: *** [install-3m] Error 1
make: *** [install] Error 2
```

Finally, the installation succeeds if I also apply the following patch:

```
diff --git a/src/Makefile.in b/src/Makefile.in
index ce4bac4..5d12d25 100644
--- a/src/Makefile.in
+++ b/src/Makefile.in
@@ -62,7 +62,7 @@ both:

 # Install (common) ----------------------------------------

-SETUP_ARGS = -X @DIRCVTPRE@"$(DESTDIR)$(collectsdir)"@DIRCVTPOST@ -N "raco setup" -l- setup $(PLT_SETUP_OPTIONS) $(PLT_ISO) @INSTALL_SETUP_FLAGS@
+SETUP_ARGS = -X @DIRCVTPRE@"$(DESTDIR)$(collectsdir)"@DIRCVTPOST@ -N "raco setup" -l- setup $(PLT_ISO) @INSTALL_SETUP_FLAGS@ $(PLT_SETUP_OPTIONS)

 # Pass compile and link flags to `make install' for use by any
 #  collection-setup actions that compile and link C code:
```

(it just swaps the order of `@INSTALL_SETUP_FLAGS@` and `$(PLT_SETUP_OPTIONS)`)

So, I don't know whether I'm crudely working around a deeper bug, or whether the documentation just needs to be updated, or some other alternative.

I'll be happy to help, but at this point it seems like someone knowledgeable with Racket just needs to make a decision about what the intended behavior should be.

Thanks for your help! I've pushed the patch, plus a related repair so that the `-l` flag isn't needed.

You are entirely welcome!

It's kinduva relief that all that time spent debugging wasn't wasted =P

So, should I close the issue then?

On Fri, Oct 25, 2013 at 6:14 PM, MerelyAPseudonym
notifications@github.comwrote:

> So, should I close the issue then?

Yes, that would be great.

This seems fine, plus the top level is hopeless.

I just merged this.

lgtm

Ping.

Can you submit this as a bug to the Racket bug tracker at http://bugs.racket-lang.org ?

Done: http://bugs.racket-lang.org/query/?cmd=view&pr=14127

LGTM

Fixed a stupid error, and showed this to @rfindler.

I'm not quite getting why expanded-stx and original-stx are used. Also, is
it traversing those objects each time it inserts a wcm?

Robby

On Sat, Oct 26, 2013 at 5:52 PM, Sam Tobin-Hochstadt <
notifications@github.com> wrote:

> Also minor cleanups elsewhere.
> 
> @rfindler https://github.com/rfindler: can you look at DrRacket changes?
> 
> @mflatt https://github.com/mflatt: thoughts on the changes to
> 
> ## errortrace?
> 
> You can merge this Pull Request by running
> 
>   git pull https://github.com/samth/racket errortrace-prof
> 
> Or view, comment on, or merge it at:
> 
>   https://github.com/plt/racket/pull/476
> Commit Summary
> - Make `profile-lib` a single-collection package.
> - Fix benchmarks to not use `collection-path`.
> - Clarify the data definitions used by drracket for stacktraces.
> - Remove dead code.
> - Remove one-armed `if` handling.
> - Required identifiers cannot error on use.
> - Implement statistical errortrace-based profiling.
> 
> File Changes
> - _M_ pkgs/drracket-pkgs/drracket/drracket/private/debug.rkthttps://github.com/plt/racket/pull/476/files#diff-0(14)
> - _M_ pkgs/errortrace-pkgs/errortrace-lib/errortrace/errortrace-lib.rkthttps://github.com/plt/racket/pull/476/files#diff-1(10)
> - _M_ pkgs/errortrace-pkgs/errortrace-lib/errortrace/stacktrace.rkthttps://github.com/plt/racket/pull/476/files#diff-2(33)
> - _M_ pkgs/errortrace-pkgs/errortrace-lib/info.rkthttps://github.com/plt/racket/pull/476/files#diff-3(2)
> - _M_ pkgs/plt-services/meta/propshttps://github.com/plt/racket/pull/476/files#diff-4(2)
> - _M_ pkgs/profile-pkgs/profile-doc/info.rkthttps://github.com/plt/racket/pull/476/files#diff-5(2)
> - _M_ pkgs/profile-pkgs/profile-doc/profile/scribblings/sampler.scrblhttps://github.com/plt/racket/pull/476/files#diff-6(10)
> - _M_ pkgs/profile-pkgs/profile-doc/profile/scribblings/toplevel.scrblhttps://github.com/plt/racket/pull/476/files#diff-7(12)
> - _R_ pkgs/profile-pkgs/profile-lib/analyzer.rkthttps://github.com/plt/racket/pull/476/files#diff-8(0)
> - _M_ pkgs/profile-pkgs/profile-lib/info.rkthttps://github.com/plt/racket/pull/476/files#diff-9(4)
> - _R_ pkgs/profile-pkgs/profile-lib/main.rkthttps://github.com/plt/racket/pull/476/files#diff-10(6)
> - _R_ pkgs/profile-pkgs/profile-lib/render-graphviz.rkthttps://github.com/plt/racket/pull/476/files#diff-11(0)
> - _R_ pkgs/profile-pkgs/profile-lib/render-text.rkthttps://github.com/plt/racket/pull/476/files#diff-12(0)
> - _R_ pkgs/profile-pkgs/profile-lib/sampler.rkthttps://github.com/plt/racket/pull/476/files#diff-13(40)
> - _R_ pkgs/profile-pkgs/profile-lib/structs.rkthttps://github.com/plt/racket/pull/476/files#diff-14(0)
> - _R_ pkgs/profile-pkgs/profile-lib/utils.rkthttps://github.com/plt/racket/pull/476/files#diff-15(0)
> - _M_
>   pkgs/racket-pkgs/racket-benchmarks/tests/racket/benchmarks/shootout/run.rkthttps://github.com/plt/racket/pull/476/files#diff-16(8)
> - _A_ pkgs/typed-racket-pkgs/source-syntax/info.rkthttps://github.com/plt/racket/pull/476/files#diff-17(9)
> - _R_ pkgs/typed-racket-pkgs/source-syntax/source-syntax.rkthttps://github.com/plt/racket/pull/476/files#diff-18(4)
> - _M_ pkgs/typed-racket-pkgs/typed-racket-lib/info.rkthttps://github.com/plt/racket/pull/476/files#diff-19(1)
> - _M_
>   pkgs/typed-racket-pkgs/typed-racket-lib/typed-racket/utils/tc-utils.rkthttps://github.com/plt/racket/pull/476/files#diff-20(4)
> 
> Patch Links:
> - https://github.com/plt/racket/pull/476.patch
> - https://github.com/plt/racket/pull/476.diff

On @rfindler's advice, I tried benchmarking this on `drracket/private/unit.rkt`. Although I was unable to write a program that successfully timed `errortrace-annotate` (best effort here: https://gist.github.com/samth/7207880 ) I did benchmark the whole compile process and eventually killed it as it was really slow.

The culprit is the `find-source-syntax` code.  Unfortunately, it isn't easy to amortize this cost over lots of calls -- it'll require some actual work with interval maps or something like that.

@stamourv -- see above comment.

Do you mean recover-source-syntax?

You could start with something that just reports source locations for now
and then in the GUI that shows the profile you can open files and show
lines or something. (DrRacket does this for stacktraces when you click the
stop icon.)

Robby

@rfindler 

Yes, that's what I meant.

There is no GUI -- this is all for the `profile` library. We could just have source locations by themselves, but to a first approximation the syntax bits used by the current `errortrace` implementation are useless for this application.  They always look like `(#%app ...)` or `(let-values (...) (let-values (...) ...))` etc.

I had the impression that the source locations were good, but the actual
expressions inside them aren't so useful? (And I shouldn't have said
"GUI"-- I really just mean "UI".)

In other words, does it work to, when you render the actual profile, open
up the files and get what's in them at that point (and just store the
source/pos/span in the continuation marks)?

Robby

PS: should I be putting @samth or something in these messages?

Yes, I meant the same as Sam.

Laurent

On Fri, Oct 25, 2013 at 8:59 PM, Sam Tobin-Hochstadt <
notifications@github.com> wrote:

> Sorry, I was very unclear. What I meant was that C-pgup/dn move between
> tabs in browsers, as the do in DrRacket, and C-S-pgup/dn move the tabs in
> browsers, and thus it seems like a good idea to emulate that as well in
> DrRracket.
> 
> On Fri, Oct 25, 2013 at 2:00 PM, Robby Findler notifications@github.comwrote:
> 
> > It looks like to me like c:pageup and c:pagedown already move around
> > between tabs.
> > 
> > Do you not see that?
> > 
> > Robby
> > 
> > On Wed, Oct 16, 2013 at 3:25 PM, Sam Tobin-Hochstadt <
> > notifications@github.com> wrote:
> > 
> > > Ctrl-PageUp/PageDown is what switches tabs for me on both Chrome and
> > > Firefox, and Ctrl-Shift-PageUp/PageDown reorders tabs. So those
> > > keybindings
> > > would be great for me.
> > > 
> > > —
> > > Reply to this email directly or view it on GitHub<
> > > https://github.com/plt/racket/pull/455#issuecomment-26454198>
> > > .
> > 
> > —
> > Reply to this email directly or view it on GitHub<
> > https://github.com/plt/racket/pull/455#issuecomment-27113117>
> > .
> 
> —
> Reply to this email directly or view it on GitHubhttps://github.com/plt/racket/pull/455#issuecomment-27117249
> .

Messed this up, see #480 

Thanks, guys. I've pushed that change.

Robby

On Tue, Oct 29, 2013 at 4:02 AM, Laurent Orseau notifications@github.comwrote:

> Yes, I meant the same as Sam.
> 
> Laurent
> 
> On Fri, Oct 25, 2013 at 8:59 PM, Sam Tobin-Hochstadt <
> notifications@github.com> wrote:
> 
> > Sorry, I was very unclear. What I meant was that C-pgup/dn move between
> > tabs in browsers, as the do in DrRacket, and C-S-pgup/dn move the tabs
> > in
> > browsers, and thus it seems like a good idea to emulate that as well in
> > DrRracket.
> > 
> > On Fri, Oct 25, 2013 at 2:00 PM, Robby Findler notifications@github.comwrote:
> > 
> > > It looks like to me like c:pageup and c:pagedown already move around
> > > between tabs.
> > > 
> > > Do you not see that?
> > > 
> > > Robby
> > > 
> > > On Wed, Oct 16, 2013 at 3:25 PM, Sam Tobin-Hochstadt <
> > > notifications@github.com> wrote:
> > > 
> > > > Ctrl-PageUp/PageDown is what switches tabs for me on both Chrome and
> > > > Firefox, and Ctrl-Shift-PageUp/PageDown reorders tabs. So those
> > > > keybindings
> > > > would be great for me.
> > > > 
> > > > —
> > > > Reply to this email directly or view it on GitHub<
> > > > https://github.com/plt/racket/pull/455#issuecomment-26454198>
> > > > .
> > > 
> > > —
> > > Reply to this email directly or view it on GitHub<
> > > https://github.com/plt/racket/pull/455#issuecomment-27113117>
> > > .
> > 
> > —
> > Reply to this email directly or view it on GitHub<
> > https://github.com/plt/racket/pull/455#issuecomment-27117249>
> > .
> 
> —
> Reply to this email directly or view it on GitHubhttps://github.com/plt/racket/pull/455#issuecomment-27286891
> .

Cool, thanks Robby!

On Tue, Oct 29, 2013 at 4:07 PM, Robby Findler notifications@github.comwrote:

> Thanks, guys. I've pushed that change.
> 
> Robby
> 
> On Tue, Oct 29, 2013 at 4:02 AM, Laurent Orseau notifications@github.comwrote:
> 
> > Yes, I meant the same as Sam.
> > 
> > Laurent
> > 
> > On Fri, Oct 25, 2013 at 8:59 PM, Sam Tobin-Hochstadt <
> > notifications@github.com> wrote:
> > 
> > > Sorry, I was very unclear. What I meant was that C-pgup/dn move
> > > between
> > > tabs in browsers, as the do in DrRacket, and C-S-pgup/dn move the tabs
> > > in
> > > browsers, and thus it seems like a good idea to emulate that as well
> > > in
> > > DrRracket.
> > > 
> > > On Fri, Oct 25, 2013 at 2:00 PM, Robby Findler <
> > > notifications@github.com>wrote:
> > > 
> > > > It looks like to me like c:pageup and c:pagedown already move around
> > > > between tabs.
> > > > 
> > > > Do you not see that?
> > > > 
> > > > Robby
> > > > 
> > > > On Wed, Oct 16, 2013 at 3:25 PM, Sam Tobin-Hochstadt <
> > > > notifications@github.com> wrote:
> > > > 
> > > > > Ctrl-PageUp/PageDown is what switches tabs for me on both Chrome
> > > > > and
> > > > > Firefox, and Ctrl-Shift-PageUp/PageDown reorders tabs. So those
> > > > > keybindings
> > > > > would be great for me.
> > > > > 
> > > > > —
> > > > > Reply to this email directly or view it on GitHub<
> > > > > https://github.com/plt/racket/pull/455#issuecomment-26454198>
> > > > > .
> > > > 
> > > > —
> > > > Reply to this email directly or view it on GitHub<
> > > > https://github.com/plt/racket/pull/455#issuecomment-27113117>
> > > > .
> > > 
> > > —
> > > Reply to this email directly or view it on GitHub<
> > > https://github.com/plt/racket/pull/455#issuecomment-27117249>
> > > .
> > 
> > —
> > Reply to this email directly or view it on GitHub<
> > https://github.com/plt/racket/pull/455#issuecomment-27286891>
> > .
> 
> —
> Reply to this email directly or view it on GitHubhttps://github.com/plt/racket/pull/455#issuecomment-27310928
> .

This is what the output looks like with this PR:

```
[samth@huor:~/sw/plt (errortrace-prof) plt] r -l errortrace -t /tmp/prof.rkt
Profiling results
-----------------
  Total cpu time observed: 1220ms (out of 1264ms)
  Number of samples taken: 24 (once every 51ms)

=============================================================
                               Caller
Idx   Total        Self      Name+src                  Local%
      ms(pct)      ms(pct)     Callee
=============================================================
[1] 1220(100.0%)    0(0.0%)  for /tmp/prof.rkt:12:2
                               l [2]                   100.0%
-------------------------------------------------------------
                               for [1]                 100.0%
[2] 1220(100.0%)    0(0.0%)  l /tmp/prof.rkt:9:20
                               with-input-from-file [3] 82.6%
                               file->string [4]         17.4%
-------------------------------------------------------------
                               l [2]                   100.0%
[3] 1008(82.6%)  1008(82.6%) with-input-from-file /tmp/prof.rkt:7:4
-------------------------------------------------------------
                               l [2]                   100.0%
[4]  212(17.4%)   212(17.4%) file->string /tmp/prof.rkt:8:4
-------------------------------------------------------------
```

The names like `with-input-from-file` are taken from the unexpanded code. 

Line 7 is indeed:

```
7      (with-input-from-file "/tmp/data.txt" read)
```

So we could just read the file.  Unfortunately, this wouldn't work in some cases -- the code in `recover-source-syntax` can find original source code even when there are no or bad source locations.  But maybe it's enough until I make the `recover-source-syntax` code faster.

On Tue, Oct 29, 2013 at 1:29 PM, Sam Tobin-Hochstadt <
notifications@github.com> wrote:

> This is what the output looks like with this PR:
> 
> [samth@huor:~/sw/plt (errortrace-prof) plt] r -l errortrace -t /tmp/prof.rkt
> 
> ## Profiling results
> 
>   Total cpu time observed: 1220ms (out of 1264ms)
>   Number of samples taken: 24 (once every 51ms)
> 
> # 
> 
> ```
>                            Caller
> ```
> 
> Idx   Total        Self      Name+src                  Local%
> 
> #       ms(pct)      ms(pct)     Callee
> 
> [1] 1220(100.0%)    0(0.0%)  for /tmp/prof.rkt:12:2
> 
> ##                                l [2]                   100.0%
> 
> ```
>                            for [1]                 100.0%
> ```
> 
> [2] 1220(100.0%)    0(0.0%)  l /tmp/prof.rkt:9:20
>                                with-input-from-file [3] 82.6%
> 
> ##                                file->string [4]         17.4%
> 
> ```
>                            l [2]                   100.0%
> ```
> 
> ## [3] 1008(82.6%)  1008(82.6%) with-input-from-file /tmp/prof.rkt:7:4
> 
> ```
>                            l [2]                   100.0%
> ```
> 
> ## [4]  212(17.4%)   212(17.4%) file->string /tmp/prof.rkt:8:4
> 
> The names like with-input-from-file are taken from the unexpanded code.
> 
> Line 7 is indeed:
> 
> 7      (with-input-from-file "/tmp/data.txt" read)
> 
> So we could just read the file. Unfortunately, this wouldn't work in some
> cases -- the code in recover-source-syntax can find original source code
> even when there are no or bad source locations. But maybe it's enough until
> I make the recover-source-syntax code faster.
> 
> I don't think we need to hold up the profiler for that, but if you want to
> fix it first, that's also fine with me.

Robby

> —
> Reply to this email directly or view it on GitHubhttps://github.com/plt/racket/pull/476#issuecomment-27329998
> .

Looks good to me.

Thanks for the help! I've pushed changes to support Retina displays. Please let me know how it works, and if it's easiest to use a built snapshot, see http://www.cs.utah.edu/plt/snapshots/

Works like a charm! Thanks for your effort I can now fully enjoy DrRacket on my display!

Thanks @mflatt, works really well!

Ok, thanks. I've merged this now.

@samth -- this is unrelated to making it work with errortrace, but it
sounds like a good general profile-whatever-you-want thing.  I'm
thinking of some profiler/whatever that would give you a convenient
continuation-mark-around-this-code form, which you could then use to
debug anything you want, like gui callbacks, IO, DB, ffi glue, and
whatever...

## 

```
      ((lambda (x) (x x)) (lambda (x) (x x)))          Eli Barzilay:
                http://barzilay.org/                   Maze is Life!
```

@elibarzilay I'm not sure what you're referring to/suggesting. What is "it" in your first sentence?

Just now, Sam Tobin-Hochstadt wrote:

> @elibarzilay I'm not sure what you're referring to/suggesting. What
> is "it" in your first sentence?

You made it work with errortrace by adding a way to use any
continuation mark for collecting profiling data, right?  If so, then
I'm saying that with a simple macro utility you can make it track
costs for anything you want.  (Provided that you're tracking things in
your own code, of course.)

## 

```
      ((lambda (x) (x x)) (lambda (x) (x x)))          Eli Barzilay:
                http://barzilay.org/                   Maze is Life!
```

Any continuation mark that follows the undocumented format (that this PR also changes) that errortrace uses to store source locations. 

Right -- and what I'm saying is that with a macro that makes it easy
to use, you can use it for your own needs.  Also, if the format is
undocumented, then such a macro becomes more than just a convenience,
of course.  It could be a way to make that functionality available
without exposing the actual concrete representation, in case it
changes in the future.

Merged - thanks!

Merged, thanks!

This works great for me, very much appreciated!

Repairs pushed.

@rfindler The new implementation now takes about 200ms longer than the old on `drracket/private/unit.rkt`, an increase of about 5% overall. Benchmark run with this script: https://gist.github.com/samth/7286143

It could be faster in this benchmark by doing more work up-front, even when the searched-for source location is found early.  That would improve things for errortrace, but slow them down (probably only a little) for Typed Racket.

Do redex files suffer only a similar 5% slowdown? (They seem to be hit
relatively hard by errortrace.)

A good one to try
is pkgs/redex-pkgs/redex-examples/redex/examples/racket-machine/reduction.rkt,
but maybe all of the files in that directory are worth trying.

And your second para makes me think that maybe we want two functions?

Robby

On Sat, Nov 2, 2013 at 11:48 PM, Sam Tobin-Hochstadt <
notifications@github.com> wrote:

> @rfindler https://github.com/rfindler The new implementation now takes
> about 200ms longer than the old on drracket/private/unit.rkt, an increase
> of about 5% overall. Benchmark run with this script:
> https://gist.github.com/samth/7286143
> 
> It could be faster in this benchmark by doing more work up-front, even
> when the searched-for source location is found early. That would improve
> things for errortrace, but slow them down (probably only a little) for
> Typed Racket.
> 
> —
> Reply to this email directly or view it on GitHubhttps://github.com/plt/racket/pull/476#issuecomment-27638964
> .

Are you blocked on me for this one? Github threw away discussions on specific commits, so I don't remember which ones you addressed.

Sorta, I also have been busy and haven't worked much on racket in the last few weeks.
I believe I addressed all specific concerns, but it was also two weeks ago.

I remember that none of my concerns were major, so you should probably push it.
I plan to rephrase the complex unboxing missed optimization message, but I'll do that after you push.

LGTM too.

If you're exporting the other `Top` types, they should probably also be documented.

Updated docs. Also I realized my earlier concern made no sense. We already document `VectorTop` and `HashTableTop` under those names, so the naming convention is already set. The printing behavior was just very odd.

I'll try again :/

LGTM

r+

Merged.

Merged.

Merged, thanks!

LGTM

I'll push that change soon. Thanks!

Any chance to have this included in the upcoming release? It's quite convenient to generate Github's README.md, in particular for interactions and examples, but without the fix, it's not pretty (no title, and sections are displayed like titles).

Btw, it says the travis build failed, but it doesn't seem to be because of this pull request. (or is it?)

Would it be okay to change rackunit so that check-equal? worked with
multiple values? That is, a test case like this:

(check-equal? (values 1 2) (values 1 2))

would pass and these would be considered failing tests:

(check-equal? (values 1 2) (values 3 2))
(check-equal? (values 1 2) 3)

Robby

On Thu, Nov 7, 2013 at 12:42 PM, Ryan Culpepper notifications@github.comwrote:

> Merged, thanks!
> 
> —
> Reply to this email directly or view it on GitHubhttps://github.com/plt/racket/pull/484#issuecomment-27993825
> .

I think it would have to be macroized.

My rackunit/chk does this though:

http://jeapostrophe.github.io/2013-11-05-chk-post.html

On Sat, Nov 9, 2013 at 7:28 AM, Robby Findler notifications@github.comwrote:

> Would it be okay to change rackunit so that check-equal? worked with
> multiple values? That is, a test case like this:
> 
> (check-equal? (values 1 2) (values 1 2))
> 
> would pass and these would be considered failing tests:
> 
> (check-equal? (values 1 2) (values 3 2))
> (check-equal? (values 1 2) 3)
> 
> Robby
> 
> On Thu, Nov 7, 2013 at 12:42 PM, Ryan Culpepper notifications@github.comwrote:
> 
> > Merged, thanks!
> > 
> > —
> > Reply to this email directly or view it on GitHub<
> > https://github.com/plt/racket/pull/484#issuecomment-27993825>
> > .
> 
> —
> Reply to this email directly or view it on GitHubhttps://github.com/plt/racket/pull/484#issuecomment-28128306
> .

## 

Jay McCarthy jay@cs.byu.edu
Assistant Professor / Brigham Young University
http://faculty.cs.byu.edu/~jay

"The glory of God is Intelligence" - D&C 93

It seems like we can make it happen if we want to make it happen.

Robby

On Sat, Nov 9, 2013 at 9:07 AM, Jay McCarthy notifications@github.comwrote:

> I think it would have to be macroized.
> 
> My rackunit/chk does this though:
> 
> http://jeapostrophe.github.io/2013-11-05-chk-post.html
> 
> On Sat, Nov 9, 2013 at 7:28 AM, Robby Findler notifications@github.comwrote:
> 
> > Would it be okay to change rackunit so that check-equal? worked with
> > multiple values? That is, a test case like this:
> > 
> > (check-equal? (values 1 2) (values 1 2))
> > 
> > would pass and these would be considered failing tests:
> > 
> > (check-equal? (values 1 2) (values 3 2))
> > (check-equal? (values 1 2) 3)
> > 
> > Robby
> > 
> > On Thu, Nov 7, 2013 at 12:42 PM, Ryan Culpepper <
> > notifications@github.com>wrote:
> > 
> > > Merged, thanks!
> > > 
> > > —
> > > Reply to this email directly or view it on GitHub<
> > > https://github.com/plt/racket/pull/484#issuecomment-27993825>
> > > .
> > 
> > —
> > Reply to this email directly or view it on GitHub<
> > https://github.com/plt/racket/pull/484#issuecomment-28128306>
> > .
> 
> ## 
> 
> Jay McCarthy jay@cs.byu.edu
> Assistant Professor / Brigham Young University
> http://faculty.cs.byu.edu/~jay
> 
> "The glory of God is Intelligence" - D&C 93
> 
> —
> Reply to this email directly or view it on GitHubhttps://github.com/plt/racket/pull/484#issuecomment-28129074
> .

Ping.

Ping.

This is great. r+ with the above comments.

[Here](http://www.ccs.neu.edu/home/stamourv/errortrace-slowdown.pdf) are the slowdowns I get on that DrRacket file and the racket-machine files. `regular` is without errortrace. Sorry for the x-axis label glitch, something weird is going on with the benchmarking library.

Thanks!! Looks like there is only one file to worry about at all.

Which one is it? (5th from the left)

Robby

On Wed, Nov 13, 2013 at 4:42 PM, Vincent St-Amour
notifications@github.comwrote:

> Here http://www.ccs.neu.edu/home/stamourv/errortrace-slowdown.pdf are
> the slowdowns I get on that DrRacket file and the racket-machine files.
> regular is without errortrace. Sorry for the x-axis label glitch,
> something weird is going on with the benchmarking library.
> 
> —
> Reply to this email directly or view it on GitHubhttps://github.com/plt/racket/pull/476#issuecomment-28441724
> .

On Wed, Nov 13, 2013 at 5:50 PM, Robby Findler notifications@github.comwrote:

> Thanks!! Looks like there is only one file to worry about at all.
> 
> Which one is it? (5th from the left)

On IRC @stamourv informed me that it's `impl-exec.rkt`.  I plan to push the
changes anyway, and then we can worry about speeding up this one case.

Sam

Is that a promise to investigate before the release?

Robby

On Wednesday, November 13, 2013, Sam Tobin-Hochstadt wrote:

> On Wed, Nov 13, 2013 at 5:50 PM, Robby Findler <notifications@github.com<javascript:_e({}, 'cvml', 'notifications@github.com');>
> 
> > wrote:
> > 
> > Thanks!! Looks like there is only one file to worry about at all.
> > 
> > Which one is it? (5th from the left)
> 
> On IRC @stamourv informed me that it's `impl-exec.rkt`. I plan to push the
> changes anyway, and then we can worry about speeding up this one case.
> 
> Sam
> 
> —
> Reply to this email directly or view it on GitHubhttps://github.com/plt/racket/pull/476#issuecomment-28442554
> .

Is this slowdown something we/you are worried about?

On Wed, Nov 13, 2013 at 6:29 PM, Robby Findler notifications@github.comwrote:

> Is that a promise to investigate before the release?
> 
> Robby
> 
> On Wednesday, November 13, 2013, Sam Tobin-Hochstadt wrote:
> 
> > On Wed, Nov 13, 2013 at 5:50 PM, Robby Findler <notifications@github.com<javascript:_e({},
> > 'cvml', 'notifications@github.com');>
> > 
> > > wrote:
> > > 
> > > Thanks!! Looks like there is only one file to worry about at all.
> > > 
> > > Which one is it? (5th from the left)
> > 
> > On IRC @stamourv informed me that it's `impl-exec.rkt`. I plan to push
> > the
> > changes anyway, and then we can worry about speeding up this one case.
> > 
> > Sam
> > 
> > —
> > Reply to this email directly or view it on GitHub<
> > https://github.com/plt/racket/pull/476#issuecomment-28442554>
> > .
> 
> —
> Reply to this email directly or view it on GitHubhttps://github.com/plt/racket/pull/476#issuecomment-28445033
> .

Yes. Enough to try to understand it at least. May we decide not to fix it
but we should not just ignore it. Especially when it is due to an
essentially cosmetic feature.

Robby

On Wednesday, November 13, 2013, Sam Tobin-Hochstadt wrote:

> Is this slowdown something we/you are worried about?
> 
> On Wed, Nov 13, 2013 at 6:29 PM, Robby Findler <notifications@github.com<javascript:_e({}, 'cvml', 'notifications@github.com');>>wrote:
> 
> > Is that a promise to investigate before the release?
> > 
> > Robby
> > 
> > On Wednesday, November 13, 2013, Sam Tobin-Hochstadt wrote:
> > 
> > > On Wed, Nov 13, 2013 at 5:50 PM, Robby Findler <
> > > notifications@github.com <javascript:_e({}, 'cvml',
> > > 'notifications@github.com');><javascript:_e({},
> > > 'cvml', 'notifications@github.com <javascript:_e({}, 'cvml',
> > > 'notifications@github.com');>');>
> > > 
> > > > wrote:
> > > > 
> > > > Thanks!! Looks like there is only one file to worry about at all.
> > > > 
> > > > Which one is it? (5th from the left)
> > > 
> > > On IRC @stamourv informed me that it's `impl-exec.rkt`. I plan to push
> > > the
> > > changes anyway, and then we can worry about speeding up this one case.
> > > 
> > > Sam
> > > 
> > > —
> > > Reply to this email directly or view it on GitHub<
> > > https://github.com/plt/racket/pull/476#issuecomment-28442554>
> > > .
> > 
> > —
> > Reply to this email directly or view it on GitHub<
> > https://github.com/plt/racket/pull/476#issuecomment-28445033>
> > .
> 
> —
> Reply to this email directly or view it on GitHubhttps://github.com/plt/racket/pull/476#issuecomment-28445534
> .

On Wed, Nov 13, 2013 at 6:48 PM, Robby Findler notifications@github.comwrote:

> Yes. Enough to try to understand it at least. May we decide not to fix it
> but we should not just ignore it. Especially when it is due to an
> essentially cosmetic feature.

I 100% disagree that this is a "cosmetic feature".  The output of the
statistical errortrace profiler that we built is close to unusable without
this, in my opinion.

You can reopen the files and completely avoid the overhead. You already
admitted this before I feel pretty sure.

On Wednesday, November 13, 2013, Sam Tobin-Hochstadt wrote:

> On Wed, Nov 13, 2013 at 6:48 PM, Robby Findler <notifications@github.com<javascript:_e({}, 'cvml', 'notifications@github.com');>
> 
> > wrote:
> > 
> > Yes. Enough to try to understand it at least. May we decide not to fix it
> > but we should not just ignore it. Especially when it is due to an
> > essentially cosmetic feature.
> 
> I 100% disagree that this is a "cosmetic feature". The output of the
> statistical errortrace profiler that we built is close to unusable without
> this, in my opinion.
> 
> —
> Reply to this email directly or view it on GitHubhttps://github.com/plt/racket/pull/476#issuecomment-28446663
> .

On Wed, Nov 13, 2013 at 6:56 PM, Robby Findler notifications@github.comwrote:

> You can reopen the files and completely avoid the overhead. You already
> admitted this before I feel pretty sure.

You can re-open the files, and read the s-expression at the given source
location, but that doesn't give you the same information that the current
code gives you -- that would require re-expanding the file as well, and
running all this code.

I'm also confused about why you're worried about this. Do you use
errortrace from the command line on large redex files?  This change has no
impact on drracket's use of errortrace.

On Wed, Nov 13, 2013 at 6:00 PM, Sam Tobin-Hochstadt <
notifications@github.com> wrote:

> On Wed, Nov 13, 2013 at 6:56 PM, Robby Findler <notifications@github.com
> 
> > wrote:
> > 
> > You can reopen the files and completely avoid the overhead. You already
> > admitted this before I feel pretty sure.
> 
> You can re-open the files, and read the s-expression at the given source
> location, but that doesn't give you the same information that the current
> code gives you -- that would require re-expanding the file as well, and
> running all this code.
> 
> This doesn't make sense to me. I think you can just record filename,
> position, and span and use that as an opaque thing (without doing any
> searching) during profiling and then when you go to render, just open the
> file and extract the code in that range.

It is even better than recording syntax because you preserve the
indentation.

> I'm also confused about why you're worried about this. Do you use
> errortrace from the command line on large redex files? This change has no
> impact on drracket's use of errortrace.

Oh, I thought your change affected DrRacket. Sorry for the confusion. (You
probably told me this before and I just forgot, too.)

So, nevermind. Push away.

Robby

On Wed, Nov 13, 2013 at 8:03 PM, Robby Findler notifications@github.comwrote:

> On Wed, Nov 13, 2013 at 6:00 PM, Sam Tobin-Hochstadt <
> notifications@github.com> wrote:
> 
> > On Wed, Nov 13, 2013 at 6:56 PM, Robby Findler <notifications@github.com
> > 
> > > wrote:
> > > 
> > > You can reopen the files and completely avoid the overhead. You already
> > > admitted this before I feel pretty sure.
> > 
> > You can re-open the files, and read the s-expression at the given source
> > location, but that doesn't give you the same information that the current
> > code gives you -- that would require re-expanding the file as well, and
> > running all this code.
> > 
> > This doesn't make sense to me. I think you can just record filename,
> > position, and span and use that as an opaque thing (without doing any
> > searching) during profiling and then when you go to render, just open the
> > file and extract the code in that range.
> 
> It is even better than recording syntax because you preserve the
> indentation.

The code does something different than that, though.  The strategy you
describe produces nothing when you have no source location, for example.
The find-source-syntax function finds a slightly larger region of the
original code that includes the code searched for, instead of nothing.

> I'm also confused about why you're worried about this. Do you use
> errortrace from the command line on large redex files? This change has no
> impact on drracket's use of errortrace.

Oh, I thought your change affected DrRacket. Sorry for the confusion. (You

> probably told me this before and I just forgot, too.)
> 
> So, nevermind. Push away.

I'll do that, but I will take a look at the slowdown on that one file
before the release (but after the PLDI deadline :).

Thanks.

Robby

On Wed, Nov 13, 2013 at 9:05 PM, Sam Tobin-Hochstadt <
notifications@github.com> wrote:

> On Wed, Nov 13, 2013 at 8:03 PM, Robby Findler <notifications@github.com
> 
> > wrote:
> > 
> > On Wed, Nov 13, 2013 at 6:00 PM, Sam Tobin-Hochstadt <
> > notifications@github.com> wrote:
> > 
> > > On Wed, Nov 13, 2013 at 6:56 PM, Robby Findler <
> > > notifications@github.com
> > > 
> > > > wrote:
> > > > 
> > > > You can reopen the files and completely avoid the overhead. You
> > > > already
> > > > admitted this before I feel pretty sure.
> > > 
> > > You can re-open the files, and read the s-expression at the given
> > > source
> > > location, but that doesn't give you the same information that the
> > > current
> > > code gives you -- that would require re-expanding the file as well, and
> > > running all this code.
> > > 
> > > This doesn't make sense to me. I think you can just record filename,
> > > position, and span and use that as an opaque thing (without doing any
> > > searching) during profiling and then when you go to render, just open the
> > > file and extract the code in that range.
> > 
> > It is even better than recording syntax because you preserve the
> > indentation.
> 
> The code does something different than that, though. The strategy you
> describe produces nothing when you have no source location, for example.
> The find-source-syntax function finds a slightly larger region of the
> original code that includes the code searched for, instead of nothing.
> 
> > I'm also confused about why you're worried about this. Do you use
> > errortrace from the command line on large redex files? This change has no
> > impact on drracket's use of errortrace.
> 
> Oh, I thought your change affected DrRacket. Sorry for the confusion. (You
> 
> > probably told me this before and I just forgot, too.)
> > 
> > So, nevermind. Push away.
> 
> I'll do that, but I will take a look at the slowdown on that one file
> before the release (but after the PLDI deadline :).
> 
> —
> Reply to this email directly or view it on GitHubhttps://github.com/plt/racket/pull/476#issuecomment-28455882
> .

Merged.

Looks good.

At this point, I think everything LGTM.
A bit more squashing (more than just for the last few commits) would help, IMO. I had a bit of a hard time following the big picture of the changes.

I think the new static contract modules would benefit from having purpose statements explaining what the modules do. Even better if the functions had them too.

BTW: Is the plan to merge this in time for 6.0? I have a commit to add contract generation for `Channelof` types, but if the plan is to merge this soon, then I'll hold off on pushing it since it would need to be re-written to fit static contracts anyway and would needlessly complicate the rebase.

I don't think so. I don't want to push such a large change in the last few
days.

On Mon, Nov 18, 2013 at 10:57 PM, Asumu Takikawa
notifications@github.comwrote:

> BTW: Is the plan to merge this in time for 6.0? I have a commit to add
> contract generation for Channelof types, but if the plan is to merge this
> soon, then I'll hold off on pushing it since it would need to be re-written
> to fit static contracts anyway.
> 
> —
> Reply to this email directly or view it on GitHubhttps://github.com/plt/racket/pull/453#issuecomment-28769856
> .

Addressed the two comments about commit messages. Squashed some commits together, rebased to head, and fixed some issues in parse type and type annotation tests with them running at the wrong phase.

@rfindler, @stamourv did some new benchmarks after fixing some bugs I introduced before he pushed the changes.  You can see them here: https://drive.google.com/file/d/0B_PD5hI-SVauLUNXYlludVR6UERMMHFEbVV4MDVHYWY5WWg0/edit?usp=sharing

The result is that it's now sometimes faster, sometimes slower, which is better than before, but I'll still take a look at why the `impl-exec.rkt` file is slower. 

Sweet, thanks!

On Thu, Nov 21, 2013 at 1:58 PM, Sam Tobin-Hochstadt <
notifications@github.com> wrote:

> @rfindler https://github.com/rfindler, @stamourvhttps://github.com/stamourvdid some new benchmarks after fixing some bugs I introduced before he
> pushed the changes. You can see them here:
> https://drive.google.com/file/d/0B_PD5hI-SVauLUNXYlludVR6UERMMHFEbVV4MDVHYWY5WWg0/edit?usp=sharing
> 
> The result is that it's now sometimes faster, sometimes slower, which is
> better than before, but I'll still take a look at why the impl-exec.rktfile is slower.
> 
> —
> Reply to this email directly or view it on GitHubhttps://github.com/plt/racket/pull/476#issuecomment-29018007
> .

Merged, thanks!

Thanks, I've merged this now. I kept the comma printing and made the changes you suggested.

This should _really_ use `list-collects.rkt` instead of creating another copy, possibly making it depend on a shell variable to do things that are specific to each shell (but IIRC, they should both use it in the same way).

(BTW, you left the error message when you copy-pasted it...)

Merged - thanks!

Thanks Tony. I decided to go with the hard version and went through the pain this morning.

Thank you, Jay! Very cool.

Ping.

Ping.

Ping.

Still not a fan of that interface, but let's push it.

Merged: https://github.com/plt/racket/commit/27119013b3a746ff4a251b7c16ca7233588a203d

Thanks, I've pushed it. (Sorry for the overly long delay.)

Robby

On Tue, Dec 3, 2013 at 12:19 AM, Matthew Butterick <notifications@github.com

> wrote:
> 
> A few small fixes, based on bug reports from @rfindlerhttps://github.com/rfindlerand
> 
> ## @mbutterick https://github.com/mbutterick
> 
> You can merge this Pull Request by running
> 
>   git pull https://github.com/mbutterick/racket scribble-css-fixes
> 
> Or view, comment on, or merge it at:
> 
>   https://github.com/plt/racket/pull/504
> Commit Summary
> - small Scribble CSS fixes
> - add missing weight of Source Code font
> 
> File Changes
> - _M_ pkgs/scribble-pkgs/scribble-lib/scribble/manual-fonts.csshttps://github.com/plt/racket/pull/504/files#diff-0(6)
> - _M_ pkgs/scribble-pkgs/scribble-lib/scribble/manual-racket.csshttps://github.com/plt/racket/pull/504/files#diff-1(5)
> - _M_ pkgs/scribble-pkgs/scribble-lib/scribble/manual-style.csshttps://github.com/plt/racket/pull/504/files#diff-2(2)
> 
> Patch Links:
> - https://github.com/plt/racket/pull/504.patch
> - https://github.com/plt/racket/pull/504.diff

Messed this up with a force push. Fixing...

r+

Looks good to me.

Merged - thanks!

Merged - thanks!

Merged - thanks!

Merged - thanks!

@Metaxal Thanks very much, I'm glad you did this, it's a great idea!

I made a couple comments. The first is optional code simplification. The second is I think the tests won't pass as-is.

Forgot to remove displays. Don't commit this patch.

Merged, thanks!

Merged, thanks!

What should happen if the value is set!'d on the untyped side (currently
the contract system is broken in this case anyway, as you can see from the
recent test suite addition)?

Relatedly, does it seem possible that if someone writes (provide/contract
[f (-> real? real?)]) that TR could know to just import that with the type
(Real -> Real), without having to explicitly add 'f' to some internal TR
table somewhere?

The change to provide.rkt seems okay to me.

Robby

On Fri, Dec 13, 2013 at 3:56 PM, Asumu Takikawa notifications@github.comwrote:

> This PR is for code review.
> 
> Right now, contracted identifiers like ~a cannot be imported into TR's
> base type environment. They only work with require/typed.
> 
> This is because contracted identifiers are really bound to transformers
> which lift into an expression that actually produces the value. TR may have
> a type assigned for the transformer identifier, but the resulting
> expression contains identifiers with no type information.
> 
> These commits allow the contract system to inform TR what transformer
> identifier resulted in the lifting, so that TR can assume the resulting
> expression has the same type that the base type environment records.
> 
> This should be sound if the following assumptions are met: (1) TR only
> allows untyped identifiers to have a type if they are in the base type
> environment or brought in with require/typed (I think this is true), and
> (2) the contracted identifiers have chaperone contracts, so that their
> "type" cannot change (or just assign a type where that's ok).
> 
> With these changes, something like this type-checks:
> 
> (module a typed/racket (~a 3 "foo" 5))
> 
> Doesn't work at the top-level yet because TR's top-level and lifting don't
> fit together well yet.
> 
> Relevant people for this PR: @rfindler https://github.com/rfindler
> 
> ## @samth https://github.com/samth
> 
> You can merge this Pull Request by running
> 
>   git pull https://github.com/takikawa/racket tr-contracts-base-env
> 
> Or view, comment on, or merge it at:
> 
>   https://github.com/plt/racket/pull/516
> Commit Summary
> - Add support for type-checking lifted contracted values
> - Add syntax property that tracks the exported name
> - Add type for ~a
> 
> File Changes
> - _M_
>   pkgs/typed-racket-pkgs/typed-racket-lib/typed-racket/base-env/base-env.rkthttps://github.com/plt/racket/pull/516/files#diff-0(14)
> - _M_
>   pkgs/typed-racket-pkgs/typed-racket-lib/typed-racket/typecheck/tc-app-combined.rkthttps://github.com/plt/racket/pull/516/files#diff-1(4)
> - _M_
>   pkgs/typed-racket-pkgs/typed-racket-lib/typed-racket/typecheck/tc-app/signatures.rkthttps://github.com/plt/racket/pull/516/files#diff-2(3)
> - _A_
>   pkgs/typed-racket-pkgs/typed-racket-lib/typed-racket/typecheck/tc-app/tc-app-contracts.rkthttps://github.com/plt/racket/pull/516/files#diff-3(38)
> - _M_
>   pkgs/typed-racket-pkgs/typed-racket-lib/typed-racket/typecheck/tc-app/tc-app-main.rkthttps://github.com/plt/racket/pull/516/files#diff-4(4)
> - _M_ racket/collects/racket/contract/private/provide.rkthttps://github.com/plt/racket/pull/516/files#diff-5(45)
> 
> Patch Links:
> - https://github.com/plt/racket/pull/516.patch
> - https://github.com/plt/racket/pull/516.diff

> The change to provide.rkt seems okay to me.

Thanks.

> What should happen if the value is set!'d on the untyped side (currently the contract system is broken in this case anyway, as you can see from the recent test suite addition)?

Do you mean the problem mentioned in the Guide section 7.8.4? If so, that seems fine since the mutation isn't observable right? Or something else?

> Relatedly, does it seem possible that if someone writes (provide/contract [f (-> real? real?)]) that TR could know to just import that with the type (Real -> Real)

That sounds do-able with support from the contract system. In particular if the contract system provided a syntax property with some representation of the contract that's checked. TR could then parse that and use the corresponding type if TR can figure one out.

On Fri, Dec 13, 2013 at 5:57 PM, Asumu Takikawa notifications@github.comwrote:

> The change to provide.rkt seems okay to me.
> 
> Thanks.
> 
> What should happen if the value is set!'d on the untyped side (currently
> the contract system is broken in this case anyway, as you can see from the
> recent test suite addition)?
> 
> Do you mean the problem mentioned in the Guide section 7.8.4? If so, that
> seems fine since the mutation isn't observable right? Or something else?

I thought it got worse with my push, but maybe it didn't. In any case, the
value of the exported variable is looked up only once, not once per
reference in the client module.

>  Relatedly, does it seem possible that if someone writes
> (provide/contract [f (-> real? real?)]) that TR could know to just import
> that with the type (Real -> Real)
> 
> That sounds do-able with support from the contract system. In particular
> if the contract system provided a syntax property with some representation
> of the contract that's checked. TR could then parse that and use the
> corresponding type if TR can figure one out.

contract-out can put a representation of its export as a syntax property,
but I think it would probably be better to have something that
syntactically checked to make sure the contract was expressible as a type
and that it was visible syntactically somehow, since I guess things like
this won't be supported:

#lang racket/base
(define (x y) y)
(define x/c (-> real? real?))
(provide (contract-out [x x/c])

In other words, how about:

#lang racket/base
(require typed/contracts)
(define (x y) y)
(provide (typed/contract-out [x (Real -> Real)]))

and that is the same as contract-out if the client side is untyped, but it
is a type if the client side is typed. It seems like most of the pieces are
around to make that work without too much trouble.....  well, maybe there's
some refactoring to make the typed/contracts library small.

(Also, I'd love to get TR's arrow back to the proper place where it belongs
in this Lisp-like language.... Sam promised me he'd do something ages
ago...)

Robby

> and that is the same as contract-out if the client side is untyped, but it is a type if the client side is typed. It seems like most of the pieces are around to make that work without too much trouble..... well, maybe there's some refactoring to make the typed/contracts library small.

Oh, yes something like that is possible; @stamourv and I have discussed something like it. Basically the form just needs to set up a `#%type-decl` submodule and then do a normal `contract-out` using the contract generated from the type. It would still need to apply the contract in all cases for soundness.

On Fri, Dec 13, 2013 at 7:31 PM, Asumu Takikawa notifications@github.com
wrote:

> and that is the same as contract-out if the client side is untyped, but
> it is a type if the client side is typed. It seems like most of the pieces
> are around to make that work without too much trouble..... well, maybe
> there's some refactoring to make the typed/contracts library small.
> 
> Oh, yes something like that is possible; @stamourv and I have discussed
> something like it. Basically the form just needs to set up a #%type-decl
> submodule and then do a normal contract-out using the generated contract.
> It would still need to apply the contract in all cases for soundness.

It could use type->contract and the improvements coming to check only half
of the contract on the typed side, I presume. But yes, it has to be just
contract-out for the untyped side. Probably you want to use
define-module-boundary-contract instead of contract-out, tho.

Robby

I don't think this is a good idea. If `lazy-require` isn't propagating dependencies correctly, we should fix that.

The big reason to avoid this is  "time to type error". Further, now that DrRacket supports providing incremental results, we can start providing types sooner as well. Loading the optimizer early works against both of those goals.

Lazy require is propagating dependencies according to its documentation, which prevents cycles when it is used for such, but is not the desired behavior here. We want tc-setup to depend on the optimizer.

Can you give me a benchmark that you think represents 'time to type error', and I will calculate the slow down. In my initial checks it was a negligable difference, for #:no-optimize programs.

r+

And you don't need to bother with review for new tests. 

Use `in-value` for that:

```
(for* ([title '("Guide" "Reference" "Notes")]
       [title-length (in-value (string-length title))]
       #:when (> 8 title-length))
  (printf "Title ~a. (length: ~a)\n" title title-length))
```

hmm, I'm a bit surprised. Thanks

@greghendershott Thanks a lot for your feedback! I thought I had checked everything but apparently not at all... Well, I hope all is fixed now. One small thing: The tests seem to pass, but when I run `raco test .` in the scribble-test/tests directory, some tests fails (that do not seem related to markdown though, but more to the scribble reader). I hope this doesn't interact badly with my commit. Could you confirm you see the same thing? I've asked on the mailing list but no one replied.

@shekari I see that you've gotten lots of docs done on this.  Any sense of when it's likely to be ready for merging?

This is now quite out of date, given the package switch.  @paddymahoney do you think you can rebase this onto current HEAD?  @mflatt or @elibarzilay can you review this change?

I've got a bunch of fixes and new tests in work. I recently added tests
with regards to Asumus complaints and it is still failing those.

If you think the docs are good enough, I'd like to submit this as soon as
it passes all the tests.

Also after writing the docs for optimize and trying to remember how the
second argument worked, I decided that it needed rework (which lead to more
tests, and the fixes).

On Tue, Dec 17, 2013 at 4:20 PM, Sam Tobin-Hochstadt <
notifications@github.com> wrote:

> @shekari https://github.com/shekari I see that you've gotten lots of
> docs done on this. Any sense of when it's likely to be ready for merging?
> 
> —
> Reply to this email directly or view it on GitHubhttps://github.com/plt/racket/pull/453#issuecomment-30805466
> .

I think this is a good change overall. Your second example error message has a problem though. It seems to be saying that 1 != 1.

Ah whoops. That was a bug I introduced but fixed already. I hadn't updated the sample output though (just did).

> Could you confirm you see the same thing?

Yes.

>  I've asked on the mailing list but no one replied.

I replied that confirm seeing the same thing.

I also tried again just now after doing `git clean -x -d -f` (i.e. a sort of `make clean`) and `make`. Same result.

Thanks. They've been talking about changes in the way the contracts are displayed, maybe this is related, in which case they might look into this after the next release maybe.

I think this last set of commits addresses the comments so far.

Merged - thanks!

Thanks!

On Thu, Dec 19, 2013 at 3:02 AM, Matthew Flatt notifications@github.comwrote:

> Merged - thanks!
> 
> —
> Reply to this email directly or view it on GitHubhttps://github.com/plt/racket/pull/478#issuecomment-30899632
> .

LGTM.

This looks okay to me to include in the release at first glance.

But Matthew B: if you think it should be included in the release, do you
midn sending us "before" and "after" screenshots (or just pointing us to a
snapshot build for the before, if that's easier).

Thanks,
Robby

On Sat, Dec 21, 2013 at 1:59 PM, Matthew Butterick <notifications@github.com

> wrote:
> 
> This change fixes a bizarre line-spacing problemhttp://stackoverflow.com/questions/20695333/in-css-why-does-decimal-line-height-behave-differently-from-percentage-or-emthat crops up when CSS line-height is specified with a percentage or an em
> value, and the paragraph contains mutiple font sizes. (Illustrated herehttp://jsfiddle.net/Y7Jta/2/.)
> 
> ## The fix is to use unitless line-height values.
> 
> You can merge this Pull Request by running
> 
>   git pull https://github.com/mbutterick/racket scribble-css-fixes
> 
> Or view, comment on, or merge it at:
> 
>   https://github.com/plt/racket/pull/529
> Commit Summary
> - switch to unitless line-heights
> 
> File Changes
> - _M_ pkgs/scribble-pkgs/scribble-lib/scribble/manual-racket.csshttps://github.com/plt/racket/pull/529/files#diff-0(2)
> - _M_ pkgs/scribble-pkgs/scribble-lib/scribble/manual-style.csshttps://github.com/plt/racket/pull/529/files#diff-1(18)
> 
> Patch Links:
> - https://github.com/plt/racket/pull/529.patch
> - https://github.com/plt/racket/pull/529.diff

Sure. Here's a comparison from the quick introduction.

Before: http://www.cs.utah.edu/plt/snapshots/current/doc/quick/index.html
After: http://mbutterick.github.io/racket-doc-redo/doc/quick/index.html

In the "before" example, the second paragraph ("An expression can also be ...") shows the intended line spacing. But notice that the first and third paragraphs have slightly larger spacing in lines where Racket terms appear. This is a bug. 

Whereas in the "after" example, all the lines are the same height. This is the intended result.

Sorry for the late commit — it took a while to puzzle out.

![comparison](https://f.cloud.github.com/assets/1425051/1796664/d663efcc-6a7d-11e3-8da9-9d6aecda0b19.gif)

Looks great! Thank you.

And, if'll you excuse me the liberty of assuming you'd go along: we
generally take a long-term perspective here. There will always be another
release. There are small windows where we are careful about commits going
into upcoming releases (basically the time between when we start special
testing on the release branch and when we actually release). That time is
now, so we audit each commit and this one seems pretty clearly unlikely to
introduce an crippling bugs.

Robby

On Sat, Dec 21, 2013 at 2:35 PM, Matthew Butterick <notifications@github.com

> wrote:
> 
> Sure. Here's a comparison from the quick introduction.
> 
> Before: http://www.cs.utah.edu/plt/snapshots/current/doc/quick/index.html
> After: http://mbutterick.github.io/racket-doc-redo/doc/quick/index.html
> 
> In the "before" example, the second paragraph ("An expression can also be
> ...") shows the intended line spacing. But notice that the first and third
> paragraphs have slightly larger spacing in lines where Racket terms appear.
> This is a bug.
> 
> Whereas in the "after" example, all the lines are the same height. This is
> the intended result.
> 
> Sorry for the late commit — it took a while to puzzle out.
> 
> [image: comparison]https://f.cloud.github.com/assets/1425051/1796664/d663efcc-6a7d-11e3-8da9-9d6aecda0b19.gif
> 
> —
> Reply to this email directly or view it on GitHubhttps://github.com/plt/racket/pull/529#issuecomment-31071644
> .

[Here's the answer](http://stackoverflow.com/a/20818206/1486915) to the conundrum of why different ways of specifying `line-height` produce different results.

Are there any plans for adding contracts for StructTypes? I have thought about it before, and haven't seen a good way to do it because there aren't chaperones for them.

I think there are actually chaperones for them: http://www.cs.utah.edu/plt/snapshots/current/doc/reference/chaperones.html?q=chaperone-struct-type#%28def._%28%28quote._~23~25kernel%29._chaperone-struct-type%29%29

I haven't done any work on contracts for them, but it seems like a good thing to add too.

@mflatt ping.

In the first patch, I think changing `(get-compiled-time mode roots path)` to `path-zo-time` is unlikely to be right. The intent (if I remember correctly) is to see the side effect of `(build)`.

In the second patch, putting the `collects-relative-cache` at the module top-level assumes too much about when collection changes happen, but it would make sense to tie that cache to the `up-to-date` cache.

Fixed both patches according to comments.

Second one now makes the cache like the `up-to-date` cache, and has it passed everywhere via arguments.

Ok, I'll rerun the performance tests I did originally and confirm that the improvement is still there, and then submit later tonight.

At Mon, 06 Jan 2014 13:44:07 -0800, Stephen Olsen wrote:

> I downloaded the latest 6.0.0.1 snapshot. The icons look great but
> the text is still pixelated. Is there something else to do to fix
> that?

I'm not sure what's wrong. Can you tell me more about your machine and
display configuration?

Merged - thanks!

Woo!

r+

r+

r+ after addressing the comments.

There's already infrastructure for handling renamed ids in Typed Racket, for typed exports.  Can we create a re-useable abstraction?

Thanks for the comments. Merged.

Thanks, merged.

Thanks for the comments, merged.

Merged.

Note: let me know if the notation doesn't match correctly with the `->*` contract combinator because I had screwed up the parenthesization earlier, so there may be more mistakes.

Also, @stamourv pointed out that the printer could do more aggressive recovery of optional argument types. He also came up with an implementation strategy (using greedy set coverage and `group-by`) which I'll try to implement.

Updated with the more aggressive `->*` type printing mentioned above. This turns the type for `regexp-match` into:

```
(case-> (->* ((U Regexp String) Path-String) 
             (Integer (U Integer False) (U False Output-Port) Bytes) 
             (U False (Pairof String (Listof (U False String)))))
        (->* ((U Byte-Regexp Bytes) (U Path-String Bytes Input-Port)) 
             (Integer (U Integer False) (U False Output-Port) Bytes) 
             (U False (Pairof Bytes (Listof (U False Bytes)))))
        (->* ((U Regexp Byte-Regexp String Bytes) (U Bytes Input-Port)) 
             (Integer (U Integer False) (U False Output-Port) Bytes) 
             (U False (Pairof Bytes (Listof (U False Bytes))))))
```

from this:

```
(case-> ((U Byte-Regexp Regexp Bytes String) (U Bytes Input-Port) Integer (U Integer False) (U False Output-Port) Bytes
          -> (U False (Pairof Bytes (Listof (U False Bytes)))))
        ((U Byte-Regexp Regexp Bytes String) (U Bytes Input-Port) Integer (U Integer False) (U False Output-Port) 
         -> (U False (Pairof Bytes (Listof (U False Bytes)))))
        ((U Byte-Regexp Regexp Bytes String) (U Bytes Input-Port) Integer (U Integer False) 
          -> (U False (Pairof Bytes (Listof (U False Bytes)))))
        ((U Byte-Regexp Regexp Bytes String) (U Bytes Input-Port) Integer -> (U False (Pairof Bytes (Listof (U False Bytes)))))
        ((U Byte-Regexp Regexp Bytes String) (U Bytes Input-Port) -> (U False (Pairof Bytes (Listof (U False Bytes)))))
        ((U Byte-Regexp Bytes) (U Path-String Bytes Input-Port) Integer (U Integer False) (U False Output-Port) Bytes 
          -> (U False (Pairof Bytes (Listof (U False Bytes)))))
        ((U Byte-Regexp Bytes) (U Path-String Bytes Input-Port) Integer (U Integer False) (U False Output-Port) 
         -> (U False (Pairof Bytes (Listof (U False Bytes)))))
        ((U Byte-Regexp Bytes) (U Path-String Bytes Input-Port) Integer (U Integer False)
         -> (U False (Pairof Bytes (Listof (U False Bytes)))))
        ((U Byte-Regexp Bytes) (U Path-String Bytes Input-Port) Integer -> (U False (Pairof Bytes (Listof (U False Bytes)))))
        ((U Byte-Regexp Bytes) (U Path-String Bytes Input-Port) -> (U False (Pairof Bytes (Listof (U False Bytes)))))
        ((U Regexp String) Path-String Integer (U Integer False) (U False Output-Port) Bytes 
         -> (U False (Pairof String (Listof (U False String)))))
        ((U Regexp String) Path-String Integer (U Integer False) (U False Output-Port)
         -> (U False (Pairof String (Listof (U False String)))))
        ((U Regexp String) Path-String Integer (U Integer False) -> (U False (Pairof String (Listof (U False String)))))
        ((U Regexp String) Path-String Integer -> (U False (Pairof String (Listof (U False String)))))
        ((U Regexp String) Path-String -> (U False (Pairof String (Listof (U False String))))))
```

Note: line breaks added manually. Combined with the pretty printing PR, it will have automatic linebreaks.

Merged - thanks!

I added some `opt-lambda` improvements as well. The reason it's not in a separate PR is that it depends on the `->*` syntax. Hopefully this'll make it easier to support keyword and optional arguments in ordinary `lambda:` sometime.

Ok, have made a bunch of fixes/changes.

Major changes:
New mechanism for contracts that are terminal so that it is extensible.
Good error messages when the static contract cannot be be converted (Similar to before my changes).
Checking of bad parametric contracts is back, and improved to catch more cases.
Unused recursive contracts are now cleaned up when optimizing.
Bunch of changes to the printer of static contracts to make them easier to look at when debugging.

Does this introduce much overhead in compile-time for TR programs? For example, when compiling the math library.

LGTM modulo comments above.

First run is with my code, second is without.
endobson@yggdrasil () ~/proj/racket/plt/pkgs/typed-racket-pkgs/typed-racket-lib % for i in {1..5}                                                                                                                                        (0)
rm -rf ~/proj/racket/compile-root/6.0.0.1/Users/endobson/proj/racket/plt/pkgs/math-pkgs/math-lib/ && time raco setup -D math >/dev/null  
raco setup -D math > /dev/null  353.26s user 39.92s system 439% cpu 1:29.42 total
raco setup -D math > /dev/null  359.36s user 40.48s system 435% cpu 1:31.90 total
raco setup -D math > /dev/null  356.67s user 40.07s system 435% cpu 1:31.02 total
raco setup -D math > /dev/null  365.19s user 41.77s system 440% cpu 1:32.43 total
raco setup -D math > /dev/null  352.59s user 40.36s system 431% cpu 1:30.97 total
endobson@yggdrasil () ~/proj/racket/plt/pkgs/typed-racket-pkgs/typed-racket-lib % for i in {1..5}                                                                                                                                        (0)
rm -rf ~/proj/racket/compile-root/6.0.0.1/Users/endobson/proj/racket/plt/pkgs/math-pkgs/math-lib/ && time raco setup -D math >/dev/null
raco setup -D math > /dev/null  352.52s user 39.07s system 433% cpu 1:30.30 total
raco setup -D math > /dev/null  351.67s user 39.82s system 439% cpu 1:28.98 total
raco setup -D math > /dev/null  357.61s user 39.79s system 436% cpu 1:31.07 total
raco setup -D math > /dev/null  371.53s user 40.84s system 434% cpu 1:34.83 total
raco setup -D math > /dev/null  360.93s user 40.32s system 442% cpu 1:30.59 total

Looks like it is all noise.

Some integration tests are broken, and there may be an infinite loop somewhere.

Fixed both the infinite loop and the broken tests.

LGTM.

Looks right to me.

LGTM

There's a lot of repetition between the unary and binary cases. Do you think abstracting the two would make the code clearer? (or would it turn the code into a tangled mess?)

LGTM too

r+ with comments.

r+ with comments

I have later changes which abstract over the differences.

See https://github.com/shekari/racket/blob/opts/pkgs/typed-racket-pkgs/typed-racket-lib/typed-racket/optimizer/arithmetic.rkt#L178 for the final results.

But it currently is about 50ish commits to build up the necessary infrastructure. The issue with the current system is it only works on floats and just blindly transforms the results into floats when it wants them. What I have built doesn't do the conversion (because it is unsound) and just tracks when the results get turned to floats and then starts doing optimizations.

So I think waiting till that fixes it is the better solution. 

Looks like most of the optimizations are applying magnitude to a float. I'll add such optimizations back.

Sounds good. LGTM

Thanks for the feedback. Merged.

Does that restore all the optimizations that were disabled?

Merged.

LGTM on new changes. I haven't actually gone through all the original code in detail, but the changes look good overall. (and issues at the detail-level can be dealt with post-merging)

Just FYI to keep everyone in the loop, I have changes to how contracts are serialized sitting in my classes branch that lifts out sharing in the contract syntax in order to reduce bytecode size. Once this PR is merged, I'm planning to re-write that code to fit into the `instantiate` pass of these static contracts. The change should be fairly non-invasive because of the new architecture (hopefully) and I don't think it duplicates any of the work here.

Merging shouldn't be too bad, as I have been keeping this mostly up to date
with HEAD. I'll try to get this in tonight, so that you can start on that.

On Mon, Jan 13, 2014 at 3:55 PM, Asumu Takikawa notifications@github.comwrote:

> LGTM on new changes. I haven't actually gone through all the code in
> detail, but the changes look good overall. (and issues at the detail-level
> can be dealt with post-merging)
> 
> Just FYI to keep everyone in the loop, I have changes to how contracts are
> serialized sitting in my classes branch that lifts out sharing in the
> contract syntax in order to reduce bytecode size. Once this PR is merged,
> I'm planning to re-write that code to fit into the instantiate pass of
> these static contracts. The change should be fairly non-invasive because of
> the new architecture (hopefully) and I don't think it duplicates any of the
> work here.
> 
> —
> Reply to this email directly or view it on GitHubhttps://github.com/plt/racket/pull/453#issuecomment-32225582
> .

@samth: Thinking about your question, I'm not sure there's a good abstraction that is more general. In this case, we can trust the syntax property that racket/contract provides because TR trusts the contract system.

In general, though, we don't want to trust any other macros that claim that an identifier is really "the same" as another binding. And I don't see an obvious way to connect this to the existing handling of renamed identifiers, since by the point that TR gets its hands on the syntax it's too late to figure out the connection.

By my count it did.

Rebased against head, and changed the error message to reflect that it is only possible real arithmetic. Also sent a patch for optimization coach.

LGTM

This version causes bizareness when a traced function is called inside (with-output-to-file ...). I'm not sure what the correct behavior should be.

Is the function defined at the module level, or in some inner scope?

Module level.

On Tue, Jan 14, 2014 at 10:59:51AM -0800, Vincent St-Amour wrote:

> Is the function defined at the module level, or in some inner scope?
> 
> ---
> 
> Reply to this email directly or view it on GitHub:
> https://github.com/plt/racket/pull/525#issuecomment-32295256

This patch makes me very happy.  r+ w/ comments.

I'm not sure how I feel about this. I'll just list some of my thoughts on the subject.
- Some people are unhappy about the existing infix syntax.
- The infix syntax allows this:

```
    ;; foo : Integer -> Integer
```

to turn into this:

```
    (: foo : Integer -> Integer)
```

which I like a lot. (It looks especially good in talks :)
- I want to have a shorter syntax for optional arguments -- it's probably the biggest current TR syntax problem.
- It would be nice for the optional-argument syntax to be more like what we write in documentation.
- I find the contract library `->*` syntax consistently confusing, and always have to look at the docs.

That's about it for thought at the moment.

cc: @rfindler @shekari @stamourv

On Wed, Jan 15, 2014 at 9:25 AM, Sam Tobin-Hochstadt <
notifications@github.com> wrote:

> I'm not sure how I feel about this. I'll just list some of my thoughts on
> the subject.
> - ## Some people are unhappy about the existing infix syntax.
>   
>   The infix syntax allows this:
>   
>   ;; foo : Integer -> Integer
> 
> to turn into this:
> 
> (: foo : Integer -> Integer)
> 
> which I like a lot. (It looks especially good in talks :)

Use dotted notation for that. No one will notice in talks.

> - I want to have a shorter syntax for optional arguments -- it's
>   probably the biggest current TR syntax problem.
> - It would be nice for the optional-argument syntax to be more like
>   what we write in documentation.
> - I find the contract library ->\* syntax consistently confusing, and
>   always have to look at the docs.
> 
> This isn't what I was asking about. For the record.
> 
> That's about it for thought at the moment.
> 
> cc: @rfindler https://github.com/rfindler @shekarihttps://github.com/shekari
> @stamourv https://github.com/stamourv
> 
> —
> Reply to this email directly or view it on GitHubhttps://github.com/plt/racket/pull/535#issuecomment-32370936
> .

Robby, I realize that wasn't what you were asking about, but it's what's in the pull request.  Also, if we're trying to align with contract syntax (which I think is valuable) we'd want to align as much as is reasonable.

Okay.

FWIW, I don't mind adding a new combinator, but I find the ->\* notation
pretty straight forward, actually: it's two sequences which are both like
the domain part of ->, one for mandatory arguments and one for optional
ones. (The optional one is itself optional.) Does that help?

Robby

On Wed, Jan 15, 2014 at 9:31 AM, Sam Tobin-Hochstadt <
notifications@github.com> wrote:

> Robby, I realize that wasn't what you were asking about, but it's what's
> in the pull request. Also, if we're trying to align with contract syntax
> (which I think is valuable) we'd want to align as much as is reasonable.
> 
> —
> Reply to this email directly or view it on GitHubhttps://github.com/plt/racket/pull/535#issuecomment-32371500
> .

Well, I don't have any good ideas for what a new combinator would look like, otherwise I'd suggest it.

And the syntax of `->*` always makes sense to me after I look it up.  I think my problem is that it doesn't look like anything else that I write, such a function definitions or documentation.

LGTM

Re: the infix `->` looking good for talks, I'm not proposing to eliminate the infix form since we need to maintain backwards compatibility anyway (and this PR doesn't remove it). We would have to pick a canonical one for printing, but we could offer a way to change the printing behavior.

For optional argument types, I would be inclined to pick `->*` (well, I wrote the PR so I'm biased :p) just because it's already a notation that a bunch of people already use/know from contracts. Making up a new combinator for both contracts and types might work too, but that means nobody will be familiar with it initiailly.

To get something closer to the docs would be great, I agree. But I think
that would require thinking a bit larger, going in the direction that Jay
and Matthias have been thinking about for moving entire specifications out.
So I think it is good for to work towards that, but it doesn't seem good to
hold up these changes for that to happen.

My $0.02,
Robby

On Wed, Jan 15, 2014 at 9:57 AM, Asumu Takikawa notifications@github.comwrote:

> Re: the infix -> looking good for talks, I'm not proposing to eliminate
> the infix form since we need to maintain backwards compatibility anyway
> (and this PR doesn't remove it). We would have to pick a canonical one for
> printing, but we could offer a way to change the printing behavior.
> 
> For optional argument types, I would be inclined to pick ->\* (well, I
> wrote the PR so I'm biased :p) just because it's already a notation that a
> bunch of people already use/know from contracts. Making up a new combinator
> for both contracts and types might work too, but that means nobody will be
> familiar with it initiailly.
> 
> —
> Reply to this email directly or view it on GitHubhttps://github.com/plt/racket/pull/535#issuecomment-32374336
> .

IMO, Asumu's design is the right way to go. Consistency with the contract system is a big improvement. Even though `->*`'s syntax is not 100% obvious at first, having two different syntaxes (one for TR, one for contracts) would be worse.

Re printing: I'd go with prefix printing, especially since we want to be able to use `->*` when printing.

I'm for consistency.

Ok, the consensus here is pretty clear. I'll have a look at the code (and the rest of you should too).

I think the opt-lambda typechecking things should be put in a different Pull Request, because we already have special casing for opt-lambda and I would hope that we can fit the new stuff entirely within that function instead of having to special case it in tc-expr.

Okay, I've reverted the opt-lambda changes and will work on them in another PR.

I believe have addressed all the current comments.

LGTM

Nevermind my last comment, I hadn't actually gotten to the third commit yet. In terms of commit organization though, would it make more sense to put the shared implementation first and then use it in `parse-type`?

LGTM

I think you should add the correct name while keeping the old one.

Done, that makes more sense after the fact. I split it out orignally so that I could get it working for-label without breaking everything in the optimizer.

Thanks, this has been merged.

Ping, any other comments? Looked into making the parsing errors better as Eric suggested, but it's non-trivial. Maybe best done in a separate PR later?

I rebased the PR, so it now incorporates pretty printing and has printing tests. I also added some syntax classes for parsing `->*` types. The type for `regexp-match` now prints like this:

```
Welcome to Racket v6.0.0.1.
-> regexp-match
- : (case->
     (->*
      ((U Regexp String) Path-String)
      (Integer (U Integer False) (U False Output-Port) Bytes)
      (U False (Pairof String (Listof (U False String)))))
     (->*
      ((U Byte-Regexp Bytes) (U Path-String Bytes Input-Port))
      (Integer (U Integer False) (U False Output-Port) Bytes)
      (U False (Pairof Bytes (Listof (U False Bytes)))))
     (->*
      ((U Regexp Byte-Regexp String Bytes) (U Bytes Input-Port))
      (Integer (U Integer False) (U False Output-Port) Bytes)
      (U False (Pairof Bytes (Listof (U False Bytes))))))
#<procedure:regexp-match>
```

I'll also change function types to print with the prefix arrow before merging, which I forgot to do in this round of commits.

I finally did my yearly scan, and found many more files.  I tried to make it a nice two commits with yours in, but managed to mess it up thoroughly, so I'll just do a single commit -- sorry.

(Closing this too.)

(See comment in the issue, I meant for it to go here.)

LGTM. I think the documented syntax is better, and that the contradictory syntax should be disposed of. There may be a backwards compatibility issue though.

Did we reach a conclusion on how All and prefix -> should interact?

Github is being stupid and displaying the commits in the wrong order for me. But they are in the order Cleanup, Split out, Make parse type.

LGTM.

This makes a bunch of the logging give 'interesting' results. But I'm not sure how to improve it. There is no original syntax object that corresponds to a and b in (+ a b c). We also get new logging that corresponds to let expressions that don't exist in the original program.

I agree with @shekari on the syntax. Is there any code in the tree that uses the working-but-undocumented syntax?

@samth none in the tests, since I ran them without problems. I also doubt there are any in the rest of the tree, but will try building everything again to check. The only use I know of is an example snippet by Norman Gray in this e-mail: http://lists.racket-lang.org/users/archive/2013-March/056757.html

Merged. Addressed Eric's first comment. Used the documented syntax and also checked that the rest of the tree builds.

There should be syntax objects for `a` and `b` (not for `(+ a b)`, though).
Would `recover-source-syntax` help here?

Would logging optimizations on `(+ a b)` using the source location for `(+ a b c)` work? IIUC, that should give us the same logging (except maybe with duplicates) as before.

When I build this branch, I get errors about `unsafe-flmin` being given 3 arguments instead of 2.

Just to keep everyone updated, I added more tests as Eric requested and thanks to him I've found some bugs (multiple optional keywords just didn't work...) so I restructured the code a bunch (it's now simpler). I'll push that to the PR soon after tests pass.

Added more tests, made it work for more than 1 optional keyword argument, and addressed PR comments. Also, future work for this is to allow TR `lambda` to come with mixed (i.e., some argument types are elided) type annotations on keywords and optional arguments. This is already possible in this PR with reader-based type annotations, but syntactic support would be nice.

Thanks for the comments. Merged.

I think one issue is that convert currently is broken on functions with two or more optional arguments, because it only creates a type with all the arguments provided or none provided.

I think I've now fixed type-checking for optional argument functions. Also addressed the PR feedback so far.

 I'm not seeing the problem. Does it help to get rid of all of your .zo
files and try again?

Robby

On Sat, Feb 1, 2014 at 11:25 AM, Jens Axel Søgaard notifications@github.com
wrote:

> The MetaPict package works in DrRacket only if the option
> "Populate "compiled" directories (for faster loading) provokes error"
> is turned off.
> 
> The error message is:
> Welcome to DrRacket, version 6.0.0.1--2014-01-30(7476ca0/d) [3m].
> Language: racket; memory limit: 256 MB.
> ../racket/collects/compiler/cm.rkt:430:6: write: unsealed
> local-definition or module context found in syntax object
> 
> To reproduce:
> 1) Get MetaPict here: https://github.com/soegaard/metapict
> 2) Open and run main.rkt
> 
> —
> Reply to this email directly or view it on GitHub.

Hi,

It didn't help to delete the contents of the compiled directories.

I have produced a minimal example:

## def.rkt

#lang racket
(provide (all-defined-out))
(define-syntax def  (make-rename-transformer #'define))

## bug.rkt

#lang racket
(require "def.rkt")

The error:
racket/collects/compiler/cm.rkt:430:6: write: unsealed local-definition or
module context found in syntax object

The flags in the DrRacket language menu is:
  Debugging
  Populate ...
  Preserve stacktrace
  Enforce constant definitions

/Jens Axel

2014-02-01 Robby Findler notifications@github.com:

> I'm not seeing the problem. Does it help to get rid of all of your .zo
> files and try again?
> 
> Robby
> 
> On Sat, Feb 1, 2014 at 11:25 AM, Jens Axel Søgaard <
> notifications@github.com>
> wrote:
> 
> > The MetaPict package works in DrRacket only if the option
> > "Populate "compiled" directories (for faster loading) provokes error"
> > is turned off.
> > 
> > The error message is:
> > Welcome to DrRacket, version 6.0.0.1--2014-01-30(7476ca0/d) [3m].
> > Language: racket; memory limit: 256 MB.
> > ../racket/collects/compiler/cm.rkt:430:6: write: unsealed
> > local-definition or module context found in syntax object
> > 
> > To reproduce:
> > 1) Get MetaPict here: https://github.com/soegaard/metapict
> > 2) Open and run main.rkt
> > 
> > —
> > Reply to this email directly or view it on GitHub.
> 
> —
> Reply to this email directly or view it on GitHubhttps://github.com/plt/racket/issues/559#issuecomment-33883512
> .

## 

## 

Jens Axel Søgaard

ping

Oh, whoop, sorry. It would be good to use #:val-first-projection instead of
#:projection here:

https://github.com/plt/racket/pull/551/files#diff-cb89b967c5266a1d7091e0228b05d60aR1517

which entails a bunch of other small changes.

I see I didn't describe this in the docs, tho, so go ahead and push without
that and I'll try to explain it soon. (The docs say it is subject to
change, but I think it has settled by now.)

Sorry again for the delay.

Robby

On Mon, Feb 3, 2014 at 3:20 PM, Asumu Takikawa notifications@github.comwrote:

> ping
> 
> —
> Reply to this email directly or view it on GitHubhttps://github.com/plt/racket/pull/551#issuecomment-34001307
> .

(this is the version that the finder shows)

Here's a simpler way to reproduce it: `(match '(1 1) [(list-no-order b b) 'blorgh])`

I've pushed a repair, I think. Let's see if the next snapshot build is right.

I addressed most of the feedback received so far in the commits I just pushed. There are some small things still remaining, such as moving the class typecheck tests out. I also added support for positional init arguments and init-rest (put it in this PR since it involves a small representation change).

Fixed.

Great idea! I love this.
Did you forget to include `reset-port.rkt`, though? I can't find it.
Also, some of these tests have large blocks of newlines (added to make the log diffs less confusing), which can now be removed.

I think 0 is the right answer. Checking at all places definitely sounds right.

Okay, thanks Robby. I'll go ahead and push this and fix it to match the new API later.

Transcript of some discussion with @samth:

```
< samth> asumu: this is also useful for `make-struct-type` among other things
< samth> asumu: i think with sufficient work this could be made to be a significant simplification of the subtyping/inference code
< asumu> samth: hmm, maybe, but it also seems like it could complicate it. e.g., it will have to deal with when the rest arg is a heterogeneous list versus homogeneous list type.
< samth> asumu: well, you could just ditch the homogenous case
< samth> the heterogenous case subsumes it
< samth> and you could treat subtyping/inference for multi-arg functions as a list-subtyping/inference problem in all cases
< asumu> Hmm, yes I guess that could work, if you fold the argument types as (-pair first-arg (-pair ... (-pair last-arg rest-type))) and let inference/subtyping go.
< asumu> Also, it might make it possible to ditch the drest argument of function types.
< asumu> By having the rest type be (ListDots ...) (stamourv suggested this)
< samth> that would work
< samth> and then a lot of problems become the same problem
< samth> which would be very good for the sensibleness of the code
< asumu> We could also change the internals along these lines (as a refactoring) without changing user-visible syntax or types too.
```

Merged.

@mflatt 
Changed to have 0 in all three cases. I looked at the tests but didn't know where to add them? Should I put both a reader that changes the port in the test dir and the actual file, or should the reader be in the directory above.

@stamourv 
Yep forgot to include reset port. Fixed that and removed a bunch of extra newlines. There are still going to be corner cases where it logs the `#%module-begin` form (saw some in vector-sum), but I believe these are all bad logging.

Re `#%module-begin`: Yeah, that looks unrelated.
Re `vector-sum.rkt`: Log sorting is a bit odd there, any idea what's going on?

Not sure what you mean by the sorting. Do you mean the fact that 9 > 10, if so that is just because we do an alphabetical sort not numeric.

I figured out one cause of the bunch of duplicated logs and fixed that. I also figured out the source of the `#%module-begin`, that syntax object has no location info. I'm not sure what we should log there, but I think that `#%module-begin` is the wrong thing. Perhaps `<unknown>`?

Re sorting: Good catch, yes that's alphabetical order. That's unfortunate.
Re `#%module-begin`: Makes sense, `recover-source-syntax` won't find anything and will return the most top-level thing it knows. Do you know if we're the ones losing the source location, or if it's some other macro before us? Either way, we should fix this.

AFAICT it is the for macro, but my debugging didn't show where.

On Thu, Feb 6, 2014 at 6:36 AM, Vincent St-Amour
notifications@github.comwrote:

> Re sorting: Good catch, yes that's alphabetical order. That's unfortunate.
> Re #%module-begin: Makes sense, recover-source-syntax won't find anything
> and will return the most top-level thing it knows. Do you know if we're the
> ones losing the source location, or if it's some other macro before us?
> Either way, we should fix this.
> 
> —
> Reply to this email directly or view it on GitHubhttps://github.com/plt/racket/pull/563#issuecomment-34328034
> .

Confirmed that it is for and filed a bug, pr/14343.

On Thu, Feb 6, 2014 at 9:21 AM, Eric Dobson eric.n.dobson@gmail.com wrote:

> AFAICT it is the for macro, but my debugging didn't show where.
> 
> On Thu, Feb 6, 2014 at 6:36 AM, Vincent St-Amour <notifications@github.com
> 
> > wrote:
> > 
> > Re sorting: Good catch, yes that's alphabetical order. That's unfortunate.
> > Re #%module-begin: Makes sense, recover-source-syntax won't find
> > anything and will return the most top-level thing it knows. Do you know if
> > we're the ones losing the source location, or if it's some other macro
> > before us? Either way, we should fix this.
> > 
> > —
> > Reply to this email directly or view it on GitHubhttps://github.com/plt/racket/pull/563#issuecomment-34328034
> > .

This might help :)

```
diff --git a/racket/collects/racket/private/for.rkt b/racket/collects/racket/private/for.rkt
index ba64270..79b84fb 100644
--- a/racket/collects/racket/private/for.rkt
+++ b/racket/collects/racket/private/for.rkt
@@ -1233,7 +1233,8 @@
                         pre-guard
                         post-guard
                         [loop-arg ...]) ...) (reverse (syntax->list #'binds))])
-         #`(let-values (outer-binding ... ...)
+         (quasisyntax/loc #'orig-stx
+           (let-values (outer-binding ... ...)
              outer-check ...
              #,(syntax/loc #'orig-stx
                  (let for-loop ([fold-var fold-init] ...
@@ -1249,7 +1250,7 @@
                                    (for-loop fold-var ... loop-arg ... ...)
                                    (values* fold-var ...)))
                              (values* fold-var ...)))
-                       (values* fold-var ...))))))]
+                       (values* fold-var ...)))))))]
       ;; Bad body cases:
       [(_ [orig-stx . _] fold-bind ())
        (raise-syntax-error
```

Yes, it did. Thanks! (Pushed @tohammer's patch.)

I think more needs to be said about the problems with enumerators and the
example should show two indices that produce the same result. In
particular, don't assume that your audience knows what property "soundness"
refers to here. Just explain what goes wrong directly.

I can give this a try if you want; let me know.

Robby

On Mon, Feb 10, 2014 at 6:56 AM, Max S. New notifications@github.comwrote:

> ## Includes documentation.
> 
> You can merge this Pull Request by running
> 
>   git pull https://github.com/maxsnew/racket mismatch
> 
> Or view, comment on, or merge it at:
> 
>   https://github.com/plt/racket/pull/567
> Commit Summary
> - Use disjoint sum in redex production enumerators
> - Redex Enumerator support for mismatch patterns
> - Update redex enumeration docs
> 
> File Changes
> - _M_ pkgs/redex-pkgs/redex-doc/redex/scribblings/ref.scrblhttps://github.com/plt/racket/pull/567/files#diff-0(18)
> - _M_ pkgs/redex-pkgs/redex-lib/redex/private/enum.rkthttps://github.com/plt/racket/pull/567/files#diff-1(22)
> - _M_ pkgs/redex-pkgs/redex-lib/redex/private/preprocess-pat.rkthttps://github.com/plt/racket/pull/567/files#diff-2(1)
> - _M_ pkgs/redex-pkgs/redex-test/redex/tests/enum-test.rkthttps://github.com/plt/racket/pull/567/files#diff-3(23)
> 
> Patch Links:
> - https://github.com/plt/racket/pull/567.patch
> - https://github.com/plt/racket/pull/567.diff
> 
> —
> Reply to this email directly or view it on GitHubhttps://github.com/plt/racket/pull/567
> .

Yeah "unsound" is too vague.

I wasn't sure that I should go into that much depth since the reason ambiguous mismatch pattern enums are unsound is the same reason other patterns are non-injective in the presence of ambiguity and there's a section preceding it explaining the difficulty with ambiguity (which should also be reworded I think).

Ideally we could get an explanation for anyone that understands what
enumeration is supposed to be doing plus a little bit of analytical
thinking skill, but without necc. much more.

I didn't look at the paragraph before, tho: let me know who gets the next
try on the text. If you want, I can, but tell me to... :)

Robby

On Mon, Feb 10, 2014 at 7:35 AM, Max S. New notifications@github.comwrote:

> Yeah "unsound" is too vague.
> 
> I wasn't sure that I should go into that much depth since the reason
> ambiguous mismatch pattern enums are unsound is the same reason other
> patterns are non-injective in the presence of ambiguity and there's a
> section preceding it explaining the difficulty with ambiguity (which should
> also be reworded I think).
> 
> —
> Reply to this email directly or view it on GitHubhttps://github.com/plt/racket/pull/567#issuecomment-34631690
> .

Have at it.

-Max Stewart New

On Mon, Feb 10, 2014 at 7:46 AM, Robby Findler notifications@github.comwrote:

> Ideally we could get an explanation for anyone that understands what
> enumeration is supposed to be doing plus a little bit of analytical
> thinking skill, but without necc. much more.
> 
> I didn't look at the paragraph before, tho: let me know who gets the next
> try on the text. If you want, I can, but tell me to... :)
> 
> Robby
> 
> On Mon, Feb 10, 2014 at 7:35 AM, Max S. New notifications@github.comwrote:
> 
> > Yeah "unsound" is too vague.
> > 
> > I wasn't sure that I should go into that much depth since the reason
> > ambiguous mismatch pattern enums are unsound is the same reason other
> > patterns are non-injective in the presence of ambiguity and there's a
> > section preceding it explaining the difficulty with ambiguity (which
> > should
> > also be reworded I think).
> > 
> > ## 
> > 
> > Reply to this email directly or view it on GitHub<
> > https://github.com/plt/racket/pull/567#issuecomment-34631690>
> > .
> 
> ## 
> 
> Reply to this email directly or view it on GitHubhttps://github.com/plt/racket/pull/567#issuecomment-34632618
> .

I asked for some feedback on IRC this morning because I want to merge this in the near future. @samth's concern was that error messages for invalid lambdas could be bad. It turns out the typed lambda gives better error messages than the core one.

@stamourv thinks we should carefully consider the various `:` suffixed forms and transition all of them to have no `:` if we're going to do it for `lambda`. Here is a list of all `:` forms listed in the docs (not counting legacy forms):
- `let:`, `plet:`, `letrec:`, `let*:`, `let-values:`, `letrec-values:`, `let*-values:`
- `let/cc:`, `let/ec:`
- `lambda:`, `plambda:`
- `case-lambda:`
- `opt-lambda:`, `popt-lambda:`
- `for:` and many many derived forms
- `do:` (rarely used)
- `define:`
- `struct:`, `define-struct:`, `define-struct/exec:`
- `provide:` (nobody uses this)

Of these, the `let`-like forms should be unambiguous because a binding form has two elements while a typed binding form has three. For the loop form, the `:` before the bindings is unambiguous. Similarly with `plet`.

None of the `lambda` forms should be ambiguous again because of the number of items in the formals.

The `for:` clauses already allow type annotations to be omitted (at least the documented syntax claims so, though this often won't typecheck) and the result type annotation is unambiguous.

I thnk `do:` should be fine, but few people use it anyway.

The `define:` form may be ambiguous since the polymorphic variant has type variables that look like a function header. This could be a problem if the result type annotation is optional (which it would have to be to work as plain `define`).

@samth has said before that it doesn't make sense to change the `struct:` form since it always requires type annotations to be useful.

Re `plet:` / `plambda:` / `pdefine:`: We could allow `let` / `lambda` / `define` (no `:`, although the `:` variants probably should too for consistency) to take a keyword argument for type variables, and make `plet:` and co legacy forms.
Re `struct:`: If we make the non-`:` versions of the other macros accept type annotations, plain `struct` should too.

Progress update: I have all of the `let`, `lambda`, and `struct` forms in good shape now.

I have a working `define` that I need to test more. It allows mixed type annotations along with currying. Needs more testing though, and it currently fails to support polydots.

The `do` form is done. I'm not going to bother with an analogue of `provide:` (eventually we can consider providing a `typed-out` or something).

Haven't started on the `for` forms yet.

@stamourv now agrees with you two that the un-parenthesized prefix arrow doesn't make sense. I'll go implement the special case and then merge it.

Also, the `opt-lambda` improvements that I originally talked about in this PR are now superceded by PR 557.

Update: this PR now provides non-: versions of all of the important forms. All existing tests pass (though it still needs better new ones too).

There are some syntax questions to resolve. For example, is the new syntax for type variables okay?

```
(lambda ([x : A]) #:forall (A) x)
(lambda ([x : A]) #:forall (A) : A x)
```

The ordering matters in this case. Should the type variables come before the return type annotation or before? Is it odd that it comes after the formals? (the binding goes right to left) It also accepts the unicode forall.

@samth suggested putting the type variables before the names in these forms, so they now look like this:

```
(lambda #:forall (A) ([x : A]) x)
(lambda #:forall (A) ([x : A]) : A x)
(define #:forall (A) (f [x : A]) x)
(let #:forall (A) ([x : A 0]) x)
```

which I think looks better in general since the binding comes first, but I think the `define` case is a bit ugly because the name comes later. Also it might be slightly worse for indentation.

Any other feedback on this PR?

1. This needs (short) docs for all of the newly-exported forms.
2. I'm not a fan of `(struct p (x y))` working with `Any` for `x` and `y`.

Ok, my plan for docs was to document the :-less forms and move the current forms as-is to the legacy section. Does that sound good?

Re: `struct`, is there a better default or are you just opposed to having a default? We could in theory also just emit an error saying you need an annotation.

For docs, that sounds good.  My major concern is that we always have something linked for `let` etc in TR code.

For `struct`, I just don't think a default is useful. A related case is that in ML/Haskell, you could declare datatypes as:

```
data F = A | B | C
```

and then just use it as `A 1 2` and inference could work out the appropriate arity/types of the constructors.  But that would be much harder to understand.

Okay, in that case I will have the syntax class for the no-annotation case emit an error message saying something like "struct field x must have a type annotation".

Will merge this today with the changes I've mentioned unless someone objects.

Merged.

Merged. I'm still planning to move out the class tests into a separate file (requires refactoring test harness machinery) and address some other minor feedback that I didn't get around to (didn't want to keep waiting and keep making the push bigger).

Is this good to go in with fixups merged?

r+

Yes, r+ for this.

@mflatt @stamourv Can you take a look at this patch?

I'm going to close this because I plan to submit a new pull request today that supersedes it.

You can definitely do this without defining a new grammar or adding a type to the term. The pattern you supply to `redex-match` doesn't necessarily need to conform to the language it references, for example,

``` racket
(redex-match L
             (e_1 e_2 e_3)
             (term (1 2 (+ 3 4))))
```

succeeds even though there aren't any `L` expressions that look like that. However the three subexpressions (i.e. `e_1`) all have to match the `e` non-terminal in `L`.

The grammar for Redex patterns is in the docs at:
http://docs.racket-lang.org/redex/The_Redex_Reference.html#%28tech._pattern%29
Would a link to that in the tutorial have helped?

Thanks.

I've pushed this change. Does that help?

http://git.racket-lang.org/plt/commitdiff/4b15bcedbf0f47fdf573ea35c5e43b4edd7ab76f?hp=60948fabf48bb3360aae68fc939c70cf5aa223ab

Otherwise: what Burke said. :)

Robby

On Wed, Feb 26, 2014 at 4:57 PM, Ryan Davis notifications@github.comwrote:

> In exercise 1 of http://docs.racket-lang.org/redex/tutorial.html it asks
> you to extract the body of the function for the following expression
> 
> ((λ (x) (+ x 1))
>  17)
> 
> As exercise 1, and with the language used, it seems like defining a custom
> grammar to do so is out of scope, and you're supposed to use the supplied
> language L. The problem is that you can't match the above expression with
> L because it expects lambda forms to have 2 args (x t), as shown in the
> first failed match example.
> 
> Further, it asks for you to extract "the body of the function" and I
> honestly can't tell if I'm supposed to extract the body of the function
> application 17 or the function body being applied (+ x 1). The former is
> easy, the latter seems infeasible given the lesson so far. I've gotten it
> to work via:
> 
> (redex-match L ((λ (_ _) e_1) e_2)
>              (term ((λ (x num) (+ x 1))
>                     17)))
> 
> But it was a huge leap to assume that I could manually substitute e_1with something as complex as (λ
> (_ _) e_1) and _ hasn't been mentioned to ignore pieces. Since it seems
> that match is actually being used under the covers of redex-match, maybe
> at least add a link to the patterns available? Either this tutorial should
> be as standalone as possible, or it needs to link to the applicable
> reference material to finish the exercises.
> 
> —
> Reply to this email directly or view it on GitHubhttps://github.com/plt/racket/issues/571
> .

Yeah. I think that clarifies it quite a bit.

I do think a link to the redex match patterns would help too.

I am confused by what @bfetscher said about not having to conform to the language. I mean, I get it... but I don't see why redex would allow for the match pattern to not conform to the language specified. Seems like it'd be easy to be thrown off by your own bug simply because redex allowed you to go off course. Example?

Well, sometimes you might want to match a sequence of expressions. And
often there are multiple non-terminals in a language -- which one is the
"right one" for any given match? Redex doesn't know those things. Perhaps
another design could have a better set up to do more error checking, I can
easily admit that, but it isn't an obvious thing to know how to do what
you're asking.

hth,
Robby

On Wed, Feb 26, 2014 at 9:15 PM, Ryan Davis notifications@github.comwrote:

> Yeah. I think that clarifies it quite a bit.
> 
> I do think a link to the redex match patterns would help too.
> 
> I am confused by what @bfetscher https://github.com/bfetscher said
> about not having to conform to the language. I mean, I get it... but I
> don't see why redex would allow for the match pattern to not conform to the
> language specified. Seems like it'd be easy to be thrown off by your own
> bug simply because redex allowed you to go off course. Example?
> 
> —
> Reply to this email directly or view it on GitHubhttps://github.com/plt/racket/issues/571#issuecomment-36206083
> .

LGTM

Seems quite sensible. r+

Just to double-check, is the following the correct reasoning for this change?

The result of `object->sexp` will only be used either in a case where `Empty` or `NoObject` are guarded against anyway (the `Result` case in printing) or for messages printed for debugging. In other cases (such as in `check-below.rkt`) there is some custom message printed instead.

Looks good. r+

I finally got around to addressing @shekari's comments for this PR. The latest commit separates the code that generates the list of non-recursive clauses to check, the actual checking code, and the 2nd pass that remains the same as before.

To replace the algorithm with a better one that uses Tarjan's algorithm, only one function should need modification if I set things up correctly. (and once the other PR that has an implementation of Tarjan's algorithm is merged, we could do this)

r+

LGTM.

I'm not getting a double-encoding result when I add `#lang scribble/manual` in a file "h.scrbl" and render with `scribble h.scrbl`.

Can you say more about how you're running the example?

Ah you're right; I only seem to get this problem when using Frog to generate pages from Scribble files. I'll look into this more.

If there's a Racket bug, it's with `xexpr->string`, which is where this originates:

``` racket
(xexpr->string '(a ([href "/foo/path?a=1&b=2"]) "a"))
;; =>
"<a href=\"/foo/path?a=1&amp;b=2\">a</a>" ;??
```

This doesn't seem correct to me. I don't think `xexpr->string` should be encoding characters in attribute value strings?  (Encode the element "bodies", yes, but not attribute values.)

@greghendershott The XML standard explicitly mentions that & cannot appear in attribute values: http://www.w3.org/TR/xml/#NT-AttValue

The HTML5 standard (which xexpr->string is not a generator for) appears ambiguous this part

http://www.w3.org/TR/html-markup/syntax.html#syntax-attribute-value

says that named references are always allowed (which means xexpr->string is correct) but also says that any Unicode text that is not a "control character" is allowed. There is no reference for a "control character" in the document, but I presume that & is not one. This means that an HTML5 generator doesn't have to encode &, but can.

The second document you reference says, at the top: "This document has been discontinued and is only made available for historical purposes. For an up to date reference on HTML elements (and more) please consult Web Platform Docs."  The up to date reference we should use is:

http://www.whatwg.org/specs/web-apps/current-work/multipage/syntax.html#attributes-0

which does define control characters by reference to this document:

http://www.unicode.org/Public/5.1.0/ucd/PropList.txt

in which you can see that it isn't listed as having character class `Cc`, which mean it isn't a control character.  Here:

http://www.fileformat.info/info/unicode/char/0026/index.htm

it says that it has character class Po.

As to XML, I really wish we'd stop treating XML as the primary use case for x-expressions.  Almost all uses that I've seen of them are for generating HTML, which has different rules. XML, the minority use case, should be the one doing more work.

Thanks for the better reference. That document also says that & is only allowed if it is not ambiguous, implying that encoding it is always allowed, but not necessary.

Anyone is welcome to make (require html) or (require html5) do something more appropriate for HTML generation, but an XML-expression (xexpr) is an encoding of XML, not HTML.

The bottom-line: xexpr->string is correct by its spec (generating XML) in general and in this case in particular. Some other process is inappropriately double-encoding or a browser is not reading HTML.

@jeapostrophe Thanks for the response. I fixed the bug logged against Frog by defining my own variation on `xexpr->string`.

---

Considering it's exported by a module named `xml` I think it's understandable for `xexpr->string` to be defined in terms of strict XML rules.

However it's also confusing because people routinely use x-expressions to represent things that aren't strict XML -- for example HTML (not XHTML). So in practice the `x` in x-expression isn't XML, it's more like a variable x meaning "XML-ish or HTML-ish".

For example: The `html` module's `read-html-as-xml` returns `(listof content/c)` -- which happily stores the `&` in the attribute. The `xml` module's `xml->xexpr` converts it to an x-expression -- which happily stores the `&` in the attribute. It's only upon using `xexpr->string` that it gets encoded as `&amp;`.

Would you be opposed to a parameter to control what's encoded?  (Either a flag for `&`, or, a string or set of what's to be encoded?)

Or are you saying you'd prefer that the `html` provide its own variation of `xexpr->string`?  (In this case I'd suggest, as long as "the hood is open", also defining a convenience `read-html-as-xexpr` to avoid the awkwardness using `xml->xexpr` (which I remember was very confusing as a newb, and even now I still have to double-check the docs to get it right)).

@greghendershott 

The "x" is not a variable. "X-expression" is a technical term in the docs defined here:

http://docs.racket-lang.org/xml/index.html?q=xexpr#%28tech._x._expression%29

as: "XML can be represented as an instance of the document structure type, or as a kind of S-expression that is called an X-expression."

## 

I think that an html library should provide its own versions and how you choose to share code between the two is up to your engineering taste. I'd say that the parameter approach seems mostly okay, but I would think that it would be ugly from the xml side because there's no sensible documentation for the parameter other than "used to not generate XML from the XML library" which is strange thing to support.

@jeapostrophe 

I think the attitude that "the documentation says it's for XML, so what people use it for is irrelevant" is a big mistake.  Working with HTML is, I think, the majority use case for x-expressions, HTML is not XML, and we should pay attention to this. A quick grep suggests that the string `require xml` appears 19 times in the `pkgs` directory, and only 2 of those are actual applications working with XML as opposed to HTML (5 are tests/docs/implementation for the `xml` library). 

Right now, our libraries are harder to use than they should be, and we should fix that, rather than standing on ceremony.

@samth 

I find your attitude incredible. The documentation for the XML package describing XML expression and the behavior of a function called XML to String is the only thing we should think about when deciding if it is right.

A rational point could be that the XML package is not what the users want and the HTML package is so bad that the XML package, despite its faults for HTML generation, is the next best choice. But that is a comment on how to improve the HTML package and not really relevant for the XML package.

I agree that the HTML package should be fixed to make the libraries easier to use for HTML generation. But that has nothing to do with the XML package.

Furthermore, the source of the discussion is not actually a mismatch between HTML and XML, because "&amp;" is allowed to mean "&" in HTML attribute values.

Perhaps a better response earlier would have been to either point the OP to
another library or to say that we don't have another library but would love
contributions? Maybe that's what Sam should really be asking for?

Robby

On Mon, Mar 10, 2014 at 3:30 PM, Jay McCarthy notifications@github.comwrote:

> @samth https://github.com/samth
> 
> I find your attitude incredible. The documentation for the XML package
> describing XML expression and the behavior of a function called XML to
> String is the only thing we should think about when deciding if it is right.
> 
> A rational point could be that the XML package is not what the users want
> and the HTML package is so bad that the XML package, despite its faults for
> HTML generation, is the next best choice. But that is a comment on how to
> improve the HTML package and not really relevant for the XML package.
> 
> I agree that the HTML package should be fixed to make the libraries easier
> to use for HTML generation. But that has nothing to do with the XML package.
> 
> Furthermore, the source of the discussion is not actually a mismatch
> between HTML and XML, because "&" is allowed to mean "&" in HTML attribute
> values.
> 
> —
> Reply to this email directly or view it on GitHubhttps://github.com/plt/racket/issues/577#issuecomment-37230288
> .

I hate to interrupt the lively discussion, but as pointed out, the bug was downstream and has been fixed there, so I'm going to close this issue. Perhaps we can settle how to solve people using the XML library for HTML in the mailing list.

@jeapostrophe 

Here's one quote about the `xml` library:

"The xml library gives us xexpr->string, which takes a Racket value that looks like HTML and turns it into actual HTML:"

Here's another one:

"the following examples illustrate how natural it is to use X-expressions to represent HTML"

Those are from the "More" and "Continue" tutorials, respectively, and were written by Matthew and by you. I don't think we can claim that you and Matthew are confused about x-expressions.

So maybe we're giving misleading advice about x-expressions in our documentation, and we should change these to say that using x-expressions for HTML will introduce subtle bugs, but we're just using them for convenience. Or we could have some totally different library for HTML, and all switch to that. 

Or, and this is what I prefer, we could recognize that x-expressions are a very effective notation for HTML, and are mostly used for that, _including in our own documentation_, and maintain the library with that in mind.

r+ once comments are all addressed.

@takikawa, do you plan to use the Tarjan's algorithm implementation here from #570? 

@samth yes, that's the plan. I'll extract out the algorithm into a utility module and generalize it a bit.

Sam Tobin-Hochstadt notifications@github.com writes:

> Or, and this is what I prefer, we could recognize that x-expressions
> are a very effective notation for HTML, and are mostly used for that,

i often use x-expressions but mostly not for (X)HTML

(update:
sorry for the noise, but I have to correct myself here because i thought
x-expression means sxml which apparently is not true (i often use sxml
but mostly not for (X)HTML)
)

There was a time when HTML was XML, when XHTML was considered to be its future. Those comments were written in that context. I think Continue was written in 2007. As time has progressed, I agree with you that they are now misleading.

I totally disagree with you about using X-expressions for HTML. I do see value in creating something like an H-expression that is very similar to X-expressions, but it would be a different type with different expectations.

> I totally disagree with you about using X-expressions for HTML. I do see value in creating something like an H-expression that is very similar to X-expressions, but it would be a different type with different expectations.

What would be different about H-expressions besides this issue?

Probably nothing except for little things like this on the other side of decoding. It may also be an opportunity to do special stuff like not encoding inside of Javascript blocks (which messes up <) and stuff like that.

Unclosed tags?

Robby

On Tue, Mar 11, 2014 at 11:41 AM, Jay McCarthy notifications@github.comwrote:

> Probably nothing except for little things like this on the other side of
> decoding. It may also be an opportunity to do special stuff like not
> encoding inside of Javascript blocks (which messes up <) and stuff like
> that.
> 
> —
> Reply to this email directly or view it on GitHubhttps://github.com/plt/racket/issues/577#issuecomment-37318094
> .

Both of those sound like issues that would be fixed by having `xexpr->html`, rather than needing a separate h-expr type, right?

Another data point is [response/xexpr](http://docs.racket-lang.org/web-server/http.html#%28def._%28%28lib._web-server%2Fhttp%2Fxexpr..rkt%29._response%2Fxexpr%29%29) exported by `web-server/http/xexpr`. It's shorthand for:

``` racket
(response/full
 code message seconds mime-type
 (append headers (map cookie->header cookies))
 (list preamble (string->bytes/utf-8 (xexpr->string xexpr))))
```

If this were to be used strictly for XHTML then it seems like there shouldn't be any `#:preamble` argument? Instead that would be hardwired to the DOCTYPE for XHTML.  And also the response would automatically include a `Content-Type: application/xhtml+xml` header.

I think `response/xexpr` also indicates that the spirit of x-expressions as actually used is more like "s-expressions for SGML flavors". One advantage of xexprs is that they're s-expressions and don't require fussing with matching close tags. The advantage isn't really XML-specific.

@tonyg: Although that might be a good change on its own merits, I don't see how it helps this. The problem (in some people's opinion) is:

``` racket
(xexpr->string '(a ([href "/foo/path?a=1&b=2"]) "a"))
;; =>
"<a href=\"/foo/path?a=1&amp;b=2\">a</a>"
```

So even if your PR reads the HTML attribute with either `&` or `&amp;` as `&` -- if I give that `&` to `xexpr->string` then it will still change it to `&amp;` as above.

Unless I'm misunderstanding.

That's right: but `xexpr->string` yielding `&amp;` in that case is correct for both HTML and XML. The OP's problem was double encoding, which resulted from frog using `read-html-as-xml` on the output of Scribble. So Scribble was rendering `(tag ((x "&")))` as `<tag x="&amp;"></tag>` or similar, which was then being read by `read-html-as-xml` as `(tag ((x "&amp;")))`, which is wrong. Then, frog was using `xexpr->string` on this, yielding `<tag x="&amp;amp;"></tag>`, which in and of itself is correct, for both HTML and XML. The fault lies with `read-html-as-xml`.

> The OP's problem was double encoding, 

Ah yes. Good point.

> `xexpr->string` yielding `&amp;` in that case is correct for both HTML and XML.

To make sure I understand.

``` html
<a href="/api?a=1&b=2">link</a>
```

is AFIK common HTML. Separating query parameters with `&` is very common.

It should be possible to express that as an x-expression

``` racket
(a ([href "/api?a=1&b=2"]) "link")
```

You're saying the changing the URI path from `/api?a=1&b=2` is `/api?a=1&amp;b=2` is OK. Therefore it's OK for `xexpr->string` to do so. Correct?

Yes, that's right. `(a ([href "/api?a=1&b=2"]) "link")` is an xexpr containing an href attribute which has a literal `#\&` character in the middle of its value string; the correct XML concrete syntax for this shows up as `&amp;`, and `&amp;` is also correct for HTML. Browsers read concrete HTML (and XML) `&amp;` in attribute value strings and convert them internally into `#\&` characters.

ETA: Concrete HTML syntax `<a href="foo&bar"></a>` is common, but not reliable; saying `<a href="foo&amp;bar"></a>` is reliable and is always correct. I don't want to go so far as to say it's _incorrect_ to have a naked ampersand in an HTML attribute value, but it's certainly not a good idea.

I don't really follow the technical aspects of this discussion, but I would
be very leery of changing this code. It is used in so many places that are
out of our control and probably its bugs are being worked around and a
change like this seems scary.

But that said, I won't object if others still think it is safe, now that
I've written my worry down. :)

Robby

On Tue, Mar 11, 2014 at 3:22 PM, Tony Garnock-Jones <
notifications@github.com> wrote:

> Yes, that's right. (a ([href "/api?a=1&b=2"]) "link") is an xexpr
> containing an href attribute which has a literal #& character in the
> middle of its value string; the correct XML concrete syntax for this shows
> up as "&", and "&" is also correct for HTML. Browsers read concrete HTML
> (and XML) "&" in attribute value strings and convert it internally into the
> #& character.
> 
> —
> Reply to this email directly or view it on GitHubhttps://github.com/plt/racket/issues/577#issuecomment-37344932
> .

@rfindler, are you saying that we shouldn't fix `read-html-as-xml` in #580 because people might be working around that bug? Or that we shouldn't change how `xexpr->string` behaves because that would break backwards compatibility in a more straightforward way?

Thanks for the comments. I merged this without commit c90d073 for now, but I may push that later with the suggested fixes included. (there are also two comments I will get around to in a later push)

Now merged, with cycle detection. Thanks for the feedback.

I'm saying that we should be leery of changes to these html-related
libraries unless the changes are obvious bug fixes.

In this case, my understanding from the discussion is that we're making a
change that is probably legal according to the spec but designed to be
taking advantage of a little leeway in the spec to do something that's more
likely to work well in a few more situations. That, if true, it seems to me
is asking for trouble.

Not entirely the same thing, but I remember lots and lots of pain when the
url->string and string->url functions were changed wrt to encoding in
attributes several years ago.

In short, I'm leaning towards what Jay says about making a different
library, but perhaps for different reasons.

But again, I have not tried to track down all of the technical details of
the spec. So hopefully this will be my last message here and you guys can
decide if the right thing is to take this patch or to do something else
that won't affect existing code at all.

Robby

On Tue, Mar 11, 2014 at 4:15 PM, Sam Tobin-Hochstadt <
notifications@github.com> wrote:

> @rfindler https://github.com/rfindler, are you saying that we shouldn't
> fix read-html-as-xml in #580 https://github.com/plt/racket/pull/580because people might be working around that bug? Or that we shouldn't
> change how xexpr->string behaves because that would break backwards
> compatibility in a more straightforward way?
> 
> —
> Reply to this email directly or view it on GitHubhttps://github.com/plt/racket/issues/577#issuecomment-37350998
> .

A quick note: one of the goals I had for scribble/html was to replace
the xexpr thing -- it's much less fragile (no quoting problems, prefer
using functions so no tag typos, no `(,@(if ...)) and append-map
hacks), still open for anything (using the constructors), and easily
extensible to new tags that require all kinds of weird content
encodings.

(/me goes back into the zombieland shadows.)

## 

```
      ((lambda (x) (x x)) (lambda (x) (x x)))          Eli Barzilay:
                http://barzilay.org/                   Maze is Life!
```

@rmculpepper. Ping.

Looks good to me.

@rfindler's comments in #577 caused me to reevaluate this patch. `read-html-as-xml` is still buggy, IMO, but this patch is a half-measure as it stands, and could make the situation worse. An improved fix for the bug in `read-html-as-xml` would process HTML entities at least as well as `lex-entity` from `sgml-reader.rkt` does. This requires a bit of design thinking to cope with unknown/unrepresentable entities.

@rfindler, I think the bug in `read-html-as-xml` falls into the "obvious bug" category, but the patch I proposed wasn't a good enough fix, because it didn't handle enough of the HTML character escape syntaxes. So `read-html-as-xml` is still broken, but at least it's _unambiguously_ broken.

If we all think it worth fixing, I'm happy to figure out a better solution and update my patch. If not, I suggest updating the documentation to make it clear that `read-html-as-xml` doesn't quite honor the `content/c` contract because it doesn't properly unescape attribute values.

Great! Thanks.

On Wed, Mar 12, 2014 at 12:15 PM, Tony Garnock-Jones <
notifications@github.com> wrote:

> @rfindler https://github.com/rfindler, I think the bug in
> read-html-as-xml falls into the "obvious bug" category, but the patch I
> proposed wasn't a good enough fix, because it didn't handle enough of the
> HTML character escape syntaxes. So read-html-as-xml is still broken, but
> at least it's _unambiguously_ broken.
> 
> If we all think it worth fixing, I'm happy to figure out a better solution
> and update my patch. If not, I suggest updating the documentation to make
> it clear that read-html-as-xml doesn't quite honor the content/c contract
> because it doesn't properly unescape attribute values.
> 
> —
> Reply to this email directly or view it on GitHubhttps://github.com/plt/racket/issues/577#issuecomment-37436177
> .

Thanks!!

On Wed, Mar 12, 2014 at 12:09 PM, Tony Garnock-Jones <
notifications@github.com> wrote:

> Closed #580 https://github.com/plt/racket/pull/580.
> 
> —
> Reply to this email directly or view it on GitHubhttps://github.com/plt/racket/pull/580
> .

Thanks for the suggestions, but I'd prefer to avoid changing Boehm's GC as much as possible. We upgrade to the latest version every once in a while.

Is there a more portable alternative to `$$` in this case? I try to avoid GNU make extensions.

In this specific case, ``...`` should work instead of `$(...)`. I'll update the pull request.

I guess this means anything under racket/gc shouldn't be changed?

Right. Files in racket/gc2 or even racket/sgc are fair game.

Closed by 139b228f.

Looks like the Travis build failed on building the math library.

This pull request combines a bunch of stuff, in particular:
- making everything use `check-below` at simpler types
- restricting `check-below` to those simpler types
- fixing some other bugs

Is it reasonable to split it up into multiple PRs along these lines?

On Mar 12, 2014, at 8:17 AM, Eli Barzilay notifications@github.com wrote:

> A quick note: one of the goals I had for scribble/html was to replace
> the xexpr thing -- it's much less fragile (no quoting problems, prefer
> using functions so no tag typos, no `(,@(if ...)) and append-map
> hacks), still open for anything (using the constructors), and easily
> extensible to new tags that require all kinds of weird content
> encodings.
> 
> (/me goes back into the zombieland shadows.)

NIce to hear from you! How are the zombieland shadows treating you?

John

Feh. Please disregard (the public version of) this message.

John

On Mar 13, 2014, at 9:25 AM, John Clements clements@brinckerhoff.org wrote:

> On Mar 12, 2014, at 8:17 AM, Eli Barzilay notifications@github.com wrote:
> 
> > A quick note: one of the goals I had for scribble/html was to replace
> > the xexpr thing -- it's much less fragile (no quoting problems, prefer
> > using functions so no tag typos, no `(,@(if ...)) and append-map
> > hacks), still open for anything (using the constructors), and easily
> > extensible to new tags that require all kinds of weird content
> > encodings.
> > 
> > (/me goes back into the zombieland shadows.)
> 
> NIce to hear from you! How are the zombieland shadows treating you?
> 
> John

@elibarzilay I totally agree with you that the scribble/html is the right approach. I don't think it's "H-expr"s either. It's a different and better system, it seems.

I think that splitting the first two out is reasonable and have done so. They are simple on their own so only split it out into one PR with two commits.

I also don't think this should be commited as is (in terms of how the commits are) but not sure the best way to go, moving them around and trying to clean them up was painful. I think I'm going to try to rearrange it to get the test infrastructure in the early commits.

`scribble/text` is an awesome way to generate text output. From looking at the `scribble/html` source very briefly and trying a few things, it looks like that is an awesome way to generate HTML text.

Maybe I'm being dense, but I don't understand how this relates in the case where you start with HTML text, and want to parse it into a sort of AST structure for processing?  (Where you might, but also might not, convert the new thing back into HTML text.)

Speaking of which, xexprs and `match` are a _wonderful_ way to work with HTML. In my admittedly limited but non-trivial reviewing of Racket code (on GitHub, Planet packages, and so on), I see hardly anyone using the `html` module's `struct`-based approach. They use xexprs. Of course people using Racket would like s-expressions. And sure they're not the right tool for everything. But well-formed HTML and XML are basically s-expressions as re-invented by the department of redundancy department. I think there's a good reason why people seem to prefer that approach.

r+

r+

Can we get it to say 

```
expected: A
actual: B
```

Yep, that was the check info I was talking about. I'll try and add those but am heading out shortly.

r+

### Now:

```
--------------------
Typechecker tests > tc-literal tests > 2527 (LITERAL -5)
2527 (LITERAL -5)
FAILURE
location:   <pkgs>/typed-racket-test/tests/typed-racket/unit-tests/typecheck-tests.rkt:2527:3
actual:     Negative-Fixnum
expected:   (U 1 Byte-Larger-Than-One)
tc-literal did not return the expected value
--------------------
```

Would this work if we used prefab structs instead of cross-phase persistent ones?

Testing shows no.

```
endobson@yggdrasil () ~ % racket                                                                                                                                                                                                          (0)
Welcome to Racket v6.0.0.4.
-> (struct foobar () #:prefab)
-> (begin-for-syntax (struct foobar () #:prefab))
-> (define-syntax (go stx)
      (raise (foobar)))
-> (with-handlers ([foobar? void]) (go (raise (foobar))))
; uncaught exception: '#s(foobar) [,bt for context]
-> 
```

Strange.

On Mon, Mar 17, 2014 at 12:27 PM, Eric Dobson notifications@github.comwrote:

> Testing shows no.
> 
> endobson@yggdrasil () ~ % racket                                                                                                                                                                                                          (0)
> Welcome to Racket v6.0.0.4.
> -> (struct foobar () #:prefab)
> -> (begin-for-syntax (struct foobar () #:prefab))                                                                                                                                                                                             -> (define-syntax (go stx)                                                                                                                                                                                                                         (raise (foobar)))
> -> (with-handlers ([foobar? void]) (go (raise (foobar))))
> ; uncaught exception: '#s(foobar) [,bt for context]
> ->
> 
> —
> Reply to this email directly or view it on GitHubhttps://github.com/plt/racket/pull/588#issuecomment-37836607
> .

Correct testing shows that it does work.

```
#lang racket

(module s racket
  (provide (struct-out foo))
  (struct foo () #:prefab))

(require
  's
  (for-syntax 's))

(define-syntax (go stx)
  #`'#,(foo))

(with-handlers ([foo? displayln])
  (raise (go)))
```

r+

Does this make `#:ret` mandatory for `tc-err` tests?

No it does not, most cases need it though.

I'm having trouble making a line comment, but line 390ish in the typecheck tests has a couple where it is not needed.

In what sense do you mean "most cases need it"? Will it fail if `#:ret` is omitted?

It has a default of (ret -Bottom). If that is the correct value, than specifying a return value is not necessary.

The reasoning behind making the check always happen was so that we would get more coverage of these code paths. Especially since there are a lot of code paths that are currently incorrectly returning the expected tc-results instead of -Bottom and letting a check below turn that in to a valid return tc-results (turning no-filter/no-object into top-filter/empty-object).

Is there a new unit test that could help test this fix or do the existing unit tests already cover it well?

Other than that, LGTM. Thanks!

I can add a test for the change to tc-expr unit, which would have required the class changes.

Any more comments?

r+ with my additional comment.

Do we need the 'and'?

Probabbly not. I just kept it so the contract was the same.

Also my quarter second measurements might have been noise.

r+

If it's not actually an improvement, then I don't think we should include this.

I agree. I'm going to try and come up with a better test than new-metrics that is both faster and less noisy, and see how this fares.

Remeasured and while it is noisy, it is a definite 1-2% improvement.

What do you mean by "temporary"?

Temporay = Rough draft, but words are hard some times.

What do you mean by "using filters sequentially"?  Also, do you want a detailed review for this now?

@zenspider Is this fixed?

@zenspider Is this fixed?

This is a duplicate of PR 10083, here: http://bugs.racket-lang.org/old/10083

Turns out not to be a bug.

@mflatt Did this get fixed?

It looks like the contract in the docs is correct, but the prose is wrong. @jeapostrophe, what should this say?

@mflatt I think only you can figure this out.  Is it likely to have been fixed since 5.3.5?

@mflatt I think this is for you.

Something seems to have gone very wrong here. Can you say more about your system, and perhaps also try the most recent release? Thanks!

This would be good, I think:

Produces a forest of XML content, each of which could be turned into a
X-expression, if necessary, with xml->xexpr.

On Tue, Mar 25, 2014 at 8:56 AM, Sam Tobin-Hochstadt <
notifications@github.com> wrote:

> It looks like the contract in the docs is correct, but the prose is wrong.
> @jeapostrophe https://github.com/jeapostrophe, what should this say?
> 
> —
> Reply to this email directly or view it on GitHubhttps://github.com/plt/racket/issues/427#issuecomment-38573955
> .

## 

Jay McCarthy jay@cs.byu.edu
Assistant Professor / Brigham Young University
http://faculty.cs.byu.edu/~jay

"The glory of God is Intelligence" - D&C 93

Yes, this is fixed.

Unlikely. My guess is that the GC needs to be configured to use a 64K allocation-page size for certain PPC configurations, but I'm not sure.

I will try to look into this sometime soon.

Yes ppc64 is using 64K

Using filters sequentially means in `(begin (f x) (g x))` we now can represet if `f` returns then `x` has some type. And yes this is ready for review, I'm going to look at the math library failure. I believe that is to do with the fact that we cannot currently generate a contract for (-> Bottom -bot-filter), but which is trivial to do.

Should now cleanly build the math library.

r+

It's not live, but the commit seems good. I don't know how often the website gets pushed, but feel free to close.

I don't think this ticket should be closed because of a duplicate in an old bug repository that, arguably, won't get as many eyeballs as this one.

FWIW, this is what I wound up doing:

``` scheme
(define (filter-not-not xs)
  (define (rewrite xxs a b) 
    (for/list ([xs xxs]) (for/list ([x xs]) (if (eq? x a) b x))))
  (match xs
    [(list-no-order `(nand ,a1 ,a2 ,c1)
                    `(nand ,b1 ,b2 ,c2) rest ...)
     #:when (and (eq? a1 a2)
                 (eq? b1 b2)
                 (eq? c1 b1))
     (filter-not-not (rewrite rest c2 a1))]
    [else xs]))
```

Yes, confirmed against yesterday's snapshot. Closing. Thanks!

We update the website when the new docs at each release. Snapshot builds
(that happen on a daily basis) of the as-yet-unreleased documentation are
available here:

  http://plt.eecs.northwestern.edu/snapshots/current/doc/

Robby

On Tue, Mar 25, 2014 at 4:53 PM, Ryan Davis notifications@github.comwrote:

> It's not live, but the commit seems good. I don't know how often the
> website gets pushed, but feel free to close.
> 
> —
> Reply to this email directly or view it on GitHubhttps://github.com/plt/racket/issues/571#issuecomment-38625899
> .

@zenspider While the URL has "old" in the name, that's just the shortest form of the URL. That's the current bug database, and it's the one we use for all of Racket. In general, GH issues are not currently used to track bugs. We do plan to change that in the future, but as part of a larger shift in how we structure the repository.

In particular, the relevant bit of the docs is here: http://plt.eecs.northwestern.edu/snapshots/current/doc/redex/tutorial.html

@rfindler bump

I thought I did this already. It isn't in the tree?

On Tuesday, March 25, 2014, Max S. New notifications@github.com wrote:

> @rfindler https://github.com/rfindler bump
> 
> —
> Reply to this email directly or view it on GitHubhttps://github.com/plt/racket/pull/599#issuecomment-38630346
> .

Oh woops it is.

r+ with comments

I've pushed a change that is intended to fix this problem.

Why is define-type not enough here?

This will let you abstract over parts that aren't themselves types, as with
the Mixin constructor.
On Mar 26, 2014 10:48 PM, "Eric Dobson" notifications@github.com wrote:

> Why is define-type not enough here?
> 
> —
> Reply to this email directly or view it on GitHubhttps://github.com/plt/racket/pull/604#issuecomment-38764071
> .

Ah, I didn't get that the argument to implements has to be an id and cannot be an actual class form.

More generally, there are other type notations that could be made into type expanders instead of built-in. For example, the new `->*` type constructor could just be a type expander. Users could define their own function type syntaxes.

Note: making `->*` a type expander is actually not a good idea because we want them to print nicely. That's one disadvantage of type expanders.

I think I've addressed the PR feedback so far (except making `Mixin` more interesting), but I've discovered a problem: I had only been testing this at the REPL (where it works fine) but `define-type-expander` does not work in a module. Though it does work if the expander is defined in `prims.rkt` like `Mixin`.

e.g., this does not work:

```
#lang typed/racket

(define-type-expander Empty (lambda (stx) #''()))

(: x Empty)
(define x '())
```

Any ideas why? (the `syntax-local-value` is presumably failing to get the data)

Edit: Ryan gave me an idea of what's going on, so I think I can fix it but we'll see.

Old error message:

```
samth@samth:~$ racket 2d-test.rkt 
2dmatch: no matching clauses for 'b and 'a
  context...:
   /home/samth/2d-test.rkt: [running body]
```

New error message:

```
[samth@huor:~ (master) plt] r /tmp/2d-typed.rkt
2dmatch: no matching clause for '(b a)
  context...:
   /home/samth/sw/plt/racket/collects/racket/match/runtime.rkt:21:0: match:error
   /tmp/2d-typed.rkt: [running body]
```

This seems to have broken the math library build via the optimizer.

What's the current status here?

I've merged this. Thanks!

@takikawa This got merged, right?

Looks like it didn't.

I committed this fix, but it had to be done differently b/c of changes in the interim. Thanks!

@takikawa ping

Note: you can see the problem by running this gist: https://gist.github.com/samth/9834239

Working at merging the pieces in smaller ones. Currently I need to get the
next one in reviewable status.

On Mon, Mar 31, 2014 at 8:13 AM, Sam Tobin-Hochstadt <
notifications@github.com> wrote:

> What's the current status here?
> 
> —
> Reply to this email directly or view it on GitHubhttps://github.com/plt/racket/pull/583#issuecomment-39100068
> .

@shekari ping?

r+ with comments. 

I particularly like how elegant the whole machinery ends up.

No, I've given up on this for now because it was difficult to get working with the new contract system optimizations.

This seems to have its documentation in an old `doc.txt` file.  The real documentation is in the `racket-doc` pkg, under `syntax/scribblings/transformer-helpers.scrbl`.

When merged, this has the following error:

```
/home/samth/sw/plt/pkgs/data-pkgs/data-doc/data/scribblings/heap.scrbl:112:43: defproc: bad argument form
  in: (#:same? (-> any/c any/c any/c) equal?)
  context...:
   /home/samth/sw/plt/racket/collects/compiler/cm.rkt:345:0: compile-zo*
   /home/samth/sw/plt/racket/collects/compiler/cm.rkt:552:26
   /home/samth/sw/plt/racket/collects/compiler/cm.rkt:545:42
   /home/samth/sw/plt/racket/collects/compiler/cm.rkt:510:0: maybe-compile-zo
   /home/samth/sw/plt/racket/collects/compiler/cm.rkt:621:2: do-check
   /home/samth/sw/plt/racket/collects/compiler/cm.rkt:660:15
   /home/samth/sw/plt/racket/collects/compiler/../racket/private/map.rkt:113:23: loop
   /home/samth/sw/plt/racket/collects/compiler/cm.rkt:621:2: do-check
   /home/samth/sw/plt/racket/collects/compiler/cm.rkt:703:4
   /home/samth/sw/plt/racket/collects/setup/parallel-do.rkt:420:20: loop
```

That's sad -- we do want this, and we wouldn't want the contract system to make it impossible.

@mflatt any thoughts on this?

@ianj is this ready to merge? Did you look at `checked-struct-info?`

I did consider checked-struct-info?, but I still am of the mind that this fix will remain unsatisfactory because struct-info does not store field names separately from the selector function identifiers. The ambiguities will remain.

----- Original Message -----
From: "Sam Tobin-Hochstadt" notifications@github.com
To: "plt/racket" racket@noreply.github.com
Cc: "J. Ian Johnson" ianj@ccs.neu.edu
Sent: Monday, March 31, 2014 2:53:42 PM GMT -05:00 US/Canada Eastern
Subject: Re: [racket] struct-copy uses struct-info to determine field accessors rather than break hygiene. (#403)

@mflatt any thoughts on this? 

@ianj is this ready to merge? Did you look at checked-struct-info? 

— 
Reply to this email directly or view it on GitHub .

Does that mean you don't think we should merge this?

Don't merge. Structs need to change first.
-Ian
----- Original Message -----
From: "Sam Tobin-Hochstadt" notifications@github.com
To: "plt/racket" racket@noreply.github.com
Cc: "J. Ian Johnson" ianj@ccs.neu.edu
Sent: Monday, March 31, 2014 3:02:01 PM GMT -05:00 US/Canada Eastern
Subject: Re: [racket] struct-copy uses struct-info to determine field accessors rather than break hygiene. (#403)

Does that mean you don't think we should merge this? 

— 
Reply to this email directly or view it on GitHub .

Ok, I closed this.

Fixed.

Looks reasonable.
@bluephoenix47: can you add a test that would have failed with the old version?

Silly me forgot the identifier following #:same?. Fixed now.

@mflatt Thoughts on this?

@rmculpepper, can you look at this?

@rmculpepper, does this look ok?

What is the issue?

On Mon, Mar 31, 2014 at 1:50 PM, Sam Tobin-Hochstadt <
notifications@github.com> wrote:

> That's sad -- we do want this, and we wouldn't want the contract system to
> make it impossible.
> 
> —
> Reply to this email directly or view it on GitHubhttps://github.com/plt/racket/pull/516#issuecomment-39126315
> .

Yes, looks good to me.

This bug is now fixed, and the PR can be closed.

Merged.

@schuster ping

This was merged a while ago, closing.

@jrslepak ping

@jbclements ping

@jeapostrophe Can you look into this?  I think this was brought up on the mailing list recently as well.

@elibarzilay I plan to merge this soon unless you object.

@pmechai Any interest in updating this pull request?

@mflatt I think you're the right person to review this.

@samth pong. I haven't touched this since the original PR. Did you have a specific queston?

Well, @elibarzilay had some specific suggestions in his comment.

I reviewed, thanks.

As I merged this forward I ran into the match bug with multiple (list a ...) patterns. To solve that I needed to fix check-below. Fixing check below correctly required fixing a bunch of cases that were misusing expected values.

So long story short this is in the process of being merged but it is non trivial due to it bringing up other bugs.

This now correctly compiles the math library. I'm not sure what the code in tc-app-helper was trying to do before, but it didn't fail any tests with it removed. It was also trying to say that some rest variables were -Bottom, and my changes were making it such that if you know a variable has type Bottom then the code is dead.

The reason that code was there is to do better error recovery, but I'm having trouble thinking of a case where it would happen.  Maybe looking at the history will tell me.

Well, I added the code that does approximately that in this revision: 7b875d58a974a959a38a84197b413f91de83b5d1 but it doesn't seem to tell me anything about what's going on.

Oh, I think I know what's going on here. 

Imagine that the function has 3 arguments, and we only supply 1 argument. That means that the result filters might refer to arguments 2 and 3, but we only call `open-Result` with a 1-element list.

As a result, the `open-Result` will return something that's not well-scoped -- it has the equivalent of free variables.

You ought to be able to see this with something like this:

```
(define f (lambda (x y) y))
(f 1)
```

The call `(f 1)` will have a result which has a free index, given your changes.

Turns out I pushed these changes back in December, as part of push #27918.

Ok, so I covered those cases but didn't handle rest and keyword arguments because as far as I know those are not currently supported as objects.

That makes sense.  Maybe add a comment to that effect?

r+ with comments.

I think something with "fully" in the name makes more sense.  What you're checking isn't that it's not the expected type, but that it doesn't have "omitted" filters/objects.

r+ with comments.

r+ otherwise.

I've often wondered about that underline.
Hack removed --- thanks!

Added `'fullscreen-button` and `'fullscreen-aux` styles to `frame%`.

I just rebuilt my docs using the new CSS. I notice, however, that the removal of this hack collapsed the vertical space around the .toptoclink style (the comment should've tipped me off, but I inferred that  "hack to add space" referred to the horizontal direction. Sorry.) I'll submit a pull request in a moment that restores the vertical space in a non-hackish way.

![screen shot 2014-04-05 at apr 05 11 07 16 am](https://cloud.githubusercontent.com/assets/1425051/2623429/32cd0650-bcee-11e3-8bb3-2c9726ce072b.gif)

Merged.

And now I notice that the existing code had a semicolon missing this whole time. [Fix is here](https://github.com/plt/racket/pull/613).

Merged - thanks!

On Monday, Sam Tobin-Hochstadt wrote:

> @elibarzilay I plan to merge this soon unless you object.

(My notes are all above, hopefully it will have a sensible
interface...)

@elibarzilay After your comment, @greghendershott changed the interface to be more along the lines you said.

I need to refresh this:
1. It's been awhile, so rebase off HEAD.
2. Dogfooding a similar feature in racket-mode, I found it better to use a slightly different syntax. I want to update the PR to be consistent with that:
   
   ```
   ,log                  ; show the levels currently in effect.
   ,log <logger> <level> ; set logger to level debug|info|warning|error|fatal|none
   ,log <logger> default ; set logger to use the default, 'all other' level.
   ,log <level>          ; set the default level, for 'all other' loggers.
   ```

My local fork of HEAD is a bit stale, and I'm deep into something else right now. So I'd like to take a day or two  -- to FF to upstream, exercise my laptop fans by rebuilding Racket, make the changes, do some quick tests, and push. (But if it's more urgent, let me know and I can try to do sooner.)

I've updated the code. It all uses a common list-collects.rkt, but zsh and bash have to use it in two different ways because of the expected output of the shell scripts. Roughly speaking, bash expects a list of collection names, while zsh expects a list of directories that contain collection directories (the collection roots and parent directories for one-off collections). So there's a separate Racket program for each shell.

Ideally each shell would do the same thing, but I don't have the bash/zsh-fu to know if that's even possible, much less implement it in a reasonable amount of time.

It's not really related to knowing bash/zsh.  The thing is that once you have two files, there's a place to write different code in each, and once there's such a place, people will use it.  It's easy to just put the two bits in the same file.  You can even add an environment variable to identify each shell, and then there's even no need for flags or whatever -- just dispatch based on the variable.  Combining these two things, results in the following: https://gist.github.com/elibarzilay/10014970
(untested shell code, but there's little that chaged)

Even easier would be to put the two functions in one file, and have two submodules, one of which does one thing and one the other.

10 minutes ago, Sam Tobin-Hochstadt wrote:

> Even easier would be to put the two functions in one file, and have
> two submodules, one of which does one thing and one the other.

That's probably easier in terms of refactoring, but there's really
very little difference between the two bits.  (And since it's still
just completion related work, the chances of the two sides staying
very similar are high, and the profits are high too since there's not
that many shell experts around.)

## 

```
      ((lambda (x) (x x)) (lambda (x) (x x)))          Eli Barzilay:
                http://barzilay.org/                   Maze is Life!
```

…and @rfindler enabled the fullscreen button for DrRacket in https://github.com/plt/racket/commit/66c5ac2904cd218bb0c7254ec94aa62d52e55759! Thank you! m(_ _)m

I'm closing this PR and replacing it with https://github.com/plt/racket/pull/615

You can maybe use lazy-require to load racket/format.

Tagging @elibarzilay

I just tried `lazy-require`. That works.

However _using_ `lazy-require` requires (no pun intended) a `(require racket/lazy-require)`.

So would that be a net improvement? (I'm not trying to be snarky; I genuinely don't know.)

Yes, I think so. At a minimum, I care about the amount of dependencies that
lazy-require has, so it ought to be kept small.

Sam
On Apr 9, 2014 5:05 AM, "Greg Hendershott" notifications@github.com wrote:

> I just tried lazy-require. That works.
> 
> However _using_ lazy-require requires (no pun intended) a (require
> racket/lazy-require).
> 
> So would that be a net improvement? (I'm not trying to be snarky; I
> genuinely don't know.)
> 
> —
> Reply to this email directly or view it on GitHubhttps://github.com/plt/racket/pull/615#issuecomment-39924535
> .

Just pushed a version that uses submodules. This seems more direct than shell variables: the shell scripts can call to their entry points directly instead of setting a flag and relying on the Racket program to branch correctly based on that.

1. This is a _shell_ completion thing -- relying on environment
   variables is as justified as you could ever get to: the shell code
   that uses it is itself relying heavily on such things.
2. You ignored the rest of my changes, and left in the obscure use of
   a hash table, which is (IIUC) a very obfuscated way to do the same
   thing that `remove-duplicates' gives you.

Sorry, I didn't notice your other changes. I might be able to take a look later this week/weekend. Or if your code fixes the original bug, I don't mind that being pushed instead. This was just intended to be a small bug fix, so the less work that has to happen, the better.

IMO it's important to keep things in a shape that makes sharing code
on future improvements easy, and doesn't encourage splittage (and
different modules still make it easy in that sense).

I pushed a commit this morning. It just occurred to me that GitHub might not notify you about a push. So for belt+suspenders here's a comment, too.

Eli, does the code you posted solve the issues @schuster's pull request solves? If so, should we use it instead? (after testing, of course)

It should, since it's basically doing the same thing.

Yeah, I just had a chance to do a quick diff: I thought it was a much larger change (gist didn't show the diff, unfortunately), but I see now it's just related to the shell variable stuff, remove-duplicates, and some variable renaming. I'll go ahead and make those changes and push.

Pushed. Had to change the shell scripts to require the main submodule explicitly, since (require shell-completion/list-collects) won't require it automatically. If we'd be better off just getting rid of the submodule and putting that code in the body of the file, let me know and I can change it.

Merged, thanks!

I'll try and take a look at this before Tuesday, but have a fairly busy
weekend so I may not be able to.
On Apr 11, 2014 2:24 PM, "Asumu Takikawa" notifications@github.com wrote:

> This PR improves contract generation for large recursive type aliases such
> as those used in the typed GUI wrapper library. In particular, contract
> generation will not use huge amounts of memory or loop effectively forever
> on these large types.
> 
> I'd like to merge this for v6.0.1 if possible (testing is supposed to
> start next Tuesday or so).
> 
> The high-level design: define the contracts for recursive type aliases
> in-line in the module, using the same mechanism as require/typed. This
> allows contracts for these type aliases to be indirected through an
> identifier. You still get the advantage of static-contracts because these
> contract definitions will go through an optimization pass (though not the
> recursive contract pruning).
> 
> The downside is that since contracts are always generated for mutually
> recursive type aliases, it's not very pay-as-you-go for recursive type
> aliases. Even type aliases that are never used for export/import generate a
> contract. I don't expect this is a huge downside for most code, but it's a
> significant downside for typed/racket/gui.
> 
> On the other hand, this defines contracts only once instead of n times for
> n imports/exports of values with the relevant type.
> 
> With this change, the zo file for typed/racket/gui is 18MB. I think I can
> reduce it by making contract generation for class types a bit more clever
> (I have a fairly simple patch for this somewhere).
> 
> Here's an example interaction that doesn't work without this PR:
> 
> Welcome to Racket v6.0.0.6.
> -> (module a typed/racket (require typed/racket/gui) (define bm% bitmap%) (provide bm%))
> -> (require 'a)
> -> (send (make-object bm% 100 200) save-file 1 2))
> ; save-file: contract violation
> ;   expected: (or/c String Path Output-Port)
> ;   given: 1
> ;   in: the 2nd argument of ...
> 
> On current git HEAD the contract generation will use up all of your RAM
> 
> ## instead.
> 
> You can merge this Pull Request by running
> 
>   git pull https://github.com/takikawa/racket tr-fix-name-contracts
> 
> Or view, comment on, or merge it at:
> 
>   https://github.com/plt/racket/pull/616
> Commit Summary
> - GUI type fixes
> - Re-implement contract generation for Name types
> - Factor typed-untyped sides into alias contracts
> 
> File Changes
> - _M_
>   pkgs/typed-racket-pkgs/typed-racket-lib/typed-racket/base-env/base-structs.rkthttps://github.com/plt/racket/pull/616/files#diff-0(8)
> - _M_
>   pkgs/typed-racket-pkgs/typed-racket-lib/typed-racket/base-env/prims.rkthttps://github.com/plt/racket/pull/616/files#diff-1(22)
> - _M_
>   pkgs/typed-racket-pkgs/typed-racket-lib/typed-racket/env/init-envs.rkthttps://github.com/plt/racket/pull/616/files#diff-2(7)
> - _M_
>   pkgs/typed-racket-pkgs/typed-racket-lib/typed-racket/env/type-alias-helper.rkthttps://github.com/plt/racket/pull/616/files#diff-3(32)
> - _M_
>   pkgs/typed-racket-pkgs/typed-racket-lib/typed-racket/env/type-name-env.rkthttps://github.com/plt/racket/pull/616/files#diff-4(2)
> - _M_
>   pkgs/typed-racket-pkgs/typed-racket-lib/typed-racket/infer/infer-unit.rkthttps://github.com/plt/racket/pull/616/files#diff-5(2)
> - _M_
>   pkgs/typed-racket-pkgs/typed-racket-lib/typed-racket/private/parse-type.rkthttps://github.com/plt/racket/pull/616/files#diff-6(2)
> - _M_
>   pkgs/typed-racket-pkgs/typed-racket-lib/typed-racket/private/syntax-properties.rkthttps://github.com/plt/racket/pull/616/files#diff-7(1)
> - _M_
>   pkgs/typed-racket-pkgs/typed-racket-lib/typed-racket/private/type-contract.rkthttps://github.com/plt/racket/pull/616/files#diff-8(196)
> - _M_
>   pkgs/typed-racket-pkgs/typed-racket-lib/typed-racket/private/with-types.rkthttps://github.com/plt/racket/pull/616/files#diff-9(8)
> - _M_
>   pkgs/typed-racket-pkgs/typed-racket-lib/typed-racket/rep/type-rep.rkthttps://github.com/plt/racket/pull/616/files#diff-10(5)
> - _M_
>   pkgs/typed-racket-pkgs/typed-racket-lib/typed-racket/typecheck/internal-forms.rkthttps://github.com/plt/racket/pull/616/files#diff-11(2)
> - _M_
>   pkgs/typed-racket-pkgs/typed-racket-lib/typed-racket/typecheck/tc-structs.rkthttps://github.com/plt/racket/pull/616/files#diff-12(6)
> - _M_
>   pkgs/typed-racket-pkgs/typed-racket-lib/typed-racket/typecheck/tc-toplevel.rkthttps://github.com/plt/racket/pull/616/files#diff-13(2)
> - _M_
>   pkgs/typed-racket-pkgs/typed-racket-lib/typed-racket/types/printer.rkthttps://github.com/plt/racket/pull/616/files#diff-14(2)
> - _M_
>   pkgs/typed-racket-pkgs/typed-racket-lib/typed-racket/types/remove-intersect.rkthttps://github.com/plt/racket/pull/616/files#diff-15(8)
> - _M_
>   pkgs/typed-racket-pkgs/typed-racket-lib/typed-racket/types/resolve.rkthttps://github.com/plt/racket/pull/616/files#diff-16(10)
> - _M_
>   pkgs/typed-racket-pkgs/typed-racket-lib/typed-racket/types/subtype.rkthttps://github.com/plt/racket/pull/616/files#diff-17(6)
> - _M_ pkgs/typed-racket-pkgs/typed-racket-more/typed/pict.rkthttps://github.com/plt/racket/pull/616/files#diff-18(4)
> - _M_
>   pkgs/typed-racket-pkgs/typed-racket-more/typed/racket/private/gui-types.rkthttps://github.com/plt/racket/pull/616/files#diff-19(25)
> - _A_
>   pkgs/typed-racket-pkgs/typed-racket-test/tests/typed-racket/fail/recursive-type-alias-lazy-contract-failure.rkthttps://github.com/plt/racket/pull/616/files#diff-20(13)
> - _M_
>   pkgs/typed-racket-pkgs/typed-racket-test/tests/typed-racket/unit-tests/typecheck-tests.rkthttps://github.com/plt/racket/pull/616/files#diff-21(2)
> 
> Patch Links:
> - https://github.com/plt/racket/pull/616.patch
> - https://github.com/plt/racket/pull/616.diff
> 
> —
> Reply to this email directly or view it on GitHubhttps://github.com/plt/racket/pull/616
> .

On Fri, Apr 11, 2014 at 5:40 PM, Eric Dobson notifications@github.comwrote:

> I'll try and take a look at this before Tuesday, but have a fairly busy
> weekend so I may not be able to.

I will not get to this before tuesday, but I'll try after that.

Sam

Use `in-dict`, etc from racket/dict.

On Mon, Apr 14, 2014 at 6:45 PM, Ryan Culpepper
notifications@github.com wrote:

> Use in-dict, etc from racket/dict.

I think the proposed code may be significantly faster, since it
generates specialized loops.  This is also something that could be
usefully targeted by Typed Racket.

Sam

My thinking for this patch is more along the lines samth mentions. I really want to exploit sequence-syntax when I can.

I finally got a chance to look at this. Because of the new http-client library, the patch isn't really useful any more because a lot would need to change. However, I'll put it on my TODO list to implement it using this as a model.

Even if we keep this code, you can still get uninitialized variable errors.  We'd have to reject any code that might have `Undefined` to fix that, which would reject a bunch of current code.

If it can be in a separate package, wouldn't we want it to be? We can
always make some basic thing depend on it and keeping it separate helps us
avoid too much tangling.

Which commits do you have in mind I could help with?

Robby

On Tue, Apr 22, 2014 at 1:16 PM, Vincent St-Amour
notifications@github.comwrote:

> These commits add instrumentation to a number of language and standard
> library features. This instrumentation allows a profiling tool to report
> the time spent in each feature, broken up by feature instance. This is
> similar to the contract system instrumentation used by the contract
> profiler.
> 
> The instrumentation is mostly in the form of "latent continuation marks",
> which are syntax properties that can be selectively turned into
> continuation marks at compile-time, and have no run-time overhead by
> default.
> 
> Different commits affect different features. If possible, I'd like review
> from @mflatt https://github.com/mflatt, @rfindlerhttps://github.com/rfindler,
> @samth https://github.com/samth and @shekarihttps://github.com/shekari/
> @takikawa https://github.com/takikawa, depending on the commit.
> 
> After this review, the feature-specific profiler itself will also be ready
> to merge. I'm still debating whether to include it in the main Racket repo
> (like the contract profiler) or as a separate package (like the
> 
> ## optimization coach). I'd like opinions on that.
> 
> You can merge this Pull Request by running
> 
>   git pull https://github.com/stamourv/racket feature-instrumentation
> 
> Or view, comment on, or merge it at:
> 
>   https://github.com/plt/racket/pull/623
> Commit Summary
> - Instrument the opt/kw protocol for feature-specific profiling.
> - Add instrumentation to profile generic sequence overhead.
> - Instrument send dispatch for feature-specific profiling.
> - Instrument pattern matching for feature-specific profiling.
> - Instrument TR casts / asserts for feature-specific profiling.
> - Export analysis function for use by the feature-specific profiler.
> 
> File Changes
> - _M_ pkgs/contract-profile/main.rkthttps://github.com/plt/racket/pull/623/files#diff-0(3)
> - _M_
>   pkgs/typed-racket-pkgs/typed-racket-lib/typed-racket/base-env/extra-procs.rkthttps://github.com/plt/racket/pull/623/files#diff-1(26)
> - _M_
>   pkgs/typed-racket-pkgs/typed-racket-lib/typed-racket/base-env/prims.rkthttps://github.com/plt/racket/pull/623/files#diff-2(37)
> - _M_ racket/collects/racket/match/compiler.rkthttps://github.com/plt/racket/pull/623/files#diff-3(13)
> - _M_ racket/collects/racket/match/gen-match.rkthttps://github.com/plt/racket/pull/623/files#diff-4(17)
> - _M_ racket/collects/racket/private/class-internal.rkthttps://github.com/plt/racket/pull/623/files#diff-5(6)
> - _M_ racket/collects/racket/private/classidmap.rkthttps://github.com/plt/racket/pull/623/files#diff-6(12)
> - _M_ racket/collects/racket/private/for.rkthttps://github.com/plt/racket/pull/623/files#diff-7(24)
> - _M_ racket/collects/racket/private/kw.rkthttps://github.com/plt/racket/pull/623/files#diff-8(82)
> 
> Patch Links:
> - https://github.com/plt/racket/pull/623.patch
> - https://github.com/plt/racket/pull/623.diff
> 
> —
> Reply to this email directly or view it on GitHubhttps://github.com/plt/racket/pull/623
> .

@rfindler I think @stamourv was asking if it should be in the `plt/racket` repository or not.

Oh. Sure, stick it in for now if you want (or not, if you don't). I think,
at some point in the future we'll want to break everything out and so can
decide better at that time.

Robby

On Tue, Apr 22, 2014 at 1:21 PM, Sam Tobin-Hochstadt <
notifications@github.com> wrote:

> @rfindler https://github.com/rfindler I think @stamourvhttps://github.com/stamourvwas asking if it should be in the
> plt/racket repository or not.
> 
> —
> Reply to this email directly or view it on GitHubhttps://github.com/plt/racket/pull/623#issuecomment-41075356
> .

Right, as @samth said, I was asking whether to put it in the main repo or not.

For now, I'm leaning towards making it a separate package, but there's always the issue that, because it depends on instrumentation that's inside the core, the tool and the instrumentation can get out of sync. FWIW, OC suffers from that issue, but it hasn't been much of a problem in practice.

One general comment -- the syntax property names here are very generic.  I think they should either have a prefix, or be gensyms, or something along those lines.

Re key names: I could use `make-continuation-mark-key`, like contract instrumentation does, but that would require exporting the keys from the relevant libraries (like the contract library does). Adding a prefix may be a good compromise.

This is what version numbers are for. If putting it into a separate repo
helps you maintain them better, then do that! :)

On Tue, Apr 22, 2014 at 1:31 PM, Vincent St-Amour
notifications@github.comwrote:

> Right, as @samth https://github.com/samth said, I was asking whether to
> put it in the main repo or not.
> 
> For now, I'm leaning towards making it a separate package, but there's
> always the issue that, because it depends on instrumentation that's inside
> the core, the tool and the instrumentation can get out of sync. FWIW, OC
> suffers from that issue, but it hasn't been much of a problem in practice.
> 
> —
> Reply to this email directly or view it on GitHubhttps://github.com/plt/racket/pull/623#issuecomment-41076710
> .

Good point.

Wait, plain `...` and non-linear patterns should work, I thought.

Nope. racket -e '(match\* ((list 1) (list 2)) [((list x ...) (list x ...))
x])'

On Tue, Apr 22, 2014 at 3:13 PM, Sam Tobin-Hochstadt <
notifications@github.com> wrote:

> Wait, plain ... and non-linear patterns should work, I thought.
> 
> —
> Reply to this email directly or view it on GitHubhttps://github.com/plt/racket/pull/622#issuecomment-41102625
> .

This looks fine samth

Any comments on generic sequence, opt/kw args or pattern matching instrumentation?

Thanks for this fix!

I've been working on this code too. May I ask, tho: do you use the contract
random generation support somehow in a larger program? Can you tell me
about it?

Robby

On Fri, Apr 25, 2014 at 12:17 AM, Jay Kominek notifications@github.comwrote:

> The random value generators for the between/c, /c contracts all feed
> random a value computed from a user-provided input without ensuring that
> the value is an exact integer. So if you feed them an inexact (or
> rational), they do some math, get something random won't like, and then it
> explodes.
> 
> I feel I should describe the fix, but I can't come up with anything more
> succinct than the diff.
> 
> The change causes the random value generators to always produce inexact
> numbers, rather than the integers you would've gotten by necessity before.
> Obviously shouldn't violate any contracts, but I feel I should point it out.
> 
> ## Also fixed a typo in the docs, and added some tests.
> 
> You can merge this Pull Request by running
> 
>   git pull https://github.com/jkominek/racket random-contracts-fix
> 
> Or view, comment on, or merge it at:
> 
>   https://github.com/plt/racket/pull/625
> Commit Summary
> - Avoid feeding inexact numbers to random while generating
>   contract-satisfying values.
> 
> File Changes
> - _M_ pkgs/racket-pkgs/racket-doc/scribblings/reference/contracts.scrblhttps://github.com/plt/racket/pull/625/files#diff-0(2)
> - _M_ pkgs/racket-pkgs/racket-test/tests/racket/contract-rand-test.rkthttps://github.com/plt/racket/pull/625/files#diff-1(5)
> - _M_ racket/collects/racket/contract/private/misc.rkthttps://github.com/plt/racket/pull/625/files#diff-2(6)
> 
> Patch Links:
> - https://github.com/plt/racket/pull/625.patch
> - https://github.com/plt/racket/pull/625.diff
> 
> —
> Reply to this email directly or view it on GitHubhttps://github.com/plt/racket/pull/625
> .

The whole of `module-language-configure-runtime` seems like it belongs in a library. @rfindler would you be able to use that in DrRacket?

I think that we may need something a little different for `enter!`: it may be necessary to load or re-load the module declaration to determine a runtime configuration. (If I remember correctly, DrRacket has the luxury of  knowing that the relevant module declaration was just evaluated before it checks for a runtime configuration.) I'll take a closer look.

Nope, I don't actually use it. I was flipping through the docs while I was bored, saw contract-random-generate and decided to play with it. I just happened to start with a case that blew up.

Ah, okay. Thanks.

Robby

On Fri, Apr 25, 2014 at 9:03 AM, Jay Kominek notifications@github.comwrote:

> Nope, I don't actually use it. I was flipping through the docs while I was
> bored, saw contract-random-generate and decided to play with it. I just
> happened to start with a case that blew up.
> 
> —
> Reply to this email directly or view it on GitHubhttps://github.com/plt/racket/pull/625#issuecomment-41395671
> .

The more I think about this, the less I think it can work for `enter!`. The runtime-configure protocol is set up in an imperative way; the intent is that a context is configured in a particular way once and for all, and there's not enough plumbing to change the configuration. For example, after going into a typed module and then into an untyped module, there would need to be a way to cancel the "in a typed context" state that is installed by the typed runtime configure, but there's no protocol for that right now.

DrRacket creates a new, sandboxed context for each module, so it doesn't have this problem. I imagine that things similarly work in an Emacs mode. For something like `enter!`, I think we'd have to introduce a new protocol for switching runtime configurations.

I see. So with the current runtime-config approach, it would only make sense to do this in the context of a hypothetical new `run!` procedure. Such a `run!` is basically [what I've done in racket-mode](https://github.com/greghendershott/racket-mode/blob/master/sandbox.rkt#L21).

I did it "on my own" because I wasn't sure it would be possible to add a `run!` in a way that would be xrepl compatible. And even if possible, I wasn't sure it would it be welcome; maybe there's not a very large audience for this sort of stuff.

Merged, thanks!

Oh, I had assumed that "enter!" was more like DrRacket, I'm sorry about
that.

Robby

On Fri, Apr 25, 2014 at 9:34 AM, Greg Hendershott
notifications@github.comwrote:

> I see. So with the current runtime-config approach, it would only make
> sense to do this in the context of a hypothetical new run! procedure.
> Such a run! is basically what I've done in racket-modehttps://github.com/greghendershott/racket-mode/blob/master/sandbox.rkt#L21
> .
> 
> I did it "on my own" because I wasn't sure it would be possible to add a
> run! in a way that would be xrepl compatible. And even if possible, I
> wasn't sure it would it be welcome; maybe there's not a very large audience
> for this sort of stuff.
> 
> —
> Reply to this email directly or view it on GitHubhttps://github.com/plt/racket/pull/626#issuecomment-41399083
> .

Ping.

I wrote a patch that adds a primitive "string-port?" which tests if a port is a (byte)string input or output port.  It appears to work; I have not written any tests for it yet.

https://www.student.cs.uwaterloo.ca/~cs136/racket-string-port.patch 

@e45lee, when you have a finished version of your patch, can you create a pull request for it? That's the easiest way for us to track it.

There are a lot of little things do to here: documentation, tests, and improve some existing contracts in documentation and error messages. I have time to do those things at the moment, but as @samth says, it's generally easier when all the pieces are in place.

Changes merged!

Ping.

r+

r+ with comments

The reason that all of these cases error is that we're trying to avoid generating a constraint on `dbound` that we can't represent. 

However, I think there's no constraint needed in this case, and thus it's safe.  Can you add a comment to that effect when you push this?

Merged.

Seems reasonable, but needs docs.

I think one reasonable way to do docs for this would be to just document all the filter syntaxes at once. Does that sound good? (printing them right will come later)

Yes.

I added a first pass at docs, but it leaves out explanations for things like `Or` and `And` filters because it's highly unlikely that anyone will ever write those. OTOH, if we allow people to toggle complex filters we will need to explain how to read those types.

e.g., for functions like `(lambda (x y) (cond [(equal? x "foo") x] [else y]))`.

@mflatt ping

@shekari Do you have other inference work that this is part of? Because I have a major revamp of this code (to eliminate exceptions) that I need to get back in shape. It's on this branch https://github.com/samth/racket/tree/fast-infer but there are still a few test failures (and it's out of date).

LGTM otherwise.

I currently do not have any more, (well modulo a two line change deleting duplicate code). But I plan on writing more. My goal is to improve inference on ListDots so that apply works better. I don't care whose work goes in first, but I think I'm in agreement with you that one of us should take the lock so that we don't have to deal with nasty merges.

Ok, I'll get this rebased and in pull-request form today, hopefully, and
then start working on finding the last couple bugs. :)  Your new tests
should help, I think.

On Wed, Apr 30, 2014 at 11:48 AM, Eric Dobson notifications@github.comwrote:

> I currently do not have any more, (well modulo a two line change deleting
> duplicate code). But I plan on writing more. My goal is to improve
> inference on ListDots so that apply works better. I don't care whose work
> goes in first, but I think I'm in agreement with you that one of us should
> take the lock so that we don't have to deal with nasty merges.
> 
> —
> Reply to this email directly or view it on GitHubhttps://github.com/plt/racket/pull/630#issuecomment-41813264
> .

Addressed all the comments.

@bluephoenix47 I think the trace output should go to the file.  What else would happen?

@jeapostrophe Does this mean this PR should be closed?

Merged a while ago.

I'll merge soon, with a few changes: add `call-` to the function names (since the weak convention is to use `with-` for syntactic forms), use the temporary directory instead of the current directory, fix up contracts, and adjust documentation style.

I'm having trouble seeing how a failure can happen. The function should be called only on fully expanded forms, and I think those are either identifiers or sequences that start with an identifier. It's probably better to add the guard anyway, though, so I'll merge the patch.

Can you say more about why you'd like this in contrast to `raco setup` and the current `make again`?

I see that, unlike `raco setup`, this `again` builds the C-implemented core. Unlike the current `make again`, though, it assumes that the set of packages and package dependencies hasn't changed. That seems like an awkward combination to explain.

Depending on what you want, does it make sense to leave the documented `again` target alone and introduce a new target? Updating "INSTALL.txt" might help clarify either way.

I don't think the revised `win32-in-place` target will work with NMAKE.

My standard workflow (say, when getting to the office in the morning) is:
- `git pull`
- `make`

The second step is `make` instead of `raco setup` because most of the time, there has been some change to the C code.  The current `make again` is substantially slower to get to the point where `raco make` works again then the revised version here. 

The reason not to handle changed packages is (a) that they don't change very often (b) I hope that they change even less often as new code goes into packages not in the main repo and (c) that I think ignoring that case is a reasonable approach for something that's supposed to be fast.

I'd be happy to have this as a different target, but I don't know if anyone uses the current `make again`.

I'll take out the win32 handling -- does NMAKE support conditionals at all?

It sounds like you want the effect of `make again`, but faster. Maybe a better approach is to improve the re-linking step so that it's faster when nothing has changed. On my machine, the re-linking step is a small part of `make`, but I'm sure it can be faster, anyway.

I won't merge this, but I will comment on it when I adapt the patch. I don't want closing it to imply to the original author that we're "done" with it, but in principle I think it could be closed.

I think just closing pull requests that we aren't going to merge is fine.

K

Certainly, I am a bit obsessed with build times.

For me, the 3 steps on a no-op build are the following times:
- `make base -j8` 2.1 sec
- `make pkg-links` 3.6 sec (with or without `--restore`)
- `raco setup` 11 sec

(The `raco setup` time could be a lot faster -- `raco setup -DKU` is 3.4 seconds)

The other concern is that I've had issues where re-linking has failed or otherwise left my installation in a bad state, and thus I'm (perhaps irrationally) worried about it.  I don't have specific failures to point to, but I think it's that if it doesn't do the right thing, most of the packages are no longer found.

The easy way to make sure you don't get in a bad state is to not try to
take shortcuts. And you can do that by just doing your builds at night
before bed instead of first thing in the morning. No?

Robby

On Thu, May 1, 2014 at 12:49 PM, Sam Tobin-Hochstadt <
notifications@github.com> wrote:

> Certainly, I am a bit obsessed with build times.
> 
> For me, the 3 steps on a no-op build are the following times:
> - make base -j8 2.1 sec
> - make pkg-links 3.6 sec (with or without --restore)
> - raco setup 11 sec
> 
> (The raco setup time could be a lot faster -- raco setup -DKU is 3.4
> seconds)
> 
> The other concern is that I've had issues where re-linking has failed or
> otherwise left my installation in a bad state, and thus I'm (perhaps
> irrationally) worried about it. I don't have specific failures to point to,
> but I think it's that if it doesn't do the right thing, most of the
> packages are no longer found.
> 
> —
> Reply to this email directly or view it on GitHubhttps://github.com/plt/racket/pull/631#issuecomment-41935403
> .

BTW, Travis says this breaks the math library

@stamourv, sorry this is still a little ways down on my TODO list. 

@mflatt, I discovered this when trying to use errortrace to do some
profiling, and got several contract error messages that seemed to be
caused exactly by `free-identifier=?` being called on `syntax?` that were
not `identifier?` If this shouldn't happen, then perhaps this patch is just
duck tape over another problem.

I've sped up `make pkg-links` by a factor of 10 or so.

The main change was to extend `raco setup` to perform package-conflict and package-version checks, since it was already gathering practically all of the needed information. With that change, we don't lose checking overall by skipping a reinstall in `make pkg-links` (although failure can be delayed). I think it's good to have a check in `raco setup`, anyway.

A second change is a shortcut in `get-info` to speed it up for simple "info.rkt" files, where nearly all the package "info.rkt" files are simple enough.

> I've sped up make pkg-links by a factor of 10 or so.

Wow! That sounds great.

Do we have performance numbers on this?

Not ones that I've run recently, but I recall it being a big speedup on
something when I originally wrote this code.

Travis is complaining again. It seems to suggest that `typed-racket/utils/early-return.rkt` is not checked into git.

Maybe I just missed it, but should the last commit also have a `fail.rkt` file in the diff? I didn't see one, but I saw imports for it.

Yeah, `git reset HEAD^` + `git add -p` + `git commit` turns out to miss new files.  Fixed now.

Turns out this code is obsolete; I plan to remove the whole thing instead.

Merged with the rest of the changes.

No longer needed thanks to @mflatt's optimizations.

Now that my big refactoring is merged, we should get this merged too.

r+

@elibarzilay any thoughts?

Merged.

Merged.

The pattern matching changes are fine with me.

Already merged.

This is finally all in.

r+ with comments

@rmculpepper any thoughts?

Merged.

It's probably safe to assume that Greg knows what he's doing there now more
than I do.

On Tue, May 6, 2014 at 2:26 PM, Sam Tobin-Hochstadt <
notifications@github.com> wrote:

> @elibarzilay https://github.com/elibarzilay any thoughts?
> 
> —
> Reply to this email directly or view it on GitHubhttps://github.com/plt/racket/pull/615#issuecomment-42340082
> .

## 

```
      ((lambda (x) (x x)) (lambda (x) (x x)))          Eli Barzilay:
                http://barzilay.org/                   Maze is Life!
```

Redone as #639 

Formerly #449. Added more explanation to docs, accounted for changes to Redex codebase since old PR

Hi: I asked some questions after looking at the old PR: have you looked
into them?

Robby

On Wednesday, May 7, 2014, Justin Slepak notifications@github.com wrote:

> Formerly #449 https://github.com/plt/racket/pull/449. Added more
> explanation to docs, accounted for changes to Redex codebase since old PR
> 
> —
> Reply to this email directly or view it on GitHubhttps://github.com/plt/racket/pull/639#issuecomment-42484936
> .

I expanded on the explanation of cache poisoning in the Redex reference.
I don't currently have my machine in a state where I can do performance testing, but I should be able to take proper measurements once I get back to Boston.

@rmculpepper I think you're the right reviewer here.

I like changes that remove lines of code.

it occurs to me now that i was a little early in taking SNI off the todo list, since i only did the client half of it.

it looks like the thing to do would be to take a callback which is fed the requested server name, and returns the ssl context to use?
https://github.com/openssl/openssl/blob/master/apps/s_server.c#L758
https://github.com/apache/httpd/blob/33835bf1230d340a0ab48b5adf29281188eabb8c/modules/ssl/ssl_engine_kernel.c#L1934
http://stackoverflow.com/questions/5113333/how-to-implement-server-name-indicationsni-on-openssl-in-c-or-c

that doesn't sound too bad...

@jkominek, the client part looks good from the quick look I took this morning. A few notes and questions:

There's a magic constant 0 in the call to `SSL_ctrl` that has a name in openssl/tls1.h.

Does it work even if the client context uses a version before pre-TLS 1.0 (ie, SSL 3.0)?

How can it be tested? (For example, can you set up a server via "openssl s_server" that uses SNI with different certificates? Or is implementing server-side SNI in Racket the best way to test this?)

On Wed, May 7, 2014 at 10:38 PM, Justin Slepak notifications@github.com
wrote:

> I expanded on the explanation of cache poisoning in the Redex reference.

Thanks! That looks great.

> I don't currently have my machine in a state where I can do performance
> testing, but I should be able to take proper measurements once I get back
> to Boston.

I'm not completely sure from reading the diff, but it seems like you're
computing the cache-posioning transitive behavior at runtime. But I think
that you can do that at compile time. That is, when 'term' processes the
right-hand sides of a metafunction, it will find out what other
metafunctions are called and, based on that, it can know if any of them are
cache poisoners. Then, it can just pass a boolean in as the cache-poison?
argument instead of having to pass a box and do the complex chaining that
your'e doing. So the right changes should be to have the compile-time
computations that rewrite metafunctions inside 'term's (see term.rkt and
related files) return a boolean to indicate if they've found a cache
poisoner.

Also, avoiding state like that will be important for future performance
improvements of Redex, I believe.

Robby

oops, I missed the constant for some reason.

openssl doesn't mind the attempt to set the value when using SSL3, it just has no effect.

For a non-automatic, I-just-want-to-see-it-work test, sni.velox.ch is the simplest thing to do; you can visually check the CN of the certificate you get back and see that it varies with the server name you send.

For an automatic test, yeah, s_server can do the job: "openssl s_server -cert a.pem -cert2 b.pem -servername test.com" - when you connect and send a servername of "test.com" you'll get the cert from b.pem, and anything else will send you the cert in a.pem. (just tried it.) For bonus points if you monitor the output of s_server, it prints out a line indicating what was received:

```
Hostname in TLS extension: "foo.com"
```

I tried adding an SNI test that runs `openssl s_server` as a subprocess, and it fails for mysterious reasons probably not related to these commits. (The test works when the server is started separately from a terminal.) I'd like to have a fully-automated test before merging, but if I can't figure out the problem in the next day or two I'll settle for a manual-intervention-required test for now.

BTW, I think only doing client-side SNI is fine for this pull request.

Assuming that it's ok with you, I'll move this note to a margin note and then merge. Thanks!

Sounds good to me :-)

This seems right to me, but I'm not sure.

@sstrickl, any thoughts?

Also, can the bug here be expressed in terms of our paper?

@samth, I cannot seem to find inference described in the paper formalism, which seems to only describe substitution, subtyping, and typechecking.

Using the stuff here:
http://www.ccs.neu.edu/racket/pubs/esop09-sthf.pdf
ssh://git@git.racket-lang.org/sstrickl/papers/polydots.git

Right, inference isn't described, but I was hoping that we could use the
type system to characterize the issue.  But thinking about that more, I
doubt it will work.

i got the server-side SNI working, it's available here: https://github.com/jkominek/racket/commit/47d631cdf4500b91f945eaee2b754cc7d3ee925b
i could pull that into this request (i think?) if you'd like, or do a separate one.

and i put together a test program that uses the client & server pieces together:
https://gist.github.com/jkominek/605a26e72ab0b995a6cd

Thanks, just merged this.

Done!

Can you rebase this so that it's easier to review?

Rebase against what/passed what? The stuff that it is based on is still in review.

Sorry, got confused by GitHub notifications. Never mind.

On Thu, May 15, 2014 at 4:13 PM, Eric Dobson notifications@github.comwrote:

> Rebase against what/passed what? The stuff that it is based on is still in
> review.
> 
> —
> Reply to this email directly or view it on GitHubhttps://github.com/plt/racket/pull/646#issuecomment-43258980
> .

Actually, not done yet.

I hadn't submitted a pull request, since I was investigating why it made such a difference. Turns out quotient/remainder doesn't get JITed:

http://bugs.racket-lang.org/query/?cmd=view&pr=14511

quotient/remainder gets jitted, then it might end up faster than separate arithmetic-shift & bitwise-and, in which case this would slow things done. If it isn't jitted, then I'd planned to submit a pull request for my change.

I've updated this so that the current TR tests all pass. There are likely still cases where the new non-uniform rest args will blow up (e.g., if you supply something weird like `Any` or any other non-list type or possibly strange list types)..

Next I'll try to see if I can use it to simplify dotted rest args.

I now have a version which handles structural recursion in a (semi-)principled fashion.

Ok rebased against master now that the first part is pushed.

Added a short description.

This is very nice. As it says inline, I think we need some larger comment block somewhere explaining what's going on. Otherwise, r+

I've now merged this.

Rebased this so now it has only the interesting commits.

I was being stupid before.

I wanted to specify that the traced output should go to one port, while my program IO goes to another port. It looks like I can do that via `current-trace-notify`, as done here: https://gist.github.com/bluephoenix47/cb037265e7aa054d29bb

Ok, great.

Okay, I made the name for trace-lambda optional and added some little tests.

This looks great!

This looks good, I'll merge it soon.

Merged, thanks.

I finally got the test working, and I've merged the commits above. Can you start a new one for the server side? Thanks!

I don't understand what this means. When does `AnyValues` have a filter?

We can write the type assert-string `(Any -> Void : (String @ 0 | String @ 0)`. We can also have that return `AnyValues` instead of `Void`, and it still makes sense. I'm not sure of the use case, but we need the filter in `tc-any-results` and thus it seems like it should be there for symetry. 

We need it in `tc-any-results` because we need to understand filters even if we don't need to understand the values.

I acutally have a possible reason for AnyValues

```
(begin
  (let loop ((y x))
    (unless (string? y)
       (error 'bad-input)))
  (string-length x))
```

I cannot see anyone manually writing that but I can see a macro expanding to something like that.

r+

If I understand correctly, we need filters in `tc-any-results` because even if we don't care about the returned values, we might care about the filters, as in `(begin e e*)`.  And add ing it to `AnyValues` is both symmetric and potentially useful in the example given.
1. Let's make that a test case.
2. We really need some internals documentation to record this discussion, since my ICFP paper is way to simple to cover this.

cc: @sgtamk

What does the `math` library fail on?  Usually this would be a bug, I think.

Extracted function. There are multiple cases and in some branches of the ifs don't make sense if the argument is a certain type.

```
#lang typed/racket


(require racket/flonum
         math/private/flonum/flvector
         math/private/flonum/flonum-functions
         math/private/flonum/flonum-more-functions)

(define-predicate float-complex? Float-Complex)
(: atanh (case-> (Zero -> Zero)
                 (Float -> Float)
                 (Real -> Real)
                 (Float-Complex -> Float-Complex)
                 (Number -> Number)))
(define (atanh x)
  (cond [(flonum? x)  (flatanh x)]
        [(eqv? x 0)  0]
        [(real? x)  (flatanh (fl x))]
        [(float-complex? x)  (* 0.5 (- (log (+ 1.0 x)) (log (- 1.0 x))))]
        [else  (* 1/2 (- (log (+ 1 x)) (log (- 1 x))))]))
```

merged - thanks!

Added signature to tc-body/check.

Do you have any memory limits set within the shell? I think "Killed" means that the Racket process was terminated from outside Racket, possibly because it exceeded a memory-use limit.

@shekari 

Works great in a freshly built Racket. Is there a way to push the commit directly from Github?

Travis failure looks like you forgot to include a file in your commit.

Thanks, added the file. (though argh, Github forgets comments on some force pushes)

On why a prefab, I think it's because I didn't want the prims module to depend on kw-types for the structure type.

More comments on old commit https://github.com/takikawa/racket/commit/0babf53ae961c238403cbca8176cd00e570f2dfb, that github decided to eat.

I haven't taken a look at the actual changes (will later tonight). But by
the files changed I can see that you are not using the logic for merging
results that exists in tc-if, this should share code with that. I have a
change that moves it out and shares it with something else (not sure
exactly what at the moment). That change may be out for review or it is
blocked by the changes I have out for review.

On Mon, Jun 9, 2014 at 2:35 PM, Asumu Takikawa notifications@github.com
wrote:

> The commits I'd like to get reviewed are mainly the last two. They
> implement support for better checking applications of unioned functions or
> unioned objects (with method send).
> 
> Instead of crashing with an internal error, TR should now union the
> results of the function call correctly. If the number of values are not
> consistent, it will lift the result to AnyValues conservatively.
> Otherwise it will pointwise union if there are multiple values.
> 
> The main concern I have is: should the union-results function error
> instead of lifting to AnyValues? Also let me know if the union logic
> seems bogus. It could also be smarter about filters, but that can be added
> 
> ## later.
> 
> You can merge this Pull Request by running
> 
>   git pull https://github.com/takikawa/racket tr-union-funs
> 
> Or view, comment on, or merge it at:
> 
>   https://github.com/plt/racket/pull/670
> Commit Summary
> - Refactor tc-send, delete trailing whitespace
> - Fix TR `send` for multiple/any values as receiver
> - Allow `send` to union of objects
> - Handle union of different values for functions too
> 
> File Changes
> - _M_
>   pkgs/typed-racket-pkgs/typed-racket-lib/typed-racket/typecheck/tc-funapp.rkt
>   https://github.com/plt/racket/pull/670/files#diff-0 (37)
> - _M_
>   pkgs/typed-racket-pkgs/typed-racket-lib/typed-racket/typecheck/tc-send.rkt
>   https://github.com/plt/racket/pull/670/files#diff-1 (65)
> - _M_
>   pkgs/typed-racket-pkgs/typed-racket-test/tests/typed-racket/unit-tests/class-tests.rkt
>   https://github.com/plt/racket/pull/670/files#diff-2 (32)
> - _M_
>   pkgs/typed-racket-pkgs/typed-racket-test/tests/typed-racket/unit-tests/typecheck-tests.rkt
>   https://github.com/plt/racket/pull/670/files#diff-3 (14)
> 
> Patch Links:
> - https://github.com/plt/racket/pull/670.patch
> - https://github.com/plt/racket/pull/670.diff
> 
> —
> Reply to this email directly or view it on GitHub
> https://github.com/plt/racket/pull/670.

That's a good point, it looks like it would be possible to use the code in `tc-if` by folding it over the results pairwise. It implements a different semantics for differing numbers of values though. I guess it may be better to be consistent with `if` here anyway though?

I think being consistent is the right way to go, given that I cannot see a use case for wanting different numbers of values (except in a case where you don't care about the number of returned values).

Thanks, I addressed all of the comments. Merged.

This seems unlikely to be a good idea, unless we have some benchmarks that
show it to be faster on real programs. Plus it will increase memory use
significantly, I expect.

Given that Neil had to pass handles across the typed/untyped boundary instead of his datastructure because the contract checking was O(n), I think we have a real program that would benefit from it.

@ntoronto Can you try your BSP tree example with this? 

This is not a real program but I think it is representative of a real program.

We construct a binary tree and then ask for its root node from the untyped world. They are approximately the same speed on my machine but if you increase the size of the tree then the lazy contract wins out.
https://gist.github.com/shekari/a1fa282db349ec584f50

Sure, we can easily construct programs where this is a big win. But almost
all contracts between typed and untyped are simpler and for smaller data,
and I suspect that this will make programs overall worse.

If we can allow people to control what kind of contracts are generated, I
think that's a better solution.

If the contract is on simple smaller data then contract overhead is tiny and making it more doesn't change anything. I don't understand what you mean by real programs, we already have evidence that TR programmers are not writing programs where this is an issue because it is slow. Thus we will not see real programs because of it.

We could do interesting things where if we know the type is not recursive then make it strict, but I don't want to guarentee when contract errors will be raised but can that limits future changes.

Also are you worried about the slowdown because we have to make struct contracts chaperone contracts or the fact that the contracts actually chaperone the value at runtime? Because the first will be coming anyway for soundness reasons (we need to protect access to fields of subtype), but can conceivable stay flat for non subtypes.

On Wed, Jun 11, 2014 at 10:58 AM, Eric Dobson notifications@github.com wrote:

> If the contract is on simple smaller data then contract overhead is tiny and making it more doesn't change anything. I don't understand what you mean by real programs, we already have evidence that TR programmers are not writing programs where this is an issue because it is slow. Thus we will not see real programs because of it.

If we make the overhead significantly larger for passing back and
forth small structures, I expect that real TR programs will become
slower. I agree that there are other programs people aren't writing
because of the slowdown, but I'm not convinced that we'll be making
them enough faster to make up for this.

> We could do interesting things where if we know the type is not recursive then make it strict, but I don't want to guarentee when contract errors will be raised but can that limits future changes.

I agree that we don't want to guarantee this.  And I bet that strict
struct contracts are much faster.

> Also are you worried about the slowdown because we have to make struct contracts chaperone contracts or the fact that the contracts actually chaperone the value at runtime? Because the first will be coming anyway for soundness reasons (we need to protect access to fields of subtype), but can conceivable stay flat for non subtypes.

Well, I'm still hoping that we can find solutions to the subtype
soundness issue with lower runtime cost.

All of those branches should type check with type `(U)` for `x` and return type `Any`. So maybe we just need to relax the typechecking of dead code?

I thought Neil already said that he did some crazy hack to work around the
issue that you're saying doesn't exist, Sam?

On Wed, Jun 11, 2014 at 10:09 AM, Sam Tobin-Hochstadt <
notifications@github.com> wrote:

> On Wed, Jun 11, 2014 at 10:58 AM, Eric Dobson notifications@github.com
> wrote:
> 
> > If the contract is on simple smaller data then contract overhead is tiny
> > and making it more doesn't change anything. I don't understand what you
> > mean by real programs, we already have evidence that TR programmers are not
> > writing programs where this is an issue because it is slow. Thus we will
> > not see real programs because of it.
> 
> If we make the overhead significantly larger for passing back and
> forth small structures, I expect that real TR programs will become
> slower. I agree that there are other programs people aren't writing
> because of the slowdown, but I'm not convinced that we'll be making
> them enough faster to make up for this.
> 
> > We could do interesting things where if we know the type is not
> > recursive then make it strict, but I don't want to guarentee when contract
> > errors will be raised but can that limits future changes.
> 
> I agree that we don't want to guarantee this. And I bet that strict
> struct contracts are much faster.
> 
> > Also are you worried about the slowdown because we have to make struct
> > contracts chaperone contracts or the fact that the contracts actually
> > chaperone the value at runtime? Because the first will be coming anyway for
> > soundness reasons (we need to protect access to fields of subtype), but can
> > conceivable stay flat for non subtypes.
> 
> Well, I'm still hoping that we can find solutions to the subtype
> soundness issue with lower runtime cost.
> 
> —
> Reply to this email directly or view it on GitHub
> https://github.com/plt/racket/pull/671#issuecomment-45754374.

I didn't say the issue doesn't exist -- that would be very silly of me. I'm
skeptical that this change will make things better, and more importantly, I
expect that this will significantly slow down some existing TR programs.
Adding a constant factor overhead of 60 is rarely going to be a good idea.

Ok, made it set all lexical variables to Bottom. We need all in the case that there are dependencies ie (Float Float -> Float) and (Int Int -> Int).

This has all the comments addressed. I plan on merging the last two commits into earlier ones (but need to sleep.)

I also need to revisit the expected csets because it is definitely slower now especially on succeed/values-dots.rkt

At that point, I don't know how useful the checking is. Maybe we should
just drop this, as you originally suggested.

LGTM otherwise. It's nice that this cuts out a bunch of redundant code.

LGTM modulo comments.

SGTM, will submit the original version.

LGTM otherwise.

@mflatt I think you're the right person to review this.

Any update on the perf issues?

I believe the perf issue is actually the issue in
http://bugs.racket-lang.org/query/?debug=&database=default&cmd=view+audit-trail&cmd=view&pr=14576
. As I was able to replicate slowness when passing in a dotted list instead
of having dotted arguments. This would cause performance differences
because we know ahead of time the number of args that we want the function
to have. I'm currently trying to fix that PR and see if it clears up the
performance issue.

On Mon, Jun 16, 2014 at 3:29 PM, Sam Tobin-Hochstadt <
notifications@github.com> wrote:

> Any update on the perf issues?
> 
> —
> Reply to this email directly or view it on GitHub
> https://github.com/plt/racket/pull/650#issuecomment-46246288.

r+ from me too, w/ comments.

Since the cache was added in e450e281 for performance reasons, do we have something showing that this doesn't slow us down?

I don't see how it could speed us up.

Any type variable that we would put into the cache should not be in the
resulting cset that we return from the function that generates the prefix,
as they should all be removed by the function to move it into the dmap. No
arguments to the subcalls have the type variable that is the key in them.
Thus the only way we get a cache hit is if two distinct branches of a type
both use a dotted variable, but in this case there is no benefit of having
the cache.

On Mon, Jun 16, 2014 at 4:06 PM, Sam Tobin-Hochstadt <
notifications@github.com> wrote:

> Since the cache was added in e450e28
> https://github.com/plt/racket/commit/e450e281 for performance reasons,
> do we have something showing that this doesn't slow us down?
> 
> —
> Reply to this email directly or view it on GitHub
> https://github.com/plt/racket/pull/673#issuecomment-46249248.

No measurable difference when running all the tests. Did that change come with a problematic piece of code that was slow?

Nope that is not it. Still unclear on what is the cause of this is.

Are there any comments on this other than performance issues? If not I'm going to merge what I can. Like the cleanup in funapp and the values change.

Merged. I merged the commits for tests with the changes that make them pass, and then added an improvement that builds on these.

Thanks!

All the commits I commented on look good, which is I think the ones you mean.

I've updated this PR to check the kw function even if there are missing keywords in the lambda. It'll check the remaining matching cases. If there are _too many_ keywords, however, it won't try to check it.

It should also now produce a useful error when there are too many keywords.

Note: the last two commits are new.

Do you have a sense of how often this would be triggered across the code base?

Is this good to go in with comments resolved?

Yes.

No, but I can try to count them for the weekend.

But theses two optimizations are “cheap”, the new code is very short and
the optimizer does almost all the calculation anyway.

The other optimization in the PR comment [ (not (if x y (list 1))) => (not
(if x y #t)) ] is more complex. It needs ~30 LOC and it adds an additional
check to many expression. I’m not sure if it would be a net win, so I
didn’t write it.

Gustavo

On Wed, Jun 18, 2014 at 10:46 AM, Sam Tobin-Hochstadt <
notifications@github.com> wrote:

> Do you have a sense of how often this would be triggered across the code
> base?
> 
> —
> Reply to this email directly or view it on GitHub
> https://github.com/plt/racket/pull/675#issuecomment-46437075.

I merged this, finally, but I kept the name `"mzscheme"` in the readline data, since @mflatt kept that intentionally as well.

I'll merge the first one soon. For the second one, I think it works better to trigger boolean-mode handling in the application case of optimization; that goes with some other clean-up and generalizations that I'll push.

Thanks!

This is now merged.

This is much better. I was thinking about a more restrictive solution.
Something similar to only the commit: “optimizer: boolean conversion
on app of predicate-matching primitives”
https://github.com/plt/racket/commit/780a825d349d76331f1b07639b0773d04368e1c2

Merged.

This looks good now, but will need rebasing on top of #650 (which should simplify it).

LGTM.
I'm not sure gnats will recognize your commit message, though. Could you rephrase it to include `Closes PR14589` and squash the two commits together?

@stamourv Done.

Merged, thanks!

Can you try seeing if you still need this at HEAD?

I changed this a bit, and addressed the comments.

Addressed the comments, except kept as let/ec as discussed on IRC.

I don't, just the call/ec type stuff. I'll make a new PR for it. The inference problem remains for typing (let/ec x : (values) (x)) in a file versus the REPL.

Can you file a bug for the inference problem, I cannot seem to replicate from your description.

Can you give an example of the issues that marketplace has?

@shekari in the marketplace nightly tests, the failures are for inferring the type of #hash(). It gets promoted to IHashTableTop, i.e., (IHashTable Any Any), instead of staying the new type of (IHashTable Nothing Nothing)

Can you add a test case file showing a new use case that is actually enabled by this. I.e. Using hashes covariantly.

Performed `git pull --rebase upstream` and fixed some merge conflicts.

r+ w/ comment.

This all looks good to me. We just need to add some documentation.

Are there any tests for `trace` currently?

LGTM otherwise.

@rfindler Sorry this dropped off my radar and I didn't get back to you. Recently @stchang hit this same issue again while implementing a new TR feature so I'm thinking about this again.

I've managed to make it work again for everything but applications of module boundary contracted functions with keyword arguments. The issue is that a keyword function application expands to something like this:

``` racket
(let-values (((readline-input:1:8) idY31)
             ((lifted.01) (#%top . lifted.0))
             ((temp2) '3)
             ((temp3) '10))  
 (#%app
   (#%app
    checked-procedure-check-and-extract
    struct:keyword-procedure
    readline-input:1:8
    keyword-procedure-extract
    '(#:precision)
    '4)
   '(#:precision)
   (#%app list temp3)
   lifted.01
   temp2))
```

This has an extra argument of `lifted.01` (the negative blame) which needs to be ignored by the type system, since the domain types of the function isn't going to include that.

Unfortunately there's no property that the contract system can attach that will be visible to TR on the arguments in this `#%app` (which is really a `#%plain-app`) because the Racket `#%app` will let-bind the arguments and pull them up like you see here.

Since TR's type rule doesn't look at the `let` bindings around the application, it can't figure out whether the contract system has actually inserted an extra argument or the programmer mistakenly added another argument.

TR could be changed to look at the entire `let` expression for keyword applications, but that's a messy change and ends up duplicating code (e.g., for checking `let` clauses). Maybe that is what we have to do though.

I couldn't find any tests.

When I tried to add some for my macros, Travis got errors when about `rackunit` not found (despite the `(module+ test ...)` starting with `(require rackunit)`).

I removed the tests in a recentish commit. The Travis job number is `2151.1`, line 848, https://travis-ci.org/plt/racket/jobs/25679987. If you can make any sense of it, I'll revert that commit.

I'll get around to some documentation, but maybe not until after POPL.

You can't depend on `rackunit` in this file, which is inside the core. 

It looks to me like tests are here: https://github.com/plt/racket/blob/master/pkgs/racket-pkgs/racket-test/tests/racket/trace.rktl

Ah I see. Does trace.rkt belong in core? ... Maybe a thought for another place.

I'll add some tests to there.

On Mon, Jun 23, 2014 at 10:21:09AM -0700, Sam Tobin-Hochstadt wrote:

> You can't depend on `rackunit` in this file, which is inside the core. 
> 
> It looks to me like tests are here: https://github.com/plt/racket/blob/master/pkgs/racket-pkgs/racket-test/tests/racket/trace.rktl
> 
> ---
> 
> Reply to this email directly or view it on GitHub:
> https://github.com/plt/racket/pull/525#issuecomment-46874688

Probably it doesn't, but I don't think changing it now is the right choice.
​

Just to be sure we are on the same page, regular, non-keyword functions
also add this extra argument.

I think we could probably change the expansion of keyword applications to
propagate some specific property. (But the keyword expansion code has
multiple paths for optimization purposes, I believe.) Does this not work?

Robby

On Mon, Jun 23, 2014 at 11:14 AM, Asumu Takikawa notifications@github.com
wrote:

> @rfindler https://github.com/rfindler Sorry, this dropped off my radar
> and I didn't get back to you. Recently @stchang
> https://github.com/stchang hit this same issue again implementing a new
> TR feature so I'm thinking about this again.
> 
> I've managed to make it work again for everything but applications of
> module boundary contracted functions with keyword arguments. The issue is
> that a keyword function application expands to something like this:
> 
> (let-values (((readline-input:1:8) idY31)
>              ((lifted.01) (#%top . lifted.0))
>              ((temp2) '3)
>              ((temp3) '10))
>  (#%app
>    (#%app
>     checked-procedure-check-and-extract
>     struct:keyword-procedure
>     readline-input:1:8
>     keyword-procedure-extract
>     '(#:precision)
>     '4)
>    '(#:precision)
>    (#%app list temp3)
>    lifted.01
>    temp2))
> 
> This has an extra argument of lifted.01 (the negative blame) which needs
> to be ignored by the type system, since the domain types of the function
> isn't going to include that.
> 
> Unfortunately there's no property that the contract system can attach that
> will be visible to TR on the arguments in this #%app (which is really a
> #%plain-app) because the Racket #%app will let-bind the arguments and
> pull them up like you see here.
> 
> Since TR's type rule doesn't look at the let bindings around the
> application, it can't figure out whether the contract system has actually
> inserted an extra argument or the programmer mistakenly added another
> argument.
> 
> TR could be changed to look at the entire let expression for keyword
> applications, but that's a messy change and ends up duplicating code (e.g.,
> for checking let clauses).
> 
> —
> Reply to this email directly or view it on GitHub
> https://github.com/plt/racket/pull/516#issuecomment-46866354.

Yes, non-keyword function applications get an extra argument too, but those are easier to detect so they are ok.

If we change the keyword application expansion, that would also work. Like if it propagated the syntax properties on the argument expressions to the new let-bound variable names or something like that. It does seem invasive though.

It seems fine to me to expect the keyword expansion to cooperate with typed
racket and the contract system to get the behavior we want.

Just take the usual care: make it a seemingly reasonable behavior for the
keyword to have, and simple to explain at that level (eg, "if there is a
syntax property on one of my arguments named X, then it gets propagated"),
documented, and add test cases with a little comment next to the test cases
that test the behavior at that level saying "this is in support of
contracts/keyword arguments/typed/untyped interaction -- see test cases in
file x/y/z.rkt for the larger use case".

If you were especially worried about backwards compatibility, you could put
the explanation in the docs that also includes a rationale "this is
intended only to support TR and may change in future releases. if you need
to rely on this behavior, please post about your use case on the mailing
list and we'll discuss with the likely outcome being that this will become
guaranteed behavior". Something like that.

Does that all seem doable?

Robby

On Mon, Jun 23, 2014 at 8:12 PM, Asumu Takikawa notifications@github.com
wrote:

> Yes, non-keyword function applications get an extra argument too, but
> those are easier to detect.
> 
> If we change the keyword application expansion, that would also work. Like
> if it propagated the syntax properties on the argument expressions to the
> new let-bound variable names or something like that. It does seem invasive
> though.
> 
> —
> Reply to this email directly or view it on GitHub
> https://github.com/plt/racket/pull/516#issuecomment-46921675.

The bottom and multiple values has shown up in multiple places. I think the best solution is one that @ianj was trying to implement which was to add a different datastructure for bottom results. This would require a reasonable amount of checking all the use sites, but we won't get a case where it works for single value and not for multiple value.

r+

I think we should stick with type-equal?, since I think there are applications where we want to create equal types with different representation. This is needed, for example, to print types the way they were written.

How is that supposed to work with our current interning? Or are you thinking of a huge overhaul of that aswell?

Yes. I've tried to do this before, unsuccessfully, but we have to do it sometime to get good error messages.

Changed this to be more wordy but conceptually simpler.

Merged - thanks!

Ah, clever idea. Could you use `unsafe-Rep-seq` here?

r+

I don't think it is safe to do that because a bug could cause a non rep to flow where we thing a rep should be.

Are there programs that this causes to error (esp. that worked before)? If so, please add a test w/ one of them.

r+ o/w

This looks good to me, but @takikawa might know the channel code better.

LGTM as well. When you merge it, can you squash the commits together? Also there's a typo in the first commit msg.

r+ with comments

This looks reasonable to me.

@rmculpepper ping

@mflatt ping

All 4 unit tests that I added worked before (incorrectly though).

I was thinking about actual programs, but I guess it's pretty obvious how to generate them.

I dont think I have the ability to merge. @samth, can you give me access?

Can you not commit to the plt tree?

On Tue, Jun 24, 2014 at 5:57 PM, Stephen Chang notifications@github.com
wrote:

> I dont think I have the ability to merge. @samth
> https://github.com/samth, can you give me access?
> 
> —
> Reply to this email directly or view it on GitHub
> https://github.com/plt/racket/pull/685#issuecomment-47036400.

Yes, you can commit -- it's just like any other commit you want to push.

Ah ok.

commit 500745f

@rfindler Yes, thanks for the advice. I've pushed some new commits and I think it works now. Can you take a look at the changes to the contract system? (it's not that much different from the original thing I had, but there are more properties)

@mflatt Do the changes to the keyword application expansion look reasonable? (that's in the first commit)

Is this still the right url? https://github.com/plt/racket/pull/516

On Tue, Jun 24, 2014 at 7:01 PM, Asumu Takikawa notifications@github.com
wrote:

> @rfindler https://github.com/rfindler Yes, thanks for the advice. I've
> pushed some new commits and I think it works now. Can you take a look at
> the changes to the contract system? (it's not that much different from the
> original thing I had, but there are more properties)
> 
> @mflatt https://github.com/mflatt Do the changes to the keyword
> application expansion look reasonable?
> 
> —
> Reply to this email directly or view it on GitHub
> https://github.com/plt/racket/pull/516#issuecomment-47045911.

Yes, you can find the new commits in the commits tab or near the bottom of the discussion.

It looks okay to me, thanks. At some point, I think that the syntax/parse
system used make-provide/contract-arrow-transformer but maybe not anymore?

Robby

On Tue, Jun 24, 2014 at 7:27 PM, Asumu Takikawa notifications@github.com
wrote:

> Yes, you can find the new commits in the commits tab or near the bottom of
> the discussion.
> 
> —
> Reply to this email directly or view it on GitHub
> https://github.com/plt/racket/pull/516#issuecomment-47047558.

I have traced the issue down to the lack of an `#:expected-cset`. But it is not caused by my change, my change just makes it show up in new cases, but the problem exists at HEAD.

```
#lang typed/racket

(: map-with-funcs (All (b a ...) ((a ... a -> b) * -> (a ... a -> (Listof b)))))

(define (map-with-funcs . fs)
 (lambda as
   (map (lambda: ([f : (a ... a -> b)])
          (apply f as))
        fs)))

(define v (map-with-funcs - - -))
```

This takes absurdly long to typecheck and grows nearly exponentially in the number of funcs, because the size of the csets we are making is growing exponentially. I don't think we can avoid this in the general case, but we may be able to do something in some cases.

I assume it's only growing quadratically -- each new addition of `-` should take the cross-product of all of the cases of `-` with the previous cset.

I don't think there's really a possible fix for this, since the semantics just are that anything in that cross-product is legal. Separately, I'm working on some research that might provide a different algorithm, but that's not short-term.

I think we should keep the `#:expected-cset`, since it's needed for perf in non-pathological cases, and try to figure out better things in the future.

@rrnewton, you'll be interested in this.

My math may be a little rusty. I believe taking the cross product each time makes it grow exponentially, in the number of `-`s and the base of the exponent is the number of cases in `-`.

Also note that the issue isn't tha `#:expected-cset` is needed for perf in the non-pathological cases. Its that we already have some of the pathological cases in our test suite, and we need the `#:expected-cset` to avoid as large of a blowup.

Given that we don't have a fix for the performance issue, I think we should keep `#:expected-cset` and try to do better in the future.

Its not keep `#:expected-cset` but push it everywhere because the heavy logic is getting moved from `cgen/list` to `cgen/seq`. But yes I agree.

Sorry that I kept overlooking this patch. It looks ok to me, though a couple of minor style details could be fixed in the docs: capital "T" to start the prose, and change "this" used as a noun in the last sentence to "The `err-no-body?` argument".

Meanwhile, I've put "clean up lingering doc.txt files" on my todo list.

Whoops, had forgotten to commit a TR file and so travis was failing. Hopefully will pass now.

I just merged this with a different location, filename and commit message.

r+ w/ comments

Also, while reviewing this I noticed that `type-env-structs.rkt` uses dict operations everywhere. We should be able to get some performance win by specializing them.

This was merged.

type-env-structs is about 1/2 dead code I have a commit to remove most of it, and I'll rework it for perfomance as well when all the dependent code is in.

Also, this seems to have broken the math library, but in a way that I don't understand at all.

I figured out the breakage. It is reported in pr14608.

On Fri, Jun 27, 2014 at 1:20 PM, Sam Tobin-Hochstadt <
notifications@github.com> wrote:

> Also, this seems to have broken the math library, but in a way that I
> don't understand at all.
> 
> —
> Reply to this email directly or view it on GitHub
> https://github.com/plt/racket/pull/690#issuecomment-47395701.

The details of https://travis-ci.org/plt/racket/builds/28665270 show 3 working builds, but the clang on os x "failed". I don't think it is related to this pull request.

r+

Committed.

This looks nice. I warn you that passing the expected-cset might break some inference cases, though.
 r+

The `history` form gets the relevant package from a `declare-exporting` form within the section. Since the use of `defmodule` is marked with `#:no-declare`, it doesn't identify the package. Maybe the right fix is to add a "dummy" `declare-exporting` form to that documentation section so that any `history` notes will pick up the right package.

Meanwhile, don't use the version "6.0.1.13". Use (and increment as needed) the version of the relevant package, which probably means adding `(define version "1.1")` to the "info.rkt" of `typed-racket-more`.

3da81b5

For some reason, adding `@declare-exporting{typed-racket-more}` changed the package in the note from `typed-racket-lib` to `typed-racket-doc`, which are both wrong. Not sure what's happening there, but I found that if I included the note within the defmodule (and dropped the `#:no-declare`), it got the correct pkg name.

I don't understand why there's this big change to how dmaps work. Can you say more?

Quick answer: We assumed before that we were only creating a cset with a
single pair of maps, when creating the cset containing just the dbound
variable and its dcon. This assumption doesn't hold anymore because there
can be multiple pairs in the expected cset each with a different dcon.

On Tue, Jul 1, 2014 at 5:00 PM, Sam Tobin-Hochstadt <
notifications@github.com> wrote:

> I don't understand why there's this big change to how dmaps work. Can you
> say more?
> 
> —
> Reply to this email directly or view it on GitHub
> https://github.com/plt/racket/pull/702#issuecomment-47723263.

Addressed comments.
Removed dead commented code, used match-lambda (not define), used in-value, and added contract.

See #705 for related new unit test in TR.

Looks like this broke the  math library according to Travis.

LGTM.

Sense made.

Merged - thanks!

This has already triggered an unintended consequence on the top page of the docs. The right-hand box uses `margin-note*`, and the left column doesn't wrap because it's in a table. I tried taking out the call to `not-on-the-web` in [start.scrbl](https://github.com/plt/racket/blob/53e3d104f7adda1d94598ed498dec3b5f205e308/pkgs/racket-pkgs/racket-index/scribblings/main/start.scrbl) which wraps the `margin-note*`, but this didn't help.

The best solution here would be to fix the systemic problem, and change all TOCs to render as nested lists rather than tables.

The patch would be to change the markup around the box to use `margin-note` rather than `margin-note*`. (cf. the top page of the Racket reference, which does not exhibit the same problem.) 

![screen shot 2014-07-04 at jul 04 12 20 19 pm](https://cloud.githubusercontent.com/assets/1425051/3484620/5df86d3e-03b0-11e4-8804-5b67ecfe36f8.gif)

I've pushed the easy repair for now.

This code looks fine. Can you add a test case for it? Also, I originally thought that I'd add procedures that would just lazily return the same type as everything else allowed, like

Data = Atoms + (-> Data)

So, if we add that in the future, then we'll have to remember to fix that procedure? thing to do something like arity = 1.

The broken math library was because of generalization not handling unrolled lists well. That has been fixed, so this should be good now.

Thanks, @jeapostrophe – added a test case.

I like your idea for incrementally returning chunks – perhaps we'll experiment with that in comparison to this implementation. One benefit with this approach is that only one closure is allocated per call to http-conn-send! as opposed to one per chunk. 

r+

r+ w/ comment

r+

The first half of this (about `rest`) is clearly right.

The second half I'm less convinced about. I don't totally see why the `ann` solution @ntoronto mentions in the bug isn't enough. At a minimum, we should simplify complex list-like types in the printer, the way we do with precise numeric types (cc @stamourv). 

The current type of cons is too wide and no annotations can solve that. Our
semantics for case lambda types implies the first one that matches is
taken. Thus if we want to do `(cons x y)` where `x` has type `X` and 'y`
has type`Y`, with`Y <: (-lst X)`then there is no way an instatiation or
an annotation will make the expression have the type`(-pair X Y)`.

I agree with the printer comments, but I think that is a different bug.

On Mon, Jul 7, 2014 at 11:14 AM, Sam Tobin-Hochstadt <
notifications@github.com> wrote:

> The first half of this (about rest) is clearly right.
> 
> The second half I'm less convinced about. I don't totally see why the ann
> solution @ntoronto https://github.com/ntoronto mentions in the bug
> isn't enough. At a minimum, we should simplify complex list-like types in
> the printer, the way we do with precise numeric types (cc @stamourv
> https://github.com/stamourv).
> 
> —
> Reply to this email directly or view it on GitHub
> https://github.com/plt/racket/pull/711#issuecomment-48217743.

I don't think that's accurate. If you look at http://bugs.racket-lang.org/query/?cmd=view&pr=14457  the expression `(ann (cons v1 vs) (Listof+3 Index))` does what @ntoronto wants, even though `(cons v1 vs)` doesn't. The reason this works is that the first case doesn't unify with the desired result type, and thus the second case is picked. As the bug notes, this doesn't work for instantiation.

The reason that I bring up the printer is that doing this will, in addition to breaking a few programs, change lots of types to be more complex, because they'll have lots of `(Cons a (Listof b))` in them.

Right, I got confused about how case lambda works.

I think changing types to be more complex is required and good. The cases
where this shows up is when we ask TR to infer the return type of an
expression instead of checking it, if we don't return complex types then we
run into issues where inference requires help, as @ntoronto's bug shows.
Given that expected types do not go into arguments of polymorphic function
application, this can be a lot of work and sometimes impossible in macro
generated code.

For example I believe that `(cons 'a (cons 'a (cons 'a '())))` will have
type `(List 'a 'a 'a)` with my change and `(Listof 'a)` with the old code.
(Cannot test right now). I don't see programs having complex types as a
problem, (as long as we make sure that exposed version to users is simple).

On Mon, Jul 7, 2014 at 11:29 AM, Sam Tobin-Hochstadt <
notifications@github.com> wrote:

> I don't think that's accurate. If you look at
> http://bugs.racket-lang.org/query/?cmd=view&pr=14457 the expression (ann
> (cons v1 vs) (Listof+3 Index)) does what @ntoronto
> https://github.com/ntoronto wants, even though (cons v1 vs) doesn't.
> The reason this works is that the first case doesn't unify with the desired
> result type, and thus the second case is picked. As the bug notes, this
> doesn't work for instantiation.
> 
> The reason that I bring up the printer is that doing this will, in
> addition to breaking a few programs, change lots of types to be more
> complex, because they'll have lots of (Cons a (Listof b)) in them.
> 
> —
> Reply to this email directly or view it on GitHub
> https://github.com/plt/racket/pull/711#issuecomment-48220256.

Re printing types: There are two things that simplify printing of detailed numeric types: omitting intersection clauses that are subsumed by a subsequent clause, and using set coverage to print unions with the smallest set of types possible. Both of those apply to any intersection/union types (respectively), so we shouldn't need to do anything special here.

We also simplify/generalize at the repl:

Welcome to Racket v6.0.1.13.
-> 3
- : Integer [more precisely: Positive-Byte]
  3

In this case, always generating `Pair` types will change the printing,
which is what I'm concerned about:

-> (cons 1 null)
- : (Listof One)
  '(1)

I think we should also try to print that as (Listof Integer), the same as
the above example.

Sam

Sam are you solely worried that printing of types will change? Or are you
also saying that inferring more precise types internally is problematic as
well?

On Mon, Jul 7, 2014 at 1:32 PM, Sam Tobin-Hochstadt <
notifications@github.com> wrote:

> We also simplify/generalize at the repl:
> 
> Welcome to Racket v6.0.1.13.
> -> 3
> - : Integer [more precisely: Positive-Byte]
>   3
> 
> In this case, always generating `Pair` types will change the printing,
> which is what I'm concerned about:
> 
> -> (cons 1 null)
> - : (Listof One)
>   '(1)
> 
> I think we should also try to print that as (Listof Integer), the same as
> the above example.
> 
> Sam
> 
> —
> Reply to this email directly or view it on GitHub
> https://github.com/plt/racket/pull/711#issuecomment-48236585.

In general, more precise types are exposed to the user in other ways (such as error messages and complex inference failures). We can, in general, fix these issues, but we haven't yet and so this will add complexity in those places.

Right, but in avoiding complex inference failures we have to make inference
less powerful leading to errors like the bug report. I think the trade off
of having more simple programs work without annotations is worth having
slightly worse error messages in some cases.

On Mon, Jul 7, 2014 at 1:46 PM, Sam Tobin-Hochstadt <
notifications@github.com> wrote:

> In general, more precise types are exposed to the user in other ways (such
> as error messages and complex inference failures). We can, in general, fix
> these issues, but we haven't yet and so this will add complexity in those
> places.
> 
> —
> Reply to this email directly or view it on GitHub
> https://github.com/plt/racket/pull/711#issuecomment-48238458.

I don't mean that the semantics are the problem, just how they're reported.

Great. I think we are in agreement then, I'll look at trying to get the
printer to do simplification.

On Mon, Jul 7, 2014 at 2:10 PM, Sam Tobin-Hochstadt <
notifications@github.com> wrote:

> I don't mean that the semantics are the problem, just how they're reported.
> 
> —
> Reply to this email directly or view it on GitHub
> https://github.com/plt/racket/pull/711#issuecomment-48241449.

r+ w/ comments

I don't mean to say that we need to do that before merging this, but if we plan to do that it reduces the cost of changing `cons`'s type.

Ok, I think I'll wait till after the release cut for changing `cons`'s type
so that we don't have worse printing in the next release. I'll try to get
the `rest` type change in the release though.

On Mon, Jul 7, 2014 at 2:16 PM, Sam Tobin-Hochstadt <
notifications@github.com> wrote:

> I don't mean to say that we need to do that before merging this, but if we
> plan to do that it reduces the cost of changing cons's type.
> 
> —
> Reply to this email directly or view it on GitHub
> https://github.com/plt/racket/pull/711#issuecomment-48242190.

Merged.

Hold off on reviewing this, I'm going to send an email because I think this need a larger different fix.

I'm not familiar with libdispatch, but it looks like the point is to get concurrency via separate threads of execution. If so, that will not work with Racket. Racket can support callbacks from foreign threads, but only by moving the Racket computation back to the original thread. (See the `#:async-apply` option for `_fun`.)

In the absence of threads, there's a memory-management problem with your example. You need to make sure that the function passed as a callback remains reachable (as far as the garbage collector can see) as long as the callback might be used.

In the `dispatch_sync` case, I assume that the callback is used only during the `dispatch_sync` call; then, the function passed to `dispatch_sync` remains reachable as one of the arguments to a call in progress. For the `dispatch_async` case, I assume that the callback-providing call is not in progress by the time that the callback is invoked; then, you'd need to make sure that the callback function is retained as long as it might be needed. See also the `#:keep` argument to `_fun`.

My guess is that you're seeing a concurrency-related crash, though, instead of a memory-related crash.

The Travis failure looks like one of those random SIGSEGV failures, nothing to do with my change.
"SIGSEGV MAPERR si_code 1 fault on addr 0x2ba3147e0000"

Ok, I'm rerunning the travis build.

And it passed. I'll merge this hopefully soon, or someone else can.

I just pushed some tests and documentation.

I am not sure how to test `trace-define-syntax`. I also don't know what version numbers to use with `@history`.

I think it's right not to allow this, but I'd like to find an actually-unsound program that exhibits it.

```
(: f : (All (A) (Rec C (U A (Vectorof C))) (Vectorof A) -> Any))
(define (f v e) ...)
(define s (vector 'x))
(f 'b s)
```

Okay. This looks great.

@samth I have VERY sporadic and poor Internet access, so I can't get a fast enough connection to a "git pull" on the main tree before integrating this request. Can you merge it for me?

Done.

Merged.

Release has now been cut.

I'm planning to hash this out on email and then review the results.

I think we should just merge this.

@jeapostrophe Once you're back online, can you review this?

This looks good to me. Are there any invariants remaining about the constraint sets, for example that they don't map any variables not in X?

`data-procedure/c` needs to be documented.

(It's referenced in the documentation, but not itself documented.)

This looks good to me.

No objections from me.

Meanwhile, I think I finally fixed the bug that caused the Travis CI failure.

I'm rerunning the travis build.

@mflatt There's sadly still at least one other intermittent failure on travis that appears in some of the synchronization tests.

@mflatt you can see that error here: https://travis-ci.org/plt/racket/jobs/28895156

@samth That's correct

@shekari You're probably the person I most need to review this. Note that it doesn't do any real work yet, but it pushes the error later (to when it probably doesn't happen).

I did by applying the patch, because I wasn't sure whether merging a pull request went against the "no merges" rule. And now I can't close this.

What's the One True Way to do this?

I'll merge this --- thanks!

Merged, thanks!

Merged and generalized --- thanks!

I think maybe the problem is elsewhere. On my machine:

> (find-seconds 0 0 0 1 1 1958)
> -378669600
> (find-seconds 0 0 0 1 1 234)
> -54782848800

Robby

On Fri, Jul 11, 2014 at 5:45 AM, Kalimehtar notifications@github.com
wrote:

> In current version one cannot get date before 1970, because seconds->date
> doesn't allow such dates.
> But `date' struct doesn't have such restriction, so it is better to drop
> day-of-year (one can calculate it if needed), than disallow all dates
> 
> ## before 1970
> 
> You can merge this Pull Request by running
> 
>   git pull https://github.com/Kalimehtar/racket master
> 
> Or view, comment on, or merge it at:
> 
>   https://github.com/plt/racket/pull/726
> Commit Summary
> - Fix _date to allow dates before 1970 year
> 
> File Changes
> - _M_ racket/collects/ffi/unsafe/com.rkt
>   https://github.com/plt/racket/pull/726/files#diff-0 (17)
> 
> Patch Links:
> - https://github.com/plt/racket/pull/726.patch
> - https://github.com/plt/racket/pull/726.diff
> 
> —
> Reply to this email directly or view it on GitHub
> https://github.com/plt/racket/pull/726.

Oops, sorry. Here's the interaction I intended:

> (seconds->date (find-seconds 0 0 0 1 1 1958))
> (date\* 0 0 0 1 1 1958 3 0 #f -21600 0 "CST")
> (seconds->date (find-seconds 0 0 0 1 1 234))
> (date\* 0 0 0 1 1 234 3 0 #f -21600 0 "CST")

On Fri, Jul 11, 2014 at 6:03 AM, Robby Findler robby@eecs.northwestern.edu
wrote:

> I think maybe the problem is elsewhere. On my machine:
> 
> > (find-seconds 0 0 0 1 1 1958)
> > -378669600
> > (find-seconds 0 0 0 1 1 234)
> > -54782848800
> 
> Robby
> 
> On Fri, Jul 11, 2014 at 5:45 AM, Kalimehtar notifications@github.com
> wrote:
> 
> > In current version one cannot get date before 1970, because seconds->date
> > doesn't allow such dates.
> > But `date' struct doesn't have such restriction, so it is better to drop
> > day-of-year (one can calculate it if needed), than disallow all dates
> > 
> > ## before 1970
> > 
> > You can merge this Pull Request by running
> > 
> >   git pull https://github.com/Kalimehtar/racket master
> > 
> > Or view, comment on, or merge it at:
> > 
> >   https://github.com/plt/racket/pull/726
> > Commit Summary
> > - Fix _date to allow dates before 1970 year
> > 
> > File Changes
> > - _M_ racket/collects/ffi/unsafe/com.rkt
> >   https://github.com/plt/racket/pull/726/files#diff-0 (17)
> > 
> > Patch Links:
> > - https://github.com/plt/racket/pull/726.patch
> > - https://github.com/plt/racket/pull/726.diff
> > 
> > —
> > Reply to this email directly or view it on GitHub
> > https://github.com/plt/racket/pull/726.

@ntoronto If you actually pushed this change, I can just close the PR (or @shekari can). But I don't see the commit.

The way I usually merge pull requests is as follows:

```
$ git merge whatever-branch
$ git rebase origin/master
$ git push
```

Provided all of that goes cleanly, then you've pushed the change with no merge commits.

This looks good to me. 

I just realized that @shekari added functionality that renders BotValues useless (perhaps there's a performance benefit to a canonical BotValues?). It's really just the second commit in this PR that needs merging. I just rolled back this push and tried just the fixed test and got a pass.

> (seconds->date (find-seconds 0 0 0 1 1 1958)) 
> . . find-seconds: non-existent date
>   wanted: (0 0 0 1 1 1958)
>   nearest below: 0 is (0 0 6 1 1 1970)
>   nearest above: 1 is (1 0 6 1 1 1970)

Racket 6.0.1

Maybe find-seconds was fixed in 6.0.2. Then my pull request is not needed.

Found the source:
Linux:

``` racket
> (seconds->date -1)
(date* 59 59 4 1 1 1970 4 0 #f 21600 0 "SVET")
```

Windows:

``` racket
> (seconds->date -1)
. . seconds->date: integer is out-of-range
  integer: -1
```

```

```

I've addressed everything but the new directory, I think.

LGTM.

There still appears to be a Travis build failure on the math library.

We're apparently using gmtime() under windows which is documented not to
work with negative numbers (ie dates before 1970):
http://msdn.microsoft.com/en-us/library/0z9czt0w.aspx (code in fun.c).

I'm not turning up an alternative, but stack overflow does have a pointer
to the date section of the windows docs:
http://msdn.microsoft.com/en-us/library/windows/desktop/ms725473%28v=vs.85%29.aspx
that maybe holds an answer.

Robby

On Fri, Jul 11, 2014 at 11:25 AM, Kalimehtar notifications@github.com
wrote:

> Found the source:
> Linux:
> 
> > (seconds->date -1)(date\* 59 59 4 1 1 1970 4 0 #f 21600 0 "SVET")
> 
> Windows:
> 
> > (seconds->date -1). . seconds->date: integer is out-of-range
> >   integer: -1
> 
>  —
> Reply to this email directly or view it on GitHub
> https://github.com/plt/racket/pull/726#issuecomment-48751881.

We may use SystemTimeToFileTime as date->seconds and FileTimeToSystemTime as seconds->date. Then date should be after 1601 year. Or we can make Racket version of seconds->date, that work as linux version.

Otherwise, please accept my patch to at least make COM-interface usable with dates (now it cannot read half of birthdates from MS Excel).

Yet one extreme case: some Windows programs use "empty date" value. Usually 0001-01-01 00:00:00 or 0100-01-01 00:00:00. If limit date to 1601 year, then one should add special case to process empty date.

While `seconds->date` should be improved on Windows, I think this change is probably the right one to make for `_date`.

Okay. Sorry for the long digression.

Robby

On Saturday, July 12, 2014, Matthew Flatt notifications@github.com wrote:

> While seconds->date should be improved on Windows, I think this change is
> probably the right one to make for _date.
> 
> —
> Reply to this email directly or view it on GitHub
> https://github.com/plt/racket/pull/726#issuecomment-48804428.

I've pushed the change and a further one to use `date*`. I pushed even though I won't be able to check the change until Monday.

I just pushed a change which should avoid those errors, although I don't actually understand why they happened.

Good!! :)

On Sat, Jul 12, 2014 at 9:57 AM, Sam Tobin-Hochstadt <
notifications@github.com> wrote:

> ---
> 
> You can merge this Pull Request by running
> 
>   git pull https://github.com/samth/racket removed-defined-check
> 
> Or view, comment on, or merge it at:
> 
>   https://github.com/plt/racket/pull/728
> Commit Summary
> - Remove defined-ness checks in insert-large-letters.
> 
> File Changes
> - _M_
>   pkgs/drracket-pkgs/drracket/drracket/private/insert-large-letters.rkt
>   https://github.com/plt/racket/pull/728/files#diff-0 (12)
> 
> Patch Links:
> - https://github.com/plt/racket/pull/728.patch
> - https://github.com/plt/racket/pull/728.diff
> 
> —
> Reply to this email directly or view it on GitHub
> https://github.com/plt/racket/pull/728.

This was merged.

I merged the relevant commit.

@mflatt If you can review this, that would be great.

An access of a field by position should use `scheme_struct_ref()` so that chaperones work.

The arity check shouldn't be needed when the property value is used, since that's covered by the guard, right?

Tests?

Minor: I'd get rid of the intermediate `result` variable.

- If `scheme_struct_ref()` is needed, then I think the code for `prop:evt` is broken as well. See https://github.com/plt/racket/blob/master/racket/src/racket/src/struct.c#L1524 
- Similarly, the code for `prop:evt` did the arity check as well, but I can drop it.

I'll fix the rest.

Probably `prop:evt` does need `scheme_struct_ref()`. I'll look into that.

An arity check is needed in `prop:evt` because `v` can be the value of a field.

I'm just wondering would it be possible to have another option for spat be (~seq #:id pat) ?
So for example:

``` racket
(struct foo (a b c) #:transparent)
(match (foo 1 2 3)
  [(foo #:a a #:b b #:c c)
   (list a b c)])
;=> '(1 2 3)
```

Lots of comments, but this overall looks good.

@mflatt and @rfindler Since this touches your code, you probably want to take a look.

@AlexKnauth That's unfortunately ambiguous with matching one of the fields against the keyword `#:foo`.

How could it be ambiguous when `#:foo` isn't an expression?

I thought the whole point of making keywords not be expressions was to get rid of that ambiguity.  

I understand that `#:first`, `#:last`, and `#:full` couldn't appear as the first field kw, but that shouldn't mean that other kws are excluded, right?

While `#:foo` isn't an expression, it is a legal match pattern. That may
have been an unwise decision when keywords were added, but it's probably
one we're stuck with.
​

Couldn't the struct match-pattern override that?

Right now, this works:

(struct x (a b))
(match (x '#:foo 0)
  [(x #:foo y) y])

and produces 0.

Ok that looks really weird.  
And it wouldn't be too much of a bad thing to change that?  

And also doesn't this break that too?:
(struct-id mode spat ...)

Ah, good point. That's another potential strike against modes, I guess.

I looked through the commits and didn't detect any particular problem. I'm unsure that I have the big picture, but it looks plausible.

The big picture is that there's now an `extended-struct-info` substructure of `struct-info`, which has a list of symbols for the field names. As a result, we no longer need to do string-pasting to find accessors in things like `struct-copy`. `struct` creates `extended-struct-info` by default.

I think that about covers it.

The changes look great, thanks!
Could you squash your commits into a single one?
Also, could you add a test that would have failed before your fix for `(range 1)`? It can be either a unit test (in `pkgs/typed-racket-pkgs/typed-racket-tests/tests/typed-racket/unit-tests/typecheck-tests.rkt`) or an integration test (add a new file in the `pkgs/typed-racket-pkgs/typed-racket-tests/tests/typed-racket/success/` directory), whichever you prefer.

@shekari, @samth, @takikawa: We really should do something about those paths. They're ridiculous.

How do I squash the commits into a single one?

You can do that using `git rebase -i`. Here's an intro to `git rebase`: http://gitready.com/intermediate/2009/01/31/intro-to-rebase.html

A potentially easier solution would be to do a soft `git reset` to right before your changes, and re-commit them all at once.

If you don't feel comfortable doing it, I can do it for you.

Re: paths: we could make the tests package for TR be a single collection package, which would remove two levels of nesting:

```
pkgs/typed-racket-pkgs/typed-racket-tests/unit-tests/typecheck-tests.rkt

vs.

pkgs/typed-racket-pkgs/typed-racket-tests/tests/typed-racket/unit-tests/typecheck-tests.rkt
```

I made a new branch and a new pull request that has it all in one commit.
https://github.com/plt/racket/pull/735

On Wed, Jul 16, 2014 at 9:36 PM, Asumu Takikawa notifications@github.com
wrote:

> We could make the tests package for TR be a single collection package,
> which would remove two levels of nesting:

Do it!

The latest CI error means I didn't update parse-legacy with my change to parse-struct, and I failed to actually run makeexn to generate kernstruct.rkt (not part of the normal build process for some reason?). Testing locally then I'll push.

Merged, thanks!

@mflatt Doc fixup done.

I've now updated this PR after a long hiatus to address Eric's main feedback which was that TR was not keeping track of the flat, chaperone, impersonator constraints on recursive alias contracts. This could lead to poor error behavior. (for example, if you tried to make a predicate using a custom list type it would fail)

This required a fairly major restructuring. To compute the contract kind, TR now tries to compute flat, chaperone, and impersonator contracts for every recursive alias. It stops at the most restrictive one (e.g., flat is more restrictive than chaperone) and future references will use that contract.

This approach requires storing an extra table, which interfered with how contracts for `provide`s are generated. To avoid this, TR will now use the same mechanism as `require` to generate `provide` contracts (i.e., the contract fixup pass). This is useful even if recursive aliases weren't around because it puts control of contract generation in one place.

Contracts at the top-level also conflict for the same reason as `provide`. They are now also generated using the same means as `provide` and `require`, (this is possible since the TR top level now supports syntax lifting) which means the TR top-level has a contract fixup pass too.

One thing I haven't fixed is that `with-type` still conflicts with recursive alias contracts, but that's because `with-type` currently doesn't handle lifting correctly and should use the same mechanism for contract generation as everything else.

---

This series of commits enables a few refactorings that I haven't done yet. One is that `type->contract` should be removed as an import everywhere (once `with-type` is fixed). It probably doesn't even need to be exported now.

Another is that `type->contract`'s interface can change to handle the failure condition in a functional manner (by return value instead of by side effect).

---

A remaining downside is that this adds .zo overhead for TR files with mutually recursive aliases, since the contracts are always defined with the type alias. This shouldn't be much overhead for most code, but it's significant for the GUI type definition file. I think we can reduce this via other means later though.

I think I pushed a fix for this a few days ago.

Robby

On Tue, Jul 22, 2014 at 2:53 PM, J. Ian Johnson notifications@github.com
wrote:

> There was a problem with heap-remove-index! that made it only really work
> with index 0. This should fix it. I added random testing of the heap
> 
> ## invariant.
> 
> You can merge this Pull Request by running
> 
>   git pull https://github.com/ianj/racket fix-heap
> 
> Or view, comment on, or merge it at:
> 
>   https://github.com/plt/racket/pull/737
> Commit Summary
> - Closes PR 14651
> 
> File Changes
> - _M_ pkgs/data-pkgs/data-doc/data/scribblings/heap.scrbl
>   https://github.com/plt/racket/pull/737/files#diff-0 (2)
> - _M_ pkgs/data-pkgs/data-lib/data/heap.rkt
>   https://github.com/plt/racket/pull/737/files#diff-1 (25)
> - _M_ pkgs/data-pkgs/data-test/tests/data/heap.rkt
>   https://github.com/plt/racket/pull/737/files#diff-2 (170)
> 
> Patch Links:
> - https://github.com/plt/racket/pull/737.patch
> - https://github.com/plt/racket/pull/737.diff
> 
> —
> Reply to this email directly or view it on GitHub
> https://github.com/plt/racket/pull/737.

Oh, sorry: I pushed a fix for this yesterday. Commit 017480c9b98.

Robby

On Tue, Jul 22, 2014 at 6:33 PM, Robby Findler robby@eecs.northwestern.edu
wrote:

> I think I pushed a fix for this a few days ago.
> 
> Robby
> 
> On Tue, Jul 22, 2014 at 2:53 PM, J. Ian Johnson notifications@github.com
> wrote:
> 
> > There was a problem with heap-remove-index! that made it only really work
> > with index 0. This should fix it. I added random testing of the heap
> > 
> > ## invariant.
> > 
> > You can merge this Pull Request by running
> > 
> >   git pull https://github.com/ianj/racket fix-heap
> > 
> > Or view, comment on, or merge it at:
> > 
> >   https://github.com/plt/racket/pull/737
> > Commit Summary
> > - Closes PR 14651
> > 
> > File Changes
> > - _M_ pkgs/data-pkgs/data-doc/data/scribblings/heap.scrbl
> >   https://github.com/plt/racket/pull/737/files#diff-0 (2)
> > - _M_ pkgs/data-pkgs/data-lib/data/heap.rkt
> >   https://github.com/plt/racket/pull/737/files#diff-1 (25)
> > - _M_ pkgs/data-pkgs/data-test/tests/data/heap.rkt
> >   https://github.com/plt/racket/pull/737/files#diff-2 (170)
> > 
> > Patch Links:
> > - https://github.com/plt/racket/pull/737.patch
> > - https://github.com/plt/racket/pull/737.diff
> > 
> > —
> > Reply to this email directly or view it on GitHub
> > https://github.com/plt/racket/pull/737.

Okay, cool. Good to see we came to the same solution.
-Ian
----- Original Message -----
From: "Robby Findler" notifications@github.com
To: "plt/racket" racket@noreply.github.com
Cc: "J. Ian Johnson" ianj@ccs.neu.edu
Sent: Tuesday, July 22, 2014 7:35:06 PM GMT -05:00 US/Canada Eastern
Subject: Re: [racket] Closes PR 14651 (#737)

Oh, sorry: I pushed a fix for this yesterday. Commit 017480c9b98. 

Robby 

On Tue, Jul 22, 2014 at 6:33 PM, Robby Findler robby@eecs.northwestern.edu 
wrote: 

> I think I pushed a fix for this a few days ago. 
> 
> Robby 
> 
> On Tue, Jul 22, 2014 at 2:53 PM, J. Ian Johnson notifications@github.com 
> wrote: 
> 
> > There was a problem with heap-remove-index! that made it only really work 
> > with index 0. This should fix it. I added random testing of the heap 
> > 
> > ## invariant. 
> > 
> > You can merge this Pull Request by running 
> > 
> > git pull https://github.com/ianj/racket fix-heap 
> > 
> > Or view, comment on, or merge it at: 
> > 
> > https://github.com/plt/racket/pull/737 
> > Commit Summary 
> > - Closes PR 14651 
> > 
> > File Changes 
> > - _M_ pkgs/data-pkgs/data-doc/data/scribblings/heap.scrbl 
> >   https://github.com/plt/racket/pull/737/files#diff-0 (2) 
> > - _M_ pkgs/data-pkgs/data-lib/data/heap.rkt 
> >   https://github.com/plt/racket/pull/737/files#diff-1 (25) 
> > - _M_ pkgs/data-pkgs/data-test/tests/data/heap.rkt 
> >   https://github.com/plt/racket/pull/737/files#diff-2 (170) 
> > 
> > Patch Links: 
> > - https://github.com/plt/racket/pull/737.patch 
> > - https://github.com/plt/racket/pull/737.diff 
> > 
> > — 
> > Reply to this email directly or view it on GitHub 
> > https://github.com/plt/racket/pull/737. 

— 
Reply to this email directly or view it on GitHub .

On Tue, Jul 22, 2014 at 6:43 PM, J. Ian Johnson notifications@github.com
wrote:

> Okay, cool. Good to see we came to the same solution.
> 
> Yes, indeed! Even random testing the same three operations, I see. :)

Robby

Still looking at this. There's currently some cost to using `call-as-atomic` instead of `dynamic-wind`, and I'm trying to figure out whether it matters and/or whether it can be avoided.

Merged. (Despite my comment above, I didn't recognize the request today. Maybe I confused it with another one.)

Merged - thanks!

Thanks!

I don't understand why your algorithm moves the solving of the recursive contract kind constraints outside of the static-contract -> contract translation. Why isn't that suitable for what you are trying to do? Also I don't see how you are actually solving all the constraints. It seems like you just try some assigments, and then do a second pass and assume that any more passes would result in the same assignments. Do you have an argument for why this is sufficient?

@shekari Do you mean why don't I generate static contracts for all of the aliases at once first, then solve the constraints all at once for the static contracts, and then finally generate those to syntax?

(I could potentially do that but it might be more complicated. Also it would still need the table that tracks the contract kind for later uses of `type->contract` for generating contracts for things other than the aliases)

r+ w/ comments from me.

Merged - thanks!

Merged - thanks!

I've just read the [Performance of open-output-nowhere](http://lists.racket-lang.org/users/archive/2014-July/063560.html) thread and to clarify why it bothers me: I want to read data using the `json` module that makes use of `regexp-match` functions on ports. Sadly, that results in reads of less than 12 bytes at a time, which translates to 100% overhead on my sample file.

Does your application use `peeking-input-port`?

I see that `peeking-input-port` produces an input port that doesn't support or take advantage of buffering. I think it should be changed to support buffering and to initially use the buffer mode of the given port --- or use 'block buffering when the given port doesn't support buffer modes, which is the case for string ports.

That changes makes the `pin` case take about twice as long as `in`, instead of about 10 times as long.

Starting with a port that reads from a 1-MB JSON file and wrapping with `peeking-input-port`, the buffer change similarly speeds up a JSON read by a factor of 5: a 10% overhead over using the file port directly, instead of a 400% overhead.

OK, how do I create a buffering input port with `make-input-port`? Is there some infrastructure for that? I am toying with `replace-evt` and ports, see [misc1/direct-to-evt](https://github.com/mordae/racket-misc1/blob/master/misc1/direct-to-evt.rkt).

To expose a port's buffering to the run-time system, deliver more bytes than requested for a read request by returning a pipe input port (instead of filling the given byte string and returning a count).

Works like a charm!

Merged already.

Would it make sense to put these into racket/set?

Robby

On Wed, Jul 30, 2014 at 3:26 PM, Daniel King notifications@github.com
wrote:

> I find myself using these frequently. Perhaps they should be defined in
> 
> ## core Racket?
> 
> You can merge this Pull Request by running
> 
>   git pull https://github.com/danking/racket patch-1
> 
> Or view, comment on, or merge it at:
> 
>   https://github.com/plt/racket/pull/745
> Commit Summary
> - Add for/set-union for/seteqv-union for/seteq-union
> 
> File Changes
> - _M_ racket/collects/racket/private/for.rkt
>   https://github.com/plt/racket/pull/745/files#diff-0 (21)
> 
> Patch Links:
> - https://github.com/plt/racket/pull/745.patch
> - https://github.com/plt/racket/pull/745.diff
> 
> —
> Reply to this email directly or view it on GitHub
> https://github.com/plt/racket/pull/745.

You need a conditional somewhere to not do that in the "alternate racket is
enabled" case I think. Otherwise, looks good.

Robby

On Wed, Jul 30, 2014 at 6:23 PM, Sam Tobin-Hochstadt <
notifications@github.com> wrote:

> ---
> 
> You can merge this Pull Request by running
> 
>   git pull https://github.com/samth/racket rel-string
> 
> Or view, comment on, or merge it at:
> 
>   https://github.com/plt/racket/pull/746
> Commit Summary
> - Shorten strings shown in C-S-o
> 
> File Changes
> - _M_ pkgs/drracket-pkgs/drracket/drracket/private/get-module-path.rkt
>   https://github.com/plt/racket/pull/746/files#diff-0 (3)
> 
> Patch Links:
> - https://github.com/plt/racket/pull/746.patch
> - https://github.com/plt/racket/pull/746.diff
> 
> —
> Reply to this email directly or view it on GitHub
> https://github.com/plt/racket/pull/746.

Merged.

Ignore the patch. I forgot to close the pull request.

Apparently the patch is not enough to fix racket on i386. The dev in charge of the bulk build got an error related to boehm. I gave up and the port is using Senora now.

Respect to the OpenBSD patches to Boehm. The patches are always sent to upstream in this case. I'm reviewing the gcconfig.h file and there are some fixes included.

Maybe the more simple fix is to use Senora by default on OpenBSD. 

This needs both tests and docs, but otherwise looks good.

Is there anything else or should I squash it into one commit now?  

@rmculpepper Can you review?

Ok, good to squash and then I'll merge.

This looks great!

@mflatt can you review this?

Looks good to me.

These should be in racket/set because for.rkt doesn't need the dependency on a higher-level library. Additionally, the in-set sequence generator is generic and would have no benefit to loop construction by utilizing private operations in for.rkt.

My https://github.com/ianj/nifty-macros/tree/master/for-acc package supports union-based comprehensions in a more versatile way. 
Particularly, you can specify an initial value other than the empty set, and you can have multiple interacting comprehensions positionally (say, a for/set-union for the first value and a for/list for the second). If it would be acceptable, I could rewrite this extension to for/fold in a lower level to actually integrate into for.rkt.

@takikawa @shekari @stamourv what do you think?

Can you add a test? I think the tests live in https://github.com/greghendershott/racket/blob/fix-bit-vector/pkgs/data-pkgs/data-test/tests/data/bit-vector.rkt

Yes.

Also, I think I did this wrong -- checking the first word, not the last.

Sorry. I'll push another commit after I finish rebuilding from HEAD, and can add and run all the tests properly.

It would be great to have the original author(s) review this PR, because, the more I read the code, the less I understand the comment, `; TODO: check last word`.

I'm not sure why "the last word" is the first byte. More basically I'm not sure why it needs to be handled differently at all.  As best I can tell, the implementation has the invariant that the "unused" or "unreachable" bits of the last word will be zero.

In other words, I _think_ an even simpler fix is to change the `for/and` to consider _all_ the bytes:

``` racket
            (for/and ([index (in-range (- (bytes-length vx) 0 #;1))])
              (eq? (bytes-ref vx index)
                   (bytes-ref vy index)))
```

or just:

``` racket
            (for/and ([index (in-range (bytes-length vx))])
              (eq? (bytes-ref vx index)
                   (bytes-ref vy index)))
```

---

Also the comment here about 30 or 62 bits per word seems misleading (true but N/A); maybe it's leftover from an earlier design?

``` racket
; A bit vector is represented as a vector of words.
; Each word contains 30 or 62 bits depending on the size of a fixnum.
(serializable-struct bit-vector (words size)
  ; words     is the bytes of words
  ; size      is the number of bits in bitvector
  #:guard ;; needed because deserialization doesn't go through contracts
```

At this point the original author is probably rolling their eyes, because they could have fixed it in less time than it took them to read this PR discussion. :)

However. If you did want to take the PR, I'd be happy to squash it to one commit (or recommend you do so).

In any case, at least I added some tests in commit a237eac. ;)

@soegaard, can you take a look at this?

Hi Greg,

I think the original design was to use the filler in make-bit-vector. For a
bit-vector with a length not divisible by the word-size, the last bits of
the last word get their value from the filler given to make-bit-vector. It
was thus possible that they are non-zero.

As far as I can tell from the current implementation of make-bit-vector it
makes sure the last bits are zero. If no one use the the raw bit-vector
constructor, then it would be safe to not to special case the last word in
equal-proc.

About the 30/62 bit comment: Originally the word-size was 30 on 32-bit
machines and 62 on 64-bits machines - the thought was that larger words
would result in greater speed. It was changed due to a problem with
serialization. I can't remember why the word-size was changed to 8 instead
of 30.

Here is my attempt (not-tested) which assumes the word size is 8 (this
still special cases the last word).

(define (equal-proc x y recursive-equal?)
  (let ([vx (bit-vector-words x)]
        [vy (bit-vector-words y)]
        [nx (bit-vector-size x)]
        [ny (bit-vector-size y)])
    (define bits-used-in-last-word (remainder nx 256))
    (define all-bits-used-in-last-word? (zero? bits-used-in-last-word))
    (define last-index (bytes-length vx))
    (and (= nx ny)
         (for/and ([index (in-range (if all-bits-used-in-last-word?
last-index (- last-index 1)))])
           (eq? (bytes-ref vx index)
                (bytes-ref vy index)))
         ;; check last word only if the last bits aren't a full word
         (or all-bits-used-in-last-word?
             (eq? (bitwise-bit-field (bytes-ref vx last-index) 0
bits-used-in-last-word)
                  (bitwise-bit-field (bytes-ref vy last-index) 0
bits-used-in-last-word))))))

2014-08-20 15:06 GMT+02:00 Greg Hendershott notifications@github.com:

> At this point the original author is probably rolling their eyes, because
> they could have fixed it in less time than it took them to read this PR
> discussion. :)
> 
> However. If you did want to take the PR, I'd be happy to squash it to one
> commit (or recommend you do so).
> 
> In any case, at least I added some tests in commit a237eac
> https://github.com/plt/racket/commit/a237eac229f4f55433c927c6f39202be789a62ae.
> ;)
> 
> —
> Reply to this email directly or view it on GitHub
> https://github.com/plt/racket/pull/756#issuecomment-52774679.

## 

## 

Jens Axel Søgaard

I like the idea. I sometimes type in that syntax by accident.
Would it make the syntax ambiguous, though?
As for the "two ways to do it" being confusing, that annoys me slightly, but we have a precedent with the arrow syntax, and I don't think that caused any issues.

I worried about ambiguity too, but `:` by itself isn't a legal expression form.

Merged - thanks!

Thanks!

The coordinate shifting isn't quite right. For example, the optimizer crashes on

```
(lambda ()
  (car (let ([y (random)])
         (list y (set! y 5)))))
```

because `y` is more nested than expected.

I'll adjust the patch to shift coordinates in a different way: by passing `delta` wherever `info` goes.

Good point.
It looks like a 2-line change, so I'll look into it.

Fix pushed. Thanks for the report!
Turned out to be a 2±300 line change in the end.
@mordae @samth can you close the issue?

Merged.

Ups! I think I missed that in do_make_discarding_sequence the info was
shifted, but I still have to read the changes carefully to be sure that I
understand all of them.

Luckily next PR is more straightforward, so I hope it will be correct from
the start.

On Thu, Aug 21, 2014 at 12:30 PM, Matthew Flatt notifications@github.com
wrote:

> Thanks!
> 
> The coordinate shifting isn't quite right. For example, the optimizer
> crashes on
> 
> (lambda ()
>   (car (let ([y (random)])
>          (list y (set! y 5)))))
> 
> because y is more nested than expected.
> 
> I'll adjust the patch to shift coordinates in a different way: by passing
> delta wherever info goes.
> 
> —
> Reply to this email directly or view it on GitHub
> https://github.com/plt/racket/pull/753#issuecomment-52936751.

I just replaced in the lines 1825 and 1854 
    if (nested_count) {
with 
    if (nested) {
to handle correctly the possible side effects. I still can't find an example where the previous code is incorrect, but I don't want to wait until Matthew finds one.

I think that `nested_count` was ok and the pessimistic clock increments are never needed. If the optimizer gets to that point, then it's working with a rator that is already optimized, and optimizing that rator has already incremented the clock as needed.

I'm double-checking, but if I find no problems, then I'll push a variant that uses `nested_count` and removes the clock increments.

Merged - thanks!

After the changes, "nested" is unused. I just created a PR to remove it
completely.

https://github.com/plt/racket/pull/760

On Sat, Aug 23, 2014 at 12:02 PM, Matthew Flatt notifications@github.com
wrote:

> I think that nested_count was ok and the pessimistic clock increments are
> never needed. If the optimizer gets to that point, then it's working with a
> rator that is already optimized, and optimizing that rator has already
> incremented the clock as needed.
> 
> I'm double-checking, but if I find no problems, then I'll push a variant
> that uses nested_count and removes the clock increments.
> 
> —
> Reply to this email directly or view it on GitHub
> https://github.com/plt/racket/pull/759#issuecomment-53155290.

I pushed another commit.

Unfortunately this PR now has 8 commits (sorry). If you want me to squash these into one commit, please let me know.

Wow! Thanks a lot, it's much more readable this way.

merged

From a first skim, this looks great - thanks!

You should be aware that we are hoping to replace the C-implemented compiler with a Racket-implemented compiler, possibly even within the next year. I think all of your changes are helpful in the long term, because the new compiler will be informed by the current one and need to pass the test suite, but I don't want that change to be a surprise when we finally move that direction.

 I read a few times that the expansion phase was going to be replaced by a
Racket version and I suspected that the other phases were going to change
too. I'll be happy, because some ideas are very difficult to implement in C.

Merged.

@jeapostrophe If you could take a look at the first commit in particular, to make sure I didn't do anything crazy to `command`.

Clues: The output of `raco decompile` ends in the following:

```
(#%apply-values
     |_print-values:p@(lib "racket/private/modbeg.rkt")|
     (let ((local145
            (|_curry:f@(lib "racket/function.rkt")| (#%checked _foo))))
       (let ((local147 ((#%checked _bar))))
         (begin ((#%sfs-clear local145) ((#%checked _bar))) local147))))))
```

`(#%checked _bar)` is being evaluated twice: once as the argument of the curried foo in the inlined evil-func and once as the last expression in evil-func.

```
Marcs-Mac-Pro:racket m4burns$ git bisect good
a7a912eeabd2561eb3376985f86a44b677ac321b is the first bad commit
```

Thanks for the report! The bug turns out not to be in the commit where things start to go wrong, but that commit improved the optimizer in a way that exposed a problem in a much older part.

Let's merge this.

Coming back to this, here's what I think a better solution for this is.  We should allow `struct` in TR to allow a `#:lazy-contract` keyword, which is recorded in the struct type. Then we generate the appropriate `struct/c` for those structs, and then @ntoronto can do what he needs without slowing down other programs.

@mflatt fixed this in b0f4a32049661a362f8ba309715c10b633e5089e.

Sometimes having this username sucks ;)

@CodeBlock it's not haskell; must be safe to ignore? :p

This needs a little more tweaking — I'm closing this and will put up a new pull request.

@Nami-Doc :P why do you say that? I do occasionally write code in non-Haskell languages if you look at my profile. ;)

Apologies, but this won't work either, because it fouls up plain `@filebox`. IMO the problem is that `@racketmod` renders oddly: it wraps an .SCodeFlow block around the .RFilebox block, whereas the others wrap .RFilebox around .SCodeFlow (= the more logical way to do it, I think). 

Anyhow it makes a CSS patch difficult-to-hopeless.

@samth it looks great to me

Merged, thanks!

On Fri, Sep 5, 2014 at 7:14 AM, Juan Francisco Cantero Hurtado <
notifications@github.com> wrote:

> I talked with @samth https://github.com/samth in the IRC channel a week
> ago and he agreed to test the code also with the jit disabled is a good
> idea. I've added some additional test to the initial proposal. My intention
> is to enable some tests with configurations not widely tested by the users.
> 
> If I understand the racket documentation correctly, places is emulated in
> systems without support for thread local storage. Travis CI uses an OS with
> support for that, so racket always uses real threads for places. I don't
> know how to force to racket to use the "emulated behavior" on Linux. Is it
> enough to disable places with configure to force to racket to emulate
> places?.

Yes, I believe so.

Robby

> @mflatt https://github.com/mflatt Can you take a look to the options? I
> 
> ## usually break things when I play with the configure option :)
> 
> You can merge this Pull Request by running
> 
>   git pull https://github.com/juanfra684/racket travis
> 
> Or view, comment on, or merge it at:
> 
>   https://github.com/plt/racket/pull/777
> Commit Summary
> - Enable some extra tests in Travis CI.
> 
> File Changes
> - _M_ .travis.yml https://github.com/plt/racket/pull/777/files#diff-0
>   (8)
> 
> Patch Links:
> - https://github.com/plt/racket/pull/777.patch
> - https://github.com/plt/racket/pull/777.diff
> 
> —
> Reply to this email directly or view it on GitHub
> https://github.com/plt/racket/pull/777.

Sorry, I didn't see that you pushed more commits to this PR or I would've merged it earlier. I'll squash your commits and then merge this. Thanks!

Other than those issues, this is nice and should be merged. 

Thanks! Merged.

Thanks for the repairs! I'm adjusting the first one to just always use `skip-bytes`, because that seems simpler and more reliable than catching filesystem exceptions.

Merged - thanks!

Merged - thanks again!

Looks good.

Thanks. Can you also add or modify some of the code in [this test file](https://github.com/plt/racket/blob/master/pkgs/typed-racket-pkgs/typed-racket-test/tests/typed-racket/succeed/stx.rkt) to catch these bugs?

also should typed/syntax/stx provide types for `Stx-Null`, `Stx-Pairof`, and `Stx-Listof`?
And for stx-lists, should the types allow something like `(stx->list (cons #'a #'(b c)))` or `(stx->list #'(a . (b c)))`?  Because right now the `(stx->list (cons #'a #'(b c)))` doesn't type-check and `(stx->list #'(a . (b c)))` type-checks as False.  

I've been away for a while and likely won't be really active/responsive for another couple weeks., and hopefully will be able to be more thoroughly review these changes (and all of your syntax type ons) then . Please don't wait for my ok to submit them as I don't know when that will be.

I had taken a look at this problem in June or so but never got to implementing it because of lots of edge cases. One in particular is http://bugs.racket-lang.org/query/?cmd=view%20audit-trail&database=default&pr=14730

Can you document what types of values `(Syntaxof a)` represents here: 
https://github.com/plt/racket/blob/master/pkgs/typed-racket-pkgs/typed-racket-lib/typed-racket/rep/type-rep.rkt#L477

If my skiming of your changes is correct, it should be something like 't is the type of the values returned by syntax-e'.

Merged, thanks!

We should merge this

Unfortunately, this isn't sound. Imagine if you apply force to something that's a (U (Promise String) Integer). The result type won't contain String, but it should.

Ugh, yes, I see, now. :( Nothing to be done about it, I take it?

Yeah, promises are just not a great fit with types, sadly.
On Sep 19, 2014 2:12 PM, "Jay Kominek" notifications@github.com wrote:

> Ugh, yes, I see, now. :( Nothing to be done about it, I take it?
> 
> —
> Reply to this email directly or view it on GitHub
> https://github.com/plt/racket/pull/781#issuecomment-56221589.

I guess this should be okay (but I didn't write this code), but some test
cases are in order.

Robby

On Mon, Sep 22, 2014 at 4:38 PM, Spencer Florence notifications@github.com
wrote:

> typeset-code assumes that a lexeme must be eof on an eof, however
> test:color<%> allows it to be anything. instead, type should be 'eof. This
> 
> ## change makes typeset-code respect that.
> 
> You can merge this Pull Request by running
> 
>   git pull https://github.com/florence/racket manual-eof
> 
> Or view, comment on, or merge it at:
> 
>   https://github.com/plt/racket/pull/783
> Commit Summary
> - change typeset-code to conform to text:color<%>'s interface
> 
> File Changes
> - _M_ pkgs/scribble-pkgs/scribble-lib/scribble/private/manual-code.rkt
>   https://github.com/plt/racket/pull/783/files#diff-0 (2)
> 
> Patch Links:
> - https://github.com/plt/racket/pull/783.patch
> - https://github.com/plt/racket/pull/783.diff
> 
> —
> Reply to this email directly or view it on GitHub
> https://github.com/plt/racket/pull/783.

Where do the test cases for scribble/manual live? I don't see anything in scribble-test/tests that screams "scribble/manual tests go here."

I think there are some tests somewhere that use the text renderer to
compare output.

In this case, however, that might not be the best way to go, tho, since you
want to compare colors somehow.

.... in other words, I don't know. Sorry. You may be best off just starting
a new file and refactoring typeset-code so that it first computes something
that you can test as a datastructure and then renders its output from that
data structure.... at least that's how I'd start here, I think.

Robby

On Mon, Sep 22, 2014 at 4:51 PM, Spencer Florence notifications@github.com
wrote:

> Where do the test cases for scribble/manual live? I don't see anything in
> scribble-test/tests that screams "scribble/manual tests go here."
> 
> —
> Reply to this email directly or view it on GitHub
> https://github.com/plt/racket/pull/783#issuecomment-56449094.

I performed the refactor and added some tests, but I am honestly not quite sure of everything thats going on. @elibarzilay or @mflatt might want to take look, If they have time.

Looks good.

Merged with some changes. The use of contracts in pattern-expander-prob.rkt mysteriously caused problems later in the build, so I moved them out to syntax/parse. I also removed pattern-expander-proc from the exported functions.

Thanks for adding this! It will be very useful.

Great
But why not export `pattern-expander-proc`?

This is fine by me, but needs review from @rmculpepper.

It'd be great to get this checked in. As far as I can see, the original type for this function is incorrect – it has two `url` parameters when it should have only one. This makes the function unusable from typed racket at the moment. This PR (incidentally) fixes this bug.

This is now merged. Thanks!

@florence, have you seen the `typed/racket/gui` library? That should have all the types you need.

`typed/mred/mred` is outdated and should eventually just point to `typed/racket/gui`.

I was using `plot/typed/bitmap`, which for whatever reason doesn't work with `typed/racket/draw` (Which I assume is what `typed/racket/gui` is using. I would rather not instantiate `racket/gui` if I don't need to).

I was getting errors which were the equivalent of "Expected (Instance Bitmap%), but got (Instance Bitmap%)."

Ah, right `plot/typed/bitmap` isn't using that because at the moment type->contract translation isn't working on the GUI types. I guess we can merge this in the short term and fix contracts in the medium term (there's an outstanding PR for it).

Merged long ago.

Merged, thanks!

It doesn't seem necessary, and the existing precedent (eg match transformers, require transformers) is to keep the accessor private.

@samth, @takikawa: ping.

(Yes, I know that IFL is not done, but I really want to stop patching student installations...)

I pushed a fix. Thanks for the report!

I think I have a solution to this, however it does involve moving `check-duplicate` out of `unstable/list`, and moving it into `racket/list`. (Otherwise we basically need to just redefine the function in `syntax/parse/lib/function-header`.

I will add that to this pull request if you're okay with that.

+1 to moving `check-duplicate` to `racket/list`. We really need to move (some) things in `unstable` to a more permanent home.

Are you using check-duplicate to signal syntax errors?

If so, I think this is the wrong way to go, because you (presumably)
include only one of the duplicates in the resulting error message.

Robby

On Fri, Oct 3, 2014 at 2:56 PM, Vincent St-Amour notifications@github.com
wrote:

> +1 to moving check-duplicate to racket/list. We really need to move
> (some) things in unstable to a more permanent home.
> 
> —
> Reply to this email directly or view it on GitHub
> https://github.com/plt/racket/pull/785#issuecomment-57847903.

Yes, I am using `check-duplicate` to signal syntax errors. Also, afaik, it should only show one of them, for example:

```
-> (lambda (x x) 3)
; readline-input:1:11: lambda: duplicate argument name
;   at: x
;   in: (lambda (x x) 3)
; [,bt for context]
```

I am pushing the commit with a copy of check-duplicate copied from unstable/list into function-header.rkt. I'm not sure if I missed anything else.

I pushed a commit that addresses the current feedback I think. (except whether to put vectors or prefabs)

Looks good. r+

@juanfra684 I think this is too many options, since we don't want to overwhelm Travis. But a few choices seems reasonable.

@mflatt can you have a look at this?

I have not a good reason to add the tests with extflonum. I would like to keep the others. 

I think it makes sense to disable futures and places at the same time, since that disables further pieces where the configuration often goes wrong. Building without extflonums makes sense, but I think it's common enough that problems rarely go undetected.

I've combined the tests for places and extflonums. I guess that both don't interfere each other.

Merged.

BTW, I merged this already.

I think I've now addressed all of the code-level comments that I got. The rest of the comments are concerns about code complexity/the algorithm.

I also fixed the algorithm to run to a fixpoint instead of just twice. It turns out you need n iterations if you have type alias cycles of length n (I had only tested with 2 mutually recursive types earlier). This should always terminate though.

I do think this approach is awfully complicated, but I tried for a long time to make this work in the existing recursive static contracts approach. It didn't work because it was so slow/used so much memory that it was impractical. Part of the problem is that you need memoization for every step of the static contract computation.

But I think if we figure out how to do it with the standard recursive contract infrastructure, we could swap that in later without changing behavior.

This binding isn't exported by any public parts of the interface, so it isn't intended to be documented.

FWiW, I think the right way to think about this is that a channel has two
higher order behaviors and events only one. Any time you can use a type
cast to "forget" about some higher order mode of interaction, you need to
make the corresponding contract prohibit it.

That is, I don't think this is specific to channels or events. And a
prop:evt would not introduce the ability to do something like send on a
channel.

My unasked for $0.02,
Robby

On Wednesday, October 8, 2014, Asumu Takikawa notifications@github.com
wrote:

> This PR finally adds contract generation for Evtof types, which was
> delayed for a while (even though evt/c has been ready for a while).
> 
> The reason for the delay is that TR needs to be careful with the
> interaction of synchronizable events and types of values that are writable
> (e.g., channels). The problem is that the latter have invariant subtyping
> while the former has covariant subtyping.
> 
> This mismatch lets you break the type system if you upcast a value of type (Channelof
> String) to an (Evtof (U String #f)) and export it to untyped code. TR's
> read end for original channel is unprotected (and should return String)
> but the untyped code can write a #f to the channel.
> 
> The solution is to make TR's version of event contracts seal off the
> writing end of channels (those are the only problematic kind of event that
> I know of) when they are exported with an event type.
> 
> Another solution would be to have TR use invariant subtyping on event
> types. This seemed worse to me because it'd be unintuitive that a read-only
> type has invariant subtyping.
> 
> If we add support for prop:evt, we will need to be careful about that
> too. Though I suspect it may be fine because if TR imports a prop:evt
> struct with an Evtof type, TR always has a protected read end of the
> event even if it re-exports it elsewhere. If TR itself is defining the
> struct with prop:evt, then it should still be safe because TR will
> 
> ## protect the struct mutators.
> 
> You can merge this Pull Request by running
> 
>   git pull https://github.com/takikawa/racket tr-evt-c
> 
> Or view, comment on, or merge it at:
> 
>   https://github.com/plt/racket/pull/790
> Commit Summary
> - Add contract generation for Evtof types
> 
> File Changes
> - _M_
>   pkgs/typed-racket-pkgs/typed-racket-lib/typed-racket/private/type-contract.rkt
>   https://github.com/plt/racket/pull/790/files#diff-0 (2)
> - _M_
>   pkgs/typed-racket-pkgs/typed-racket-lib/typed-racket/static-contracts/combinators/structural.rkt
>   https://github.com/plt/racket/pull/790/files#diff-1 (6)
> - _M_
>   pkgs/typed-racket-pkgs/typed-racket-lib/typed-racket/typed-racket.rkt
>   https://github.com/plt/racket/pull/790/files#diff-2 (4)
> - _A_
>   pkgs/typed-racket-pkgs/typed-racket-lib/typed-racket/utils/evt-contract.rkt
>   https://github.com/plt/racket/pull/790/files#diff-3 (61)
> - _M_
>   pkgs/typed-racket-pkgs/typed-racket-test/tests/typed-racket/unit-tests/contract-tests.rkt
>   https://github.com/plt/racket/pull/790/files#diff-4 (29)
> 
> Patch Links:
> - https://github.com/plt/racket/pull/790.patch
> - https://github.com/plt/racket/pull/790.diff
> 
> —
> Reply to this email directly or view it on GitHub
> https://github.com/plt/racket/pull/790.

Your 2 cents are always asked for, Robby. :)

Ha! Just don't ask for $1. I am not a rich man!

Robby

On Wed, Oct 8, 2014 at 8:14 AM, Sam Tobin-Hochstadt <
notifications@github.com> wrote:

> Your 2 cents are always asked for, Robby. :)
> 
> —
> Reply to this email directly or view it on GitHub
> https://github.com/plt/racket/pull/790#issuecomment-58355007.

Good catch! I'll push a fix.
You (or anyone) can close this issue.

We can do this and it is a good thing.

Unfortunately it is more difficult since github URLs were changed. (Originally we used "github://" because the pkg manager doesn't really speak the "git" protocol but uses the github API and HTTP interface. This method would have worked with Github enterprise installations too.) Now, it looks at "git://" URLs and if the domain is "github.com" then it can behave specially. This is really bogus because it isn't using the "git://" protocol.

Gitorious has a different API and way of getting archives (gitorious.org/projectname/repositoryname/archive-tarball/checksum rather than github.com/user/repo/tarbal/checksum), so it would have been natural to add "gitorious://" and support all the various installations of Gitorious out there. And again, this would be more "honest" because we wouldn't use the "git://" protocol but the API of a particular Web site.

It would be easy to add special handling for "git://gitorious.org" but that would be bogus and wouldn't support other gitorious hosts.

So, unless we actually implement "git://" (which is very hard), then we really need to revert the bogus hack of "git://github.com" URLs before we support other ways of getting package contents from git-like services.

I don't understand why "gitorious://" can't coexist with "git://" in the same way that "github://" currently does.

I'm also not convinced that supporting the "git://" protocol is inherently difficult. Using "libgit2" looks to me like an attractive option compared to adding more URI schemes. (After skimming the protocol and pack-format specs, it's tempting to try to implement it directly in Racket.)

Can't we send a couple http requests to determine if something supports
gitorious, or the GitHub protocol, etc?

Sam

I think we should remove the git:// scheme and have gitorious://

The problem with the git protocol is that we don't want a full WC but just a particular checkout. Further most servers (ie github, gitorious, etc) don't support the archive option that could do this. 

Jay

Sent from my iPhone

> On Oct 12, 2014, at 8:51 AM, Matthew Flatt notifications@github.com wrote:
> 
> I don't understand why "gitorious://" can't coexist with "git://" in the same way that "github://" currently does.
> 
> I'm also not convinced that supporting the "git://" protocol is inherently difficult. Using "libgit2" looks to me like an attractive option compared to adding more URI schemes. (After skimming the protocol and pack-format specs, it's tempting to try to implement it directly in Racket.)
> 
> \
> Reply to this email directly or view it on GitHub.

This is gross to me and could be bad when a server supports both through being a enterprise github and gitorious installation. I think we should use the url scheme for what it is for: specifying the protocol we will use for communication. 

Jay

Sent from my iPhone

> On Oct 12, 2014, at 8:57 AM, Sam Tobin-Hochstadt notifications@github.com wrote:
> 
> Can't we send a couple http requests to determine if something supports
> gitorious, or the GitHub protocol, etc?
> 
> Sam
> \
> Reply to this email directly or view it on GitHub.

(delta=delt)

On Sun, Oct 12, 2014 at 9:01 AM, Robby Findler robby@eecs.northwestern.edu
wrote:

> On Sun, Oct 12, 2014 at 8:54 AM, Jay McCarthy notifications@github.com
> wrote:
> 
> > I think we should remove the git:// scheme and have gitorious://
> > 
> > I also don't understand why you impose an ordering on these two seemingly
> > unrelated changes.
> 
> (I am happy to agree with you that if we don't actually support what one
> might expect with a "git://" pkg source then we shouldn't use that
> notation, but it sounds like we could support it, so why not put it on the
> list and skip the backwards incompatible step of entirely disabling
> "git://" sources?)
> 
> > The problem with the git protocol is that we don't want a full WC but
> > just a particular checkout. Further most servers (ie github, gitorious,
> > etc) don't support the archive option that could do this.
> > 
> > Surely this is a technical detail that can be delta with by a "small
> > matter of programming"?  :)
> > 
> > Jay
> > 
> > Sent from my iPhone
> > 
> > > On Oct 12, 2014, at 8:51 AM, Matthew Flatt notifications@github.com
> > > wrote:
> > > 
> > > I don't understand why "gitorious://" can't coexist with "git://" in
> > > the same way that "github://" currently does.
> > > 
> > > I'm also not convinced that supporting the "git://" protocol is
> > > inherently difficult. Using "libgit2" looks to me like an attractive option
> > > compared to adding more URI schemes. (After skimming the protocol and
> > > pack-format specs, it's tempting to try to implement it directly in
> > > Racket.)
> > > 
> > > \
> > > Reply to this email directly or view it on GitHub.
> > 
> > —
> > Reply to this email directly or view it on GitHub
> > https://github.com/plt/racket/issues/794#issuecomment-58799803.

The URL scheme that we're actually talking about using in all of these
cases is http. We shouldn't make up our own URL schemes -- it's confusing
to users, boxes us in to temporary choices, and goes against the
specification for URLs.

I don't see why negotiating the protocol we want to use over http or git or
whatever is gross -- it's quite common in networking.

Jay, I am not opposed to adding "gitorious://" (granting that others do feel strongly about introducing schemes), but I don't see the argument for removing "git://".

If we support the actual "git://" protocol, it would be nice if "git-upload-archive" was more widely supported. Still, I don't think that pulling down a whole repo is likely to be a problem in practice --- no more of a problem than pulling down a whole archive when only a subdirectory is wanted. In cases where "git-upload-archive" is supported, then it seems we get exactly what we want: just the files for a particular commit and particular subdirectory. When 'git-upload-archive" is not supported, then using the basic "git://" protocol means that the package system support more sources. We could continue to specialize handling for known Git providers like "github.com", or not.

Sam: I'm not enthusiastic about the HTTP-probing approach, either. It avoids introducing a new URL scheme, but it creates a kind of undeclared language (the opposite direction of `#lang`?). My sense is that it could work ok for do-what-I-mean tools, but it feels wrong to embed it into layers that are meant to be driven programmatically.

[Just for reference, the previous discussion on this topic is in PR 13656.]

My problem with git:// is that we aren't using the git protocol at all. I'm also opposed to http:// as Sam suggests because we aren't using HTTP as an application protocol, but as a transport protocol. We are relying on the details and meaning of the URLs then we use HTTP to send those protocol messages. We ARE speaking the "github" protocol and propose using the "gitorious" protocol.

I totally agree with everything you say Matthew about how it is possible to use git directly and that it is merely more expensive like getting a whole tarball for one subdirectory. The main difference is that I believe that basically no one does or will use the subdirectory option of tarballs and even if they did, the extra content is small relative to the entire history of the project just for the current state. I think that if we supported git:// and did cloning, it would be an unanticipated performance and space hog that would bit us in the end.

<3 always.

2014-10-12 14:51 GMT+02:00 Matthew Flatt notifications@github.com:

> (After skimming the protocol and pack-format specs, it's tempting to try
> to implement it directly in Racket.)
> 
> This excellent blog post describes how to implement "git clone" in Haskell.

http://stefan.saasen.me/articles/git-clone-in-haskell-from-the-bottom-up/

/Jens Axel

@mflatt, my feeling is that we want the user experience of specifying package source to be as simple as possible. So you just write `git://...` and Racket figures out how to contact the server and download the relevant data. As we gradually support more ways of contacting servers, we can just make more things work.

The alternative is that users need to know the details of how their git repositories are hosted, in order to specify them as package sources. That seems like an unnecessary detail to make users worry about. 

@jeapostrophe That we're using http as the transport protocol isn't the point -- that's the URL and the fact that we might like URLs to have information about what services they support doesn't mean they do, and it doesn't mean that we should just start making things up that no one else supports.  If we want to follow http://tools.ietf.org/html/rfc2717 and register these schemes, than that's fine -- otherwise, we should just stick with real URLs and not make things up. 

Also, I don't really understand the worry about space. Presumably, just like with zip files or directories (in non-`--link` mode), we'd copy the clone and then remove it. Even if the repository is large the space usage would go away immediately. I just looked at a repository I have locally, and the `.git` directory is 2.5 MB out of 12 MB for the whole checkout. So even if we have to clone the whole thing, the extra space isn't that much.

There's also this implementation of most of git in JS: https://github.com/creationix/js-git

This captures my opinions too. FWIW.

Robby

On Sunday, October 12, 2014, Matthew Flatt notifications@github.com wrote:

> Jay, I am not opposed to adding "gitorious://" (granting that others do
> feel strongly about introducing schemes), but I don't see the argument for
> removing "git://".
> 
> If we support the actual "git://" protocol, it would be nice if
> "git-upload-archive" was more widely supported. Still, I don't think that
> pulling down a whole repo is likely to be a problem in practice --- no more
> of a problem than pulling down a whole archive when only a subdirectory is
> wanted. In cases where "git-upload-archive" is supported, then it seems we
> get exactly what we want: just the files for a particular commit and
> particular subdirectory. When 'git-upload-archive" is not supported, then
> using the basic "git://" protocol means that the package system support
> more sources. We could continue to specialize handling for known Git
> providers like "github.com", or not.
> 
> Sam: I'm not enthusiastic about the HTTP-probing approach, either. It
> avoids introducing a new URL scheme, but it creates a kind of undeclared
> language (the opposite direction of #lang?). My sense is that it could
> work ok for do-what-I-mean tools, but it feels wrong to embed it into
> layers that are meant to be driven programmatically.
> 
> [Just for reference, the previous discussion on this topic is in PR 13656.]
> 
> —
> Reply to this email directly or view it on GitHub
> https://github.com/plt/racket/issues/794#issuecomment-58806012.

I've implemented enough of the "git://" protocol client to extract a checkout, so I'm now even more convinced that it will be practical.

Jay's point about the larger download mostly stands, but maybe not in a common case. It turns out that a kind of history pruning is built into the git protocol as reflected in the `--depth` option of `git clone`. Using `--depth 1` downloads about the same amount of data as downloading an archive from GitHub. The main limitation is that pruning is available only for commits that correspond to branches or tags. Also, "git.racket-lang.org" doesn't work with it (even though the server advertises support); I'm not sure how widespread the server problem is, and my client just retires without a depth if supplying a depth fails.

Selecting an arbitrary commit (one that doesn't match a branch or tag) requires downloading the entire repo --- without limiting the commit depth, obviously. As an extreme example, downloading the entire Racket repo takes 5.5 minutes (compared to 1.5 minutes for `git clone`). Since that's at least tractable performance for an extreme example, I don't think it's likely to create lurking performance bugs. Tagging a particular commit can always avoid the problem (i.e., if you ask for a particular commit, my client detects that it matches a tag and doesn't download the entire repository).

Meanwhile, a justification for accessing "git://github.com/..." via GitHub's HTTP protocol is that the "git://" URL identifies a resource, and GitHub's HTTP API can access that same resource. I'm pretty sure that, technically, a URL provides a _primary_ means for accessing a resource, but as a URI it identifies a resource that is conceivably obtained through other means. With that rationale, I'm inclined to leave the specialization of "git://github.com/" in place even if we generalize `raco pkg` to support "git://" generally.

Merged, thanks!

This has been merged now.

Thanks! Merged now.

Thanks for including it too!

Merged, thanks!

By the way, in the future, it would be best if your pull requests only include the commits you'd like to merge in. It took me a bit to realize that the first commit here was already merged some time ago.

I've abandoned this approach since I think it's unworkable and requires way too much code complexity so I'm closing this PR.

Inspired in part by one of @shekari's comments on this PR, I have a new approach that seems to work much better so far that I'll push once I test it more (and assuming those tests check out).

Thanks. This is now fixed as of commit 2bad36a6a1a7068f1601a21db4f553777aad7b67.

Merged --- thanks!

Merged - thanks!

Merged - thanks!

Merged - thanks!

I think it makes sense for the test of an internal function to be inside the `test` submodule, so I've made that change and squashed the commits. I'll push in a while.

Thanks!

Is there anything else needed before this can get merged?

@soegaard What's the status here? Should this be merged?

Yes.

2014-10-23 17:10 GMT+02:00 Sam Tobin-Hochstadt notifications@github.com:

> @soegaard https://github.com/soegaard What's the status here? Should
> this be merged?
> 
> —
> Reply to this email directly or view it on GitHub
> https://github.com/plt/racket/pull/756#issuecomment-60253862.

## 

## 

Jens Axel Søgaard

@greghendershott Can you rebase/squash this?

Yes, definitely. But not until later this evening or perhaps even
tomorrow. I'm blocked on other stuff until then. (Also I'm behind on
fetching Racket HEAD, so rebase/squash + build + test will take me a
little longer than usual.)

Around [line 189](https://github.com/plt/racket/blob/master/pkgs/scribble-pkgs/scribble-text-lib/scribble/text/output.rkt#L189) is `(set! write (or (car c) write-string))`, which probably also needs to be updated for a complete fix, as it seems to assume stringness. I did not edit it, however, because I did not have a test case that made me sure about what that line does.

This bug has been fixed in the pre-release. Please see http://pre.racket-lang.org/ for a build that runs in Yosemite. Our next release will include the fix.

Great! Thanks.

~Thomas

On Thu, Oct 23, 2014 at 5:42 PM, Robby Findler notifications@github.com
wrote:

> This bug has been fixed in the pre-release. Please see
> http://pre.racket-lang.org/ for a build that runs in Yosemite. Our next
> release will include the fix.
> 
> —
> Reply to this email directly or view it on GitHub
> https://github.com/plt/racket/issues/804#issuecomment-60314094.

I think the current documentation on `output`, which claims conversion to a string "along the same lines as `display`", probably doesn't make sense in the case of byte strings.

More generally, my sense is that the `output` function is deeply string-oriented --- unlike ports, which are deeply byte-oriented. I vaguely remember arriving at that conclusion after trying to make `output` more port-like myself.

The `with-writer` construct is an example, if I recall correctly, in that it expects a string and so everything (including byte strings) must be coerced to a string. And if I remember correctly, it's not the only obstacle.

I'll have to look more closely, though.

BTW, my use case: I use `include-template` (from web-server/templates) to generate output from Pollen source files, and I’m extending it to handle PDF files, like so:

``` racket
(let ([doc (output-from-pollen-source-file)])
    (include-template "pdf-renderer-that-takes-doc-and-returns-bytes.rkt"))
```

The [current `include-template` function](https://github.com/plt/racket/blob/2881b605361afacd98755c746ac2ac250e49b965/pkgs/web-server-pkgs/web-server-lib/web-server/templates.rkt) relies on `output` and `with-output-to-string`. When it gets bytes, they get sent through `output`, which gags.

For now, I’ve [made a version](https://github.com/mbutterick/pollen/blob/master/include-template.rkt) of `include-template` that handles bytes correctly. If a fix is indicated, that would be another way to go about it.

Merged.

[Sorry for the long reply, but I thought that it's best in case you (Matthew B.) hacks this code.]

@mflatt: yes, I think that it's a bad way to describe it, probably better to say that they're converted to strings using the obvious `->string` functions (except for chars that have a different function), and maybe a comment that for bytes the utf-8 function is used.  (BTW, another minor problem in that paragraph is that it claims to do the output with `display`, which is technically wrong.)

In general this patch is probably broken exactly because of of that issue with the writer.  On one hand, it makes sense to have filter writers that specify whether they deal with strings or bytes (or maybe have them deal with both), but OTOH, it piles up more stuff on something that is a bad hack to begin with.  (I think that originally I didn't document it, hoping that it doesn't need to be exposed before there's something better.)

As a general reminder, there were two motivations for the writer thing: (a) quote the usual HTML characters that need to be quoted, but only in a context that requires that quoting (eg, the `literal` thing creates a non-quoting context); (b) be able to extend this to address minor kinds of syntactical extensions to text, like `---` to mdash, or `\;` to `;` (useful to avoid confusion of non-scribble-aware editors of a text `;` as a comment).

Just these two uses mean that not only is there a need to massage text in this way, but there's also a need to combine them.  It would most likely be much better if this functionality exists with ports, so the writer stays the same, and instead the output port is replaced (temporarily) with a port that does the tweaking.  But at least at the time that I wrote that code, there was nothing that was practical: doing such random text substitutions at the port level was something that IIRC was either relatively easy but too expensive for frequent switching of filters (eg, a helper thread + pipe combo), or they could be done efficiently but suffering the overwhelming complexity of creating new custom ports.

In any case, the only other thing I can think of that makes `output` string-ish is keeping track of column numbers.  (But I'm not sure.)

@samth Rebased/squashed. Force pushed. Tests passed locally. Waiting for Travis CI builds...

@samth Although Travis Build 3059.4 didn't get scheduled for a long time, it's finally run to completion. 4 green builds. Should be good to merge.

@takikawa: I think I don't understand the change. It looks like you've removed the parameterization of `current-logger`, so that `accomplice-logger` would never receive a message from an accomplice. (Am I misreading the commit? Or misremembering how this works?)

@mflatt Ah, I think you're right. This PR code was bogus.

I think what I actually wanted to do was to change line 336 to `(make-log-receiver accomplice-logger 'info 'cm-accomplice)` (specifying a name) instead. But I'm not sure this alone accomplishes what I'm trying to do.

To clarify, I'm trying to use `log-level?` to see if DrRacket is listening to `'online-check-syntax` log messages. But it seems like `log-level?` doesn't actually factor in the logger name. Is that the case?

If it doesn't factor the name in, would it be possible to add a primitive that lets us check for a receiver not just by log level but also by name?

@takikawa: Although `log-level?` does take names into account, the problem is that `accomplice-logger` has to forward all messages, and so all names and levels count while `accomplice-logger` is in place. There's currently no way to set up a receiver that receives (and forwards) only messages for which another logger has receivers.

I think I understand your problem, and it's one I've considered before, but I don't have a solution so far. When I ran into this before, I just decided to put up with `log-level?` always returning `#t`, because it seemed like only a minor efficiency question (i.e., whether messages that are ultimately ignored are generated and forwarded).

Asumu is looking for a way to avoid pretty-printing types and putting them
into the expansion of TR when DrRacket isn't around to put them into
tooltips. DrRacket could set some parameter in some well-known module, but
that raises the question of which library it belongs in and whether or not
we want to make the TR pkg depend on a drracket one.

@tonyg You might be interested in this discussion.

Merged - thanks!

Correction: `log-level?` doesn't take names into account. We could add
an extra argument to enable testing for level + name combinations.

---

I see that the last time I thought about this kind of problem, I added
a notify-callback argument to `make-logger`. Apparently, the callback
didn't solve whatever problem I was working on, because I find no uses
of it anywhere except the test suite. In fact, I think it's a bad idea
and I'd like to remove it, despite breaking backward compatibility; I
often use `log-error` in constrained environments where I expect that
logging is one of the few things that is safe, and having an arbitrary
callback invoked by `log-error` breaks that assumption.

---

Let's go back to the original problem for CM: the current logger is
used as a channel to communicate from accomplices to CM --- and in
particular, it's a channel that can cross phases. The reason to filter
logged messages (which implies that the new logger can't just declare
the current logger as a parent, as things stand) is that compilation
contexts are dynamically nested, and messages from an inner context
should not be considered by an outer context.

Possibly, the use of logging to receive information should be detangled
from the use of "current logger" to delimit a compilation context. I
think that a separate continuation mark would work, in the current
implementation, but it feels wrong to me that continuation marks can
span phases. There are various holes in the barrier between phases, but
I'd prefer to not rely on them so directly.

Another approach is to stick with the idea of a logger as communication
context --- and one that can cross phases as long as values in logged
messages are serializable --- but add a built-in filtering mechanism.
The `make-logger` function would accept both a parent logger and a
specification of which events are passed on to the parent in terms of
levels and names. It may even make sense to allow multiple parents of a
logger, each with a different filter, although I have no immediate use
for that. The point of building in the filtering specification, instead
of allowing arbitrary filter functions, is to keep `log-level?`
reasonably efficient and avoid hooks for untrusted code.

I'm leaning toward the latter solution. Any thoughts?

I like the latter one too. (Not that I feel especially confident about my qualifications for this design decision, but it feels right to me.)

Re allowing `log-level?` to test level + name: Sounds good.

Re notify-callback: Also sounds good.

Re logging as a cross-phase communication system: +10. At this point, I'd guess that most uses of the logging system are for that (e.g. optimization coach, check syntax) and not for what we'd think of as logging.

I'm not sure I like the latter solution. It sounds like the problem we're facing is that programs are trying to have two conversations at once (one about TR tooltips, and one about compilation events), and that we have a single channel (`current-logger`) that both must go through. I think a clean solution would be to instead have multiple channels, which we could do via multiple parameters, e.g. `current-logger`, `current-cm-logger`, `current-check-syntax-logger`, etc.

In general, it sounds like this would move the logging system closer to a pub/sub system, so I'm really interested in @tonyg's opinion here.

I generally like what Vincent writes, but don't think that there should be multiple parameters. IMO, there should be a single parameter that controls how pub/sub works (so DrRacket can shut off control easily and have a "separate world") and the pub/sub mechanism should not explicitly expect clients to work with parameters.

@stamourv The problem with lots of parameters is that each of those is a first-class thing, and each would have to be treated specially for cross-phase communication. I think the "name" part of a logged message has been evolving into the extra dimension.

@takikawa  and I were just talking about the general topic.

At this point, it looks like we have a number of features that can serve as communication mechanisms (logging, continuation marks/parameters, syntax properties, channels, etc.), but no clear applicability criteria for each of them. For example, let's say we have a communication pattern where we need cross-phase communication, but where the parties can't share a first-class communication channel (i.e. they need to use some ambient mode of communication, like logging with the same symbol as topic, or continuation marks with the same symbol as key), then what mechanism should we use?

We may want to think about this more general problem (what mechanism to use for which communication patterns), then evolve our current mechanisms to fit these use cases, instead of trying to shoehorn evolving communication patterns into whichever mechanism was already in use for that use case. By considering general communication patterns, I think we can end up with a more orthogonal set of communication mechanisms.

I'm not sure this is 100% clear. Does this make any sense?

@stamourv Can you distinguish what you have in mind what what we are doing now (or, at least, what I think I'm doing know): trying to solve a cross-phase communication problem for CM, approaching loggers as seemingly the right mechanism among the current choices, and trying to evolve the logger mechanism?

+1 to Matthew's perspective on the problem. Lets not over-generalize. 

(Oh, but that said we should get it right, so thinking about pub/sub and talking with an expert a little bit seems wise.)

I thought I was agreeing with Vincent, but trying to understand some difference that he has in mind.

Even better.

@mflatt: As far as the original problem is concerned, yes it sounds like loggers are the right mechanism, and we should evolve them to cover this new communication pattern. So we're in agreement. I'm just concerned that we may end up with convergent evolution of our various communication mechanisms if we just evolve them on a case-by-case basis.

My previous comment was pointing to a more general thing: that we have a number of communication mechanisms that have overlapping, but not clearly defined sets of supported/recommended communication patterns. I think we may want to think about how they (should) relate to each other. In turn, that can inform how they're documented, or how we evolve them in the future. It's orthogonal, but related, to the original problem

Alternatively, would it make more sense to define an `identifier-hash-code`, and then define identifier sets using `make-custom-set-types` (and identifier tables with `make-custom-hash-types`)?

This would eliminate some code duplication, since I mostly borrowed the implementation here from hash sets.

FWIW, @tonyg has started looking into the problem and has a solution in mind. He is planning to post it to dev soon.

Sorry to interject into this conversation, having just come from an in-depth study of Common Lisp, this discussion of communication mechanisms, generalizing patterns from cases, and pub/subs reminded me of CL's condition system and communication protocols that can be built on top of it.

So thought I'd mention the similarity to conditions that is coming through to me. Perhaps there are historical study cases from CL that may be useful.

Alexander McLin

> On Oct 28, 2014, at 1:42 PM, Vincent St-Amour notifications@github.com wrote:
> 
> @mflatt: As far as the original problem is concerned, yes it sounds like loggers are the right mechanism, and we should evolve them to cover this new communication pattern. So we're in agreement. I'm just concerned that we may end up with convergent evolution of our various communication mechanisms if we just evolve them on a case-by-case basis.
> 
> My previous comment was pointing to a more general thing: that we have a number of communication mechanisms that have overlapping, but not clearly defined sets of supported/recommended communication patterns. I think we may want to think about how they (should) relate to each other. In turn, that can inform how they're documented, or how we evolve them in the future. It's orthogonal, but related, to the original problem
> 
> —
> Reply to this email directly or view it on GitHub.

Merged. Thanks.

@mflatt or @elibarzilay Are either of you the people to talk to about this?

I'll take a closer look sometime soon, but here are some initial observations/questions:
- The scheme_get_process_group_milliseconds() function calls itself for Windows. To produce a good answer, I imagine that Racket is going to have to record children times when it receives a notification that a child process has terminated.
- I'm don't think the Unix implementation actually involves with a process group, which is a specific concept in Unix. As far as I can tell, times() or getrusage() reports on the process plus its terminated children, which are not necessarily in the same group. Does the process group matter? Do the reported times include children's children?

> The scheme_get_process_group_milliseconds() function calls itself for Windows.

Ah, woops. That was supposed to call get_process_milliseconds(). I wasn't sure if GetProcessTime() tracked child processes or not.

> I'm don't think the Unix implementation actually involves with a process group, which is a specific concept in Unix.

Yes, I guess process-group is a bad name, I'm not really sure what would be a good replacement though. But the goal is to get the current run time of your process, plus all of it's transitive decedents.

> Does the process group matter?

Not really, thus the name was a poor choice. The goal is to be able to get the run time of a process that forks.

> Do the reported times include children's children?

I think so, from the getrusage man page:

```
These statistics will include the resources used by grand‐
children, and further removed descendants, if all of the intervening descendants  waited
on their terminated children.
```

It seems okay to me, altho I can't really say I see all the implications.

Robby

I renamed current-process-group-milliseconds to current-process+children-milliseconds. I'm not sure of a better name though.

If GetProcessTime() doesn't return time spent in child processes I'm still not sure how to deal with that.

The `current-process-milliseconds` function accepts either a Racket thread (to report time for that thread) or #f (reports time for all Racket threads and places in the process). Instead of adding a new function, we could add support for a 'children argument (similar to getrusage). Does that sound ok?

For Windows, I still think that Racket will have to record children times when it receives a notification that a child process has terminated, and I'll look into that.

On second thought, using `'subprocesses` (instead of `'children`) would bemore consistent with existing terminology.

I like the idea of using the current-process-milliseconds, and I'm also good with using `'subprocesses` rather than children.

@shekari 
- I'm not sure about `send/report`, either.
- To avoid a name (now "topic") prefix on a message when relaying to another logger, pass #f as the last argument to `log-message` when re-sending.
- Your `drain` function looks like the way to ensure that logged messages are received, but maybe that's not what you mean for ensuring that messages are received?
- I don't know what other tools might want, either.

So the logger issue is this

```
(define logger ...)
(define log-rec (make-log-reciever ...))
(sync
  (thread
    (lambda () ...))) ;; This thread may do some logging
(sync/timeout 0 log-rec)
```

When does a log reciever become ready? Could there be a gap where the machinery implementing the logging system has not forwarded the log to the reciever by the time I try and sync? 

Yes, of course. You don't know if the thread has even done any work yet, by
the time that you do the sync/timeout.

Robby

On Sat, Nov 1, 2014 at 7:22 PM, Eric Dobson notifications@github.com
wrote:

> So the logger issue is this
> 
> (define logger ...)
> (define log-rec (make-log-reciever ...))
> (sync
>   (thread
>     (lambda () ...))) ;; This thread may do some logging
> (sync/timeout 0 log-rec)
> 
> When does a log reciever become ready? Could there be a gap where the
> machinery implementing the logging system has not forwarded the log to the
> reciever by the time I try and sync?
> 
> —
> Reply to this email directly or view it on GitHub
> https://github.com/plt/racket/pull/813#issuecomment-61389104.

@robby There's a sync on the thread, so it waits until it's terminated before the call to sync/timeout. But there could still be a buffering issue.

@shekari what happens if you sleep very briefly there, or give a small nonzero timeout?

Oh, I see.

No, you still cannot rely on that.

Robby

On Sat, Nov 1, 2014 at 8:42 PM, Sam Tobin-Hochstadt <
notifications@github.com> wrote:

> @robby https://github.com/robby There's a sync on the thread, so it
> waits until it's terminated before the call to sync/timeout. But there
> could still be a buffering issue.
> 
> @shekari https://github.com/shekari what happens if you sleep very
> briefly there, or give a small nonzero timeout?
> 
> —
> Reply to this email directly or view it on GitHub
> https://github.com/plt/racket/pull/813#issuecomment-61390916.

Right, so is there anything I can rely on? I don't think there is (other than inserting a fake log message), and thus I think we need to reexamine what we are using loggers for, as they don't seem to make it easy to do this sort of thing.

@shekari When `log-message` returns, then any receiver for that event is immediately ready. There's no gap. So, in your example, `log-rec` is definitely ready if there was any logged message.

Sorry: I thought this was the same as writing to a port!

On Sat, Nov 1, 2014 at 11:51 PM, Matthew Flatt notifications@github.com
wrote:

> @shekari https://github.com/shekari When log-message returns, then any
> receiver for that event is immediately ready. There's no gap. So, in your
> example, log-rec is definitely ready if there was any logged message.
> 
> —
> Reply to this email directly or view it on GitHub
> https://github.com/plt/racket/pull/813#issuecomment-61394379.

@shekari @mflatt I hope you won't mind indulging me? I looked at the diff but I don't have enough context to get it: why would you need such a guarantee?

The goal is to perform task T in a thread, and then process all the messages that T logged --- to draw a picture of how file compilations proceed or how futures perform, for example, based on logged messages. So, the problem is to know whether there are any more messages from T given that T has finished; polling the receiver should do that reliably.

It doesn't seem like the logging system has to provide any guarantees to make that programmable. In particular, there could be a "I'm done" message in the protocol. 

I'm curious because of an offhand comment that John Reppy made ages ago where he seemed to regret the two-way syncronous rendez-vous that he put into CML. So when something comes up that seems to use that kind of a guarantee, then I wonder if it is really necessary or if there is some other, more relaxed guarantee that the system can provide that would still allow the desired functionality at the higher level.

I don't actually mean to be questioning other things or suggesting changes, blah blah blah etc.

Merged.

Addressed by commit babd420293 and related to add general "git://" support to the package manager.

I've finally pushed a repair (commit c7688818fa). Thanks for the report!

Hopefully fixed by commit cdce9541

You make a good point, but our current choices are intentional. We inherited "procedure application" from Scheme and its standards (which uses "procedure" because Scheme procedures might have side effects). Meanwhile, "function call" is by far the most common phrase among programmers. We've been moving more toward the common programming phrase.

The current development version builds for me with MinGW gcc 4.8.1. A recent upgrade of libffi may have fixed compilation problems with memcpy(), and I've also made other adjustments to repair linking.

merged

I don't think a comma is right, but I can see a semi-colon, so I made that change.

Would the utilities in `unstable/logging` help? From a quick read of this thread, it sounds like you're having issues similar to those I had when implementing OC, which led to writing `unstable/logging`.

@stamourv That won't work because of two reasons. First unstable-logging is in typed-racket-pkgs, so it cannot be used by core, secondly compiler/cm uses the logger from module initialization time not the logger from the call site while unstable/logging wraps the logger at the call site. If both of these were changed then yes they look like they would be helpful.

@rfindler The issue is, that the part of the system that is handling the logged events is just a relay (from the worker place to the parent place). And it would be nice to have that work without understanding the meaning of the logged messages, which means the stop signal needs to be out of band. And it seems very tricky/impossible to do that with only asynchronous messages with buffering between sending and arriving in the recivers queue.

@mflatt Changed the names of some identifiers and added a few comments. Are there any other blockers to getting this in?

@shekari Here are a few recommendations, but only the first one is something that I think really should be done before merging:
- Use a prefab struct instead of a list for the data in a message. It might seem that the topic `'compiler/cm` or '`setup/parallel-build` is enough to specify the shape of the data, but I've learned that it's better to be able to extend the set of messages within a topic. Then, human-readable information for (current and future extensions) can be selected with a single topic name, while programmatic handling of messages can ignore unrecognized data.
- The `(log-level? cm-logger 'info)` in "cm.rkt" could be `(log-level? cm-logger 'info 'compiler/cm)` --- using the new support for topic queries in `log-level?`.
- The message-pump thread could be started only if `(log-event? (current-logger) 'info 'setup/parallel-build)` in the original place. I guess that few enough messages are triggered that it's unlikely to matter, though.
- The newly logged messages (level, topic, and data shapes) should be documented.

Merged - thanks!

Addressed comments. First 3 bullet points were easy, my documentation/scribble skills on the other hand need much more practice. Is there any standard style for how logged structures should be documented?

Also should I put a warning on the logged events that they are subject to change as I figure out what works well/doesn't?

I don't think we have a standard style, yet. You could see "Future Performance Logging" and "Garbage Collection" in the Reference for other examples, but your documentation looks ok to me. I'd probably use `racketblock` and include `#:prefab` for the structure-type declaration, but that's about it. I wouldn't include warning that the logged events are subject to change.

Merged.

Ugh, messed up the history editing. Will try again with a fresh pull request.

Ok added racket blocks, and tried to switch a bit of the wording to a similar style.

This looks good to me, so please merge (or let me know if you'd prefer that I do it)

I can't find any existing tests, either. :(  Using rackunit in the "racket-test" package is fine.

If you haven't already been talking to Neil Van Dyke about this, I'd encourage you to ping him. Neil has a tool for starting PLaneT packages, but I don't know how much he has considered adapting it to the new package system.

Unless you have a specific reason to include the full text of "COPYING" and "COPYING.LESSER", I suggest including them by reference; see also http://lists.racket-lang.org/dev/archive/2014-February/013960.html

Is there a reason not to use `@` notation in "new.rkt" (by making the module start `#lang at-exp racket/base`)?

> If you haven't already been talking to Neil Van Dyke about this, I'd encourage you to ping him. Neil has a tool for starting PLaneT packages, but I don't know how much he has considered adapting it to the new package system.

Good idea

> Unless you have a specific reason to include the full text of "COPYING" and "COPYING.LESSER", I suggest including them by reference; see also http://lists.racket-lang.org/dev/archive/2014-February/013960.html

Also good idea, done.

> Is there a reason not to use `@` notation in "new.rkt" (by making the module start `#lang at-exp racket/base`)?

I would love to do that (hence the comment wishing for at-expressions here). However I 'think' at-expressions are lower on the dependance chain, because whenever I add them in, use them, and run make (to compile racket), I get this error:

```
standard-module-name-resolver: collection not found
  for module path: (submod at-exp reader)
  collection: "at-exp"
  in collection directories:
   /Users/leif/Library/Racket/6.1.1.4/collects
   /Users/leif/racket/racket/collects
```

(If I do run the file on it's own in racket-mode or drracket it works fine with at-exp).

Ah, right --- I agree that you can't depend on `at-exp` from "collects".

> I'm not familiar with how Travis works. Is the presence of that file sufficient for Travis to start testing the repo, or does the author need to explicitly ask it to?

As far as I can tell, you still need to go to travis and turn on the testing.

@AlexKnauth: the code in `runtime-config.rkt` looks slightly broken.  IIUC, it creates a new read-table for every interaction read, which means that if this is used then you cannot tweak the read-table's use of `@`.  Specifically, using the REPL to debug the scribble reader was a very useful thing at the time -- and if anyone try that now I expect a possible confusing result where changes seem to not have any effect.

Re Travis: Great. That's what I was hoping.

This should include documentation.

Please squash the main commit and the "GPL by reference" commit.

Okay, do you want me to also squash the commit that contains all of these small changes too?

Re squashing: If you want. My main concern is avoiding a commit that's mostly reverted in the next one.

> This should include documentation.

Will do that once I've pushed these changes.

> Re squashing: If you want. My main concern is avoiding a commit that's mostly reverted in the next one.

Done

Would something like this be better?

``` racket
#lang racket/base
(provide configure)
(require (only-in scribble/reader make-at-readtable))
(define (configure data)
  (current-readtable (make-at-readtable #:readtable (current-readtable))))
```

Except that this would extend the readtable for normal uses of read, not just the repl, right?

I don't think that that's a problem -- you want the REPL to use whatever `read` uses anyway, so any reason to change the former seems to me like a good reason to change the latter too.  IOW, I think that it's better to maintain the way that `'expr` is very similar to `(read) <LF> expr`.

As a sidenote, besides using `'@foo...` to debug the reader on the REPL, I'd also use the `(read)` and then enter some `@foo...`.  This was particularly useful when I needed to demonstrate the reader (it was before the standard printer used a `'`, so it was easier to follow that for people who were new to the syntax).

I have pushed documentation. I'm not entirely sure how I should go about making test cases for this.

I don't see the docs.

Do you see it now?

This passes all the contract tests, but I wanted to see if @rfindler had any thoughts before pushing.

Thanks to @cfbolz for noticing this.

Seems okay to me.

Tests can be put into racket-pkgs/racket-test/tests/pkg/

You could test the model by making sure that the files are created etc by
writing a traditional test. You can also use shelly to script a test of the
command. I'd suggest testing

raco pkg new blah
edit blah/main.rkt
raco pkg install blah
racket -t blah gives result you want via edit

Jay

On Fri, Nov 7, 2014 at 5:04 PM, Leif Andersen notifications@github.com
wrote:

> Do you see it now?
> 
> —
> Reply to this email directly or view it on GitHub
> https://github.com/plt/racket/pull/816#issuecomment-62222160.

## 

Jay McCarthy
http://jeapostrophe.github.io

```
       "Wherefore, be not weary in well-doing,
  for ye are laying the foundation of a great work.
```

And out of small things proceedeth that which is great."
                          - D&C 64:33

You may want to add something in the overview section of the pkg docs. Again, be sure to stress that this is only a convenience, not a necessary step.

Thanks for the improvements!

The "setup.rktl" test failed with this change, and the failure reflects a problem in the documentation: a handler takes 6 arguments instead of 5. I'll push a documentation repair and change to this patch.

Thanks! I've merged the first commit, but I'll leave the Redex part for others to review.

Merged. I worry a little that an existing use of `dynamic-rerequire` relies on the previous void result to not print output, but probably it doesn't matter.

merged

merged

It may, but that is unintentional. Currently if neither a src file nor a compiled .zo file exists, managed-compile-zo silently does nothing, which I claim is the wrong behavior. I also would claim that if a user passed in a path to a source file to compile and it didn't exist but the compiled .zo file did it is still an error. It shouldn't be an error if a recursive call tries to ensure a compiled .zo is up to date but there is no source file, and I may have broken that. Do we agree on that behavior or are there useful cases where a user can pass in files that don't exist?

When the relevant code is called through a load handler, then I think it may be important to defer no-such-file handling (or reporting) to the original load handler --- either because the original handles a missing file in a different way, or because it is in a better position to report an error.

I agree that it makes sense for `managed-compile-zo` to complain when the file that it is given directly doesn't exist, though. Maybe that's best implemented as an up-front check, instead of a check inside the part that is used by both `managed-compile-zo` and a load handler.

Thanks!

@jeapostrophe Good idea. I've added those tests. Still playing with shelly and I will add more robust tests shorty.

> You may want to add something in the overview section of the pkg docs. Again, be sure to stress that this is only a convenience, not a necessary step.

Okay, I have added a page on the overview, it should state this is an option.

I believe that address all of the suggestions. Are there any other comments? Otherwise who should I talk to about merging this?

Does it make sense for `raco pkg new` to install the new package (by default)? The "getting-started.scrbl" change isn't clear about the point where the "manual" alternative to `raco pkg new` ends.

Longer term: Should `raco pkg new` accept an optional "template" argument before the destination argument, analogous to `lein new`? The template argument might effectively select a license, choose a multi-collection package layout instead of single-collection one, and so on. Packages could provide new templates that plug into `raco pkg new` via "info.rkt" (similar to the way `raco` supports extensions).

I should add that I think it's fine to merge now, and then you and/or others can make further improvements.

> Does it make sense for raco pkg new to install the new package (by default)?

I could go either way on this. On the one hand, I could see cases where someone wants a new package but doesn't want to install it, but on the other hand it seems like it could be useful most of the time.

> The "getting-started.scrbl" change isn't clear about the point where the "manual" alternative to raco pkg new ends.

Oh, good point, I will fix that.

> Longer term: Should raco pkg new accept an optional "template" argument before the destination argument, analogous to lein new? The template argument might effectively select a license, choose a multi-collection package layout instead of single-collection one, and so on. Packages could provide new templates that plug into raco pkg new via "info.rkt" (similar to the way raco supports extensions).

I like that idea (it was in the original design document). But @mfelleisen, @stamourv, and @takikawa all seemed opposed to it, so I didn't add it in.

For whatever it's worth, I tried to design this so that we could extend it to have template if it's the right thing to do.

@rfindler, a few of us in the lab discussed this and concluded that the desired behavior (report only arguments from the call site) is not possible. 

I think the current error message could still be improved, if only to add a position, and maybe some subset of the possible arguments.

The latter can be just the required arguments, or all the arguments including optional args. Note, however, that if optional args are included but not supplied, then the output will look something like this:

```
#lang racket
(require racket/generic)
(define-generics AA
  [meth a AA c [d]])

> (meth 1 2 3)
plt-stchang/racket/collects/racket/private/generic.rkt:208:25: meth: contract violation
  expected: AA?
  given: 2
  argument position: 2nd
  other arguments...:
   1
   3
   'default-arg1285
```

Merged, thanks!

Would it make sense to make the guard return the types given for the fields, but let the constructor accept whatever types the constructor can accept?  (Edit: as opposed to making the constructor and guard accept only the types given for the fields, but changing the field types and return types of selectors to be the return types of the guard)
For example:

``` racket
(: foo-guard : [Real Any -> Integer])
(define (foo-guard n _)
  (exact-round n))
(struct foo ([n : Integer]) ; Integer, not Real
  #:guard foo-guard)
(ann foo [Real -> foo])
(ann foo-n [foo -> Integer])
```

Would something like this make sense?

@AlexKnauth that does make sense but is harder to implement (because it requires knowing the guard type, which we don't know until typechecking time, to compute the struct constructor type). Do you know of any code that uses that kind of pattern?

So I grepped to investigate all uses of `#:guard` in the core codebase. In most cases, the guard is used purely for error handling or to return values of the same "type".

However, there are a few cases that might call for something like what @AlexKnauth is proposing. For example, there is a struct guard in the db package that looks like this:

```
#:guard (lambda (center radius _n)
          (values center (exact->inexact radius))
```

The `exact->inexact` conversion could mean we  should assign a more restrictive type to `radius`. Or in another case:

```
#:guard (lambda (closed? points _n)
          (values (and closed? #t)
                  points))
```

we might want to assign `closed?` to be `Boolean` rather than `Any` (though that may not matter because of truthiness in conditionals). In another case, the guard converts all incoming bytes to immutable bytes (but TR doesn't distinguish these by type anyway).

There is a tradeoff though, because by supporting a different constructor type based on the guard it means guard functions will need more type annotations to type-check. That's because using the field types in the expected guard type allows the lambda expression to have no annotations on its arguments. But if we need to synthesize the type first to determine the constructor type, we can't rely on an expected type like that.

(Oops, originally commented on the commit.)

Merged, thanks!

Can you undo the gratuitious re-indentation and new linebreaks?

I think it will make your commit look a lot better, in addition to making
things like git blame work better. Plus it is more polite.

Robby

On Thu, Nov 20, 2014 at 4:12 PM, Sam Tobin-Hochstadt <
notifications@github.com> wrote:

> ## Work done by Earl Dean.
> 
> You can merge this Pull Request by running
> 
>   git pull https://github.com/samth/racket master
> 
> Or view, comment on, or merge it at:
> 
>   https://github.com/plt/racket/pull/828
> Commit Summary
> - Port the slidey game to Typed Racket.
> 
> File Changes
> - _M_ pkgs/games/slidey/slidey.rkt
>   https://github.com/plt/racket/pull/828/files#diff-0 (308)
> - _A_ pkgs/games/slidey/typedslidey.rkt
>   https://github.com/plt/racket/pull/828/files#diff-1 (380)
> 
> Patch Links:
> - https://github.com/plt/racket/pull/828.patch
> - https://github.com/plt/racket/pull/828.diff
> 
> —
> Reply to this email directly or view it on GitHub
> https://github.com/plt/racket/pull/828.

I've just pushed a different commit that looks much nicer. I'll try to clean it up a little more.

After trying this out with DrRacket and an updated `insert-large-letters.rkt`, it turns out that this approach doesn't work as well as I thought. Basically the deletion of methods from the method table affect a bunch of "internal" calls in a way that breaks the program (because an object might call out to a helper function that can't make internal calls and has to resort to external ones).

So I'm going to close this for now.

Can you point me to it when you're done? I'm not sure I'll see an alert
email.

Robby

On Thu, Nov 20, 2014 at 4:26 PM, Sam Tobin-Hochstadt <
notifications@github.com> wrote:

> I've just pushed a different commit that looks much nicer. I'll try to
> clean it up a little more.
> 
> —
> Reply to this email directly or view it on GitHub
> https://github.com/plt/racket/pull/828#issuecomment-63891614.

Ah, rats.

On Thu, Nov 20, 2014 at 4:26 PM, Asumu Takikawa notifications@github.com
wrote:

> After trying this out with DrRacket and an updated
> insert-large-letters.rkt, it turns out that this approach doesn't work as
> well as I thought. Basically the deletion of methods from the method table
> affect a bunch of "internal" calls in a way that breaks the program
> (because an object might call out to a helper function that can't make
> internal calls and has to resort to external ones).
> 
> So I'm going to close this for now.
> 
> —
> Reply to this email directly or view it on GitHub
> https://github.com/plt/racket/pull/812#issuecomment-63891673.

@rfindler It's now as clean as I can make it -- even re-adding the small bits of trailing whitespace that were there. :)

Mentioning @earldean

This looks great! I might have been tempted to indent the function at the end incorrectly in a first commit just to showcase how nice the diff is for types.

Too bad with the integer thing, eh? Did anyone try (U 0 1 2 3) (or whatever it would be) or using symbols or something like that?

Some thoughts:
- there should probably be a logging mode for 'raco pkg update' that
  includes the precise git commands that got run. Even better if I can get
  that log after the fact.
- a pkg source can include a git branch directly, not via
  pkgs.racket-lang.org, I believe. But I ask because I am thinking about the
  case where someone pushes a change to a repo, but the changes aren't
  visible immediately because the pkgs server hasn't yet noticed that the
  repo changed. I think this is a question about catalogs, but I'm not sure
  how to phrase it properly (sorry).
- instead of having "git pull --rebase", how about "git pull --ff-only" as
  the default semantics. For people that routinely want the --rebase
  semantics, it seems to make sense to have an option at the raco pkg level,
  that's off by default. (I like how you have the git fetch and try in
  another directory approach, tho!)

Robby

@rfindler Yes, `--ff-only` is a better idea. I'll make `git` commands shown by default as part of `raco pkg {install,update}` output. I don't know whether "pkgs.racket-lang.org" update delays are going to be an issue.

This looks very nice. A few initial thoughts:
- It looks like this would be easy to adapt if we wanted to support other version control systems. Does that seem right? (Not that I'm suggesting trying to support them now.)
- Should we make `raco pkg update` with no arguments in a directory for a pkg update that pkg (similar to how `raco pkg install` works)? This would allow it to replace `git pull` in many cases.
- I'm still not sure after reading the docs whether `raco pkg install --clone dir git-src` creates a clone that _is_ `dir` or that is _inside_ `dir`, so that should be clarified.
- It sounds like we're going with `--ff-only` on `update`, which is good. I think we should try to make sure we only do "non-destructive" git operations, although I don't know if there's a precise definition for that. Related to this, could we avoid the checkout entirely if there's going to be a conflict (by using a temporary directory/checkout).

@rfindler We tried `(U 0 1 2 3)`, which doesn't work because the type of `random` isn't precise (and dependent) enough. Using symbols would be a bigger change, which we're trying not to do for paper evaluation purposes.

A different and maybe better strategy would be to use `else` in the last clause of the `case`. @earldean can you look at that?

@samth Yes on other VCSes. Ok on `raco pkg update`. Currently, clones are created _inside_ `dir`, but after trying it, I think that should change (which means that you can't link different repos at once through the command line, but you do get a chance to name the local clone). Doesn't `--ff-only` avoid a checkout if there's a conflict?

@mflatt Sounds good on all points. And yes, switching to `--ff-only` will fix that for `update`. Are there other places where we do operations on existing git repositories (other than cloning them)?

One writing-level comment: the discussion of linked directories felt out of place for the final version of the docs. It seems like we want to go straight into git-based ones here and go straight into file-based (link) ones elsewhere and then have yet a third place on combining them. Or at least it should come after the git-based workflow comes in the description.

Using the (U 0 1 2 3) approach, you could define a helper function that had an assert in it that was just a wrapper around 'random', right? That would push the untyping into the right places in the code, right? Ie you'd get more checking?

The reason that doesn't work is that `get-random` takes an argument for the bound -- it isn't fixed to 4. So the assertion wouldn't inform the type system enough.  Unless you're suggesting a wrapper that's fixed to 4?

Once Typed Racket has @andmkent's work, we ought to be able to type check the original program, though. 

Ah, right. Yes I am suggesting changing get-random-number so it doesn't accept `bound` anymore. Either way is fine w/me.

I'll let @takikawa choose what fits best with his evaluation.

@samth I will test using the else in that last clause. 

> On Nov 21, 2014, at 2:30 PM, Sam Tobin-Hochstadt notifications@github.com wrote:
> 
> @rfindler We tried (U 0 1 2 3), which doesn't work because the type of random isn't precise (and dependent) enough. Using symbols would be a bigger change, which we're trying not to do for paper evaluation purposes.
> 
> A different and maybe better strategy would be to use else in the last clause of the case. @earldean can you look at that?
> 
> —
> Reply to this email directly or view it on GitHub.

Wow, nice! I'm glad you tracked this down.

A while back @philnguyen reported a performance issue in TR that I suspect has the same root cause as these. Can you see if your commits fix it too? (example attached below)

```
#lang typed/racket/base
(provide f)
(require racket/match)

(: f : Any → Any)
(define (f s)
  (match s
    [`(and) #f]
    [`(and ,s) #f]
    [`(and ,s ,sᵣ ...) #f]
    [`(or) #f]
    [`(or ,s) #f]
    [`(or ,s ,sᵣ ...) #f]
    [`(let* () ,s) #f]
    [`(let* ((,(? symbol? x) ,s) ,b ...) ,t) #f]
    [`(begin ,s ... ,t) #f]
    #;[(or) (error "This useless line speeds things up")]
    [`(λ (,(? symbol? x) ...) ,t) #f]
    [`(if ,s ,t₁ ,t₂) #f]
    [`(let ,(list `[,(? symbol? x) ,s] ...) ,t) #f]
    [`(recursive-contract ,c) #f]
    [`(-> ,c ... ,d) #f]
    [`(->i ([,(? symbol? x) ,c] ...) (,(? symbol? y) ,_ ,d)) #f]
    [`(struct/c ,(? symbol? t) (,c ...)) #f]
    [`(and/c ,c ...) #f]
    [`(or/c ,c ...) #f]
    [`(not/c ,c) #f]
    [(list f xs ...) #f]
    [#f #f]
    [#t #f]
    [(? number? x) #f]
    [(? string? x) #f]
    [(? symbol? x) 'reached]))

(f 'check)
```

(Phil said this took about 3 minutes to typecheck)

Also, could you add tests that make sure that the typechecking is fast? Maybe using a sandbox (like https://github.com/plt/racket/blob/master/pkgs/typed-racket-pkgs/typed-racket-test/tests/typed-racket/succeed/gui-contract.rkt), via a DrDr timeout, or some other method.

The "implied-atomic?" change does "fix" the above match statement (making it take 2 seconds or so on my machine), but the change to let expressions (generating an or instead of an imp) "breaks" it again (making it take more than anyone would reasonably wait for).

I'll experiment more and report - I suspect it will be best to just use the change to "implied-atomic?", though.

I think this suggests that we need more simplification, rather than
dropping one of your changes.

On Sun, Nov 23, 2014, 7:40 AM Andrew Kent notifications@github.com wrote:

> The "implied-atomic?" change does "fix" the above match statement (making
> it take 2 seconds or so on my machine), but the change to let expressions
> (generating an or instead of an imp) "breaks" it again (making it take more
> than anyone would reasonably wait for).
> 
> I'll experiment more and report - I suspect it will be best to just use
> the change to "implied-atomic?", though.
> 
> —
> Reply to this email directly or view it on GitHub
> https://github.com/plt/racket/pull/830#issuecomment-64116540.

merged

The true fix that I never got around to implementing is to fix the
proposition environment and get rid of implication constraints. Currently
implication constraints are only used to express in a form like (let ([x
e]) ...) that x and the result of expression e share the same object. If we
could track aliases better then we could remove implication all together
and have much simpler environments.

On Sun, Nov 23, 2014 at 4:58 AM, Sam Tobin-Hochstadt <
notifications@github.com> wrote:

> I think this suggests that we need more simplification, rather than
> dropping one of your changes.
> 
> On Sun, Nov 23, 2014, 7:40 AM Andrew Kent notifications@github.com
> wrote:
> 
> > The "implied-atomic?" change does "fix" the above match statement
> > (making
> > it take 2 seconds or so on my machine), but the change to let
> > expressions
> > (generating an or instead of an imp) "breaks" it again (making it take
> > more
> > than anyone would reasonably wait for).
> > 
> > I'll experiment more and report - I suspect it will be best to just use
> > the change to "implied-atomic?", though.
> > 
> > —
> > Reply to this email directly or view it on GitHub
> > https://github.com/plt/racket/pull/830#issuecomment-64116540.
> 
> —
> Reply to this email directly or view it on GitHub
> https://github.com/plt/racket/pull/830#issuecomment-64117066.

Aliasing may also help, however we can remove implication  today w/o adding
aliases. One of the two commits more or less does this - it replaces the
implication constructor in tc-let with an equivalent disjunction. It did
improve performance for some programs, but worsened it for this additional
match example Asumu posted. Perhaps further improvements could make this
additional example fast as well.

On Sun, Nov 23, 2014, 11:43 AM Eric Dobson notifications@github.com wrote:

> The true fix that I never got around to implementing is to fix the
> proposition environment and get rid of implication constraints. Currently
> implication constraints are only used to express in a form like (let ([x
> e]) ...) that x and the result of expression e share the same object. If
> we
> could track aliases better then we could remove implication all together
> and have much simpler environments.
> 
> On Sun, Nov 23, 2014 at 4:58 AM, Sam Tobin-Hochstadt <
> notifications@github.com> wrote:
> 
> > I think this suggests that we need more simplification, rather than
> > dropping one of your changes.
> > 
> > On Sun, Nov 23, 2014, 7:40 AM Andrew Kent notifications@github.com
> > wrote:
> > 
> > > The "implied-atomic?" change does "fix" the above match statement
> > > (making
> > > it take 2 seconds or so on my machine), but the change to let
> > > expressions
> > > (generating an or instead of an imp) "breaks" it again (making it take
> > > more
> > > than anyone would reasonably wait for).
> > > 
> > > I'll experiment more and report - I suspect it will be best to just
> > > use
> > > the change to "implied-atomic?", though.
> > > 
> > > —
> > > Reply to this email directly or view it on GitHub
> > > https://github.com/plt/racket/pull/830#issuecomment-64116540.
> > 
> > —
> > Reply to this email directly or view it on GitHub
> > https://github.com/plt/racket/pull/830#issuecomment-64117066.
> 
> —
> Reply to this email directly or view it on GitHub
> https://github.com/plt/racket/pull/830#issuecomment-64124330.

I just tried building this. This pull request can also close this old problem:
http://bugs.racket-lang.org/query/?cmd=view&pr=14658

The xdg-open change seems good to me. I don't know the motiviation behind the trampoline for linux, but  am okay with it being tried.

@rfindler The trampoline for Linux is needed because `xdg-open` doesn't accept query strings on the command line, so we can't do one without the other.

Ah, okay. I still feel like trampolining is worse than the materialize approach because it seems more fragile and is subject to gc problems.

Lets experiment with trampolining on linux and materialization on mac os x and see which cost matters more in practice?

Trampolining fixes a problem that materialization doesn't fix, so we will need it on linux (and on Windows, where we've used it for a long time). The issue on linux with `xdg-open` and on Windows is about command line syntax parsing, and not about permissions, so different directory locations won't change things.

Another possibility would be to encode query strings as `#foo` instead of `?q=foo`, which I bet would work on all systems, but I haven't tested.

@rfindler: I don't know why you're so skeptical about it -- it has been used in Windows right from the start, and that's where most users are...  (I might have made an impression that GCing files is a bigger problem because I talked about improving it, but it does now works perfectly fine, and has done so for all those years.)

@samth: Using a fragment works now, but I won't be surprised that it gets dropped in the future.  The thing is that they're essentially interpreting a `file://` as a machine path (which is valid, IIRC), and probably `#` is less common in a file name that `?`.  In any case, on Windows the problem is different: `xdg-open` fails with a `?` since it considers it part of the name, whereas windows drops it, probably for some security reasons.  And windows drops the fragment too.  (I'm 98% sure of that, since it took me a while to find a solution, and it's unlikely that I wouldn't try fragments too.)

Yeah, right. I had forgotten about the extensive windows testing! 

If you want to revert my commit and add this one instead, please go ahead.

@samth: actually, I just tried.  Maybe this is a windows 8 change, but now either a query or a fragment simply make it fail to start rather than drop it.  I'm sure it's new, since I definitely remember the droppage.

@rfindler: I don't care much either way, even having both seems fine to me...  It just sounded like you were thinking of this as being some new hack.

Turns out that `xdg-open` has actually fixed this [upstream](https://bugs.freedesktop.org/show_bug.cgi?id=45857), although it's not in the version in any of my ubuntu machines.

Nice (and good timing too)...  With Debian being what it is it'll probably be a quick 5 years for it to work properly.  (But the nice thing is that it won't get worse.)

I put in some comments. It's not really possible to test. We'll need to do a real commit (so that pkgs.rktd will be there), then kill DrDr, swap in the code, see what happens, iterate (by blowing away that first push's database and running DrDr again.)

I've addressed the comments. My plan now is:
- [x] add an empty `pkgs.rktd` file as a single commit
- [x] do this commit
- [x] see what happens
- [ ] fix and repeat

Re "see what happens". You'll need to manually copy over the DrDr source
directory with the copy script.

Jay

On Wed, Nov 26, 2014 at 9:53 AM, Sam Tobin-Hochstadt <
notifications@github.com> wrote:

> I've addressed the comments. My plan now is:
> -  add an empty pkgs.rktd file as a single commit
> -  do this commit
> -  see what happens
> -  fix and repeat
> 
> —
> Reply to this email directly or view it on GitHub
> https://github.com/plt/racket/pull/833#issuecomment-64656408.

## 

Jay McCarthy
http://jeapostrophe.github.io

```
       "Wherefore, be not weary in well-doing,
  for ye are laying the foundation of a great work.
```

And out of small things proceedeth that which is great."
                          - D&C 64:33

Yeah, discovered this. Currently in stage 4. :|

Thanks! I think we should adjust the tests, though: 
- `read` can't capture a continuation (due to barriers), although the compiler doesn't currently know that.
  A future analysis in `do_make_discarding_sequence` might recognize non-capturing expressions and
  allow the reordering.
- `random` is an immediate function, which means that there's no space-safety issue with delaying a 
  `car`. A future analysis in `do_make_discarding_sequence` might recognize
  immediate expressions and allow the reordering.

In both cases, the tests could be adjusted to call an unknown function.

I thought that `read` could capture continuation. (It was weird,
because you expect `read` to be simpler.) It's used in other places as
an example of a primitive that may capture continuations, for example:
https://github.com/plt/racket/blob/master/pkgs/racket-pkgs/racket-test/tests/racket/optimize.rktl#L2233-L2234

In the other example, I didn't like that a smart enough optimizer can
detect that `(list 1 x)` is immutable and `(car big)` is always `1`,
so I also changed `1` to `(f)`.

I pushed the new version to this branch. Do you have simpler alternatives?

The examples could just call `f`, which is unknown and therefore might capture a continuation.

Good point about the old examples.

Should I change the test?

Done and pushed. I also removed the unnecessary argument `h`.

IIRC my problem was that I forget to put `values` so something like

```
(test-comp '(lambda (f) 
              (begin (f) (list 7)))
           '(lambda (f) 
              (car (cons (list 7) (f))))
           #f)
```

succeded because the optimization added `values` to ensure a single result. 

(In the final version I put `values` in both expressions, because it makes the transformation more clear.)

This bug http://bugs.racket-lang.org/query/?cmd=view%20audit-trail&database=default&pr=14858 is reproducible on Travis CI with some of the new targets. Can someone commit finally the pull request? :-)

I'll merge this, but I still think that going from using 1.5 hours to 5.5 hours (and more once everything works) on Travis isn't the right thing to do. Can you maybe not run all the variants under both gcc and clang, or under both osx and linux?

Merged - thanks!

This was finished a while ago.

closed because rackunit was moved to https://github.com/racket/rackunit

closed because plot was moved to https://github.com/racket/plot

Pushed one sentence, the other one was correct.

@soegaard Sadly, you now need to make this a PR on racket/honu.

@mflatt @rfindler Who's the right person to review this?

Merged.

I've merged this. @juanfra684, can you look into using `matrix` in Travis to only run these extra tests on linux/gcc?

The documentation for the build matrix feature is here: http://docs.travis-ci.com/user/build-configuration/#The-Build-Matrix

Me. But I think I already included it.

Robby

On Thu, Dec 4, 2014 at 8:58 PM, Sam Tobin-Hochstadt <
notifications@github.com> wrote:

> @mflatt https://github.com/mflatt @rfindler
> https://github.com/rfindler Who's the right person to review this?
> 
> —
> Reply to this email directly or view it on GitHub
> https://github.com/plt/racket/pull/636#issuecomment-65741056.

Can you check, and close it if you did?

Does this perform better for you in some program?

A tail-recursive loop is not inherently better here. For a list of length N, this function is going to use O(N) space either way, and continuation space is not specially limited in Racket. Due to implementation details of the run-time system, I'd expect allocating intermediate O(N) space on the continuation to be faster in some cases, while encoding the continuation in a to-be-reversed list could be faster other times.

I like the simplifications in the third patch, and I expect to push it along with the other two.

In fact, I didn't check speed.
I had a error while processing 200th element of the list and was wondered to see very very long stacktrace.
I thought, that tail recursive version is more expectable.

I tried with different combinations of matrix include/exclude but nothing worked. I wanted to run the extra tests with clang and gcc only on linux. OpenBSD, NetBSD and FreeBSD will change to clang, so the clang tests are also important.

I asked how to run different tests on each platform a few days ago in the travis' google group but they haven't approved my mail yet.

@juanfra684 do you have a branch with your changes? I'm happy to try experimenting as well.

@samth I added your user to my repo.

@juanfra684 thanks. I just tried something, and filed a travis bug: travis-ci/travis-ci#3004 

New link here:
http://pagesperso-systeme.lip6.fr/Christian.Queinnec/PDF/webcont.pdf
​

I've just sent the remaining commit as a pull request to the Redex repository.

Will move to TR repo.

Will move to TR repo.

Couldn't get it working, will reopen on TR repo if I can make it work later.

Will reopen on TR repo when this is done.

We very much want this, so talk to @mflatt if you can't figure it out.

moved to https://github.com/plt/racket/pull/844

moved to https://github.com/plt/racket/pull/845

@samth, I added your changes from juanfra684/racket-travis-test.

Is epel-7 a particular variant?

This is an intermittent issue that we've seen elsewhere (such as Travis builds on OS X). It's gone on head, but hopefully rerunning the build will fix the problem for 6.1.1.

@juanfra684 can you make this a new PR? It's easier to merge.

Merged, thanks!

@juanfra684 I think we need to run fewer tests when the jit is disabled. This job times out, for example: https://travis-ci.org/plt/racket/jobs/43713372

Is this just trying to make things faster? I managed to speed things up a lot a different way, as you can see here: https://travis-ci.org/plt/racket/builds/43777945

Yes. This change is related to your comment in my last PR: "I think we need to run fewer tests when the jit is disabled."

Travis will only test clang with the default options and everything else with gcc. Look https://travis-ci.org/juanfra684/racket-travis-test/builds/43773561.

Great job! :)

Ah, cool. I'll merge this then.

Nit: `#:args maybe-pkgs` doesn't match up with `<pkgs>` in the description for "--rx". I think `#:args maybe-pkg` and `<maybe-pkg>s` are probably better, even though the variable name without "s" looks awkward in the code.

Oh, right, I remember noticing that and thinking I should fix it.

moving to typed-racket repo

Thanks for the repair! The Racket sources require `int` to be 32 bits, so increasing the shift should be right.

merged

merged

merged - thanks!

Follow up note: these changes (and more) are now here https://github.com/racket/typed-racket/pull/1 and  here https://github.com/racket/typed-racket/pull/2  (TL;DR they are all fast now)

Would anyone object if I merged this?

So far at least two others (@soegaard and @takikawa) have expressed interest in this feature.

Overall, I think it looks great.

I didn't look super-closely, but the definition of define-and-provide-id-set really sticks out. Surely you can avoid duplicating that much code with just a little more work? But even if not, that's okay with me.

Instead of copying the OpenBSD configuration for Bitrig, would it make more sense to have a single section that starts with a definition of the platform-string suffix as either "openbsd" or "bitrig"?

Also, I worry about modifying "config.guess". Maybe we should get a new "config.guess" from somewhere, instead?

I added a new section for bitrig because eventually they will differentiate increasingly from OpenBSD. e.g. they support TLS and armv7.

I will update the pull request with a new version of config.guess from GNU.

Done. Let me know if the PR needs more changes.

The general strategy here looks good, and always starting with `info->escapes = 0` sounds right, although I'm not sure I've looked closely enough. I think it's likely fine to drop the flonum detection of `x` and `y` in `(begin (error 'e) (fl+ x y))`, unless you have a counter-example already.

Thanks - I'll merge the changes, probably later today

The problem with `(begin (error 'e) (fx+ x y))` is that I still don't
understand all the details of the internal parts of the
`scheme_compiled_let_void_type` to be sure that the reduction will not
cause a problem later. If you don't see the problem, then this is probably
OK.

On Thu, Dec 18, 2014 at 3:14 PM, Matthew Flatt notifications@github.com
wrote:

> The general strategy here looks good, and always starting with info->escapes
> = 0 sounds right, although I'm not sure I've looked closely enough. I
> think it's likely fine to drop the flonum detection of x and y in (begin
> (error 'e) (fl+ x y)), unless you have a counter-example already.
> 
> —
> Reply to this email directly or view it on GitHub
> https://github.com/plt/racket/pull/851#issuecomment-67529438.

Merged - thanks!

Merged - thanks!

Merged - thanks!

Merged - thanks!

I've merged your repair - thanks!

Merged - thanks!

@samth Implemented those changes.

@samth You were right, that was unnecessary. I've removed the extra lambdas.

Thanks, I've pushed the commit to the racket repo.

@rfindler great, thanks :)

Merged, and much appreciated!

Merged - thanks!

I think write feels left out :-)

@soegaard True. Perhaps I should add `writeln` while I'm at it? :)

I'd like that.

@soegaard Okay, I added `writeln` as well. I also tweaked the `println` documentation a little to indicate that users looking for an equivalent to Java's `println` should use `displayln` instead, to avoid confusion.

I think this needs some tests.

I successfully misconfigured the Windows build to get a failure in AppVeyor :).

This builds first the `win32-at-place` version to install the packages, but it doesn't run the tests. Then it builds the `win32-base` version (that deletes a few dll?) and runs the tests.

Merged, thanks!

I'm going to close this, not because I don't want to add tests, but because I don't think this is actually all that important. For debugging, using `pretty-print` makes much more sense anyway, making this less relevant.

This looks good to me overall. Small note inside.

@rfindler Okay, after thinking about it a little more, I realized what you were saying. I've fixed that. I've also removed the `val-first-projection` implementation because I don't think it matters here, so it just seemed to make things more complicated.

Sounds good.

I actually think we should do this -- I've missed these functions before.

I've merged this.

Merged, thanks.

@mflatt I saw your comment after merging this. I've answered this question enough times in the IRC channel that I'm inclined to deal with fixing the links when sources change, but if you have another suggestion I'm happy to change it.

In the case of the self link in the Scribble docs, it has been a problem that the release gets out of sync with the development version; changing the source doesn't affect the docs that lots of people are reading.

I think that a "contribute via ..." link makes sense imposed on installation, similar to the way the Racket banner is added at http://docs.racket-lang.org, instead of having the path built into the source and rendered docs. I imagine that a JavaScript fragment could add a suitable path onto the page; the JavaScript to add the path might be updated daily by consulting pkgs.racket-lang.org. The rendered docs need to record the source of the document for use by the script; fortunately, they already do that (to support the information you see when you click on a section title).

Are you imagining that the JS would be served from some location that gets modified daily? I bet it would be easier to just consult pkgs.racket-lang.org on every load of the page, since that information is hosted statically anyway on the server.

I had in mind that pkgs.racket-lang.org doesn't currently provide a compact mapping from module names to package sources. But adding and updating that information at pkgs.racket-lang.org (and referencing it directly in the script) sounds right.

Ah, right, because the current static table has the full data. @jeapostrophe or @tonyg, how hard would it be to serve http://pkgs.racket-lang.org/racket-doc as a JSON document with the relevant data for that pkg?

It already is

http://pkgs.racket-lang.org/pkg/racket-doc.json

On Tuesday, February 10, 2015, Sam Tobin-Hochstadt notifications@github.com
wrote:

> Ah, right, because the current static table has the full data.
> @jeapostrophe https://github.com/jeapostrophe or @tonyg
> https://github.com/tonyg, how hard would it be to serve
> http://pkgs.racket-lang.org/racket-doc as a JSON document with the
> relevant data for that pkg?
> 
> —
> Reply to this email directly or view it on GitHub
> https://github.com/plt/racket/pull/874#issuecomment-73715883.

## 

Jay McCarthy
http://jeapostrophe.github.io

```
       "Wherefore, be not weary in well-doing,
  for ye are laying the foundation of a great work.
```

And out of small things proceedeth that which is great."
                          - D&C 64:33

Even better!

@jeapostrophe: I don't think that's the format that we need. The example path you provided embeds the package name, but the initial problem is mapping a document-source module path to a package name. The catalog overall contains that information, but not in a compact and easily searchable (in JS) format.

@jeapostrophe you need to allow cross-origin requests in order to make this work -- just adding the header `Access-Control-Allow-Origin: *` should fix it.

@mflatt I think we can embed the pkg name in the source, unless you're worried about the pkg that provides the reference changing names?

@samth: Yes, I did have in mind trying to support documents that move to different packages. Maybe it's good enough to embed the package name in rendered document, though.

Thanks for the patch.

Would it be more convenient or less convenient if offsets were attached to individual fields, instead of having a list for all fields?

Indeed it would be more readable. I'll look into it.

On 2/11/15, Matthew Flatt notifications@github.com wrote:

> Thanks for the patch.
> 
> Would it be more convenient or less convenient if offsets were attached to
> individual fields, instead of having a list for all fields?
> 
> ---
> 
> Reply to this email directly or view it on GitHub:
> https://github.com/plt/racket/pull/876#issuecomment-73816899

@BartAdv also, if you look at the status checks on GitHub, you'll see that there's a build error with this pull request.

Yes, but it doesn't matter, it's gonna be reworked.

On Wed, Feb 11, 2015 at 2:42 PM, Sam Tobin-Hochstadt <
notifications@github.com> wrote:

> @BartAdv https://github.com/BartAdv also, if you look at the status
> checks on GitHub, you'll see that there's a build error with this pull
> request.
> 
> —
> Reply to this email directly or view it on GitHub
> https://github.com/plt/racket/pull/876#issuecomment-73882210.

@rfindler Can I get this merged?

I have modified it to include offsets along with field specification, but don't treat it like finished patch - I must say I struggled a bit with this (basically, I needed to learn macros basics), and I don't like the way I'm extracting optional values. I'd very much appreciate just some review.

Thanks

I'm not sure how a pull request is useful here.

But if you want comments then let me suggest you add a test. Also, this
description isn't accurate.

Vectors are relevant only because they create chaperones.

Robby

I created a PR both because it gives us a concrete diff to talk about, and because it stores my progress, and it automatically runs all the tests.

Thanks for doing this, Sam. The fix seems right to me, but I would do the tests differently. Specifically, I think that test case must cover only one of the changes, and also I think a test case that involves only struct/c (or struct/dc) with a chaperone'd input is more directly focused on the issue at hand (that is, it isn't really about vectors). Including all three tests seems fine too, but if we ever have to come back here, it would be nice to have a test case that gets directly at the issue. 

I'm thinking of something very much like your test, but using something like this revision of some code you sent me earlier:

```
 (define val1
   (x (vector 1)))
 (define val2
   (chaperone-struct 
    val1 
    x-v 
    (λ (f v) 
      (chaperone-vector v
                        (λ (a b c) c)
                        (λ (a b c) c)))))
```

But also, feel free to push and I'll adjust the tests later. (Just in case, as I'm not clear how things work: thi is not going to be a merge commit, right?)

@rfindler I wrote the test you suggested, but it found a bug, I think in `opt/c`. Here's the error I see:

```
FINISHED struct-dc.rkt
FAILED struct/c-simple-contract-accessor rewrite-to-add-opt/c
       got "struct-ref: non-chaperone result;\n received a result that is not a chaperone of the original result\n  original: #<procedure>\n  received: #<procedure>"
  expected no-exn-raised
```

I haven't had a chance to look into why that might be wrong, but I'm waiting to merge this.

Probably this code needs to be adjusted in the same way:

```
                       #`(let ([answer (let ([#,sub-val 
                                              (#,sel-id
                                               #,(opt/info-val opt/info))])
                                         #,this-body-code)])
                           (let ([proc-name (λ (strct fld) answer)])
                             proc-name))))))
```

Around 1355 in the same file.

I can do it later on, if you want. If you get to it first, feel free to push.

Thanks again.

This looks good to me. Feel free to push it.

The only things I'd add would be a test in context.rkt and support for random generation (the random generation should probably look like cons/c's random generation (the function cons/c-generate in misc.rkt)).

That is rather small issue, but I've figured out I could add test case here anyway, as I noticed there are test cases for those options. However, I noticed those test cases could yield false positives, due to `syntax-test`:

https://github.com/plt/racket/blob/master/pkgs/racket-test-core/tests/racket/cstruct.rktl#L75-L76

Both those linex yield success, however, both tested cases are in fact reporting an error message not related to what they are supposed to test (if I'm reading this correctly, that is). Because of this, when I add another test case for that small fix I've made (before applying it, of course), tests report nothing.

OK, found out where's the error, I'm on it

merged the test changes - thanks!

merged - thanks!

Merged (with test corrections) - thanks!

Looks good to me, so I merged - thanks!

OK, looks like the tests are passing now - I wonder, what are the edge cases to consider, the previous error was caused by not checking the case with `super-id`...

Added syntax test case and rebased + squashed the commits.

I'm unsure if I'm syntax-case'ing idiomatically, previously the `[slot slot-type]` was at the top level syntax case, I've merged those into single case and I'm pattern matching deeper, after parsing additional options. I've put some comments in the diff @6beb5df.

These both seem good to me.

Looks ok to me. As a minor suggestion, I think the docs should say `other-arg-expr ...` instead of `. other args`.

@rfindler Removed the unnecessary `neg-elem-proj`.

Thanks, I've pushed the commit.

I'd like to add an `#:offset` keyword before the offset, in anticipation of handling future options uniformly. I'll make that change, generally take a closer look at the implementation, update the docs, and then merge.

Thanks!

One more thing occured to me - if we allow custom offsets, shouldn't we allow specifying custom size?

The scenario for which I needed this change was just about shuffling the order of the fields, so the size stays the same. However, it's easy to imagine one could do more crazy things with it.

I think that custom sizes are handled well enough through the field's type. It would also be possible to set offsets by playing games with field types, but it would be tricky, and that's not how ctypes are intended to work. Specifying a representation size, through, is properly a job of a ctype.

Merged - thanks!

Merged - thanks!

Merged - thanks!

I've added `x-source-pkg` to Scribble's HTML rendering

@lexi-lambda turns out there's a failure here: https://travis-ci.org/plt/racket/jobs/51157234#L1521

I think the problem is that PR 14970 has partly fixed, in 2ada651dd3, and thus the use of `struct-info`, where you note the issue w/ that PR, no longer works, but I'm not 100% sure.

@mflatt @rfindler more thoughts?

I'm not really sure, but if someone else doesn't get time to look into it, I can try

I think the solution might be to extend `chaperone-generics` and `impersonate-generics` to accept properties, since they are in control of the relevant representation. Then, `impersonate-stream` and `chaperone-stream` can just pass along the properties, instead of using `impersonate-struct` and `chaperone-struct` directly.

Yes, the entire reason I used `impersonate-struct` in the first place was because `impersonate-generics` doesn't support impersonator properties. I think changing that would be the most logical fix.

@lexi-lambda I started changing `impersonate-generics`, but are you already working on it?

Merged - thanks!

Done and merged.

Merged - thanks!

Merged - thanks!

The story behind `false?` is that it's useful for following the HtDP design recipe in a literal way. That's why `false?` exists in the student languages, and we have included bindings from the student languages in `racket` so that the student programs are easy to port to Racket.

To explain a little more, the `false?` predicate is useful for following the design recipe when you have a data definition such as

```
 ; A grade is either
 ;  - #f
 ;  - a number
```

The template for a function that consumes a grade `g` has a conditional with `(false? g)` and `(number? g)` cases. ~~It's true that `not` works just as well as `false?`~~ [I forgot: the student language `not` requires a boolean], but for teaching purposes, it's more consistent to have a predicate that ends in `?`.

A `true?` function that recognizes anything other than `#f` isn't useful in the same way. It would even be confusing from that perspective.

Overall, I see your point, but I think I prefer the `(and ... #t)` idiom for coercing a value to a boolean, because it makes the coercion more explicit to me. Meanwhile, I don't think I ever use `false?`, but I like having it as a way to smooth the path from one direction into Racket.

@mflatt That makes sense, but I still think `(and ... #t)` is quite unclear for people not familiar with the idiom. Would you prefer something like `->boolean`? That would make the cast more explicit while still providing the functionality.

Merged, thanks.

Thanks for the feedback. Merged.

should this pull request be closed?

I think the solution is to keep the call to optimize_for_inline() as before, but pass true for the `optimized_rator` argument, and also fix optimize_for_inline() to treat a local variable correctly --- that is, use optimize_reverse() when `optimized_rator` is true.

Currently, I don't see a way for the optimize_reverse() code to fire and still lead to an optimization. Simply passing true for `optimized_rator` avoids the bug, since that disables the use of a local variable. I'll likely leave the generalization in place, anyway, since it might make things a little clearer.

I agree. I'm my test, I couldn't couldn't find an example that uses
the `optimize_reverse` path, but I was not sure.

I don't like the idea of using `optimized_rator = 1` because in that
case `optimize_for_inline` might go inside `begin`s and `let`s with
side effects, and the current reduction implementation is very simple
and just drops the whole expression. Nevertheless,
`finish_optimize_application2` already goes inside the `begin`s and
`let`s, so probably there is no counterexample.

I tried a few variations of

  (let ([f (lambda (x y z)
             (let ([v (display x)]) (lambda () v)))])
    (procedure? (f (random) 0 0)))

but the reduction was correct in all the cases.

(As I said a few days ago, I'm trying  to make a few changes in
`try_reduce_predicate` and nearby code, that I think will make this
more robust. While writing that I found this error, so that code is
not complete yet. I think that I don't have to add more shifting and
reversing in the new code, so I hope it will be correct in the first
try.)

Good point about the possibility of dropping side effects, but maybe that's better handled by make_discarding_sequence() instead of trying to limit the use of optimize_for_inline()

Can you say more what you mean by the second point? Maybe give a small
example so I can understand what's going on?

Also, this seems a little fishy:

https://github.com/plt/racket/pull/892/files#diff-63e7e495c3d1d91da7fe8b2e40e5eebbR1473

Why do we have two different contract combinators with the same exact
projection? Do they really check exactly the same things?

Robby

Sure, here's an example (from the tests) of the second point:

```
(let ()
  (define-local-member-name n)
  (contract (class/c #:opaque [m (-> any/c number? number?)])
            (class object% (super-new) (define/public (m x) 3) (define/public (n) 4))
            'pos
            'neg))
```

This test currently raises an error, because the `n` method is not given a contract and the contract is opaque (so requires all methods/fields to be mentioned). 

I'm proposing to make this succeed, because in general the local member name `n` could have been defined (and un-exported) in another module. In that case, it's not possible to write an opaque contract on that class outside of that module that does not fail.

---

On the exact same projection, I've modified the `instanceof/c` projection to check if the given contract is an `instanceof/c` or an `object/c` and have slightly different behavior. But they do have pretty similar behavior to begin with, since they both ultimately wrap the class associated with the object. The difference is that `instanceof/c` applies the class contract projection, while `object/c` would construct a more minimal wrapper. Also, the `object/c` case needs a bit more checking to ensure the fields/methods are there (which the class projection normally does).

Well, on the principle that #:opaque was added for TR and it isn't the
right thing to support TR then changing it seems fine.

But on the principle that #:opaque is out as it's own thing there and
you're changing its behavior, it doesn't seem so fine.

Are there any uses of #:opaque in any pkgs on pkgs.racket-lang.org?

Also, I think that if you do change it, a little more discussion should go
into the notes in the history.

---

re same projection: I feel like that's a less than ideal code organization
but it is also something that can be changed another day, so I'm fine with
pushing it.

apparently taken care of in be6e1a404536f126363c53b85167f515dd383660

@rfindler I agree with the potential concern about backwards compatibility, but I think this is a very niche feature that hasn't seen much use so far. 

My main concern is actually that it would prevent Typed Racket from supporting local member names. I talked with Matthias about this, and we concluded that there isn't a good solution that keeps that door open. Any alternative requires Typed Racket to violate abstraction boundaries by listing the types of internal and potentially unexported methods or fields.

I looked on the package server at a few packages that seemed likely to use classes/class contracts. I did find some  uses of `class/c`, but none were opaque.

I also just pushed more documentation discussion in a separate commit.

On Tue, Mar 3, 2015 at 1:40 PM, Asumu Takikawa notifications@github.com
wrote:

> @rfindler https://github.com/rfindler I agree with the potential
> concern about backwards compatibility, but I think this is a very niche
> feature that hasn't seen much use so far.
> 
> I don't disagree, but I think that since it has been available for years,
> we must check.
> 
>  My main concern is actually that it would prevent Typed Racket from
> supporting local member names. I talked with Matthias about this, and we
> concluded that there isn't a good solution that keeps that door open. Any
> alternative requires Typed Racket to violate abstraction boundaries by
> listing the types of internal and potentially unexported methods or fields.

What is the "it" referring to here? Just to be clear, I have no problem
with a new, different keyword and TR using that one. Is that somehow
problematic?

> I looked on the package server at a few packages that seemed likely to use
> classes/class contracts. I did find some uses of class/c, but none were
> opaque.

Thanks. Do you know if there's a way to be more systematic about this? I'll
ask Jay if he has any ideas.

> I also just pushed more documentation discussion in a separate commit.
> 
> Thanks.

Robby

As Matthew points out, you can just `raco pkg catalog-archive` and
then unzip and grep. Does that turn anything up?

> What is the "it" referring to here? Just to be clear, I have no problem with a new, different keyword and TR using that one. Is that somehow problematic?

What I meant was that my proposed behavior for `#:opaque` prevents TR from being able to support local member names if that ever happens in the future (I've tried and I'm not sure it's possible).

Also, using a new keyword is fine as far as Typed Racket is concerned. The only issue is that that creates two features that only differ in a very small way (and probably nobody but TR uses anyway).

> As Matthew points out, you can just `raco pkg catalog-archive` and then unzip and grep. Does that turn anything up?

Thanks, I'll try that.

I think if that doesn't turn up any uses of the keyword, then it is okay to
change. I'd be slightly in favor of changing the name of the keyword at the
same time as the behavior changes, if that's the way things end up going,
but I don't have a strong opinion here.

I feel like there should be a way to make local-member-names work with TR. Perhaps by putting type information into the define-local-member-name declaration instead of elsewhere?

Grepping through all the packages revealed that only the tests use the `#:opaque` keyword. I also looked at all the packages that use `class/c` manually just in case and that confirmed it. Ok to merge?

Re: local-member-name, I think it's tricky because the goal for TR is to be able to detect when a `define/public` would fail (due to a duplicate name in the superclass) at typechecking time. With local member names, though, whether it would fail depends on what names are in scope, so TR would have to figure that out. (and similarly adjust contract checking depending on what names are in scope)

On Tuesday, March 3, 2015, Asumu Takikawa notifications@github.com wrote:

> Grepping through all the packages revealed that only the tests use the
> #:opaque keyword. I also looked at all the packages that use class/c
> manually just in case and that confirmed it. Ok to merge?

What do you think about changing the name while we are at it? That way
people will learn quickly instead of slowly if something could go wrong? Or
if that is too drastic is there something else? Or do you think I worry too
much? :)

> Re: local-member-name, I think it's tricky because the goal for TR is to
> be able to detect when a define/public would fail (due to a duplicate
> name in the superclass) at typechecking time. With local member names,
> though, whether it would fail depends on what names are in scope. (and
> similarly contract checking depends on what names are in scope)

Dynamic check there seems fine!

Robby

> —
> Reply to this email directly or view it on GitHub
> https://github.com/plt/racket/pull/892#issuecomment-77062923.

> What do you think about changing the name while we are at it? That way people will learn quickly instead of slowly if something could go wrong? Or if that is too drastic is there something else? Or do you think I worry too much? :)

Maybe we could make the `#:opaque` keyword take an argument? Like `#:opaque 'ignore-local-member-name`? Or is it better to use multiple keywords? `#:opaque #:ignore-local-member-name`?

I think maybe you are right that we should keep compatibility, since maybe TR will want to revert to the old behavior if it gets support for local member names.

Something like that seems better I think.

Robby

On Tuesday, March 3, 2015, Asumu Takikawa notifications@github.com wrote:

> What do you think about changing the name while we are at it? That way
> people will learn quickly instead of slowly if something could go wrong? Or
> if that is too drastic is there something else? Or do you think I worry too
> much? :)
> 
> Maybe we could make the #:opaque keyword take an argument? Like #:opaque
> 'ignore-local-member-name? Or is it better to use multiple keywords? #:opaque
> #:ignore-local-member-name?
> 
> I think maybe you are right that we should keep compatibility, since maybe
> TR will want to revert to the old behavior if it gets support for local
> member names.
> 
> —
> Reply to this email directly or view it on GitHub
> https://github.com/plt/racket/pull/892#issuecomment-77078100.

Okay I pushed a commit that adds an extra keyword to customize `#:opaque` and documents it. Also have tests for both old and new behaviors.

Thanks!

Merged.

@takikawa Are you still working on this?

Not actively. The current state is that it passes the tests (at least the tests that existed at the time) but there are some corner cases that I don't think I've handled correctly. I don't currently have time to work on it.

I think this is a good idea, but it's necessary to be careful with the details, just in case someone redefined `#%datum`. 

```
#lang racket
(require (only-in racket (#%datum #%old-datum)))
(define-syntax-rule (#%datum . x) (#%old-datum . 7))
(for/list ([i 10]) i)
```

Perhaps wait until it's expanded to `(quote 10)`.

I don't think `with-disappeared-uses` is the right idea here. The `pre-expand-export` function should attach `'disappeared-use` properties, `provide-trampoline` should propagate them and add more, and `provide` should propagate properties from expansions of `(expand ....)` clauses. I have that working, I think.

Merged (after moving the test case to the less friendly ".rktl" format) --- thanks!

Merged (after moving the test case to the less friendly ".rktl" format) --- thanks!

Merged (after adding a `history` annotation to the docs) --- thanks!

I hope to look closely in a day or two. Meanwhile, beware that you need to register new global variables with the GC before initializing them. For example, register `scheme_fixnum_p_proc` with `REGISTER_SO(scheme_fixnum_p_proc)` .

I added the `REGISTER_SO` and changed a `0` to `NULL`.

And, I just added a new commit/question. Most of the uses of `extflonum` are guarded by an `#ifdef`, but I think the variables are defined in all the cases. Is this necessary?

While trying to integrate this into TR, I hit a design issue that hadn't come up before.

Here's an example (that doesn't actually run right now) to illustrate the issue:

```
#lang racket

(module t typed/racket
  (struct parent ([x : String]) #:prefab)
  (struct child parent ([y : Integer]) #:mutable #:prefab)

  (: a-child Parent) ; subtyping
  (define a-parent (child "foo" 0))

  ;; exported with a contract for `parent` struct
  (provide a-parent))

(require (submod "." t))

;; the contract doesn't prevent this "bad" mutation
(struct parent (x) #:prefab)
(struct child parent (y) #:mutable #:prefab)
(set-child-y! a-parent "not an integer")
```

This example illustrates how a `prefab/c` isn't sufficient protection when exporting a prefab with a supertype of its actual type, because that doesn't protect the subtype fields.

One solution might be to add `#:substruct-accessor` and `#:substruct-mutator` options to `prefab/c` that allow a contract to be specified for the extra accessors/mutators that might exist (with the default being to do nothing). This is a little weird in the case that a non-prefab struct extends a prefab struct (surprisingly this is allowed in Racket), but in that case it can still find all the prefab parts of the struct hierarchy via `struct-info`.

Another would be to define a custom contract just for TR that basically does what I described above but only for TR. It could re-use `prefab/c`'s projection but also apply another layer of chaperoning.

Do either of these approaches make sense?

I think it makes sense to add that as an option to prefab/c.

Robby

On Wed, Mar 11, 2015 at 12:29 PM, Asumu Takikawa notifications@github.com
wrote:

> While trying to integrate this into TR, I hit a design issue that hadn't
> come up before.
> 
> Here's an example (that doesn't actually run right now) to illustrate the
> issue:
> 
> #lang racket
> 
> (module t typed/racket
>   (struct parent ([x : String]) #:prefab)
>   (struct child parent ([y : Integer]) #:mutable #:prefab)
>   (: a-child Parent) ; subtyping
>   (define a-parent (child "foo" 0))
>   ;; exported with a contract for `parent` struct
>   (provide a-parent))
> 
> (require (submod "." t))
> 
> ;; the contract doesn't prevent this
> (struct parent (x) #:prefab)
> (struct child parent (y) #:mutable #:prefab)
> (set-child-y! a-parent "not an integer")
> 
> This example illustrates how a prefab/c isn't sufficient protection when
> exporting a prefab with a supertype of its actual type, because that
> doesn't protect the subtype fields.
> 
> One solution might be to add #:substruct-accessor and #:substruct-mutator
> options to prefab/c that allow a contract to be specified for the extra
> accessors/mutators that might exist (with the default being to do nothing).
> This is a little weird in the case that a non-prefab struct extends a
> prefab struct (surprisingly this is allowed in Racket), but in that case it
> can still find all the prefab parts of the struct hierarchy via
> struct-info.
> 
> Another would be to define a custom contract just for TR that basically
> does what I described above but only for TR. It could re-use prefab/c's
> projection but also apply another layer of chaperoning.
> 
> Do either of these approaches make sense?
> 
> —
> Reply to this email directly or view it on GitHub
> https://github.com/plt/racket/pull/879#issuecomment-78312672.

Sadly this seems difficult to implement because you can't figure out which parts of the actual struct hierarchy you get from the struct instance are substructs of the type corresponding to the prefab key you're given.

That's because a struct type obtained from the key won't necessarily be equal to the struct type you get from the actual struct instance. The name in the struct type info doesn't help because you can easily get different structs with the same name (you can even have them in the same hierarchy!).

It would help if struct type information could tell you if the type is a prefab type and, if so, its prefab key. I don't think there's any way to do that currently though.

(also there's a question of what to do with transparent non-prefab substructs of a prefab struct... should fields in those be checked or not?)

This can now be closed, right?

@rmculpepper any thoughts on this?

@rmculpepper Thoughts?

What's the status here?

@stchang @rfindler what's the status here?

@jrslepak @rfindler has the status of this changed since May?

This ended up being done differently by @andmkent in racket/typed-racket#2.

This got merged/obsoleted.

@elibarzilay @khinsen What should happen to this PR?

@danking I'm going to close this; if you want to make this work again, feel free to re-open.

Sorry

I don't think so. Sorry I have not had time to do this myself.

@rfindler I've assigned this to you (just to keep track of who should review it when it's ready).

This looks like a good improvement in the error messages to me!

If you wanted to do more, I bet you could put the names of the arguments
into the messages and maybe put an \* next to the ones that have default
values?

Robby

On Wed, Nov 12, 2014 at 1:54 PM, Stephen Chang notifications@github.com
wrote:

> @rfindler https://github.com/rfindler, a few of us in the lab discussed
> this and concluded that the desired behavior (report only arguments from
> the call site) is not possible.
> 
> I think the current error message could still be improved, if only to add
> a position, and maybe some subset of the possible arguments.
> 
> The latter can be just the required arguments, or all the arguments
> including optional args. Note, however, that if optional args are included
> but not supplied, then the output will look something like this:
> 
> #lang racket
> (require racket/generic)
> (define-generics AA
>   [meth a AA c [d]])
> 
> > (meth 1 2 3)
> > plt-stchang/racket/collects/racket/private/generic.rkt:208:25: meth: contract violation
> >   expected: AA?
> >   given: 2
> >   argument position: 2nd
> >   other arguments...:
> >    1
> >    3
> >    'default-arg1285
> 
> —
> Reply to this email directly or view it on GitHub
> https://github.com/plt/racket/pull/821#issuecomment-62782298.

On Wed, Mar 11, 2015 at 3:13 PM, Asumu Takikawa notifications@github.com
wrote:

> Sadly this seems difficult to implement because you can't figure out which
> parts of the actual struct hierarchy you get from the struct instance are
> substructs of the type corresponding to the prefab key you're given.
> 
> That's because a struct type obtained from the key won't necessarily be
> equal to the struct type you get from the actual struct instance. The name
> in the struct type info doesn't help because you can easily get different
> structs with the same name (you can even have them in the same hierarchy!).
> 
> It would help if struct type information could tell you if the type is a
> prefab type and, if so, its prefab key. I don't think there's any way to do
> that currently though.

That sounds like a completely reasonable addition.

> (also there's a question of what to do with transparent non-prefab
> substructs of a prefab struct... should fields in those be checked or not?)
> 
> yeah. Not clear.

Robby

@shekari can you open this as a PR on the racket/typed-racket repo?

I moved this PR to racket/algol60#1.

@mflatt Does this look reasonable now?

> I bet you could put the names of the arguments into the messages and maybe put an \* next to the ones that have default values?

I dont see an easy way to do this unless I roll my own error msg formatting. I could use `raise-arguments-error` but then we would lose the position information. I'll explore some things and report back. 

On Thursday, March 12, 2015, Stephen Chang notifications@github.com wrote:

> I bet you could put the names of the arguments into the messages and maybe
> put an \* next to the ones that have default values?
> 
> I dont see an easy way to do this unless I roll my own error msg
> formatting.
> 
> Right.
> 
> I could use raise-arguments-error but then we would lose the position
> information. I'll explore some thing and report back.

I think what you have done is great and if you want to push it will help
people today.

If you wanted to make a better version of r-a-e that also worked for
keyword functions separately that would be double great!

> —
> Reply to this email directly or view it on GitHub
> https://github.com/plt/racket/pull/821#issuecomment-78617967.

I agree there's still room for improvement. Are `raise-argument-error` and `raise-arguments-error` implemented in Racket? I can't seem to find them.

It's "do_raise_error" in src/racket/src/error.c.

On Thu, Mar 12, 2015 at 4:31 PM, Stephen Chang notifications@github.com
wrote:

> I agree there's still room for improvement. Is raise-argument-error and
> raise-arguments-error implemented in Racket? I can't seem to find it.
> 
> —
> Reply to this email directly or view it on GitHub
> https://github.com/plt/racket/pull/821#issuecomment-78628343.

Ok I see it, thanks.

Another valid use case stemming from a discussion on #racket:

``` racket
(andmap true? lst)
```

I'm actually _perfectly_ find with `(andmap identity lst)`, but a few people on IRC disagreed with me, and either way, this would make things more explicit.

I'm pretty sure I've written (andmap values ...) before and I know I write
(filter values ...) with perhaps more regularity than one might wish for
(because the ellipses often begin (for/list....)").

On Fri, Mar 13, 2015 at 4:47 PM, Alexis King notifications@github.com
wrote:

> Another valid use case stemming from a discussion on #racket:
> 
> (andmap true? lst)
> 
> I'm actually _perfectly_ find with (andmap identity lst), but a few
> people on IRC disagreed with me, and either way, this would make things
> more explicit.
> 
> —
> Reply to this email directly or view it on GitHub
> https://github.com/plt/racket/pull/889#issuecomment-79447894.

Merged, thanks!

Merged, thanks!

Merged, thanks!

@samth: looks good

Merged, including a commit to remove the unneeded `MZ_LONG_DOUBLE`s.

Merged - thanks!

So to move forward, we need to figure out, whether quotient/remainder is/will be jitted?

@rmculpepper have a moment to review this?

So as not to make you read the code again: I put - #x8000 up to #x7fff, a two-byte signed range.

@mflatt  , have time to review this? It seems like a relatively uncontroversial change, I'll push it myself in 24 hours if I don't hear back.  Thanks!

I'd recommend `(module test racket/base)`, but ok otherwise.

@mflatt squash fail, wound up making two separate pushes, alas.

Merged, thanks!
I changed a `1L` to `(intptr_t)1` because I don't trust "L" to be long enough. For 64-bit Windows, `long` is the same as `int`, and I think `LL` might be needed to get to `intptr_t`; I'm not sure that's right, especially if the appveyor tests passed, but it seems safer to be explicit with `(intptr_t)`.

Merged, but in case you wonder why I changed "works well", it's because I'm unconvinced that fsemaphores are a good idea overall.
Thanks!

merged - thanks!

There is a pile of first-order check tests in tests/racket/contract/first-order.rkt.

Also, what do you think about making up some `barrier/c`s and passing them in to get a more accurate first-order check?

Just moving the note about "extra-pkgs" to a margin note makes it all seem right to me – visible enough to people who can use the information, but enough out of the way for others. Assuming that's ok, I'll push that adjustment (along with some other adjustments for style and consistency; please check that I didn't mangle anything).
Overall, this section has become distressingly long, but maybe there's a lower bound to how simple it can be to mix two complex systems.

@takikawa Ok by me. Nit: "which" should be "that" in the first paragraph of the docs.

Merged (a while ago)

It sounds like "scheme.h" should look for `__SSE2_MATH__`, instead of `__SSE_MATH__`, as an indication that SSE2 is available. Right?

merged

merged, but using `(or/c (=/c -1) ...)`

Yes, thanks for the update. I think that you should also change "-mfpmath=sse" to "-msse2 -mfpmath=sse" in the README.

Add the `barrier/c`s and moved the tests. I decided to delay the `barrier/c` creation as much as possible, not sure if that is better or not. 

I am wondering if perhaps there is a better way to do this. What if polymorphic->/c insisted that there was an arrow contract in its body, syntactically? So you could write

(let ([f (lambda (x) (-> x x))]) (polymorphic->/c (x) (f x)))

anymore, but you had to actually have the -> syntactically inside the polymorphic->/c. 

Then we could read the arity checks off of the syntax and not have to call that function and not have to deal with things like this:

(polymorphic->/c (x) (if (zero? (random 2)) (-> x x x) (-> x x)))

The issue that I think you are trying to solve is that `polymorphic->/c` can possibly have two different first order checks on different applications. But that problem is present in `if/c` as well. Also the syntactic check seems wrong as it prevents using `->*` or `case->`, or it allows some well defined list of accepted forms but then people cannot expand those. In addition it breaks backwards compatability in ways that may break TR program's contract generation.

Yes, the problem is present in `if/c`. But I'm not sure that that should stop us from fixing this problem.

And the syntactic check I had in mind would include checking for all arrow combinators.

But is there another reason you think this is a bad idea? Too much work? (That seems reasonable, actually.)

The issue is that it will break TR (and possibly other usecases of polymorphic->/c).

```
#lang typed/racket/base

(provide f)

(: f (-> (All (A) (Rec X (-> A X))) #f))
(define (f x) #f)
```

The body of the inner function turns into something like

```
(polymorphic->/c (a) (letrec ([x-typed ...] [x-untyped ...] [x-both ...]) x-untyped))
```

Which would not pass your proposed check.

Yes, it would have to have a different name than `polymorphic->/c` -- sorry I thought that, but didn't say it.

And I see that TR would have to change, but presumably that's in the "do more work" category.

Looking at the commit again, I think it should just be pushed. Do you want to do it, or shall I?

I can push it.

http://docs.racket-lang.org/guide/define-struct.html#%28part._struct-subtypes%29

makes it pretty clear, but that example, or equivalent, should probably be added to the reference for completeness.

I agree now that I look at it more closely. However, I think it should be mentioned explicitly that class methods are inherited verbatim.

> On Apr 21, 2015, at 23:57, bluerider notifications@github.com wrote:
> 
> I agree now that I look at it more closely. However, I think it should be mentioned explicitly that class methods are inherited verbatim.

agreed

Sorry for the long delay in getting back to this. 

The code looks okay to me.

Can you give a little more hint on how you expect TR to use this? In particular, I guess it will seal things when they cross the boundary into the untyped code. How does the unsealing work? That is, under which conditions will a class be unsealed (at a high-level)?

@rfindler Yes it'll get sealed going into untyped code. Unsealing happens whenever it flows back into the typed side, such as being returned from a mixin. So it'll be used like the barriers in `parametric->/c`.

Okay, but how do you know it is safe to unseal?

By safe you mean the thing is actually sealed? So you don't know this in general, which is why the unsealing errors (with blame if it's used for a contract) if the thing isn't sealed. Detecting this is actually important since (just like with ordinary polymorphism for functions) you don't want to let a function return an result that is "unrelated" to the input (i.e., not sealed) if it's supposed to return a parametric thing.

I somehow thought that subclassing was allowed on the untyped side, so
there must be something more going on there? I guess you put contracts on
the new methods when the class comes back across the boundary?

Does this mean there is now a linked representation for methods somehow in
a class?

Yeah subclassing is fine because seals are inherited. If it subclasses with methods that are not supposed to be there it will error though. The method representation doesn't change at all. It's just that there's a new chaperone property added onto the class (that is copied to the child in inheritance).

Okay, well I'm missing something, but I am pretty sure its just me being
dense.

Meanwhile, small nit, don't do this:

   (for ([f all-init-checkers]) ...)

put an `in-something` on there.

@rfindler I may also be explaining this poorly. It really does work mostly like `parametric->/c` does, though, but just where the positive and negative occurrences are replacing by either sealing or unsealing on classes.

In particular here is where TR defines the sealing function contract: https://github.com/takikawa/typed-racket/blob/sealing-ctc/typed-racket-lib/typed-racket/utils/sealing-contract.rkt

Thanks! Fixed.

The issue with `struct->vector` is that it's not marked as "noncm". I think it would be safe to use `scheme_make_noncm_prim` for that one, instead of `scheme_make_prim_w_arity`, and that would fix `values`.

I worry about dropping the arity checks in `rator_implies_predicate`. Does that allow `finish_optimize_any_application` to discard a call that would raise an exception?

So far, I don't see why `resolved` would be needed for `scheme_omittable_expr`. I'll have to try it out.

Nice!

I agree that it's fine to leave the checks as strings in this case, because it gets tedious to make a global variable for every function. Maybe there's a better way overall.

I worry a little about introducing `app_o` as an alias of `app` to avoid a cast. I've gotten into trouble with that pattern by later adding an assignment of the original (i.e., `app`) without noticing that I need to also change the alias (i.e., `app_o`).

Looks good to me.

I changed this to caution only about `with-handlers`, in response to @mflatt 's comment.

I amended the commit and force-pushed, because I figured that would effectively be the end result of rebasing and squashing. But that "sliced off" the commentary attached to the original commit, from this pull request. For reference, it's here: https://github.com/greghendershott/racket/commit/5c74d581f8952fa80c9fddabb11422b86951af6e#commitcomment-10952304

I see that `finish_optimize_any_application` is ok because it defers to `make_discarding_sequence`.

Dropping the `resolved` requirement for `make-vector` as omitable breaks validation because the validator can't reconsrtuct the optimizer's reasoning that `(make-vector <num> <const>)` will never fail. The `scheme_is_functional_nonfailing_primitive` normally reconstructs the optimizer's conclusion, but that function cannot handle the argument-sensitivity of the `make-vector` case. I think the solution is to extend `validate_expr` in the three places that it calls `is_functional_nonfailing_rator`.

I read `finish_optimize_any_application` more carefully and I added a check, so in a Boolean context an `<error>` is not wrapped as `(begin <error> #t)`.

There are still a few corner cases like the `make-vector` in

```
(if (if z 
        (make-vector (f z))
        (void))
    'a
    'b)
```

but they are more difficult to detect and I hope they are very unusual.

This seems to have an extra merge commit, and also to add a bunch of .css files and others.

samth: Not sure were those .css files are. Let me check. The extra merge commit is when I updated my fork against PLT/Racket master.

Submitted Pull Request #925

Must've occured when I ran raco scribble to check if the HTML doc was fine. I'll remove them

Not sure how to solve the merge commit though. Any help there?

You should rebase your branch that you're working on, and then do a force push to `bluerider:master`.

Okay, I rebased. Is it fine now?

Yes, the commits are fixed, thanks! That makes it much easier to review just the change you've made.

I improved the error message, by manually formatting it using `raise-arguments-error`. It reports all optional and keyword arguments and labels them. The rest arg is only displayed if present, but optional args are always shown.

The drawback is that the "other" args ellipses cannot be hidden. Also, the position is displayed as just an index and not an ordinal. If this is ok, I'll merge.

```
#lang racket
(require racket/generic)
(define-generics AA
  [meth1 a AA c [d] [e] #:reqkw req #:optkw [optkw]]
  [meth2 f g AA . restargs])
(meth1 "1" 'notAA 5 #:reqkw 4)
```

=>

```
meth1: contract violation:
expected: AA?
given: 'notAA
argument (0-base) pos: 1
other arguments...:
  a: "1"
  c: 5
  d (optional): 'default-arg850
  e (optional): 'default-arg850
  #:reqkw: 4
  #:optkw (optional): 'default-arg850
```

`(meth2 5 6 7 8 9 10)` 
=>

```
meth2: contract violation:
expected: AA?
given: 7
argument (0-base) pos: 2
other arguments...:
  f: 5
  g: 6
  rest args: '(8 9 10)
```

That looks great!!!

Arguments are base one in most other places, tho, so maybe change that?

-> (+ 1 'x 2)

; +: contract violation

;   expected: number?

;   given: 'x

;   argument position: 2nd

; [,bt for context]

-> (define/contract (f x y) (-> integer? integer? integer?) (+ x y))

-> (f 1 'x)

; f: contract violation

;   expected: integer?

;   given: 'x

;   in: the 2nd argument of

;       (-> integer? integer? integer?)

;   contract from: (function f)

;   blaming: top-level

;    (assuming the contract is correct)

;   at: readline-input:2.18

; [,bt for context]

Robby

On Wed, Apr 29, 2015 at 3:53 PM, Stephen Chang notifications@github.com
wrote:

> I improved the error message, by manually formatting it using
> raise-arguments-error. It reports all optional and keyword arguments and
> labels them. The drawback is that the "other" args ellipses cannot be
> hidden. Also, the position is displayed as just an index and not an
> ordinal. If this is ok, I'll merge.
> 
> #lang racket
> (require racket/generic)
> (define-generics AA
>   [meth1 a AA c [d] [e] #:reqkw req #:optkw [optkw]]
>   [meth2 f g AA . restargs])
> (meth1 "1" 'notAA 5 #:reqkw 4)
> 
> =>
> 
> meth1: contract violation:
> expected: AA?
> given: 'notAA
> argument (0-base) pos: 1
> other arguments...:
>   a: "1"
>   c: 5
>   d (optional): 'default-arg850
>   e (optional): 'default-arg850
>   #:reqkw: 4
>   #:optkw (optional): 'default-arg850
> 
> (meth2 5 6 7 8 9 10)
> =>
> 
> meth2: contract violation:
> expected: AA?
> given: 7
> argument (0-base) pos: 2
> other arguments...:
>   f: 5
>   g: 6
>   rest args: '(8 9 10)
> 
> —
> Reply to this email directly or view it on GitHub
> https://github.com/plt/racket/pull/821#issuecomment-97582779.

Ok I can fix the position.

Thanks!

Now:

`(meth1 "1" 'notAA 5 #:reqkw 4)`
=>

```
meth1: contract violation:
expected: AA?
given: 'notAA
argument position: 2nd
other arguments...:
  a: "1"
  c: 5
  d (optional): 'default-arg4574
  e (optional): 'default-arg4574
  #:reqkw: 4
  #:optkw (optional): 'default-arg4574
```

Very nice! :)

What about `rator`? Should I change it back to `app->rator`?

I think the idea here is good, but it doesn't currently render well. The long comment should be broken into two lines. I'd drop the last line (intended to be a comment?) 

Nit: I think a comma should appear before "since" in the first comment

All right. I've rebased and reworded the comment.

--This rebasing is causing me a headache --

All right. It's definitely rebased now properly. There's only one commit showing up.

I just made `app_o` local to reduce the problems of overwriting `app`. But I didn't change `rator=app->rator`.

There are a few commented primitives checks: `vector-copy!`, `vector->immutable-vector` and `vector-fill!`. It's possible to check them, but they are used very seldom. Should I remove them or uncomment them?  

Thanks for fixing the rendering problems! The second line is still long on my screen, but after further thought, I'd like to suggest text changes, anyway.

How about

   a 3d-posn has an x field, but there is no 3d-posn-x selector:

and

 use the supertype's posn-x selector to access the x field:

?

(I'm happy to adjust the patch after we arrive at text that we all like.) 

All right; I've updated the patch to use your suggestions verbatim.

Merged - thanks!

Merged - thanks!

Merged - thanks!

I change the definition of `struct->vector` to use `scheme_make_noncm_prim`. (Do you have an easy example of a primitive that really needs `scheme_make_prim_w_arity`?)

I also changed `validate_expr` to handle `(make-vector <number> x)`.

These changes are fine as far as I can tell.

The `hash-ref` function is a an example of one that is not non-cm, because it accepts a function argument that it calls in tail position. The `values` or `struct-info` functions are not non-cm, because they can multiple values.

Ok. I wouldn't bother with `vector-copy!`, etc., but I have no strong opinion.

Just to confirm, this is a great addition.

Merged - many thanks!

Fixed in c44cffe5a88c1221697cffe23dacaec42e976c4d

Does count accept multiple lists?

Well, I've just been shown on the IRC that it can accept multiple lists. filter should be replaced with filter-map then.

Fixed up to use filter-map instead of filter:
https://github.com/plt/racket/pull/927

Done, thanks.

Merged with 7d434d266e10744d27123ad91c75502e8951d488

Looks good to me!

The documentation for `string->url` should probably be updated as well to include the better regex in the contract.

Thanks! I pushed this commit.

Great, thanks for fleshing it out more, too.

This looks like a good improvement, but I wonder about encoding issues. The comment on the old version suggests that a string regexp was used so that it would only match a valid UTF-8 encoding. Does the new version need to defend against a bad encoding? Or is the implicit fixup by `get-output-string` (replacing bad encodings with "?") appropriate?

Currently, what happens in the old read-string is that it throws "unterminated string" when given non-UTF-8 text.  (The new read-string just replaces with "?")

<pre>
-> (require json)
-> (bytes 255 255 255)
#"\377\377\377"
-> (bytes->jsexpr #"\"\377\377\377\"")
; string::2: bytes->jsexpr: unterminated string [,bt for context]
</pre>

I'm not sure if either behaviour is ideal.  Alternatively, I could use `(compose bytes->string/utf-8 get-output-bytes)`, and have it toss a more descriptive exception when given invalid UTF-8, if that's better.

What do other JSON parsers do on this input?

On Tue, May 12, 2015, 12:30 PM Edward Lee notifications@github.com wrote:

> Currently, what happens in the old read-string is that it throws
> "unterminated string" when given non-UTF-8 text. (The new read-string just
> replaces with "?")
> 
> -> (require json)
> -> (bytes 255 255 255)
> #"\377\377\377"
> -> (bytes->jsexpr #"\"\377\377\377\"")
> ; string::2: bytes->jsexpr: unterminated string [,bt for context]
> 
> I'm not sure if either behaviour is ideal. Alternatively, I could use (compose
> bytes->string/utf-8 get-output-bytes), and have it toss a more
> descriptive exception when given invalid UTF-8, if that's better.
> 
> —
> Reply to this email directly or view it on GitHub
> https://github.com/plt/racket/pull/932#issuecomment-101340542.

Python's JSON parser tosses an UnicodeDecodeError.  I don't have anything else handy to test with right now.  I'll update the PR to do the equivalent thing -- use `(compose bytes->string/utf-8 get-output-bytes)`, and have it toss a more descriptive exception when given invalid UTF-8.

Merged - thanks!

Merged.

Merged.

Fixed.

This problem was fixed and merged by @mflatt in 04ce921e8fea57dee9df05ffdcb0ce6b08fb8ee6

This is somewhat intentional, so that the search query is remembered the next time you go to search. I also find it annoying, though, so I'd prefer to remove it.

This is a combination of two things:
1. Entering a string in the search box uses a url parameter to pass the search string to the search page.
2. All pages intentionally tweak URLs to keep any such parameters.  You can see that by going to `http://docs.racket-lang.org/?xxx=yyy` -- all links will have that at the end.

I don't remember the reason, but this was definitely intentional -- I remember that Matthew added this functionality at some point (I remember that at that point I stopped using the top-left search box, to avoid the sticky parameter).

Looks like this was added here: https://github.com/racket/scribble/commit/2eb8e4574f4ab2dad45d35b5e06a842036a49062 by @elibarzilay. I'm looking for discussion now.

I've been unable to find any discussion about this change from 2009, although I think I remember something about it.

Perhaps it was me who wrote the code, but I still don't like it...  In any case, there were several possible reasons for doing this: (1) there was the attempt to get to the docs from the teaching language in a way that remembers that context (so you won't find other documentation bits); (2) there was some potential mess if you have multiple versions (and that was somehow done with cookies, too, maybe?); and (3) there was the problem of remembering where to go back to if you start in a page in your local doc directory, then go to some page that is in the installation (and/or going in the other direction).

This is a bug somewhere, but probably you can avoid the bad code path by running "raco setup" with no arguments (and letting it fully complete).

I believe I fixed this with this commit: https://github.com/plt/racket/commit/a9ac3be43c8ba2ca83c9409a3e3f4847b2c599c6

Thanks! I've added this commit.

This is the code @rfindler and I developed in London to attempt to fix the test failure seen [here](http://pkg-build.racket-lang.org/server/built/test-fail/io.txt) in the "io" package. It's far from clear that this is the right fix, but it fixes the bug and doesn't break any other tests.

There might be more to this. I’ve been trying to rebuild from source today and I get hangs repeatedly at `raco setup: 3 making: <pkgs>/drracket/drracket/private/syncheck`.

FWIW, I rolled back to commit 39fda5ec9eac8bd17d276cc35e28c55ed66e9e64 and was able to build successfully.

That symptom doesn't seem especially related to the stacktrace or commit that I pushed, but it's hard to tell.

I don't suppose that if you run `raco make -v *` in the corresponding directory (and then hit control-c when it gets stuck) you get any more informative output?

I’ll try that if I come across the error again.

@rfindler or @takikawa, are you the right people to look at this?

The commit looks good to me.

Can you add a test case somewhere to demonstrate the difference with this change? Maybe in `tests/racket/contract/context` ?

I added a test in `tests/racket/contract/context.rkt` and fixed another test in `tests/racket/contract/or-and.rkt`.  

I haven't tested this or looked it over in detail, but the premise of the change looks good to me.

Shouldn't flags needed for preprocessing be in `CPPFLAGS` instead of `CFLAGS`?

See https://github.com/racket/compiler/pull/5

No, because the `-O` flags are part of the compiler, a real C preprocessor wouldn't support this type of flags. 

I think that passing `CFLAGS` to the proprocessor causes problems on some platforms and configurations, but I don't remember how it goes, exactly. (Maybe it has to do with platforms with a "real" preprocessor.) Given how many times I've been around that circle – where each time I end up concluding that `CFLAGS` and `CPPFLAGS` really are different and should not be confused – I'm reluctant to guess again.
Meanwhile, if `-D_FORTIFY_SOURCE=2` requires that `-O` is specified at preprocessing time, then `-O` must be a preprocessor option, so I think it's fair to require `-O` added to `CPPFLAGS` in that case. Note that all `CPPFLAGS` are passed to the C compiler.

I see your point. How about this?. The code would be in the section of Linux (FORTIFY_SOURCE is only available on glibc) within configure.ac and configure:

``` shell
if test "${CPP}" = "gcc -E" || test "${CPP}" = "clang -E" || test "${CPP}" = "cc -E" ; then
      OPTGREP=`echo "${CFLAGS}" | egrep -o '\-O[0-9]'`
      CPPFLAGS="${OPTGREP} ${CPPFLAGS}"
```

I've pushed this. Does it help, Alexis?

Yep, this works well! Thanks to both of you. I'll tweak my own error message slightly to fit this better, but this is definitely what I was looking for.

This error message is coming from the operating system. If you look up the error number, 13, you'll see that the text for it is "Permission Denied". http://www.virtsync.com/c-error-codes-include-errno

Almost certainly this means that you are not running as root (and thus don't have permission to bind that port) or possibly that another process has already bound it and you can't take it over.

You'll have to talk to your OS provider about a more exact message :(

Please use `_stdbool` instead of `_bool` to get a C99 boolean.

For more information, see http://lists.racket-lang.org/dev/archive/2014-April/014028.html

This is exactly what I need. No idea how I could have missed _stdbool. Thanks for clearing this up.

This looks great to me. Two requests:
- I think the library name should be `net/url-string` (i.e., single case, consistent with libraries like
  `racket/string` – granting that, unfortunately, `net/url-structs` didn't follow that convention).
- The `net/url` library should `(provide (all-from-out "url-string.rkt"))` instead of re-listing functions and
  adding an extra layer of contracts.

On 29/05/2015 21:53, Matthew Flatt wrote:

> This looks great to me. Two requests:
> 
>   *
> 
> ```
> I think the library name should be |net/url-string| (i.e., single
> case, consistent with libraries like
> |racket/string| – granting that, unfortunately, |net/url-structs|
> didn't follow that convention).
> ```
> 
>   *
> 
> ```
> The |net/url| library should |(provide (all-from-out
> "url-string.rkt"))| instead of re-listing functions and
> adding an extra layer of contracts.
> ```

Does (provide (all-from-out ...)) preserves the contract provisions?
That's the reason I chose to keep the provide/contracts as they were
passed up to net/url.

Tim

---

This email has been checked for viruses by Avast antivirus software.
http://www.avast.com

Yes, `(all-from-out)` keeps contracts.

The code is here: https://github.com/plt/racket/blob/master/racket/src/racket/src/read.c

I'm not sure how linking to that in the documentation would be explanatory, though.

@samth thanks for the pointer, I assumed reader was implemented in racket itself which is probably why I struggled with finding it.

> I'm not sure how linking to that in the documentation would be explanatory, though.

I guess I just really wished for some sort of intro how parser / compiler pipeline is set up and where relevant code lives.

Thanks

This happened to me once before. My ? fund had effects that were repeating.
Sam said don't do it and that it has to do with the reordering and
duplication in the match row algorithm.

Jay

On Tuesday, June 2, 2015, Robby Findler notifications@github.com wrote:

> The printouts you get from running this code show that the L4e? predicate
> is being called many many times on the same inputs, presumably because the
> predicates in the ? patterns can be called many times. This makes this
> function take exponential time.
> 
> I'm not sure if this is avoidable, but I have a vague memory of this
> coming up before and I don't see anything in the documentation about it.
> 
> The code below prints out a stream of numbers -- those numbers are the
> number of times that the same argument is supplied to L4e? and they get
> quite large. (4,379,424 is the maximum, I believe.)
> 
> #lang racket/base
> (require racket/match
>          racket/list)
> 
> (define ht (make-hash))
> (define (L4e? e-exp)
>   (hash-set! ht e-exp (+ (hash-ref ht e-exp 0) 1))
>   (printf "~a\n" (hash-ref ht e-exp 0))
>   (match e-exp
>     [`(,(? is-biop?) ,(? L4e?) ,(? L4e?)) #t]
>     [`(,_ ,(? L4e?)) #t]
>     [`(new-array ,(? L4e?) ,(? L4e?)) #t]
>     [`(new-tuple ,(? L4e?) ...) #t]
>     [`(aref ,(? L4e?) ,(? L4e?)) #t]
>     [`(aset ,(? L4e?) ,(? L4e?) ,(? L4e?)) #t]
>     [`(alen ,(? L4e?)) #t]
>     [`(print ,(? L4e?)) #t]
>     [`(make-closure ,(? symbol?) ,(? L4e?)) #t]
>     [`(closure-proc ,(? L4e?)) #t]
>     [`(begin ,(? L4e?) ,(? L4e?)) #t]
>     [`(closure-vars ,(? L4e?)) #t]
>     [`(let ((,(? symbol?) ,(? L4e?))) ,(? L4e?)) #t]
>     [`(if ,(? L4e?) ,(? L4e?) ,(? L4e?)) #t]
>     [`(,(? L4e?) ...) #t]
>     [(? L3v?) #t]
>     [_ #f]))
> 
> (define (is-biop? sym) (or (is-aop? sym) (is-cmp? sym)))
> (define (is-aop? sym) (memq sym '(+ - *)))
> (define (is-cmp? sym) (memq sym '(< <= =)))
> (define (L3v? v) (or (number? v) (symbol? v)))
> 
> (printf "starting\n")
> (time
>  (L4e? '(let ((less_than (make-closure :lambda_0 (new-tuple))))
>           (let ((L5_swap (make-closure :lambda_1 (new-tuple))))
>             (let ((L5_sort_helper (new-tuple 0)))
>               (begin
>                 (aset L5_sort_helper 0 (make-closure :lambda_2 (new-tuple L5_sort_helper L5_swap)))
>                 (let ((L5_sort (new-tuple 0)))
>                   (begin
>                     (aset L5_sort 0 (make-closure :lambda_3 (new-tuple L5_sort_helper L5_sort)))
>                     (print (let ((f (aref L5_sort 0)))
>                              ((closure-proc f)
>                               (closure-vars f)
>                               (new-tuple 3 1 9 4 5 6 2 8 7 10)
>                               less_than)))))))))))
> 
> —
> Reply to this email directly or view it on GitHub
> https://github.com/plt/racket/issues/952.

## 

Jay McCarthy
http://jeapostrophe.github.io

```
       "Wherefore, be not weary in well-doing,
  for ye are laying the foundation of a great work.
```

And out of small things proceedeth that which is great."
                          - D&C 64:33

On Tue, Jun 2, 2015 at 11:23 AM, Jay McCarthy notifications@github.com
wrote:

> This happened to me once before. My ? fund had effects that were repeating.
> Sam said don't do it and that it has to do with the reordering and
> duplication in the match row algorithm.

Yeah, that makes sense to me.

So I"ll wait for "official confirmation" and then suggest that we explain
this super clearly in the docs so hopefully others don't run into this
pitfall.

Robby

The documentation of 'match' says this at the bottom: "Note that the
matching process may destructure the input multiple times, and may
evaluate expressions embedded in patterns such as (app expr pat) in
arbitrary order, or multiple times. Therefore, such expressions must
be safe to call multiple times, or in an order other than they appear
in the original program."

Jay

On Tue, Jun 2, 2015 at 12:25 PM, Robby Findler notifications@github.com wrote:

> On Tue, Jun 2, 2015 at 11:23 AM, Jay McCarthy notifications@github.com
> wrote:
> 
> > This happened to me once before. My ? fund had effects that were
> > repeating.
> > Sam said don't do it and that it has to do with the reordering and
> > duplication in the match row algorithm.
> 
> Yeah, that makes sense to me.
> 
> So I"ll wait for "official confirmation" and then suggest that we explain
> this super clearly in the docs so hopefully others don't run into this
> pitfall.
> 
> Robby
> 
> —
> Reply to this email directly or view it on GitHub.

## 

Jay McCarthy
http://jeapostrophe.github.io

```
       "Wherefore, be not weary in well-doing,
  for ye are laying the foundation of a great work.
```

And out of small things proceedeth that which is great."
                          - D&C 64:33

Oh, I missed that.

I'd suggest something next to the specific ? case that has an example that
demonstrates bad behavior, tho.

This is an example that doesn't demonstrate the problem and I don't get why.

```
#lang racket

(define (bt? x)
  (printf ">> ~s\n" x)
  (match x
    [(cons (? bt?) (? bt?)) #t]
    [_ (number? x)]))

 (bt? (cons (cons (cons 1 2)
                  (cons 3 4))
            (cons (cons 5 6)
                  (cons 7 8))))

```

That program doesn't use `(? bt?)` in multiple match clauses.

However, I think I can fix `match` to call the function many fewer times in @rfindler's example. Working on that now.

Just a small bump and a request for this to be merged, so long as everything looks fine (which so far appears to be the case).

I've pushed it. Sorry for the delay.

No problem; thanks for merging it.

Thanks! I've pushed the commit.

Merged - thanks!

After thinking about it a lot more, I'm inclined to blame autoconf's selection of `CC`, `CPP`, `CFLAGS`, and `CPPFLAGS` – and try to fix things up at that level:

https://github.com/mflatt/racket/commit/7dee02f3735ce2d91a569d4fe9ce6ef8df34c245

In other words, if a programmer specifies any of the first three, the programer takes on the burden of keeping the C compiler consistent with the preprocessor. Otherwise, we make automatic selection set the flags in a way that is consistent with how the tools work.

How does that look?

Can I provide `url-regexp`? (I won't merge until #948 gets merged.)

I think it would be a good idea

Yes, that looks better. Feel free to commit the change. 

Indeed, in my local testing, forwarding the `connected?` method
to the connection in the `kill-safe-connection%` proxy resolves 
the issue with subsequent queries throwing the "not connected"
exception.

```
0  /home/xyh/lang/racket/racket-git 
bl
* master                 26e1dd0 [origin/master] xform: fix character parsing
  remotes/origin/HEAD    -> origin/master
  remotes/origin/master  26e1dd0 xform: fix character parsing
  remotes/origin/release fcfe988 keep ".LOCKpkgs.rktd" for source install
  remotes/origin/stable  091d996 Merge branch 'stable' into release
0  /home/xyh/lang/racket/racket-git 
```

and it is archlinux that I am using.

I've pushed a fix to the racket/db repo (racket/db@66044af5a58a41252f4698a2029769b2a903f6fd). The main problem was that `last-connected?` was not getting updated on error; the fix for that was to change the `begin0` to a `dynamic-wind`. The `connected?` method must not block, so I made it forward only if the connection is not in the middle of another method; otherwise, it uses `last-connected?`. Let me know if you still see problems.

Thanks! I’ve deployed this into our environment. 

> On Jun 6, 2015, at 10:24 AM, Ryan Culpepper notifications@github.com wrote:
> 
> I've pushed a fix to the racket/db repo (racket/db@66044af https://github.com/racket/db/commit/66044af5a58a41252f4698a2029769b2a903f6fd). The main problem was that last-connected? was not getting updated on error; the fix for that was to change the begin0 to a dynamic-wind. The connected? method must not block, so I made it forward only if the connection is not in the middle of another method; otherwise, it uses last-connected?. Let me know if you still see problems.
> 
> —
> Reply to this email directly or view it on GitHub https://github.com/plt/racket/issues/957#issuecomment-109620543.

Thanks for the report! More recent commits should fix this bug.

it builds now. god bless racket.

I don't think that I'm right for dealing with this: I wrote what I think about it above -- mainly, that the the `/mac` version is supposed to be internal (it is made public in this commit without documentation, BTW) and if there's any real need for this then it would be much better to extend the unix facility instead of adding more specific configuration to something that is already a pile of messy configurations.

(FWIW, and without any real OSX experience, unifying with the unix thing could also make sense in making it easy to deal with unix-y browsers that people might use on a Mac, if there are any.)

I don't mind exposing it as the arguments for exposing seem reasonable. But
not without documentation! And it also seems good to check that we are on
Mac OS X and perhaps other checks that are appropriTe now that the function
is directly callable.

Robby

On Monday, June 8, 2015, Eli Barzilay <notifications@github.com
<javascript:_e(%7B%7D,'cvml','notifications@github.com');>> wrote:

> I don't think that I'm right for dealing with this: I wrote what I think
> about it above -- mainly, that the the /mac version is supposed to be
> internal (it is made public in this commit without documentation, BTW) and
> if there's any real need for this then it would be much better to extend
> the unix facility instead of adding more specific configuration to
> something that is already a pile of messy configurations.
> 
> (FWIW, and without any real OSX experience, unifying with the unix thing
> could also make sense in making it easy to deal with unix-y browsers that
> people might use on a Mac, if there are any.)
> 
> —
> Reply to this email directly or view it on GitHub
> https://github.com/plt/racket/pull/421#issuecomment-109875310.

@elibarzilay: In today's computing world, I don't think "Unix" is a good platform category any more. MacOS and Android are technically members of the Unix family, but both add a user interface layer that has nothing in common with the X11-based approach of traditional Unices.

MacOS distinguishes between systems-level processes and user-level applications. The first are handled like in other Unices, the second are something different. MacOS browsers live in the high-level layer. I am not sure that browser handling in MacOS and traditional Unices can be unified into something that makes sense from a user's point of view. It's probably more reasonable to unify the Mac and Windows ways of addressing browsers.

@rfindler: All very valid points of course!

Re "unix", the point there is that the unix version of `send-url` uses a command-line configuration.  Even with the mac thing that you're talking about, the bottom line is that it does use a command-line to start the browser.  This has nothing to do with X, and therefore the point still stands.

Detailed explanation follows, most likely repeating stuff I previously wrote.  The actual work is likely to be shorter then this text.

I don't see how an exposed `send-url/mac` can be a good thing.  What would it be useful for?  On one hand, current clients of the library use `send-url` and therefore this will have no effect on them.  If you do envision adapting existing clients (like DrRacket) to use it, then that means that the decision of "are we on a mac" is pulled out of the library and into the client.  It's true that you can do this with setting the `external-browser` parameter, but that would require the client to have a hook that allows you to initialize it (in the DrR case, that would probably be done by some tool).  If the tool is installed/loaded automatically, then it's the problem of the decididing code being duplicated in several places, and if it's left for the user to install then it's a worse place for doing the decision.  On the other hand, new client code would often suffer from the same problem: for example, any application that uses `send-url` will need some "startup configuration file" feature so people can set the parameter before the application runs.

(As a side note, I'm half-guessing that the existence of the `external-browser` parameter is what made you go down this path -- but it's not a good way to configure the browser since it receives an arbitrary function.  For example, you generally want a configuration that can be saved in the preference file, which you can't with a random function.  IIRC, the reason for that parameter was from the days of using the racket browser ("scheme" browser, since it came from prehistoric times), where the documentation pages were shown with it, but other pages would invoke a proper browser.)

Worse, you'd probably want some preference to set the browser application name -- and that would need to be done in each client too.  But that would be too insane; the right way would be to further add functionality _in_ the library to set this preference.  The thing is that this adds more complexity, which itself is similar to the complexity that is already there in the `/unix` version.

IMO (the "M" is important), a proper way to fix this would be:
- Start with the unix configuration -- it suffers from a hack which is a hard-wired list of executable names, but the configuration itself can be used in any environment that uses a command-line to invoke a browser.
- Clean it up.  I don't remember the details, but at some point I did play with the idea of doing this.

This should result in a generic interface that has several parts:
- Find the list of available browsers, specific to each OS.  I'm guessing that doing this on a mac would be similar to _modern_ linux: dig through some OS list of browsers that can handle urls (on linux, this would use `xdg-mime`)
- For each, there should be some user-presentable name, which should be shown in the preferences dialog, and some string to store in the preferences file (maybe a path to some desktop file in linux, and an application name on a mac)
- Then, the generic `send-url` would dispatch to the platform version which would consult this value to do its work.
- Also, make it possible to use the arbitrary command-line "backdoor" on all platforms, possibly extending it (like using different `%` things for different URL encodings and/or indicating whether things like a trampoline page should be used).

The main thing in all of this is that `send-url/mac` is kept as an internal private function.

@elibarzilay I think I see your point, and I agree with it in principle. The fundamental question is where the decision about browser configuration happens. For GUI programs such as DrRacket, it should happen as part of the program's preferences, set once by the user and saved in a file. Whatever browser mechanism exists at the level of Racket libraries happens at a lower level, so it's up to the GUI layer on top of it to handle OS dependencies.

What you propose looks like a good approach to provide better library support for configurable GUI applications. I am all for it, but I don't have the competences to design or implement such an API. I wouldn't want to use it either, as I don't write configurable GUI programs.

My proposition to expose `send-url/mac` aims at a very different use case: writing special-purpose scripts that simply open a given URL in a given browser. I tried to use `send-url` with `external-browser` initially, but never got anything to work under MacOS. The mechanism of `external-browser` doesn't fit MacOS, where applications  live in a different namespace than paths to executables.

So my ideal solution would be a generic `send-url` using a platform-specific browser specification instead of the Unix-centric `external-browser`. For MacOS, the browser specification should be just a string naming the application.

Note: The reason it fails on Travis/Linux is because Linux defines a different set of signal constants than OSX does. We should use a smaller set of signals which is guaranteed to be defined everywhere.

EDIT: the offending signals are `SIGINFO` and `SIGEMT`

Can I get some feedback on this and/or get it merged?

ptr-add seems to leave the pointers tag the same, which is undesired. I don't see an easy way to allocate a new pointer. Should it just be `(cast val _pointer _pointer)`?

Is this pull request waiting on me for anything?

@tim-brown: Assuming we agree on the changes, did you already make a patch with the library name changed to `net/url-string` and re-exporting from `net/url` without an extra contract layer? I was hoping that you'd update the pull request with those changes (but haven't pressed or tried to do it myself, because I've been occupied over the past couple of weeks). Thanks!

This looks good to me.

This looks good to me. In particular, I detect no problems with the shifts.

In the implementation of intersection, I think it would be a little clearer to set `base_pred` to NULL when `base_types` is NULL – or somehow avoid the relatively subtle invariant that `base_pred` is still initialized to NULL when `base_types` is NULL.

I mostly worry about the "magical" downside. A related downside is that `(apply and (list e1 e2))` would not be the same as `(and e1 e2)` for all `e2`, which seems awkward.

As extra fodder for discussion: Would it make sense to have non-short-circuiting variants of `and` and `or` using different names? For the sake of discussion, we might call them `and*` and `or*`. That way, there's no issue with different behavior in first-order and higher-order applications. We might even adjust the `and` and `or` macros to suggest `and*` or `or*` when used in a non-application position (and when those identifiers are bound at the use site?).

I'll merge this, but with two extra tests to provide multiple elements to `stream*`.

Good – thanks! I think tests go in "name.rktl".

Thanks for the patch! I like the idea of `subprocess-signal`, but I'd like to look more into how the set of supported signals can be generally portable and complete (where the latter might mean accepting numerical values as well as symbols). I can't get to it just now, but I'll hopefully be able to follow up soon.

Yes, casting seems like the right way to drop tags.

Is there much of a compatibility issue here with defining new names? Offhand, I think that conflicts are unlikely, but I thought I'd mention it, just in case.

I can see how this would be useful. The shorthand doesn't quite feel worthwhile to me, but I have no technical objection, and I'm willing to be overridden or outvoted. Do others find this useful enough to merge?

Merged – thanks!

Do the `Scheme_Hash_Tree` have a method to count the number of items in them? Is this method O(n) or O(1)? 

I guess that the `else` brach usually adds less information than the `then` branch, so I use the `f_tree` in the outer loop and I use `hash_tree_get` to see if the item is in the `t_tree`.

Merged – thanks!

Merged – thanks!

I think it's too specific to be included, but I'm a bit of an RTFM
curmudgeon.

Jay

On Sat, Jun 20, 2015 at 9:57 AM, Matthew Flatt notifications@github.com
wrote:

> I can see how this would be useful. The shorthand doesn't quite feel
> worthwhile to me, but I have no technical objection, and I'm willing to be
> overridden or outvoted. Do others find this useful enough to merge?
> 
> —
> Reply to this email directly or view it on GitHub
> https://github.com/plt/racket/pull/930#issuecomment-113770627.

## 

Jay McCarthy
http://jeapostrophe.github.io

```
       "Wherefore, be not weary in well-doing,
  for ye are laying the foundation of a great work.
```

And out of small things proceedeth that which is great."
                          - D&C 64:33

Would it help the guide exposition to use something like this?

Robby

On Sat, Jun 20, 2015 at 9:11 AM, Jay McCarthy notifications@github.com
wrote:

> I think it's too specific to be included, but I'm a bit of an RTFM
> curmudgeon.
> 
> Jay
> 
> On Sat, Jun 20, 2015 at 9:57 AM, Matthew Flatt notifications@github.com
> wrote:
> 
> > I can see how this would be useful. The shorthand doesn't quite feel
> > worthwhile to me, but I have no technical objection, and I'm willing to
> > be
> > overridden or outvoted. Do others find this useful enough to merge?
> > 
> > —
> > Reply to this email directly or view it on GitHub
> > https://github.com/plt/racket/pull/930#issuecomment-113770627.
> 
> ## 
> 
> Jay McCarthy
> http://jeapostrophe.github.io
> 
> "Wherefore, be not weary in well-doing,
> for ye are laying the foundation of a great work.
> And out of small things proceedeth that which is great."
> - D&C 64:33
> 
> —
> Reply to this email directly or view it on GitHub
> https://github.com/plt/racket/pull/930#issuecomment-113771263.

Oh, I like the "different names with a note in the error message approach"! That's a great idea.

Is there a reason not to make this a new package?

If it's not bound at the use site, can we make the error message describe how to get it?

> [...] For GUI programs such as DrRacket, it should happen as part of the program's preferences, set once by the user and saved in a file.

Right -- in the form of the preference file, which is already done for Unix (being the only platform where there is a need to save a user choice).  (And this is only because of the inherent indecisiveness of an open-source platform, where there are OS-wide ways similar to Mac/Windows, but there was no clear winner for a long time.  That's why I raised XDG as something that should probably be the default there too.)

> My proposition to expose `send-url/mac` aims at a very different use case: writing special-purpose scripts that simply open a given URL in a given browser.

Did you have any need to actually use it rather than writing your own quick helper that ran the appropriate command-line?  I can see some situations where this would be needed -- like using `send-url/contents`, or `.../file`, and if that's what you wanted then you really are looking for a proper extension in the library.  But if you wanted just to fire off a browser pointing somewhere and you're doing your own private scripts then IMO such a helper is perfectly fine -- you're not in a situation where you need it to work everywhere anyway, which is an important point in the sendurl library.

> I tried to use `send-url` with `external-browser` initially, but never got anything to work under MacOS. The mechanism of `external-browser` doesn't fit MacOS, where applications live in a different namespace than paths to executables.

(Yeah, I suspect that `external-browser` is not a good idea in general.)

> So my ideal solution would be a generic send-url using a platform-specific browser specification instead of the Unix-centric `external-browser`. For MacOS, the browser specification should be just a string naming the application.

I think that you're confusing `external-browser` as the Unix thing -- it's not.  Rather, it's a generic way to say what you want to happen when a browser is launched through a function that you set in a parameter, with the problem of not being able to store it as a preference.  The Unix related stuff that I was talking about is just the ability to choose from a list of browsers, each with its own command-line pattern -- you can see that in the `send-url/unix` function.  That's the thing that should be generalized a bit and used on Macs too, and there, it happens that most of these command-line templates are running osascript with the name of the browser (IIUC, at least).

@rfindler Greatly, I think. Making the guide show how to use syntax parameters for the common use case and then showing the more general syntax-parameterize equivalent form would help readability

@samth No technical reason. I've personally found this to be the main use case for syntax parameters, and making the syntax system simple to use in the common case would be valuable for those learning it. But that is a personal position, and I am fine putting this in a package.

I personally like the magic, since it doesn't have any downsides for those aware of it, but I also recognize the potential confusion, so `and*` and `or*` would still be nice to have.

Well, we strive to make Racket work well for people who don't already know
the magic (as much as we can).

On Sat, Jun 20, 2015 at 6:03 PM, Jack Firth notifications@github.com
wrote:

> @rfindler https://github.com/rfindler Greatly, I think. Making the
> guide show how to use syntax parameters for the common use case and then
> showing the more general syntax-parameterize equivalent form would help
> readability
> 
> https://github.com/samth

Dare I challenge you to put your money where your mouth is with an expanded
pull request to show us just how awesome it would be?

:)

You're on :)

From a certain perspective, I agree. It would be absolutely possible to add magic in places where magic does not belong, to the point of making the language incomprehensible to newcomers. That said, it is my opinion (and nothing more than opinion) that the advantage of the magic in this case is a big enough win to warrant it, especially since I'd find it unlikely that a user would stumble upon it accidentally in 99% of use-cases.

I suppose one could make an argument for a "limited" version of the language with less magic that would be more accessible to beginners. Of course, we actually already have that: `htdp/*sl`. BSL, for example, turns off the `cons` → `list` magic. Racket, on the other hand, provides a number of conveniences for the sake of the experienced programmer.

But again, that's my opinion, and I completely understand the argument that there's a rather big difference between `cons` cells printing differently and `and`/`or` behaving in different ways in different usages. The general consensus seems to be that adding separate strict versions would be preferable, and I'd be more than happy to go that route instead.

Thanks, Alexis, for your thoughts and your flexibility.

I did start writing my own helper function. That turned out to be much more complicated than I thought, and the Racket documentation about `external-browser` and friends was not very helpful. So I decided to package my solution as a pull request to make it available to others.

I agree that `external-browser` is not unix-specific from a design point of view. But the support code available for using it is not of much practical use elsewhere. My pull request is just that: support code to make `external-browser` easier to use on the Mac.

> I agree that `external-browser` is not unix-specific from a design point of view. But the support code available for using it is not of much practical use elsewhere. [...]

Yes, and like I said, I think that it's generally not useful at all as a setting, since you can't save a random value put into it, and given that there's no gui-ish way to set it.

Anyway, why was it complicated to write a helper?  IOW, why wasn't it just a matter of calling osascript with a different command line?  (Which is what your chage did, IIRC--?)

As so often, it's not the solution that's complicated, but the process of getting there. The Racket documentation leads to you `external-browser` but provides no help for implementing the required function. I found it only by studying the source code of the Racket standard library. Users shouldn't have to dig that deep for solving a simple task.

> [...] The Racket documentation leads to you `external-browser` but provides no help for implementing the required function. I found it only by studying the source code of the Racket standard library. Users shouldn't have to dig that deep for solving a simple task.

Ah -- you're talking about a _documentation_ bug where the procedure case is not mentioned.  That definitely sounds like something that should be fixed.  But IMO the fix should mention that _and_ say that it's not really useful to set it to a procedure since it can't be saved as a preference (in addition to not being mirrored in the preferences dialog, which might be applicable for Macs too if its fixed).

It's not only the documentation of `external-browser` that needs to be improved. It isn't obvious either how "open this URL in that browser" can be implemented in Racket. I doubt many Racketeers know about osascript and how to use it from Racket code.

I added some tests and a draft of the documentation changes.

I also changed `scheme/unit` to `racket/unit`. Is this ok?

I still don't like the new redaction of the docs, and I couldn't typeset correctly `(#<void> . #<void>)`. I propose to squash and merge all but the docs changes, and perhaps you can later fix the docs.

My feeling is that the magic isn't so bad here, and in keeping with other areas of Racket where similar magic happens: `in-range` in `for` loops, keyword argument function warnings.

I think the change @lexi-lambda proposes would continue to work well (better, really) for people who don't know the magic.

(add1 @samth)

On 06/22/2015 12:25 PM, Sam Tobin-Hochstadt wrote:

> My feeling is that the magic isn't so bad here, and in keeping with
> other areas of Racket where similar magic happens: |in-range| in |for|
> loops, keyword argument function warnings.

I disagree. It's a bad idea to have an expression that changes its 
meaning depending on whether it's used in operator position: eg,

   (or 1 (/ 0)) => 1
   ((values or) 1 (/ 0)) => error
   (let ([f or]) (f 1 (/ 0))) => error

That's not the same as in-range; for detects direct uses of in-range 
(and others) to expand into a different (more efficient) implementation 
of the same behavior.

It's also different from constructs like method names within a class 
body. Method names are not expressions; they can only be used in 
operator position. (But allowing method names used in non-operator 
position to expand into the appropriate lambda expression would be okay, 
because it would be consistent with their behavior in operator position.)

Ryan

I'm with Ryan on this point overall, but I strongly agree that the
situations Sam suggests are not well characterized by the phase "similar
magic".

Robby

Ok I'll try that. 
Edit: this was in reply to this comment: https://github.com/AlexKnauth/racket/commit/2096f142d9d0584e2b2b951359f929b1d95442c9#commitcomment-11802083

Merged, thanks!

Merged, thanks!

@rmculpepper 
Does this look better?

A screenshot:
![screen shot 2015-06-23 at 12 56 43 am](https://cloud.githubusercontent.com/assets/6600123/8299185/eb34f304-1942-11e5-8a28-80ce45144c20.png)

I just changed the intersection method to make the use of `NULL` clearer and I use `tree->count` to select the smaller tree. The other commits are unchanged. 

Looks good to me.

Looks good.

I've added documentation and a contract and pushed this. Thank you.

Looks ok to me.

Merged - thanks!

Thanks! I'll copy the change to the source "configure.ac" and merge the change.

These changes look good to me.

LGTM

merged

This is great! Thanks for getting this started.

On the three questions:
1. I'm in favor of changing the name, as long as we also change all clients.
2. I think we should make a new package called "list-extra" or something like that, and put the remaining functions there. Then TR etc can depend on that package. But maybe looking at the functions individually makes more sense.
3. I agree with your plan for keeping the pkg.

1. The clients I found are TR and `refined-acl2`. We can change the former, and I can submit a PR to the latter.
2. The remaining functions are:
   - `filter-multiple`: one use, in TR
   - `extend`: a few uses, in TR. IMO, the name is too general (a lot of code uses it to mean other things, including other parts of TR), and the function is of limited usefulness, so I'd be inclined to just move it to TR, and rename it.
   - `map/values`: one use, in TR. Also, `for/lists` covers most of its use cases.
   - `map2`: one use, in `minipascal`. Special case of the above.
     Given that this is all that's left, and that those functions are not (IMO) very compelling, I'm not sure we'd want a new package for them.
3. Good. How do I remove it from the main-distribution roster?

Oh, and 4., which I forgot to bring up:
- Some of the functions I moved to `racket/list` may make more sense in `racket/base`, to be with similar functions. `list-update` and `list-set` feel like they belong with `list-ref`, and `remf` and `remf*` feel like they belong with `remove` and `memf`. Thoughts?

Update:
- Moved `unstable/hash`.
- Decided against moving `unstable/bytes` (only two packages use it, and there was disagreement on its usefulness in the comments). I have updated its uses to remove the dependency, and will submit PRs once this one gets in.
- Waiting on @rmculpepper's input re what to do with `unstable/class-iop` (he's its author and sole user). That's the last collection in `unstable-list-lib`.
- Changed `check-duplicate` to `check-duplicates`. Undecided on the name, as there is both a `remove-duplicates` and `check-duplicate-identifier`, so it's not clear which one to align to.
- Fixed all packages that use `unstable-list-lib` to remove the dependency (with the exception of those that use `unstable/class-iop`). I will send pushes and PRs once this one gets in.

merged - thanks!

merged - thanks!

This is an old bug, but let me give an update: this is “fixed” in the sense that Racket no longer ships out of date WebSocket support because it’s been outright removed from the core. The rfc6455 package implements an up-to-date version of the protocol. This issue should likely be closed, but it might be worth looking into pulling that implementation back into the core to replace the removed version.

I've pushed a repair. Thanks for the report!

- If we're not moving `unstable/bytes` (which seems fine to me) we should still get rid of it in this package.
- I would create the PRs now for other repos so that we can see what they'll look like.
- I think similarity with `remove-duplicates` is more compelling than `check-duplicate-identifier`, which is a lot more specialized.
- I think adding more things to `racket/base` should be avoided.
- For the various list functions:
  - `extend` is a terrible name, and not a very useful function. Haskell's list libraries may have a better name, but either way we should just confine this to TR.
  - I like `filter-multiple`, and would keep it.
  - I agree about `map/values`.
  - `map2` seems more likely to be useful. @soegaard, what do you think, since it's used in minipascal?

To remove things from `main-distribution`, just take them out of the relevant `info.rkt` file.

Looks good.

Should I rebase and push this to the main repository, or do you want to do more tests?

You can push it now. The fact that the Travis PR tests work is all that could be tested, really. :)

- Re `unstable/bytes`: I'm not sure I understand what you mean. My plan is to remove all uses of it, but leave it in the `unstable-list-lib` package (which still provides everything it always has, though now mostly with re-exports), which would be out of the main distribution, and so not generally available. That course of action has the advantage of preserving backwards compatibility. Are you suggesting that we remove `unstable/bytes` altogether?
- Re PRs: They're all ready. IIRC (wrote them on Friday), they're mostly removing/changing `require`s. I'll send them out today.
- Re `filter-multiple`: It took me a few reads of the documentation to figure out what it did, so I don't think the interface is great. I'm also not fond of the name, since it feels closer to `partition` than to `filter` to me. Let's leave it out for now, and feel free to submit another PR to include it.
- Re `map/values` and `map2`: Both can be replaced by `for/lists`, so I don't think we're losing much.

- `unstable/bytes`: I'm agreeing with you.
- `filter-multiple`: it's not like `partition`, because input elements can end up in multiple output lists. A better name is welcome. But I'm happy to do whatever you prefer here.

2015-07-20 15:28 GMT+02:00 Sam Tobin-Hochstadt notifications@github.com:

>    -
>       - map2 seems more likely to be useful. @soegaard
>       https://github.com/soegaard, what do you think, since it's used
>       in minipascal?
> 
> I don't know. I had to look up what it did. If I recall correctly, I wrote
> the equivalent of map2 for MiniPascal. Then stumbled upon map2 in unstable
> the day after - and used that instead.

/Jens Axel

@samth: Let's think of a better name for `filter-multiple` (and maybe a better interface) and revisit the question.

@soegaard: FWIW, I have a PR forthcoming that replaces it with `for/lists`.

Merged.

I think it is very good to thin out the core packages so we can just get what is needed per installation.

I think there are good arguments on both sides here. Shipping a small standard library reduces installation size, and allows people to choose what they need and experiment with different versions of the library.

On the other hand, choosing something for the standard library makes it easy for people to agree on a "standard" version of the package to coordinate community effort, and makes it easier for new people to learn how to use web sockets in Racket. 

I think this is ready to merge... AppVeyor is complaining about something in places -- I don’t think it’s my fault.

Looks fine to me

Yes, that error from AppVeyor is unrelated.

> On Jul 21, 2015, at 10:40 AM, Sam Tobin-Hochstadt notifications@github.com wrote:
> 
> I think there are good arguments on both sides here. Shipping a small standard library reduces installation size, and allows people to choose what they need and experiment with different versions of the library.
> 
> On the other hand, choosing something for the standard library makes it easy for people to agree on a "standard" version of the package to coordinate community effort, and makes it easier for new people to learn how to use web sockets in Racket.

FWIW, both DuckDuckGo and Google find

http://pkg-build.racket-lang.org/doc/rfc6455/index.html

… as the second hit for racket websockets, which looks pretty good to me.

John

The futures part looks great to me.

@samth: Thanks for the pointer! Fixed locally. Any other feedback?

Merged, thanks!

Looks good.

Merged.

@mflatt I was told you might want to take a look at this PR.  Thanks.

I'm not sure why this failed. Will pull in master and try again.

None of those failures are your fault -- the Travis ones are intermittent errors that I've seen before, and the Appveyor one is weird but not your fault.

Also, we should probably switch to `sudo: false`, since Travis is now explicitly marking other builds as "legacy".

Ok. I can add a sudo: false. Will add another commit.

On Thu, Jul 23, 2015 at 1:58 PM, Sam Tobin-Hochstadt <
notifications@github.com> wrote:

> Also, we should probably switch to sudo: false, since Travis is now
> explicitly marking other builds as "legacy".
> 
> —
> Reply to this email directly or view it on GitHub
> https://github.com/plt/racket/pull/981#issuecomment-124238525.

## 

http://www.apgwoz.com

I think you need a JIT_UPDATE_THREAD_RSPTR() in each of the common functions, which ensures that the global runstack pointer used by C code (including the GC) is synced with the register that JITted code uses.

I don't see any other problems, but it's difficult to be sure. The names of the common-function pointers are fine with me.

I just added them to the github branch.

 I copied the code from the `bad_XXvector_length_code`. They don't have any `JIT_UPDATE_THREAD_RSPTR()`. Is that ok?

## 

Travis just finished with an error. It's the same error in the pull request in plt/racket/ travis test and in my gus-massa/racket travis test.

```
$ export RACKET_CONFIGURE_ARGS="--disable-jit"
[...]    
Section(namespaces)
ERROR: id: unbound identifier;
 also, no #%top syntax transformer is bound
  in: id
The command "raco test -l tests/racket/test" exited with 2.
```

Missing `JIT_UPDATE_THREAD_RSPTR()` in `bad_XXvector_length_code` seems likely to be a bug.

I just saw the `Section(namespaces)` failure in my build without this change, too, so it must be unrelated.

So I just rebase and push this?

Yes

Just for the record, that really needs to be `JIT_UPDATE_THREAD_RSPTR()`, not `JIT_UPDATE_THREAD_RSPTR_IF_NEEDED()`. The "common" stubs don't have the context to say whether an update is needed, so they should always update.

I see that one other place is broken along those lines, and I'll also add the missing calls in the vector functions.

Ups! I copied it from `box_cas_fail_code` in line 545. You should check that.

Edit: I just saw that you have already fixed it.

I've merged this change, but I'd like to leave the PR open until I can investigate the JIT crash.

Does the build crash attempting to run `racketcgc` (to build `racket3m`) or only later?

When running racketcgc.  I did not gather any debugging information yet...

Here’s a further exploration of this idea with a [new version of `check-latest`](https://gist.github.com/mbutterick/3f7f22fa92e748c43ab7#file-rerequire-rkt-L108). So far this seems to work — it cures the test case shown above — but I’m sure it contains some lame error so I’m not yet upgrading it to a pull request.

Here’s the idea: because `dynamic-rerequire` only cares about the state of files on disk, my surmise is that it would be simpler to 1) take the input to `check-latest` (= a module name), 2) convert it to a list of transitive file-based dependencies (using the new `mod->file-deps` helper function, which recurses into submodules) and then 3) iterate over this flat list using the current reloading procedure in `check-latest`.

PS One obviously lame issue with this fix is that it’s slow. Instead of using the `mod-depends` field of the module’s data struct, it uses `dynamic-require` to pull the module into a namespace so `module->imports` can be used to inspect the imports (and recurse downward). AFAICT the option that doesn’t demand `dynamic-require` is `show-import-tree`, but that makes a gargantuan, mostly superfluous list.

The contract changes look good to me. Thanks!

Robby

On Mon, Jul 27, 2015 at 9:36 AM, btlachance notifications@github.com
wrote:

> 1st is a small grammatical mistake
> 2nd is in a section about ->\* yet mistakenly -> is referred to
> 3rd is about recontract-out yet contract-out is mentioned instead
> 4th clarifies return value for value-contract
> 
> ## 5th replaces free-identifier? with free-identifier=?
> 
> You can view, comment on, or merge this pull request online at:
> 
>   https://github.com/plt/racket/pull/985
> Commit Summary
> - Fix bugs/typos in docs for contracts and quote-syntax
> 
> File Changes
> - _M_ pkgs/racket-doc/scribblings/reference/contracts.scrbl
>   https://github.com/plt/racket/pull/985/files#diff-0 (8)
> - _M_ pkgs/racket-doc/scribblings/reference/syntax.scrbl
>   https://github.com/plt/racket/pull/985/files#diff-1 (4)
> 
> Patch Links:
> - https://github.com/plt/racket/pull/985.patch
> - https://github.com/plt/racket/pull/985.diff
> 
> —
> Reply to this email directly or view it on GitHub
> https://github.com/plt/racket/pull/985.

Also makes me wonder if the `mod-depends` field should hold its records in a different format to make traversing the dependencies easier in `check-latest`.

My attempts to run FreeBSD on an ARM machine (Raspberry Pi) haven't worked out, so far. In case the problem is easy to track down, can you try starting `racketcgc` in gdb? I expect that it will crash quickly, and the stack trace combined with disassembly near the crash might make the problem clear.

The Raspberry Pi probably doesn't have enough RAM (depending on the model).  What problems did you have?  I made a mistake and my BeagleBone is offline now, but I will try to debug this once it's back up.

I couldn't get it to boot after `dd`ing an image to an SD card. The boot failed with "unrecognized filesystem type" – which probably reflects some really basic problem, but searching for solutions didn't get me anywhere.

merged - thanks!

merged - thanks!

D"oh, thanks for the formatting fixes

Are you using an image from ftp.freebsd.org?  It was suggested on IRC that the SD card might be failing.  The RPI is very picky about SD cards...  Can you try a different SD card?

This also fixes many check-syntax arrows in programs that use `#lang racket/unit`, such as many of the modules in the type-checker for `typed/racket`, where their non-existance has annoyed me for a long time.

I'd prefer calling them `string-prefix?` and `string-suffix?`, for consistency with the newly added `list-prefix?` family of functions.

Also, I'm not sure these particular shortcuts are all that useful given the existence of `regexp-match` and co. ISTR us deciding against adding similar shortcuts to `racket/string` for that reason in the past.

Merged, thanks!

These structs no longer exist.

I figured there was a reason there weren't added already, and did find a brief [mailing list thread](http://lists.racket-lang.org/users/archive/2012-April/051406.html) (their conclusion: use `regexp` or `srfi-13`).

But IMO these are convenient, self-documenting functions. Just like `list-prefix?` and `sixth` are nice to have.

Are there already tests for `..k` patterns outside of `list-no-order`?

Thanks for the patch, btw!

I think we should add useful string functions, instead of expecting everyone to use regexps. Learning regexp syntax is much more complicated than a simple function call.

Strongly agree with @samth here. Simple string operations for common cases are very helpful, even for regexp masters.

Yes, I tried from ftp.freebsd.org. I tried a couple of SD cards, including a SanDisk (which I think I saw recommended somewhere), but that could still be it.

merged - thanks!

merged - thanks!

There are `..k` patterns in `other-plt-tests.rkt` and in `other-tests.rkt`, but none of those places looks like `..k` patterns are the main topic there.

Ah: this is a problem with the close function. `redex-check` is generating the term `+` which is being passed to `close`, which is returning `((lambda (+) +) (λ (x) x))`, which isn't valid.

The problem is that the `close` function needs to be extended to work in the new language so it knows that `+` isn't a variable.

Redex isn't very helpful in this case, I agree! I have some thoughts on how to do better, but they are pretty long term.

Thanks for the report!

The "keyword?" function in "symbol.c" needs to be marked as inlinable, right?

Tests can be added to "pkgs/racket-test-core/tests/racket/optimize.rktl" in the same way as for `symbol?`.

merged - thanks!

Fixed and rebased. Is it ok now?

Yes, that looks right to me.

Just used this. Works great, thanks! I did spend a lengthy debugging session to learn that pattern expander names _must_ have a `~` prefix. I guess it's a limitation of `syntax-parse` so I don't know if anything can be done about it. For now, I added a note to the docs.

I think I’ve almost figured this out ...

Still testing this approach, but so far so good … This updated [`rerequire.rkt`](https://gist.github.com/mbutterick/3f7f22fa92e748c43ab7) introduces a new `mod-dep-paths` hash that stores the initial list of loaded paths (harvested by `path-collector`) for each rerequired path. Then, when a path is rerequired again (rererequired?), `check-latest` iterates through the stored list of loaded paths. The advantage of this vs. the current approach is that you don’t end up with any submodule paths in your list of dependencies.

merged - thanks!

again: is there anything holding this up from my end?

Update: Moved the used parts of `unstable/syntax` to `syntax/X`. Also after discussion with @rmculpepper.

It seems like the JIT is generating an invalid instruction:

```
% gdb ../racketcgc  
(gdb) r
[New LWP 100112]
Welcome to Racket v6.2.900.5 [cgc].
[New Thread 20c03300 (LWP 100112/racketcgc)]

Program received signal SIGILL, Illegal instruction.
[Switching to Thread 20c03300 (LWP 100112/racketcgc)]
0x207e0014 in ?? ()
(gdb) 
#0  0x207e0014 in ?? ()
(gdb) 
```

These instructions don't make a lot of sense... More debugging tomorrow.

```
(gdb) x/10i 0x207e0000
0x207e0000:     andeq   r0, r0, r0
0x207e0004:     rsbscs  r0, lr, r0, lsr r0
0x207e0008:     rsbscs  pc, lr, r0, lsr r0
0x207e000c:     rsbscs  r0, lr, r0, lsr r6
0x207e0010:     andeq   r0, r0, r0, lsl #12
0x207e0014:     undefined instruction 0xffff0005
0x207e0018:     andeq   r0, r0, r0
0x207e001c:     cmpcs   r5, r0
0x207e0020:     andeq   r0, r0, r0
0x207e0024:     andeq   r0, r0, r0
(gdb) 
```

You'll probably have to tell gdb explicitly to decode Thumb instructions with `set arm force-mode thumb`.

Since it's an illegal-instruction error, which may mean the JIT is generating the wrong instructions for your machine, what does `gcc -dM -E - < /dev/null | grep ARM` produce on that machine?

Thanks for your help!

Our gdb is quite old, so it doesn't have that option... Maybe you're right and it's a Thumb instruction that this gdb can't parse.

```
% cc -dM -E - < /dev/null | grep ARM  
#define __ARMEL__ 1
#define __ARM_32BIT_STATE 1
#define __ARM_ACLE 200
#define __ARM_ARCH 6
#define __ARM_ARCH_6ZK__ 1
#define __ARM_ARCH_ISA_ARM 1
#define __ARM_EABI__ 1
#define __ARM_FEATURE_DSP 1
#define __ARM_FP 0xC
#define __ARM_PCS 1
#define __ARM_SIZEOF_MINIMAL_ENUM 4
#define __ARM_SIZEOF_WCHAR_T 4
#define __ARM_VFPV2__ 1
```

The preprocessor output says that Thumb is not supported, so the JIT shouldn't generate Thumb instructions, anyway. 

I see that "racket/src/racket/src/lightning/arm/asm.h" doesn't specifically recognize `__ARM_ARCH_6ZK__`. Does it help to add that alongside `__ARM_ARCH_6K__`?

That didn't help. :(

I like the motivation behind this PR!  Probably everyone agrees that the status quo -- a terse "bad syntax" error message -- is not helpful.

More-helpful alternatives seem to include:
1. The "magic" behavior in the PR.
2. A helpful error message suggesting using new `and*` `or*` functions, as @mflatt suggested.
3. A helpful error message suggesting using what's already available. For example in `qq-and-or.rkt` change
   
   ```
   (raise-syntax-error #f "bad syntax" x)
   ```
   
   to something like
   
   ```
     (raise-syntax-error #f "is syntax not a function; try `ormap' or `for/or`" x)
   ```

I wonder if 2 and/or 3 might be the most helpful, because it's teaching (or reminding) people something they do need to understand sooner rather than later?

[What to understand: It's not apparent whether `(f x)` is a function application or a macro invocation. Macros can do things like short-circuit. And so on. I think it's pretty common to "know" this from reading, but still need a few reminders in practice before it sinks in. So instead of eliminating this learning opportunity, maybe provide a clearer reminder and more enjoyable learning?]

p.s. I guess 2 and 3 are compatible; the error message could mention all of `ormap`, `for/or`, and a new `or*`.

Merged already.

Unfortunately I reached a dead end with this. My solution passed some test cases, but in others ran into “cannot redefine a constant” errors related to the `compile-enforce-module-constants` parameter. Back to the drawing board, etc.

Closing this, superseded by Pull Request #1004.

LGTM, modulo comments. Of course, I defer to @rfindler for changes in contract internals.

@stamourv, I made changes for most of your comments.

For the rest:
1. I think it makes sense to leave that one test commented out for now, I have a branch with the #:omit-constructor fix so I can submit a PR for that too.
2. The syntax-class constraint that I removed was a source of bad error messages for ill-formed unit/c contracts. The checking it was doing was already being performed by the macro that builds the contract anyway. 
3. I think we can easily get rid of the "note" field in the test macros, I'll work on that later/tomorrow.

1. Or you can roll the test change into that new PR.
   2., 3. Sounds good.

I just made a small fix in line 2579: `mz_patch_UCbranch` -> `mz_patch_ucbranch` 

A `CHECK_LIMIT()` call is needed often enough to ensure that the buffer used to general code is not over-filled. It looks like you've included enough to me.

Yes, the comparison code is long enough that I would have moved the loop to common code.

I agree about moving the call to `scheme_string_eq_2()` to common code. The call to `JIT_UPDATE_THREAD_RSPTR_IF_NEEDED()` can then be removed and changed to `JIT_UPDATE_THREAD_RSPTR()` in the common code, but since `string=?` is almost always used in a branch where and update will be inserted, anyway, I guess that won't make a difference.

If you don't want to specialize `for_branch` mode, you can just not inline in that mode, and inlining will be tried again in regular mode. I recommend specializing `for_branch` mode, though. I'm not too surprised that you couldn't measure a difference, but think the effect of `for_branch` mode is that it keeps the generated code more compact overall.

Yes, if `result_ignored` is set, then the generated code could make sure that the arguments are strings and do nothing else (i.e, not even return false).

Don't call `mz_pop_locals()`. That's for the entire enclosing function. There's no need to balance `mz_set_local_p()`s with mz_get_local_p()`s.

I think the main loop might generate too much code for a tiny jump (in which case short jumps are appropriate). Have you tried on 32-bit x86?

Does it work to avoid LOCAL3 in the main loop by checking from the end to the start with: R2 = number of bytes left to check (start at end of strings, decrement by `int` size on each iteration, stop when it hits zero), R0 = start of first string (add R2 to R0 to get each character), and R1 = start of second string (add R2 to R1 to get each character)?

On second thought, I'm not sure about moving the loop to common code. Maybe it's fine inline, especially if it can be made more compact.

I've been trying to remember why `#:omit-constructor` exists. I think it wasn't so much intended to leave a name unbound as to avoid exposing the constructor (so that instances could be created other ways) while still supporting pattern-matching and other predicate- and selector-based actions.

And it looks like `build-struct-expand-info` is supposoed to handle that... so what goes wrong? I now see that it might be the use of `make-self-name-struct-info`.

In the implementation of `do-struct~` does simply making `self-ctr?` false when `no-ctr?` is true make things consistent? It doesn't allow the example above to work, but it provides an appropriate (if less informative than ideal) syntax error. Are there other issues?

LGTM

merged – thanks!

Adjusted (the identifier `pkg` isn't bound, the PLaneT URL wasn't right!, and noted that PLaneT is the legacy site) and merged – thanks!

Merged, thanks!

I got FreeBSD running on an RPI2. Unfortunately, the JIT seems to work in that configuration, so I'm still stuck on this problem.

I compiled in 32 bits and there are no problems. Nevertheless, sometimes when I added more code the program breaks, so I guess it's close to the maximal size for tiny jumps.

I think it's necessary to use 5 registers: One for each character, one for a pointer to any place in the string, and one counter. I thought about keeping the pointers constant and counting backwards, but that doesn't change the number of registers. 

But this can be useful to unroll the loop for small strings, I didn't see a big difference in the time, but it really looks like a good idea so I'll try again.

The implementation of `string-replace` uses regexps. https://github.com/plt/racket/blob/master/racket/collects/racket/string.rkt#L103-L117

It's tricky, so it's not straightforward to use the regexp because you need to correctly escape the string, and cache the escaped version to improve the performance. So I agree that it's good to include specialized functions.

I didn't test the time, but I think that an implementation of `string-prefix/sufix` based in regexps will be faster than the proposed implementation that use `for`.

How are you enabling the JIT? In sconfig.h?  The processor on the BeagleBoard is similar to the one on the RPI2, so it's likely that I made a mistake.

I added `-DMZ_USE_JIT_ARM` to `CPPFLAGS`, since I had to pass `-I/usr/local/include` to find the installed libffi, anyway:
`../configure CPPFLAGS="-I/usr/local/include -DMZ_USE_JIT_I386" LDFLAGS=-L/usr/local/lib`
I confirmed by running a loop that the JIT was enabled and that providing `-j` to `racket` made it go slower.

It should work the same to add the definition in "sconfig.h", though.

I had to install libffi, because the sources bundled with Racket didn't build. Did you install libffi via the package manager, too?

Yup, installed libffi and used roughly the same configure arguments as you did (you made a mistake in -DMZ_USE_JIT_I386, right?).

I used the port arguments: env CPPFLAGS=-I/usr/local/include LDFLAGS=-L/usr/local/lib configure --disable-lt --enable-shared --enable-pthread

Can you email me your racketcgc binary?

Merged.

Good idea: http://www.cs.utah.edu/~mflatt/tmp/racketcgc

That crashes exactly the same way.  Guess there's something special about this CPU...

@gus-massa good point, I will run some benchmarks & share the results here

It's possible that the JIT is generating instructions that fall outside the spec, where different processors treat the undefined behavior in different ways. That has happened one time before. In that previous case, though, we were able to get disassembly from gdb to help track down the problem. 

In this case, since the disassembly at the crash point doesn't make sense, it seems more likely that a jump is going wrong. Does a `bt` in gdb offer any further hints?

It's a long shot, but what if you change `__START_SHORT_JUMPS__` in "jit.h" so that it doesn't change the `long_jumps` state?

Merged.

#948 is now merged.

A bit different:

```
% gdb ./racketcgc  
(gdb) r -cqu ./check-sdep.rkt
[New LWP 100110]
internal error in JIT;
 ending address 0x214a0adc not in [0x214a0630,0x214a0ad0] (0)
internal error: JIT buffer overflow
[New Thread 20c03300 (LWP 100110/racketcgc)]

Program received signal SIGABRT, Aborted.
[Switching to Thread 20c03300 (LWP 100110/racketcgc)]
0x204b0274 in thr_kill () from /lib/libc.so.7
(gdb) bt
#0  0x204b0274 in thr_kill () from /lib/libc.so.7
#1  0x204b0260 in raise () from /lib/libc.so.7
#2  0x204b01d8 in abort () from /lib/libc.so.7
#3  0x000bb710 in scheme_generate_one (old_jitter=<value optimized out>, 
    generate=<value optimized out>, data=<value optimized out>, gcable=<value optimized out>, 
    ndata=0x2070a128) at jitstate.c:401
#4  0x00087138 in scheme_on_demand_generate_lambda (nc=<value optimized out>, 
    argc=<value optimized out>, argv=<value optimized out>, argv_delta=<value optimized out>)
    at jit.c:3691
#5  0x000872f0 in scheme_on_demand (rs=0x211c5f90) at jit.c:3770
#6  0x203e0a94 in ?? ()
(gdb) 
```

However, this is the same crash:

```
% gdb ./racketcgc 
(gdb) r
[New LWP 100110]
Welcome to Racket v6.2.900.5 [cgc].
[New Thread 20c03300 (LWP 100110/racketcgc)]

Program received signal SIGILL, Illegal instruction.
[Switching to Thread 20c03300 (LWP 100110/racketcgc)]
0x207d0014 in ?? ()
(gdb) bt
#0  0x207d0014 in ?? ()
(gdb) 
```

Unless I've done something wrong, the non-regexp implementation is winning.

```
Running `string-prefix?` on all pairs of words in 'common-words.rktd'
Average of 30 runs: 416.43 ms
Running `string-suffix?` on all pairs of words in 'common-words.rktd'
Average of 30 runs: 685.8 ms
Running `string-prefix2` on all pairs of words in 'common-words.rktd'
Average of 30 runs: 14487.2 ms
Running `string-suffix2` on all pairs of words in 'common-words.rktd'
Average of 30 runs: 21745.23 ms
```

Code & test data is here:
https://gist.github.com/bennn/7efd60b4809a475af297

but for reference, here are the implementations:

```
#lang racket/base

(require
  (only-in racket/file file->value)
  (only-in racket/format ~r)
)

;; =============================================================================
;; Simple implementation

(define (string-prefix? str prefix)
  (and
    (<= (string-length prefix) (string-length str))
    (for/and ([c1 (in-string str)]
              [c2 (in-string prefix)])
      (char=? c1 c2))))

(define (string-suffix? str suffix)
  (define offset (- (string-length str) (string-length suffix)))
  (and
    (not (negative? offset))
    (for/and ([c1 (in-string str offset)]
              [c2 (in-string suffix)])
      (char=? c1 c2))))

;; =============================================================================
;; Regexp implementation

;; The real thing would probably share 1 cache with replace
(define prefix-cache (make-weak-hasheq))
(define suffix-cache (make-weak-hasheq))

(define (string-prefix2 s1 s2)
  (define s2* (if (regexp? s2)
                  s2
                  (hash-ref! prefix-cache s2 (lambda () (regexp-quote s2)))))
  (define s2** (regexp (string-append "^" (regexp-quote s2*))))
  (if (regexp-match s2** s1) #t #f))

(define (string-suffix2 s1 s2)
  (define s2* (if (regexp? s2)
                  s2
                  (hash-ref! suffix-cache s2 (lambda () (regexp-quote s2)))))
  (define s2** (regexp (string-append (regexp-quote s2*) "$")))
  (if (regexp-match s2* s1) #t #f))
```

> Merges in-syntax, in-pairs and in-slice to racket/sequence.

Before moving in-pairs to racket/sequence I'd like argue that the current
in-pairs
is doing the wrong thing. I expect in-pairs to loop over the spine of a
line.

From an old email:

I'd like to lobby that in-pairs is the following,
wherein the clause [p (in-pairs '(1 2 3))] lets binds p
to the pairs of the list.

(define (in-pairs xs)
  (make-do-sequence
   (λ ()
     (define (pos->element p) p)
     (define (next-position p) (cdr p))
     (define initial-position xs)
     (define (continue-with-pos? p) (pair? p))
     (values pos->element
             next-position
             initial-position
             continue-with-pos?
             #f #f))))

Examples:

> - (for ([p (in-pairs '(1 2 3 4))])
> -    (displayln p))
>   (1 2 3 4)
>   (2 3 4)
>   (3 4)
>   (4)

(define (deltas xs)
  (for/list ([p (in-pairs xs)]
             #:when (pair? (cdr p)))
    (- (cadr p) (car p))))

> - (deltas '(1 3 7 13))
>   *'(2 4 6)

Further discussion:
   http://lists.racket-lang.org/users/archive/2012-December/055531.html

2015-08-09 16:39 GMT+02:00 Vincent St-Amour notifications@github.com:

> Merges in-syntax, in-pairs and in-slice to racket/sequence.
> 
> Leaves sequence-lift and in-sequence-forever in unstable/sequence, which
> will leave the main distribution. The former is redundant given
> sequence-map, and the latter is not used very much (and doesn't have a
> 
> ## good name).
> 
> You can view, comment on, or merge this pull request online at:
> 
>   https://github.com/plt/racket/pull/1002
> Commit Summary
> - Make doc section title more accurate.
> - Improve the implementation of `in-slice`.
> - Merge part of unstable/syntax with racket/syntax.
> - Move rest of unstable/sequence to unstable-lib.
> - Move docs for part of `unstable/sequence` to the `racket/sequence`
>   docs.
> - Improve docs for the new bits of `racket/sequence`.
> - Move tests for the new bits of `racket/sequence` from
>   `unstable/sequence` tests.
> - Add more tests.
> 
> File Changes
> - _M_ pkgs/racket-doc/scribblings/reference/sequences.scrbl
>   https://github.com/plt/racket/pull/1002/files#diff-0 (36)
> - _M_ pkgs/racket-test-core/tests/racket/sequence.rktl
>   https://github.com/plt/racket/pull/1002/files#diff-1 (22)
> - _M_ racket/collects/racket/match/define-forms.rkt
>   https://github.com/plt/racket/pull/1002/files#diff-2 (2)
> - _M_ racket/collects/racket/sequence.rkt
>   https://github.com/plt/racket/pull/1002/files#diff-3 (48)
> - _D_ racket/collects/unstable/sequence.rkt
>   https://github.com/plt/racket/pull/1002/files#diff-4 (83)
> 
> Patch Links:
> - https://github.com/plt/racket/pull/1002.patch
> - https://github.com/plt/racket/pull/1002.diff
> 
> —
> Reply to this email directly or view it on GitHub
> https://github.com/plt/racket/pull/1002.

## 

## 

Jens Axel Søgaard

I've pushed a repair to argument checking `local-expand`. Thanks!

I have since changed my mind re including `in-pairs`, as `in-dict` is more general, and gets specialized by `for`. `in-pairs` will stay in `unstable/sequence` and leave the main distribution. I just forgot to update the PR.

What you're suggesting is a different function (which I'd call something like `in-tails`), which could also be a nice addition to `racket/sequence`. I'd suggest opening a new issue / PR for it, as it's a separate discussion IMO.

Oh, also, leaving `in-pairs` out of `racket/sequence` does keep the name "open" for what you're suggesting, though there is still code out there that use `unstable/sequence`'s `in-pairs`.

I'll repair reporting so that it always includes phantom bytes, so "+-" won't appear in the GC log.

I'm not sure I understand the rest of the issue. Triggering a garbage collection is very much the intent of phantom-byte allocation. In particular, a large bitmap in a loop creates garbage that must be cleaned up relatively frequently, if the bitmap is large, and phantom bytes trigger that clean up. It's a bug if phantom bytes are not lined up with actual bitmap allocation, though.

?

Merged

I agree

Adding `__acrt_iob_func` to the `non-functions` list in "racket/collects/compiler/private/xform.rkt" may let you make progress. You might have to delete a copy of "collects" in "racket/src/worksp/gc2/xform-collects".

LGTM, will merge.

Merged, thanks!

The regexp implementations have a few problems, for example they call `regexp-quote` twice on each string. Also, it's probably better to cache the final regexp than the intermediate escaped string. Anyway, after fixing this I get the same results than you, i.e. the regexp versions are slower.

```
Running `string-prefix1?` on all pairs of words in 'common-words.rktd'
Average of 1 runs: 1357 ms
Running `string-suffix1?` on all pairs of words in 'common-words.rktd'
Average of 1 runs: 1935 ms
Running `string-prefix2?` on all pairs of words in 'common-words.rktd'
Average of 1 runs: 49296 ms
Running `string-suffix2?` on all pairs of words in 'common-words.rktd'
Average of 1 runs: 52697 ms
Running `string-prefix3?` on all pairs of words in 'common-words.rktd'
Average of 1 runs: 7956 ms
Running `string-suffix3?` on all pairs of words in 'common-words.rktd'
Average of 1 runs: 8580 ms
```

PS: Looking at this, I found a bug in `string-replace` when the string is mutable. I've already submitted the PR.

The code, in case you want to rerun the tests:

```
 (define prefix-cache3 (make-weak-hasheq))
 (define suffix-cache3 (make-weak-hasheq))

 (define (string-prefix3? s1 s2)
  (define s2* (if (regexp? s2)
                  s2
                  (hash-ref! prefix-cache3 s2
                             (lambda () (regexp (string-append "^" (regexp-quote s2)))))))
  (if (regexp-match s2* s1) #t #f))

 (define (string-suffix3? s1 s2)
  (define s2* (if (regexp? s2)
                  s2
                  (hash-ref! suffix-cache3 s2 
                             (lambda () (regexp (string-append (regexp-quote s2) "$"))))))
  (if (regexp-match s2* s1) #t #f))
```

merged - thanks!

LGTM

merged

merged

Yes, this is normal.

Consider:

> (case 'quote
>     ['e1     'foo]
>     [(quote) 'goo])
> 'foo

Since 'e1 is replaced by (quote e1)  by the reader, this program is the
same as:

> (case 'quote
>     [(quote e1) 'foo]
>     [(quote)    'goo])
> 'foo

So foo is returned because quote is one of the datums in the first clause.

You can write:

> (case 'quote
>     [(e1) 'foo]
>     [(quote) 'goo])
> 'goo

to get goo.

/Jens Axel

2015-08-14 18:16 GMT+02:00 Ted Szylowiec notifications@github.com:

> Is this behavior normal? Suppose I have the following function trans. If I
> do (trans 's1 'e1) I get result 'foo. But if I do (trans 's1 'quote) I do
> not get 'goo. I get 'foo. If I put some symbol other than 'quote (such as
> 'q) then (trans 's1 'q) returns 'goo.
> 
> (define (trans state event)
> (case state
> ('s1 (case event
> ('e1 'foo)
> ('quote 'goo)
> ('e2 'soo)))
> ('s2 (case event
> ('e1 'bar)
> ('quote 'baz)
> ('e2 'boo)))))
> 
> —
> Reply to this email directly or view it on GitHub
> https://github.com/plt/racket/issues/1013.

## 

## 

Jens Axel Søgaard

I see. I understand. Thank you.

FWIW, `match` is more idiomatic than `case`. In this case, it also looks like `2dmatch` would work well.

Great! Thanks!

Thanks for fixing the sloppy regexp code.

I just tried another implementation with loops & it's faster, so I've pushed it. (Not sure what this `AppVeyor` failure is about.)

Results:

```
Running `string-prefix-loop` on all pairs of words in 'common-words.rktd'
Average of 30 runs: 273.2 ms
Running `string-suffix-loop` on all pairs of words in 'common-words.rktd'
Average of 30 runs: 302.13 ms
```

Implementation:

```
(define (string-prefix-loop str prefix)
  (define l1 (string-length str))
  (define l2 (string-length prefix))
  (let loop ([i 0])
    (cond
     [(= l2 i)  #t] ;; Finished reading all chars in prefix
     [(= l1 i)  #f] ;; Prefix is longer than string
     [else      (and (char=? (string-ref str i) (string-ref prefix i))
                     (loop (add1 i)))])))

(define (string-suffix-loop str suffix)
  (define l2 (string-length suffix))
  (define offset (- (string-length str) l2))
  (and (not (negative? offset)) ;; Suffix isn't longer than string
       (let loop ([i+o offset] [i 0])
         (or (= i l2)
             (and (char=? (string-ref str i+o) (string-ref suffix i))
                  (loop (add1 i+o) (add1 i)))))))
```

I did most of the changes, but I didn't move the main loop to jitcommon.c.

Some `jit_???` commands have a `(void)` cast. Is that necessary? Do all of them need one? Can I remove all of them?

I'm planning to add a special case for strings of small length that are known at jit time, because I think that `(string=? x "XYZ")` is a common use case. 

Don't forget to get rid of the `mz_pop_locals()` calls.

Put a `(void)` cast only if the `jit_....` function would normally return an address to patch but you won't need to patch it. That `(void)` silences warnings on some compilers. I don't think you need `(void)` anywhere in this patch.

To remove `mz_pop_locals()` I have to remove `mz_push_locals()` too, because otherwise I get an error.

I missed the `mz_push_locals()` – that shouldn't be there, either

Another question. Is this

```
   __START_TINY_JUMPS__(1);
  jit_ldxi_l(JIT_R2, JIT_R0, &SCHEME_CHAR_STRLEN_VAL(0x0));
  jit_ldxi_l(JIT_V1, JIT_R1, &SCHEME_CHAR_STRLEN_VAL(0x0));
  __END_TINY_JUMPS__(1);
  __START_TINY_OR_SHORT_JUMPS__(!for_branch, branch_short);
  ref_false1 = jit_bner_i(jit_forward(), JIT_R2, JIT_V1);
  __END_TINY_OR_SHORT_JUMPS__(!for_branch, branch_short);
```

equivalent to this

```
  __START_TINY_OR_SHORT_JUMPS__(!for_branch, branch_short);
  jit_ldxi_l(JIT_R2, JIT_R0, &SCHEME_CHAR_STRLEN_VAL(0x0));
  jit_ldxi_l(JIT_V1, JIT_R1, &SCHEME_CHAR_STRLEN_VAL(0x0));
  ref_false1 = jit_bner_i(jit_forward(), JIT_R2, JIT_V1);
  __END_TINY_OR_SHORT_JUMPS__(!for_branch, branch_short);
```

?

I.E. Do `jit_ldxi_l` have some kind of internal hidden jumps? (This would be usefull to simplify some parts of my code.)

Those are equivalennt. Short- and tiny-jump modes affect only `jit_br....()` and `jit_jmpi()`.

I added in [another branch](https://github.com/gus-massa/racket/commits/15-7-X-JIT-Inline-String-EQ-Z) an especial case for explicit strings of length 0, 1 and 2, but the difference in speed is very small and the run time difference is at the noise level. I think that it's better to keep only the special case for `""`, because it reduce the size of the jit code without increasing too much the complexity of jitinline.c

Also, to move the main loop to jitcommon.c it's necesary to have another register for the jump address (usually `JIT_V1`), so it looks difficult.

I added `bytes=?` and changed a few unrelated `SCHEME_CHAR_STR_VAL` to `SCHEME_BYTE_STR_VAL`.

I hope this is the final version. (Please review extra carefully.)

Anyway, another question. For the bytes version, I didn't find:

```
ref_false2 = jit_bner_c(jit_forward(), JIT_R0, JIT_V1);
```

so I replace it with:

```
jit_extr_c_i(JIT_R0, JIT_R0);
jit_extr_c_i(JIT_V1, JIT_V1);
ref_false2 = jit_bner_i(jit_forward(), JIT_R0, JIT_V1);
```

Merged, thanks!

merged

merged

merged

It turns out that `jit_ldr_c()` sign-extends to an integer, so the `jit_extr_c_i()`s shouldn't be needed. Otherwise, this looks good to me.

Since `string=?` and `bytes=?` have so much in common, I would have made them the same, parameterizing the code generation over `scheme_char_string_type` and `&SCHEME_CHAR_STRLEN_VAL(0x0)` and using conditionals as necessary otherwise. I'm happy to defer to your choice of separate blocks if you prefer that approach, though.

merged

Blake has fixed the crash with #1023. I think he's still looking into the other issue.

I tried to parameterize it, but half of the code is common and half of the code needs parameterizations, so it needs an `if (string) {` every other line. 

I'll try with something like 

```
intptr_t strlen_val;
[...]
if (string) 
  strlen_val = &SCHEME_CHAR_STRLEN_VAL(0x0);
else
  strlen_val = &SCHEME_BYTE_STRLEN_VAL(0x0);
```

@asumu: The issue with  `syntax-local-value/immediate` makes me reconsider the value of separating rename transformers from `prop:syntax-local-value`. If `prop:rename-transformer` allowed a single-argument function as its value, then the meaning of "rename transformer" would change so that it's target identifier is not a constant, but existing code is likely to work fine. With the separation, I can't help thinking that we'll need a variant of `syntax-local-value/immediate` eventually. And, looking at your message again, I see that you already wanted it once.

If you think the separation is better, then this commit is fine with me. If you'd like to try changing `prop:rename-transformer` after all, though, I think that would be a worthwhile experiment (despite my earlier advice).

@dfeltey ping (about `self-ctr?`)

merged

After looking _more_ through Google, I found a bug report from 5 years ago:
http://users.racket-lang.narkive.com/H5koiJH7/difference-when-choosing-language-vs-lang-line

EDIT: Maybe you can revisit this, one way or the other? At least, you can pull out `#lang htdp/bsl` till it's actually ready.

Thanks for this note. This has been fixed in the pre-release build of Racket. You can download a snapshot build or build it yourself from git.

There are still lots of things wrong with `#lang htdp/bsl` and friends, tho.

Also, this is the wrong repo. You should probably be opening issues here: https://github.com/racket/htdp

@mflatt, I'm sorry for leaving this for so long, I should be able to take another look at it later today.

@mflatt I've implemented your new suggestion and pushed it to this PR. I like this approach better because it adds fewer primitives. It works fine for all of my Racket test cases, but it doesn't quite solve all of my TR issues. Here's a unit test that I added for TR:

``` racket
#lang racket

(module m typed/racket/base
  (define x 1)
  (provide x))

(module n typed/racket/base
  (require (submod ".." m))
  (module* a #f x))
```

The use of `x` in the `module*` at the bottom hits the "single form in the module body" special case and is therefore expanded in the `'module-begin` context. This is before TR's `#%module-begin` has installed its typed context flag, so it expands to the wrong thing.

In my previous `prop:syntax-local-value` + `prop:set!-transformer` solution, I had the set! transformer detect when it's in a module-begin context and apply a `#%expression` to delay expansion. You can't do that with rename transformers though, so it seems I'm stuck even with the delayed target identifier selection. Any idea how to work around this?

---

BTW, there's also the question of what to do if the procedure returns a non-identifier. I'd rather output an error (current behavior), but it could also do what rename transformers currently do with struct fields and output a weird identifier `?` instead.

Maybe the `module` expander shouldn't try to expand a single identifier into `#%module-begin` if it's bound to a rename transformer, since the result can't possibly be a `#%module-begin` form.

Won't that have the same problem if we replace x with (x)?

Good point. Another possibility is that a rename transformer could have some sort of property to indicate the kinds of contexts where it can expand (to play a similar role as a `(syntax-local-context)` test in a recgular macro).

@mflatt I took another look at this, I hadn't thought about the pattern matching issue previously. I think your suggestion to set `self-ctr?` to false when `no-ctr?` is true does make sense, and it doesn't seem to break any of the other unit test cases. I agree, that the new error message from my original example is not very good, but there don't seem to be any other issues as far as I can tell.

How about instead of putting the expanded syntax under a `#%module-begin`, re-expanding it by putting the unexpanded original form into the `#%module-begin`? (assuming it didn't expand to a `(#%module-begin ...)` form to begin with)

I suppose this has potential backwards incompatibilities for macros that have side effects.

Yes, as a general rule, it's bad to re-expand forms, so reverting to the unexpanded form to put in `#%module-begin` doesn't sound like a good idea to me.

That looks reasonable to me. @mflatt?

Could you add a test that would have failed before? The one in the PR description is fine.
Also, please add the line "Closes PR 15139" to your commit message, so gnats can close it automatically.

I still like the opportunity to opt-out of module-begin expansion, which
avoids a lot of semantic complexity.

On Thu, Aug 27, 2015, 5:38 PM Matthew Flatt notifications@github.com
wrote:

> Yes, as a general rule, it's bad to re-expand forms, so reverting to the
> unexpanded form to put in #%module-begin doesn't sound like a good idea
> to me.
> 
> —
> Reply to this email directly or view it on GitHub
> https://github.com/plt/racket/pull/1020#issuecomment-135562899.

Perhaps there should be a separate type (and struct type prop) for module-begin transformers, similar to `set!`-transformers. I don't know if it's possible to do that in a backwards-compatible way, though. If the macro expander is already changing in 7.0 anyway, though...?

A general property to opt out of `#%module-begin` sounds like a better approach than what I had in mind, which was something specific to rename transformers.
Having to opt-in for `#%module-begin` expansion seems like an especially breaking change. (All my tutorials on Racket languages would break, I think.)

Sorry for the delay. While collapsing `string=?` and `bytes=?` to a common implementation I found a small bug. (It said something like `app->rand1` instead of `app->rand2`.) The problem is that fixing the bug caused an unexpected error in code like `(string=? x "")`, but it's not easy to trigger that because of the inlining and jit-inlining heuristics. (see 2nd patch).

It's easily solved removing the special case for explicit strings (see 3rd patch). It would be not bad to remove both special cases. I think they don't improve the speed or code size too much. The problem is that I really don't understand where the bug is, so I suspect the real bug is elsewhere and the deletion only makes the bug more difficult to find.

I wonder if the problem is that you're passing 0 (i.e., false) for the `order_matters` argument to `scheme_generate_two_args()`, but then assuming a particular assignment of arguments to R0 and R1. Does passing true for that argument help?

Obviously! :) That fixed the problem. (5 seconds to write, 1 hour to rebase, retest, ...)

Looks good to me!

Thank for all the reviews! This is finally merged.

So something like `prop:not-#%module-begin`? And anything that's a `prop:procedure`, `prop:set!-transformer`, or a `prop:rename-transformer` with this property set to `#t` would not get expanded when directly in a `'module-begin` context? (presumably if the macro that's in module-begin position does a local expansion or something it will still expand normally?)

How about `prop:expand-contexts` to hold a list of symbols like the second argument to `local-expand` (but with a generic `'definition-context` symbol)? I could add that.

This is fine as far as I know. I agree that it's important to add a test case, though.

merged

I'm stuck here. Is it ok to merge this without updating the docs?

Thanks!

The second part was fixed in 38317b87c2742236b734b1295a1a8fa11bd49ebb

Merged, thanks!

Merged, thanks!

Added `prop:expansion-contexts` as 929db29b67e80ac155868fca5e8823235a745b4e.

The issue seems to be that phantom bytes trigger major collections, but never minor collections. The expected behavior is that minor collections occur, and only when garbage survives the first collection and accumulates to a certain degree does the major collection happen. So using phantom bytes to trigger GCs can sometimes greatly increase GC latency (compared to wasting actual memory by allocating, say, bytestrings!) since minor collections don't happen before major collections are triggered. This especially affects the common case of creating bitmaps in a loop, i.e. rendering animations or even 2D games, making such programs constantly encounter annoyingly long pauses.

A thread in a loop allocating phantom bytes can even freeze up the entire VM because the phantom short-lived garbage cannot be efficiently dealt with by the generational GC, instead it thrashes the major GC (which is very slow for equivalent heap sizes compared to major GCs from other VMs, because copying collection is not a good idea for long-lived data, but that's another issue)

@jeapostrophe , can you take a look at this PR?

My pedantic side says we shouldn't do this, because it is not really gzip'd (which requires a header & footer), so there is an error, but my pragmatic side can deal with it. Regarding Greg's comment, I'm more comfortable taking the version that checks the code, but perhaps that's just best left as a comment with a link to the email thread.

Actually, one request I might reasonably make of myself is to go ahead and make path/param transparent as well, and I'd be happy to fulfill this request if asked.

Did you push -f? Looks like all our previous discussion is gone.

Well, anyway, I think the name change was the only thing left to fix, so I'll go ahead and merge it.
I'll add the `unit:` prefix to the property name, though, so please update the TR PR accordingly.

Merged, thanks!

Yes, you should do that too!

If you're thinking about optimizing `call/cc`, @gus-massa, I can mention my favorite desired optimization: transforming

```
(call/cc (lambda (k) (if e1 e2 (k e3))))
```

into

```
(if e1 e2 e3)
```

And more generally when `k` is only used as a operator in tail position wrt the `lambda`.

Looks good.

I'm not happy with this behavior, but I haven't yet figured out how to rebalance evrything. I'm still trying.

The "ignored" case is much easier, because all the information is already available. Each argument has a "use count", but it's not very reliable during the optimization pass, because it's not updated when the code is eliminated or duplicated.

0 means unused. 1 means probably at most one, and this was the source of a recent bug. More than 1 actually means undefined but probably many times. (I think that the number is correct initially, but some parts are optimized multiple times.)

With a reliable count it would be easier, because we can count all the tail calls and compare the number with the total use count. The alternative is to inspect all the expression if it's small enought, using a fuel to bound the exploration deep. For example, currently there is a similar function that checks that the expression uses no mutable bindings, to detect that it's safe to move.

This seems right as far as I can tell (but with a `printf` that I expect you already plan to remove).

Looks good to me. I don't have a good idea for the test, either, but probably the example should go in "optimize.rktl" to ensure that the flattening code is run.

Thank you.

Merged, thanks!

I think that the only way is to inspect the bytecode. Is this test ok?

Thanks! I've pushed it.

_their_!

@LeifAndersen Are you running into GitHub query limits? I think I ran into that problem a week or two ago, and I have been thinking that we should switch `raco pkg` to always use the Git protocol, instead of using GitHub API queries.

I've run into the API limits, such as with `raco pkg update -a` run repeatedly.

@samth Doah.

@mflatt Yes, I run into them quite regularly when updating.

Ditto. The limits make `raco pkg catalog-archive` unreliable, too.

Combining this with `prop:expansion-contexts` solved TR's issues nicely, thanks. So I'll go ahead and merge a squashed version of this unless anyone has any objections.

I'll merge the simple version now. I'll try to write the more complete version later.

Closed by 33bb5e906086e4e0c0951d840916f8fa4bef602c.

Thanks for the clarification! I've adjusted the collector to better take into account phantom-byte counts for triggering GCs.

Your original example still triggers only major GCs when run by itself, but it now triggers minor GCs when run in a context with a larger overall footprint. 

Just looking at Greg Hendershott's guide fo infrequent contributers to Racket: sorry this isn't in a branch.

@acarrico This is totally fine -- how you organize the `acarrico/racket` fork doesn't affect how it looks when reviewing.

Is there a test case for this, though? It looks like one ought to be pretty easy to construct.

Sorry: test case: (sort '(1 2 3))

Let me know if you add a test case to build, since I don't really know where that would go.

Actually, to test it you need a special environment. I got from in racket-mode.

Test cases would go here: https://github.com/plt/racket/blob/master/pkgs/racket-test-core/tests/racket/function.rktl

But running that expression gives me what I expect:

```
-> (sort '(1 2 3))
; sort: arity mismatch;
;  the expected number of arguments does not match the given number
;   expected: 2 plus optional arguments with keywords #:cache-keys? and #:key
;   given: 1
```

Is there something else I need to do to see the error?

Try in the racket-mode _racket REPL_. I guess there needs to be a missing (syntax-line stx), so it is context sensitive.

t﻿> (sort '(1 2 3))
; format: format string requires 2 arguments, given 3; arguments were: "~a:::~a: " 'stdin #f 6965

So a proper test case would presumably need to synthesize syntax without line numbers for evaluation.

Here's a test program that errors currently.

```
(let ()
 (define l (make-log-receiver (current-logger) 'warning))
 (eval (datum->syntax #'here '(lambda () (sort 1)) (list 'a #f #f #f #f))))
```

You can make that into a test case for that file as follows:

```
(let ()
  (define l (make-log-receiver (current-logger) 'warning))
  (test procedure? (eval (datum->syntax #'here '(lambda () (sort 1)) (list 'a #f #f #f #f))) #t))
```

You forgot the "expect" argument (below), but otherwise that works (fails before, doesn't fail after the change). I don't know the racket dev test culture, but wouldn't commiting this in "function.rktl" be a confusing legacy? It is a contrived test for a random bug, whereas all the other tests are readable tests of function operators. 

(let ()
  ;; ISSUE: format: format string requires 2 arguments, given 3; arguments were: "~a:::~a: " 'a #f #f
  (define l (make-log-receiver (current-logger) 'warning))
  (test #t
        procedure?
        (eval (datum->syntax #'here '(lambda () (sort '(1))) (list 'a #f #f #f #f)))))

Looks good to me. Commit?

On Thu, Sep 10, 2015 at 9:32 PM, Anthony Carrico notifications@github.com
wrote:

> You forgot the "expect" argument (below), but otherwise that works (fails
> before, doesn't fail after the change). I don't know the racket dev test
> culture, but wouldn't commiting this in "function.rktl" be a confusing
> legacy? It is a contrived test for a random bug, whereas all the other
> tests are readable tests of function operators.
> 
> Many of the tests I use are there to check correct behavior of functions
> (like, iiuc, this one) that were put in place because of some strange bug
> somewhere. My experience is that adding those tests is a win.

Hi Robbie, the issue here is that you get a dynamic error (a format someplace in the implementation has wrong args). Sam's test works for this case, but doesn't really test anything about functions per se. I guess my question is, why test this format string, but none of the others in the code base, and why test it here in this very indirect way (my EE training "test at the pin")? Nobody could look at the test case and say, "oh, that is testing for a bad format string". We now presume this one is correct, and unlikely to regress. I suppose, the proper solution would be for "somebody :)" to switch the code base to a format macro that checks args statically (for non higher order use of format), and then to use test cases to ensure the static checker really catches bad format strings. That would solve the problem across the code base.

That all makes sense and I understand. If there is ​a better place to put a
test case, then by all means, please put it there! If there are other test
cases that come to mind as worth testing (or perhaps an entire class of
problems to test for that you could automate by using random testing) then
make more tests.

But putting this one test in is a good idea because it makes sure in the
most concrete way that this one bug is no longer in the codebase. It is a
minimum bar to pushing a bug fix. One changed piece of behavior that makes
sure that this one specific bug is for sure gone.

Does this make more sense?

ok!

LGTM

@LeifAndersen I changed `raco pkg` to use the Git protocol for GitHub. Are you still interested in adding `PLT_GITHUB_API_KEY`?

Yes, that looks like a good test.

Cool, thanks.

Nah, I'm not really interested then. I only cared because we were hitting the API rate limit, and if that's not a problem any more then I don't care.

Thanks for pushing this.

Thanks for the patch! I ended up revising "INSTALL.txt" in other ways, based on your suggestion (see a3e359d9e167365887b0a9b4948c7fe859869021)

I agree about adding a test case. I'd put it in "syntax.rktl", since the intent is to test error formatting from the keyword-argument `lambda` layer.

Merged as 52aa11c4074041b2cfb4628b7c960c79419e3104

It doesn't seem to be the duplicate filename so much as that `tar` on Linux generates a bad file in this case. I'll adjust `untar` to report an error instead of letting an internal error through.

This actually seems to go through on OS X. :/ (Without throwing the contract violation.)

At the `pkg-archive-pkgs` level, there's a `#:package-exn-handler` argument that provides control over failure. The `pkg-build` package uses that, for example.

For `raco pkg catalog-archive`, I think it makes sense to add a flag to specify how to handle a package failure: `fail` (as currently), `ignore` (log error but succeed), or `continue` (log error, continue archiving, and report failure at the end through a specific non-zero result).

I can make the default `ignore` or `continue`, but I'm not really sure that' would be better as the default. Maybe it's enough to offer options but keep the current default?

This was merged as https://github.com/plt/racket/commit/2923a3adcfed4a10fc756ee8b8e208d266ae191b

Seems like a better place. I've put it there and committed.

Merged, thanks!

Merged.

Merged now, thanks!

Merged, finally.

Oh, good eye! I like these suggestions. HTTPS and checksums would be a nice start. 

Racket releases could also be signed using pgp/gpg by one of the core developers. Users can then use something like gpg --verify command to ensure they've received an authentic file from a trusted source. This approach is taken by many projects, such as [OpenSSL](https://www.openssl.org/docs/faq.html#MISC7), [Debian](https://www.debian.org/CD/verify), & [PyPI](https://www.davidfischer.name/2012/05/signing-and-verifying-python-packages-with-pgp/).

The reader in `send-exp` is not right for the new macro system. See the discussion at
 https://groups.google.com/d/msg/racket-dev/6khgHKygmS4/bWHpC04v8HwJ
and the example
 https://github.com/AlexKnauth/afl/commit/b0207da998a81c83af3f4ba1124339dbf4026da7
or
 https://github.com/greghendershott/rackjure/commit/58a9c87d00ea0927d5a73ad29867bf255fad9fbb

That "example.rkt" runs in plain `racket` is a bug that comes from trying to make the top level work, and I should be able to fix that.

It still seems to be the case that minor GCs don't "collect" the phantom bytes. So even though phantom-byte allocation would trigger collection of other data, the phantom bytes themselves aren't collected, and thus allocating phantom bytes in a loop (which, say manage malloc'd memory in the FFI) would still cause embarassingly long pauses.

That is, FFI memory still can't be collected in a generational manner by simply freeing them in a will of some phantom byte string. Animations using bitmaps still trigger frequent major GCs. On the other hand, using actual byte strings does the trick, and reduces GC latency.

If this is impossible/unreasonably hard to fix, at least there should be some parameter to make all the phantom-byte functions actually do nothing. GCs would probably run at inconvenient times and cause memory usage to be overly high, but I would think that pauses could be reduced. A 10 fps animation has no reason to not be smooth (almost) all of the time with a modern GC, and shouldn't pause every two seconds.

+1

Also, it seems to me that an implementation of `string-contains?` using for loops will be nearly 10x faster than using a regular expression. Argument [here](https://gist.github.com/bennn/0772b7d59bfdb421c048).

Hi Benjamin,

Can you time the following?

(define subs (make-weak-hash))

(define (string-contains4 str sub)
  (match (hash-ref subs sub #f)
    [#f  (define re (regexp sub))
         (hash-set! subs sub re)
         (regexp-match? re str)]
    [re  (regexp-match? re str)]))

/Jens Axel

2015-09-13 10:04 GMT+02:00 Benjamin Greenman notifications@github.com:

> +1
> 
> Also, it seems to me that an implementation of string-contains? using for
> loops will be nearly 10x faster than using a regular expression. Argument
> here https://gist.github.com/bennn/0772b7d59bfdb421c048.
> 
> —
> Reply to this email directly or view it on GitHub
> https://github.com/plt/racket/issues/1056#issuecomment-139849989.

## 

## 

Jens Axel Søgaard

To build a version other than the current development version out of the Git repo's top-level `make`, you'll need to supply the corresponding release's catalog:

`make SRC_CATALOG=http://download.racket-lang.org/releases/6.2/catalog/`

I'll adjust "INSTALL.txt" to explain (but, as the start of "INSTALL.txt" tries to suggest, it's better to use the source distribution from the download page).

4018.87 ms

Here's another example that tests one pair of strings repeatedly. The regular expressions are still a little slower.

```
(define (repeat-test)
  (define s1 "mississippi")
  (define s2 "wishing")
  (for ([f (in-list (list string-contains1 string-contains2 string-contains3 string-contains4))])
    (printf "Testing '~a'\n" (object-name f))
    (benchmark (for ([i (in-range 10000)]) (f s1 s2)))))
```

Results

```
Testing 'string-contains1'
Average of 30 runs: 4.87 ms
Testing 'string-contains2'
Average of 30 runs: 0.87 ms
Testing 'string-contains3'
Average of 30 runs: 0.8 ms
Testing 'string-contains4'
Average of 30 runs: 1.67 ms
```

Thanks! Pushed: http://git.racket-lang.org/plt/aa0823daf6..dedde2cd60

I'm not well-studied in this, but wouldn't an algorithm like [Boyer-Moore](https://en.wikipedia.org/wiki/Boyer%E2%80%93Moore_string_search_algorithm) be faster than regexes?

Would you test this by having a canned git repo somewhere and then asking
this to do a checkout?

Is there already a test suite for this code?

thanks!

A grep of the main repo shows no usages of `git-checkout` in a test directory (or in fact out side of the pkg collection), so I don't think there is a test suite yet.

My "test" originally was to clone the Racket repo and diff the result. I think that created the illusion of a test, so that I forgot to automate it.

minor?

I think both of those are in never-on config options.

Yeah, probably that is the reason why nobody complained before :) .

@samth, if some of the devs have some free time, try to check the code with cppcheck. It shows a lot of warnings but I don't understand the GC code.

This sounds great!

Does it make sense to use the word `system` in the name of the function?
Like system-random or something like that to indicate that it's coming from
the underlying OS?

I believe that `secure-random` is best, as it makes the procedure more "self-documenting". 

If we went with `system-random` for instance, the programmer wonders "what's the difference between this and the normal `random`?" By naming it `secure-random`, its properties are clear & the programmer need not wonder the difference. This point was convincingly argued by lexi-lambda in an IRC discussion.

I believe the documentation would be the best place to explain the source of randomness. 

Okay.

I feel pretty strongly that "secure-random" is a misleading name, because
it is very opinionated and "blesses" the function too much. There's no
reason that the OS is particularly secure and there are many instances of
mistakes in this part of OSes. I think a name like "system-random" is
perfectly apt: it is descriptive and you can use the documentation to
explain why you'd like to use it over others.

Jay

On Tue, Sep 15, 2015 at 9:12 PM, Robby Findler notifications@github.com
wrote:

> Okay.
> 
> —
> Reply to this email directly or view it on GitHub
> https://github.com/plt/racket/issues/1062#issuecomment-140591823.

## 

Jay McCarthy
http://jeapostrophe.github.io

```
       "Wherefore, be not weary in well-doing,
  for ye are laying the foundation of a great work.
```

And out of small things proceedeth that which is great."
                          - D&C 64:33

Is the goal of these random sources to be secure? (And we're just seeing
bugs (and then presumably fixes)?) Or is the design of these randomness
sources something else?

Jay, I see your point, but I disagree with that argument. I think `secure-random` is the clearest name because it expresses _intent_. All of the data sources are inherently intended to be secure. The OS may provide many random functions, but this only uses the ones specifically intended for secure/cryptographic use.

This isn't terribly unreasonable: consider the Ruby [SecureRandom](http://ruby-doc.org/stdlib-2.1.2/libdoc/securerandom/rdoc/SecureRandom.html) class. It lists the following potential sources:

> - openssl
> - /dev/urandom
> - Win32

None of these are internal to Ruby, of course, but that's probably for the best. Secure cryptography is notoriously hard, and the only way to get _any_ semblance of security is to use the existing sources that have been proven over the years.

I think throwing out the term "secure" because there might be bugs is too idealistic. All software _might_ have bugs, but whole industries depend on the fact that these pieces of software don't. The fact that any vulnerabilities make huge headlines (e.g. Heartbleed) is proof that they're overally pretty solid.

Calling a function `system-random` doesn't tell me anything at all (not even any more than the name `random`). I'd rather my code be self-documenting wrt intent than be 100% safe by avoiding a highly unlikely potential inaccuracy.

I think that phantom bytes were being double-counted, and I've pushed a change along those lines.

Sorry if It seems like I'm not giving this enough attention. Actually, I've spent the last several days on the GC with the goal of better supporting interactive programs. (I've tried to talk other people into working on the GC, but it doesn't look like that's going to happen.)

I disagree about what the name `system-random` tells you. It says "this
uses the source of randomness on the machine where the program you're
writing is eventually run". That is a lot of information, IMO.

I googled around and found nothing that seemed authoritative, but got the
general sense that things like /dev/random aren't trying to guarantee real
sources of randomness, but instead use what entropy they have available
and, when they run out, fall back to PRNG algorithms.

So system-random is starting to sound better to me too.

`dev/urandom` is the preferred Unix source of cryptographically secure randomness. Most OS level sources of randomness are used _because_ they have some actual source of entropy they can use, giving you true random numbers (as much as they can, if they run out of entropy for a request they fall back on standard PRNG methods). This does make calling them "secure" an apt term.

I interpreted the "if they run out of entropy" clause as saying that they
weren't designed to be secure, but were more of a best effort. Is that the
wrong interpretation?

It's more "as secure as is practically feasible on this system" which, unless you're making a call to a web service that provides stronger guarantees, is probably the best you're going to get.

Appeal to authority is a terrible way to argue, but I'd like to cite Daniel
J. Bernstein, Thomas Pornin, and Thomas Ptacek, whose arguments for
/dev/urandom being cryptographically secure are quoted in [this article](http://www.2uo.de/myths-about-urandom/#experts) which discusses myths about
/dev/urandom.

Alexis brings up a crucial point which is the probability that someone
[misuses randomness](https://news.ycombinator.com/item?id=639976), thereby
introducing insecurities where none may have existed, is much higher than
the probability that /dev/urandom is insecure. This motivates the
suggestive name `secure-random`.

On Tue, Sep 15, 2015 at 9:55 PM, Robby Findler notifications@github.com
wrote:

> I disagree about what the name `system-random` tells you. It says "this
> uses the source of randomness on the machine where the program you're
> writing is eventually run". That is a lot of information, IMO.
> 
> I googled around and found nothing that seemed authoritative, but got the
> general sense that things like /dev/random aren't trying to guarantee real
> sources of randomness, but instead use what entropy they have available
> and, when they run out, fall back to PRNG algorithms.
> 
> So system-random is starting to sound better to me too.
> 
> —
> Reply to this email directly or view it on GitHub
> https://github.com/plt/racket/issues/1062#issuecomment-140597898.

Additionally, there is also precedent of the output of /dev/urandom being used directly to generate keys in cryptographic software. NaCl and LibreSSL both do this (and I'm sure others exist).

NaCl in particular is an extremely well-designed cryptographic library. It embodies best practices all around. As a result, I feel it wouldn't be disingenuous to call it `secure-random`.

I'd like to post the patch [here](https://gist.github.com/eu90h/5dfd65a3aa1b276be49c) for initial review. I have another pull request  (#1055) open and apparently can't issue another one, so a gist will have to do. My plan is to put it in the `racket/collects/file` directory for lack of a better place.

I am not convinced by these arguments for secure-random vs system-random. I
think that we should reserve a name like secure-random for something that
is known to be a cryptographically secure PRNG, such as Blum Blum Shub. All
we know about /dev/urandom is that "the operating system provided it" (so
in the case of Windows that probably means the NSA provided it) and that's
what a name like "system-random" communicates.

I think that naming the module with something like "file" is confusing
because it rolls the implementation in to the name too much. I think a new
"os" collection (like mzlib/os) or extension to the "racket/system" is the
right place.

In contrast, I feel like a "secure-random" would come from a "math"-related
collection, but since we know that this implementation has no math in it,
it's clear it's not an RNG implementation we really know anything about and
can vouch for, so that's not a good place for it.

Jay

On Wed, Sep 16, 2015 at 3:39 AM, Stefan notifications@github.com wrote:

> I'd like to post the patch here
> https://gist.github.com/eu90h/5dfd65a3aa1b276be49c for initial review.
> I have another pull request open and apparently can't issue another one, so
> a gist will have to do. My plan is to place it the directory
> racket/collects/file for lack of a better place.
> 
> —
> Reply to this email directly or view it on GitHub
> https://github.com/plt/racket/issues/1062#issuecomment-140656900.

## 

Jay McCarthy
http://jeapostrophe.github.io

```
       "Wherefore, be not weary in well-doing,
  for ye are laying the foundation of a great work.
```

And out of small things proceedeth that which is great."
                          - D&C 64:33

On Tue, Sep 15, 2015 at 9:17 PM, Stefan notifications@github.com wrote:

> http://www.2uo.de/myths-about-urandom/#experts)

Reading this webpage says to me that system-random is the right name. As
Jay writes, it sends the message that this random function is one that
comes from the system. I think the documentation can explain that it is
probably the best choice for cryptographically secure random numbers (and
we can say that in the docs for the other random functions, pointing to
system-random), but fundamentally all Racket can say about it is that it's
guarantees come from elsewhere.

I agree that adding the function to `racket/system` is better than
something with the word "file" in it.

I'm strongly in favor of the name 'secure-random'. As Jay says, that should
indicate use of a CSPRNG seeded with genuine randomness, which is exactly
what /dev/random is.

On Wed, Sep 16, 2015, 7:58 AM Robby Findler notifications@github.com
wrote:

> I agree that adding the function to `racket/system` is better than
> something with the word "file" in it.
> 
> —
> Reply to this email directly or view it on GitHub
> https://github.com/plt/racket/issues/1062#issuecomment-140720060.

On Wed, Sep 16, 2015 at 8:06 AM, Sam Tobin-Hochstadt <
notifications@github.com> wrote:

> I'm strongly in favor of the name 'secure-random'. As Jay says, that should
> indicate use of a CSPRNG seeded with genuine randomness, which is exactly
> what /dev/random is.

On what platforms and where is this guarantee given? Will Racket ever be on
platform that doesn't provide such a guarantee? (say random Javascript
browsers) Are the algorithms that most OSes use actually proved to be
CSPRNGs or just "designed to be CSPRNGs"?

Jay

## 

Jay McCarthy
http://jeapostrophe.github.io

```
       "Wherefore, be not weary in well-doing,
  for ye are laying the foundation of a great work.
```

And out of small things proceedeth that which is great."
                          - D&C 64:33

On Wednesday, September 16, 2015, Sam Tobin-Hochstadt <
notifications@github.com> wrote:

> I'm strongly in favor of the name 'secure-random'. As Jay says, that should
> indicate use of a CSPRNG seeded with genuine randomness, which is exactly
> what /dev/random is.
> 
> The web claims otherwise, saying that it is best effort.

Two other observations that point towards "system" being the most important
feature of this function than "secure":
- the implementation can raise the error "/dev/urandom does not exist".
- the names of the underlying sources do not have the name "secure" in
  them.

A bit (lot) longer on why I think this should be called `secure-random` (or something similar like `crypt-random`):
1. The underlying operations are genuinely aimed at secure operations. Here's a quote from the [kernel manpage for Linux](http://man7.org/linux/man-pages/man4/random.4.html):
   
   > If a seed file is saved across reboots as recommended below (all
   >      major Linux distributions have done this since 2000 at least), the
   >      output is cryptographically secure against attackers without local
   >      root access as soon as it is reloaded in the boot sequence, and
   >      perfectly adequate for network encryption session keys.
   
   @rfindler, I think what the web claims is that _genuine randomness_ is best-effort from  `/dev/urandom` -- when entropy is low, a cryptographically-secure PRNG is used to generate more bits.
   
   Here's the Mac page:
   
   >  The random device implements the Yarrow pseudo random number generator algorithm
   
   [Yarrow](https://www.schneier.com/yarrow.html) is, according to its web page, "a secure pseudorandom number generator".
   
   The [Win32 API](https://msdn.microsoft.com/en-us/library/aa379942.aspx) is actually called `CryptGenRandom`, and says:
   
   > The CryptGenRandom function fills a buffer with cryptographically random bytes.
2. These operations are widely available. According to Wikipedia, `/dev/random` and `/dev/urandom` are available on Linux, NetBSD, OpenBSD, FreeBSD, Solaris, HP-UX, Cygwin, and AIX. A quick search shows that it's available on DragonflyBSD too. I believe that covers all of the platforms we support currently. 
   
   As for JavaScript, all recent browsers now support `crypto.getRandomValues()`, which says in its spec
   
   > The getRandomValues method generates cryptographically random values. 
   
   So I don't think we'd need to raise the "does not exist" error. 
3. Other languages expose these sources of randomness with the word "secure" or "crypto" in them. @lexi-lambda already mentioned Ruby. Java puts it in `SecureRandom` as well. The WebCrypto JS standard puts it on the `crypto` object. In [node.js](https://nodejs.org/api/crypto.html#crypto_crypto_randombytes_size_callback) it's called `crypto.random()`. Haskell has the `Crypto.Random` library (and a bunch of others). As [this StackOverflow answer](http://stackoverflow.com/a/20890675) shows, in Haskell `System.Random` is the _insecure_ random number generator. 
   
   Python seems to be the outlier, where it's called `SystemRandom` and `os.urandom()`. 
4. The name `secure-random` (or something similar, such as `crypto-random`, or `random` from a `racket/crypto` library) is important for communicating to users. The Hacker News vulnerability that @eu90h linked to (and which I strongly encourage everyone to read) came down to using Racket's `random` function with an inadequately-random seed in a security-sensitive situation. Naming the function in a way that encourages developers to use it is an important part of the user interface, for which documentation is an imperfect substitute.
5. Every OS that runs Racket provides a "system" source of randomness that is _not secure_, and it's important to distinguish the use of `/dev/random` and similar from those. On Linux/Windows/etc, that's `rand()`, on JavaScript it would the `Math.random()` function. We don't want to cause people to think that the function proposed here is a binding to those system-level operations.
6. Writing our own CSPRNG would be a very bad idea. The Racket community doesn't include any cryptographers that I know of, and even if it did, anything we write wouldn't be as tested, audited, attacked, or validated as system-provided CSPRNGs.
7. In cases where the OS doesn't provide a CSPRNG (none that we support currently, I think) we already ship OpenSSL on many platforms and can use that to provide a CSPRNG. 

Thank you Sam. Three thoughts come to mind:

I find this to be a strong argument for crypto-random more than for
secure-random.

Jay has published four crypo papers according to DBLP. What is your bar?

I think `crypto-random` is fine. @eu90h, what do you think?

And @jeapostrophe, I 100% apologize for forgetting your past as a cryptographer!

Just to interject my perspective as an user-space developer using Racket in
personal projects.

To me this discussion boils down to who has done the work of verifying the
function is secure or whether the Racket stakeholders have delegated that
to some other third-party. I define third-party as an entity non-affiliated
with Racket and Racket does not have any control over its activity.

When I read "secure-random", I interpret it as meaning Racket has done the
work of verifying the source meets acceptable standards of being secure,
including audit of the relevant code. When I follow the discussion, I am
getting the message that Racket is actually deferring to third-parties to
make the security claim.

If I use secure-random, believing that its guarantees have verified by
Racket and it's actually using the underlying operating system service
which may or may not have understated its claims, should Racket be blamed
for misleading me into believing that using this function is secure?

Since we live in a time where security claims are frequently found to be
exaggerated or mistaken, it may be more risky to claim more than intended.
It seems more appropriate to label the function to be clear to what it
really is, if that is what is is, just rebinding of /dev/urandom,

So I would say it's more honest to say "os-urandom" so developers know
exactly what it is and can decide for themselves whether urandom is
appropriate for their needs. And moreover, there is /dev/random and
/dev/urandom, one is blocking till enough entropy is collected and the
other does not and you've got to deal with the possibility that
/dev/urandom may not have had enough time to generate entropy.

Does "secure-random/system-random" already take into account the difference
between /dev/random and /dev/urandom?

On Wed, Sep 16, 2015 at 11:35 AM, Sam Tobin-Hochstadt <
notifications@github.com> wrote:

> I think crypto-random is fine. @eu90h https://github.com/eu90h, what do
> you think?
> 
> And @jeapostrophe https://github.com/jeapostrophe, I 100% apologize for
> forgetting your past as a cryptographer!
> 
> —
> Reply to this email directly or view it on GitHub
> https://github.com/plt/racket/issues/1062#issuecomment-140779713.

I feel better about crypto-random than secure-random.

I have confidence and trust in the rest of you to decide on a name and
place to put it that reflects our tradition and naming conventions. I'll
step out of the pull request debate to help make progress.

Jay

On Wed, Sep 16, 2015 at 11:35 AM, Sam Tobin-Hochstadt <
notifications@github.com> wrote:

> I think crypto-random is fine. @eu90h https://github.com/eu90h, what do
> you think?
> 
> And @jeapostrophe https://github.com/jeapostrophe, I 100% apologize for
> forgetting your past as a cryptographer!
> 
> —
> Reply to this email directly or view it on GitHub
> https://github.com/plt/racket/issues/1062#issuecomment-140779713.

## 

Jay McCarthy
http://jeapostrophe.github.io

```
       "Wherefore, be not weary in well-doing,
  for ye are laying the foundation of a great work.
```

And out of small things proceedeth that which is great."
                          - D&C 64:33

Added, thanks!
@bennn, could you close this. I can't.

Merged, thanks!
@bennn, could you close this? I can't.

@stamourv I can't close it either.

Yes!

@bennn: Oh right, you didn't open this one. Nevermind.

This thread reminds me of that old joke, "there are only two problems in CS, cache invalidation and naming things."

25 comments, this thread have been quite lively! I hope I haven't come across in any posts as rude or stubborn, if I have I preemptively apologize.

@samth I'm fine with the name `crypto-random`.
Given @jeapostrophe's background with both cryptography & Racket itself, his opinion should be weighted more heavily. If he's comfortable with `crypto-random`, then I'll choose that one.

Regarding the location, I too felt the `file` directory was a poor choice, but I'm still unfamiliar the with general file structure and available packages/collections so just went with `file` because it had sha-1 and md5 implementations there.

Thanks @bennn & @stamourv for adding this

Lets go with `crypto-random`.

I still feel like racket/system is a good place for the actual
implementation (and maybe if you flip through the code, you'll agree too?)

Also, I think that we should, at the same time, update the documentation
for the other random functions to refer to this one so people are less
likely to have exploits like the one that affected HN.

@rfindler racket/system was exactly what I had in mind when I started, I must've somehow missed it's folder.

Edit: I can update the old random docs too, if you wish.

Running with `raco setup -c` (which triggers bootstrapping) produces the same error. As does `raco pkg remove --force unstable-doc`.

I've just done the same "test" as Matthew, and everything checks out. I don't think I'll have time to actually automate that test before racket con, and `cover-coveralls` is not working without this. Is it okay to merge it anyways?

@eu90h thanks for suggesting

I don't think `raco setup` should try to fix that kind of state. It should be able to deal with arbitrarily out-of-date bytecode or other files that it's supposed to build, but I don't think it should try to patch up things like collection links.

I wasn't thinking that it should fix the situation, just not be unable to continue. Do you think `raco pkg` should work? Should anything?

I see the distinct you're making between "fix" and "continue", but I'm reluctant to commit `raco setup` to even continuing in this situation, because it seems more difficult to maintain than it's worth.

Ugh.. not sure why it's failing - give me a while.
EDIT: looks like travis-ci couldn't find raco and failed all the tests, not sure if I did that or what?

Do you have a suggestion for what I should do to fix this installation?

Any particular reason you closed this, @eu90h?

I fudged my racket fork by accidentally pushing to the master branch, so as
I pushed to OS rng stuff it was "on top" of the sha-256 binding commits.
I'll reopen later tonight/tomorrow.

On Wed, Sep 16, 2015 at 9:54 PM, Sam Tobin-Hochstadt <
notifications@github.com> wrote:

> Any particular reason you closed this, @eu90h https://github.com/eu90h?
> 
> —
> Reply to this email directly or view it on GitHub
> https://github.com/racket/racket/pull/1055#issuecomment-140941953.

additionally, it probably wouldn't hurt to wrap the whole sha-2 family
while I'm in there

On Wed, Sep 16, 2015 at 9:59 PM, Stefan A euler90h@gmail.com wrote:

> I fudged my racket fork by accidentally pushing to the master branch, so
> as I pushed to OS rng stuff it was "on top" of the sha-256 binding commits.
> I'll reopen later tonight/tomorrow.
> 
> On Wed, Sep 16, 2015 at 9:54 PM, Sam Tobin-Hochstadt <
> notifications@github.com> wrote:
> 
> > Any particular reason you closed this, @eu90h https://github.com/eu90h?
> > 
> > —
> > Reply to this email directly or view it on GitHub
> > https://github.com/racket/racket/pull/1055#issuecomment-140941953.

AppVeyor failure: `Build execution time has reached the maximum allowed time for your plan (40 minutes).`. Everything seems ok otherwise.

Does it help to create the directory that the error message complains about?

That's fine with me.

Yes, that worked.

merged - thanks!

I'm not opposed to this addition, but I wonder whether it would be better to add it in a separate package (while `openssl/libcrypto` should be documented so that packages can reasonably depend on it)

I'd expect `bytes->number` to be like `string->number`, but I don't have a good name for this function. I also worry that it's not needed enough to include in `racket/bytes`.

AppVeyor failure seems to be due to some timeout, rather than any build or test issues.

@jackfirth I don't know why it started timing out once I switch `plt/racket` to `racket/racket`. :(

As others have said in #1062, this good addition is a good idea.

Others suggested `racket/system`, but I don't think that's the right place, because "system" in `racket/system` really refers to the `system` function. I suggest making it `racket/random`.

Various tweaks would make it easier to merge:
- The internal modules "unix_rand.rkt" and "windows_rand.rkt" should be moved into a "private" subdirectory. Also, using a hyphen instead of an underscore in the name would be more consistent with our naming conventions.
- My sense from the earlier discussion is that "Provides strong randomness from the underlying OS" in the docs is too strong, and it should just be "Provides randomness from the operating system".
- Use "Unix" instead of "*NIX". I know that's less technically correct, but it's our convention for now.
- Use `@filepath{...}` for path names.
- Use `@racket[crypto-random-bytes]` in the note to make sure it typesets and hyperlinks right. But I think the note really belongs next to `random`, not next to `crypto-random-bytes` itself. Less importantly, please reword to avoid starting the sentence with a lowercase name.

Thanks

merged

merged - thanks!

It might make more sense to do it in terms of `bytes->list` rather than `bytes->hex-string`:

``` racket
(define (bytes->number bytes)
  (digits->number (bytes->list bytes) 256))

(define (digits->number digits base)
  (let loop ([n 0] [digits digits])
    (if (empty? digits)
        n
        (loop (+ (* n base)
                 (car digits))
              (cdr digits)))))
```

The rationale for this being different from `string->number` is that a byte string is already canonically one number - the result of treating it as a list of digits in base 256.

Rather than "strong randomness", would "cryptographically secure randomness" be preferable? The function is meant to guarantee that the numbers it produces are from a cryptographically secure pseudorandom number generator provided by the OS. That's more technically accurate and conveys why you'd want to use this over `random`.

Thanks a lot Matthew, `racket/random` sounds good. I'll rewrite the docs & fix everything to align with convention (sorry, still learning the ropes!)

Additionally, I'd like to thank @jackfirth a bunch for helping me review this.

I agree with @jackfirth -- "strong" is unclear, but in cases where the OS doesn't provide genuine randomness or a well-seeded CSPRNG, we should error rather than returning something weaker.

Are you using a checkout where you previous ran `make in-place` or just `make`? I think you'd get the reported error in that case. Using `make unix-style` will work only with a fresh checkout.

I can confirm that starting from a clean clone works.

FWIW, I have written this function a few times using Jack's version. I've also written it before using integer-bytes->integer and using base 2^32

I think there are still some issues with GC of phantom bytes causing more major GCs than necessary.

Consider:

```
[samth@huor:~/tmp plt] cat pb.rkt
#lang racket/base

(define t
  (thread (lambda ()
            (let loop()
              (make-phantom-bytes (* 1 1000 1000))
              (loop)))))
(sleep 2)

(kill-thread t)

[samth@huor:~/tmp plt] cat b.rkt
#lang racket/base

(define t
  (thread (lambda ()
            (let loop()
              (make-bytes (* 1 1000 1000))
              (loop)))))
(sleep 2)

(kill-thread t)
```

Running these with my `gcstats` tool:

```
[samth@huor:~/tmp plt]  r -l gcstats -t  pb.rkt


 51,445,910,528 bytes allocated in the heap
 51,444,501,720 bytes collected by GC
     79,647,080 bytes max heap size
     47,715,920 bytes max slop
    127,207,616 bytes peak total memory use

Generation 0:   1,141 collections,      218ms,   188.30ms elapsed
Generation 1:     375 collections,    1,719ms, 1,762.02ms elapsed

INIT  time        24 ms
MUT   time        86 ms (     87.74 ms elapsed)
GC    time     1,937 ms (  1,950.31 ms elapsed)
TOTAL time     2,047 ms (  2,062.06 ms elapsed)

Max pause time:      15.05 ms
%GC time             95.75 %   ( 95.69 % elapsed)

Alloc rate     598,208,261,953 bytes per MUT second
```

Whereas:

```
[samth@huor:~/tmp plt]  r -l gcstats -t  b.rkt


  3,245,420,472 bytes allocated in the heap
  3,244,016,736 bytes collected by GC
     75,715,784 bytes max heap size
    129,515,544 bytes max slop
    134,078,464 bytes peak total memory use

Generation 0:     567 collections,       96ms,   120.49ms elapsed
Generation 1:     105 collections,      470ms,   472.45ms elapsed

INIT  time        18 ms
MUT   time     1,460 ms (  1,433.07 ms elapsed)
GC    time       566 ms (    592.94 ms elapsed)
TOTAL time     2,044 ms (  2,044.01 ms elapsed)

Max pause time:       8.01 ms
%GC time             27.94 %   ( 29.27 % elapsed)

Alloc rate     2,222,890,734 bytes per MUT second
```

Racket is getting about 1/4th the allocation rate with phantom bytes, and spending 95% of its time in GC.

This is with the most recent commits.

Improved the wrapper slightly, making better use of the FFI libs (thanks @samth). 

Where would a better place for this be @mflatt? Or do you mean I should just make it a package and submit it to the index?

Would a statement like, "provides randomness from the underlying OS intended for use in cryptographic applications" be ok?

This statement conveys both the source and the intent.

That sounds right to me.

On Friday, September 18, 2015, Stefan notifications@github.com wrote:

> Would a statement like, "provides randomness from the underlying OS
> intended for use in cryptographic applications" be ok?
> 
> This statement conveys both the source and the intent.
> 
> —
> Reply to this email directly or view it on GitHub
> https://github.com/racket/racket/pull/1064#issuecomment-141588177.

Actually, I read that wrong. Racket is allocating many more phantom bytes than regular ones. I suppose that's to be expected since they're fake.

It's not needed if the server is still running, retracting this PR.

Looks like something goes wrong on windows. From the AppVeyor build (above)

```
Downloading repository git://github.com/racket/data/?path=data-lib
file-or-directory-permissions: update failed due to unsupported bit combination
  path: C:\Users\appveyor\AppData\Local\Temp\1\14422706421442270642484-racket_data_master\.gitignore
  permission value: 420 
  context...:
   C:\projects\racket\racket\collects\net\git-checkout.rkt:669:5: loop 
   C:\projects\racket\racket\collects\net\git-checkout.rkt:141:11 
   C:\projects\racket\racket\collects\net\git-checkout.rkt:38:2: retry-loop 
   C:\projects\racket\racket\collects\pkg\private\download.rkt:99:2: download! 
   C:\projects\racket\racket\collects\file\cache.rkt:63:2: fetch-and-continue 
   C:\projects\racket\racket\collects\racket\contract\private\arrow-val-first.rkt:324:3 
   C:\projects\racket\racket\collects\pkg\private\download.rkt:91:0: download-repo!24 
   C:\projects\racket\racket\collects\pkg\private\stage.rkt:299:11 
   C:\projects\racket\racket\collects\pkg\private\stage.rkt:106:0: stage-package/info46 
   C:\projects\racket\racket\collects\pkg\private\stage.rkt:106:0: stage-package/info46 
   C:\projects\racket\racket\collects\pkg\private\install.rkt:641:4: for-loop 
   C:\projects\racket\racket\collects\pkg\private\install.rkt:141:0: install-packages74 
   C:\projects\racket\racket\collects\pkg\private\..:261:28 
   C:\projects\racket\racket\collects\racket\contract\private\arrow-val-first.rkt:324:3 
   C:\projects\racket\racket\collects\racket\file.rkt:374:8 
   C:\projects\racket\racket\collects\racket\file.rkt:363:0: call-with-file-lock42 
   ... 
NMAKE : fatal error U1077: 'racket\racket.EXE' : return code '0x1'
Stop.
```

I pushed the commits, but then reverted them when I realized the issue above. Sorry about the churn.

As it turns out, `644` is not a valid set of permissions on windows. My google fu tells me that `git` handles this by converting every file to `755` on windows, so I changed things to do that. I have no local windows installs to I'm letting the automatic appveyor build do that.

Hrm, doesn't look like the appveyor build here does any kind of `raco pkg install`. Does anyone have a windows machine I can test this on?

It installs a number of packages for testing -- that's why it failed.

Oh I see, around line 2201 of the output. Missed that. I guess that means its fixed, now that the appveyor build is passing?

OK. Moved the procedure to a new file `racket/random`. Added new documentation for it & margin note on `random` procedure.

Yeah, looks good.

On Sat, Sep 19, 2015, 10:59 PM Spencer Florence notifications@github.com
wrote:

> Oh I see, around line 2201 of the output. Missed that. I guess that means
> its fixed, now that the appveyor build is passing?
> 
> —
> Reply to this email directly or view it on GitHub
> https://github.com/racket/racket/pull/1060#issuecomment-141735166.

Okay if I squash the commits?

Looks like `math`'s `random-bits`, `random-natural`, and `random-integer` should change to either call this function or to get a similar pointer/disclaimer. @ntoronto ?

Also, I noticed this slightly sub-optimal error message:

```
> (random-integer 1 1)
random-natural: contract violation
  expected: Positive-Integer
  given: 0
> 
```

2015-09-20 15:03 GMT+02:00 Robby Findler notifications@github.com:

> Looks like math's random-bits, random-natural, and random-integer should
> change to either call this function or to get a similar pointer/disclaimer.
> @ntoronto https://github.com/ntoronto ?

It would be a bad idea to change them - so a pointer is best.

The standard random functions generate pseudo-random numbers.
This implies that we can repeat experiments using random-seed.

```
#lang racket
(require math/base)
(random-seed 42)
(random-bits 10)
(random-seed 42)
(random-bits 10)
```

Output:  75 75

Note: The new random generator is slower than the standard random number
generator.
          (Not a criticism - cryptographically randomness cost more)

/Jens Axel

> Also, I noticed this slightly sub-optimal error message:
> 
> > (random-integer 1 1)
> > random-natural: contract violation
> >   expected: Positive-Integer
> >   given: 0
> 
> —
> Reply to this email directly or view it on GitHub
> https://github.com/racket/racket/pull/1064#issuecomment-141784144.

## 

## 

Jens Axel Søgaard

That makes a lot of sense.

Thanks,
Robby

On Sunday, September 20, 2015, Jens Axel Søgaard notifications@github.com
wrote:

> 2015-09-20 15:03 GMT+02:00 Robby Findler <notifications@github.com
> <javascript:_e(%7B%7D,'cvml','notifications@github.com');>>:
> 
> > Looks like math's random-bits, random-natural, and random-integer should
> > change to either call this function or to get a similar
> > pointer/disclaimer.
> > @ntoronto https://github.com/ntoronto ?
> 
> It would be a bad idea to change them - so a pointer is best.
> 
> The standard random functions generate pseudo-random numbers.
> This implies that we can repeat experiments using random-seed.
> 
> #lang racket
> (require math/base)
> (random-seed 42)
> (random-bits 10)
> (random-seed 42)
> (random-bits 10)
> 
> Output: 75 75
> 
> Note: The new random generator is slower than the standard random number
> generator.
> (Not a criticism - cryptographically randomness cost more)
> 
> /Jens Axel
> 
> > Also, I noticed this slightly sub-optimal error message:
> > 
> > > (random-integer 1 1)
> > > random-natural: contract violation
> > > expected: Positive-Integer
> > > given: 0
> > 
> > —
> > Reply to this email directly or view it on GitHub
> > https://github.com/racket/racket/pull/1064#issuecomment-141784144.
> 
> ## 
> 
> ## 
> 
> Jens Axel Søgaard
> 
> —
> Reply to this email directly or view it on GitHub
> https://github.com/racket/racket/pull/1064#issuecomment-141785117.

I'd _totally_ forgotten the random functions exported by `math`, apologies. 
I'll add a margin note on those as well.

Some other comments:
- please make a single commit
- please remove changes that are only whitespace (don't change pkgs/racket-doc/scribblings/reference/subprocess.scrbl or racket/collects/racket/system.rkt at all)
- This is a better definition of `crypto-random-unix-bytes`:

```
(define (crypto-random-unix-bytes n)
  (check-urandom-exists)
  (call-with-input-file* "/dev/urandom"
    (λ (port)
      (read-bytes n port))))
```

(It won't leak ports.)
- The file `random.scrbl` isn't linked in anywhere. I guess the `racket/string` organization is the best one to follow. So you would create a new subsection of the "Random Numbers" section in `numbers.scrbl` and put the content of `random.scrbl` there. 
- Please include some examples in the docs. Use fake output, however; don't actually call the real functions during documentation building. (Maybe the resulting bytes could be `#"\0\1\1\2\3\5\b\r\25\"7Y\220\351"` ?)

Also: should racket/random be provided by racket? I'd say yes, but I'm not positive that's a good idea.

Sorry about all that :|

I'll fix it up, thank you.

On Sun, Sep 20, 2015 at 7:43 PM, Robby Findler notifications@github.com
wrote:

> Some other comments:
> 
>    -
> 
>    please make a single commit
>    -
> 
>    please remove changes that are only whitespace (don't change
>    pkgs/racket-doc/scribblings/reference/subprocess.scrbl or
>    racket/collects/racket/system.rkt at all)
> - This is a better definition of crypto-random-unix-bytes:
> 
> (define (crypto-random-unix-bytes n)
>   (check-urandom-exists)
>   (call-with-input-file\* "/dev/urandom"
>     (λ (port)
>       (read-bytes n port))))
> 
> (It won't leak ports.)
> 
>    -
> 
>    The file random.scrbl isn't linked in anywhere. I guess the
>    racket/string organization is the best one to follow. So you would
>    create a new subsection of the "Random Numbers" section in
>    numbers.scrbl and put the content of random.scrbl there.
>    -
> 
>    Please include some examples in the docs. Use fake output, however;
>    don't actually call the real functions during documentation building.
>    (Maybe the resulting bytes could be #"\0\1\1\2\3\5\b\r\25\"7Y\220\351"
>    ?)
> 
> —
> Reply to this email directly or view it on GitHub
> https://github.com/racket/racket/pull/1064#issuecomment-141845625.

On Sunday, September 20, 2015, Stefan notifications@github.com wrote:

> Sorry about all that :|
> 
> I'll fix it up, thank you.

No worries! I am thankful for your contribution. Just want to make it as
good as it can be. :)

Here's a stack trace:

```
(gdb) where
#0  0x00007ffff711bcc9 in __GI_raise (sig=sig@entry=6) at ../nptl/sysdeps/unix/sysv/linux/raise.c:56
#1  0x00007ffff711f0d8 in __GI_abort () at abort.c:89
#2  0x00000000006b4b4e in fault_handler (sn=<optimized out>, si=0xa1fa30, ctx=<optimized out>) at ../../../racket/gc2/sighand.c:99
#3  <signal handler called>
#4  0x0000000000670632 in unmarshal_free_id_info (ut=0x7ffff63084e8, p=0x6) at ../../../racket/gc2/../src/syntax.c:6808
#5  scope_unmarshal_content (box=0x7ffff630ae98, ut=0x7ffff63084e8) at ../../../racket/gc2/../src/syntax.c:6899
#6  0x0000000000670930 in list_to_scope_set (l=0x7ffff630afc8, ut=0x7ffff63084e8) at ../../../racket/gc2/../src/syntax.c:6553
#7  0x000000000066ff4e in datum_to_wraps (w=0x7ffff630af98, ut=0x7ffff63084e8) at ../../../racket/gc2/../src/syntax.c:6713
#8  0x000000000067131e in datum_to_syntax_inner (o=0x7ffff5de3268, ut=0x7ffff63084e8, stx_src=0x99aa80 <scheme_false>, stx_wraps=0x99aa80 <scheme_false>, ht=0x0, tainted=tainted@entry=0)
    at ../../../racket/gc2/../src/syntax.c:7210
#9  0x0000000000671b0e in general_datum_to_syntax (o=0x7ffff630afe8, ut=0x7ffff63084e8, stx_src=0x99aa80 <scheme_false>, stx_wraps=0x99aa80 <scheme_false>, can_graph=can_graph@entry=0, 
    copy_props=copy_props@entry=0) at ../../../racket/gc2/../src/syntax.c:7286
#10 0x00000000006752f3 in scheme_unmarshal_datum_to_syntax (o=<optimized out>, ut=<optimized out>, can_graph=can_graph@entry=0) at ../../../racket/gc2/../src/syntax.c:7334
#11 0x00000000006130bf in read_compact (port=0x7ffff63052f8, use_stack=use_stack@entry=0) at ../../../racket/gc2/../src/read.c:4821
#12 0x000000000060abd1 in read_compiled (params=0x7fffffffabc0, ht=0x7ffff63037e8, pos=1, col=-1, line=<optimized out>, stxsrc=0x0, port=0x7ffff6303620) at ../../../racket/gc2/../src/read.c:5661
#13 read_inner_inner (port=0x7ffff6303620, stxsrc=0x0, ht=0x7ffff63037e8, indentation=0x99c438 <scheme_null>, params=params@entry=0x7fffffffabc0, comment_mode=comment_mode@entry=2, pre_char=<optimized out>, 
    pre_char@entry=-1, table=0x0, get_info=get_info@entry=0) at ../../../racket/gc2/../src/read.c:1438
#14 0x000000000060ed1e in _internal_read (port=0x7ffff6303620, stxsrc=0x0, crc=<optimized out>, cant_fail=cant_fail@entry=0, recur=0, expose_comment=0, extra_char=-1, init_readtable=0x0, magic_sym=0x0, 
    magic_val=0x0, delay_load_info=0x99aa80 <scheme_false>, get_info=get_info@entry=0) at ../../../racket/gc2/../src/read.c:2353
#15 0x000000000060f440 in scheme_internal_read_k () at ../../../racket/gc2/../src/read.c:2427
#16 0x0000000000488d45 in scheme_top_level_do_worker (k=k@entry=0x60f380 <scheme_internal_read_k>, eb=eb@entry=0, new_thread=new_thread@entry=0, dyn_state=dyn_state@entry=0x0)
    at ../../../racket/gc2/../src/fun.c:1322
#17 0x0000000000489059 in scheme_top_level_do (k=k@entry=0x60f380 <scheme_internal_read_k>, eb=eb@entry=0) at ../../../racket/gc2/../src/fun.c:1210
#18 0x000000000060f258 in scheme_internal_read (port=0x7ffff6303620, stxsrc=stxsrc@entry=0x0, crc=crc@entry=-1, cantfail=cantfail@entry=0, recur=<optimized out>, expose_comment=expose_comment@entry=0, 
    pre_char=pre_char@entry=-1, init_readtable=0x0, magic_sym=magic_sym@entry=0x0, magic_val=magic_val@entry=0x0, delay_load_info=delay_load_info@entry=0x0) at ../../../racket/gc2/../src/read.c:2458
#19 0x00000000005e752a in do_read_f (who=0x704afb "read", argc=<optimized out>, argv=0x7ffff3bf1ed8, recur=0) at ../../../racket/gc2/../src/portfun.c:2934
```

I've pushed https://github.com/racket/racket/commit/35a0f0c71c6a53a0cb09520ef9de335cb06e66d4

The second commit seems to fix http://drdr.racket-lang.org/31774/pkgs/racket-test/tests/racket/stress/fuzz.rkt

This seems to have caused a failure on a different appveyor build: https://ci.appveyor.com/project/plt/racket/build/1.0.785

@mflatt Am I missunderstanding the code in file_or_dir_permissions? I thought `755` was valid because the read and write were set for every level of permissions?

@florence write needs to be the same across all levels, and read and exec always need to be set; so, I think that means the valid permissions are 777 and 555.

Maybe the right strategy is just to not try to set permissions on Windows

Do we know what git itself does?

Spencer suggests reverting this commit, but I think a better intermediate
state is one that just doesn't make these changes on windows. Is that okay
with everyone?

Seems sensible to me.

LGTM

Sorry for the delay, been feeling a bit ill the past week.

Thanks @rfindler for fixing the port leaking and general tips. (Learned to squash commits - glad the git voodoo actually worked!)

I moved the documentation to a subsection below the random section, and included an example (had to do some whacky stuff to not actually eval the procedure, hopefully this was done ok.)

Looks like this is a bug in errortrace (which cover uses as its annotator). Given:

`(let ([i 1]) (void))`

The `i` is technically never registered as covered, because it is in an expression position. This causes the binding to look uncovered to errortrace because the binding is also copied into an expression position.

I'll open this issue in racket/errortrace, and then investigate a fix.

This looks plausible, and I hope to take a closer look soon. Anote on timing the merge: I think we'll want to wait until after the branch is made for the next release (which is about a week from now).

Thanks! I've pushed a fix (only slightly different from your suggestion).

https://github.com/racket/racket/commit/2516374744153cd571e18e773df04636fad930ce

Beyond the immediate issue, both here and in #1078: Does Scribble support assertions that fail the build, to try harder to prevent this?

One could add assertions when fixing docs that break due to breakage in interactions — or, in the extreme case, add the expected output, and ensure the build fails on a mismatch. This would have caught #1078, at the cost of more maintenance effort (maybe too much).

Thank you for the prompt reaction!

I agree that a shift error is very difficult to detect and it's better to wait until the branch for next version.

I think that https://github.com/racket/racket/pull/956 is safe to include in this version.

You missed a set of parentheses:

#lang racket
(define-syntax-rule (make-some-syntax-rule id)
  (define-syntax (id stx)
    (syntax-case stx ()
      [(_ expr (... ...))
       #'(display "it works!")])))

(make-some-syntax-rule test)
(test)

2015-10-03 21:22 GMT+02:00 Sam Vervaeck notifications@github.com:

> Not sure if this is right (maybe it is meant to be this way) but it seems
> that escaping ellipses is only possible in the much more simple
> define-syntax-rule whilst not possible in syntax-case.
> 
> This runs fine:
> 
> (define-syntax-rule (make-some-syntax-rule id)
>     (define-syntax-rule (id expr (... ...))
>       (display "it works!")))
> 
> This does not work:
> 
> (define-syntax-rule (make-some-syntax-rule id)
>     (define-syntax (id stx)
>       (syntax-case stx ()
>         (_ expr (... ...))
>         #'(display "it works!"))))
> 
> Test with:
> 
> (make-some-syntax-rule test)
> (test)
> 
> > it works!
> 
> The second one fails with the following error:
> 
> syntax: no pattern variables before ellipsis in template in: ...
> 
> —
> Reply to this email directly or view it on GitHub
> https://github.com/racket/racket/issues/1080.

## 

## 

Jens Axel Søgaard

Yes you're right, silly me! Thanks. Never mind then.

Closing because this is the wrong repo for typed racket. Sorry!

I'd lost track of this one. The change looks generally ok, although I don't think a fuel limit is needed here.

For the docs, I think the right solution is to use expressions: `(cons 'x 'x)` or `(cons (void) (void))`. (Using `('x . 'x)` seems like a hybrid of `write` and `print`.)

Since I've let this sit so long, I'll adjust and merge.

Merged (with some small changes)

merged

Merged (with minor changes, mainly for the doc location)

I've just read the email with the notification, thanks for fixing the details.

I added the fuel to avoid problems with circular lists and cyclic trees. It's not an expected use case. It was esier to choose an arbitrary bound than detect all the posible cicles in the `car` and `cdr` parts.

IIRC `#<void>` is difficult to typeset in scribble. The official way to typeset `#<void>` uses a custom function that creates the correct link. I think that `(void)` alone doesn't create a link. 

@eu90h Yes, I think this library makes sense as a new package. I've finally added documentation for `openssl/libcrypto`.

Whoops, there's already an issue [on this other (older?) bugtracker](http://bugs.racket-lang.org/query/?cmd=view&pr=15154), though it was for a prerelease. Sorry for the noise.

I don't think there's any need to change to match the SRFI. Consistency with `list-prefix?` is more important, but not necessarily definitive.

It looks like something has gone wrong installing v6.2.1 over v6.1.1, with "/usr/share/doc/racket/guide/in.sxref" (and maybe other files) left over from v6.1.1.

Can you say more about how each version was installed and how v6.1.1 was installed?

Thanks!

v6.2.1 was installed through Portage. Here's the [ebuild that was used](http://gpo.zugaina.org/AJAX/Ebuild/10634650/View).

v6.1.1 was installed outside of Portage by compiling from source because an up to date ebuild didn't exist at the time (which is a real problem when you're using "bleeding-edge" Gentoo).

For both versions I enabled X, doc, futures, jit, places, and threads.

Understood. Thanks for for documenting libcrypto. I'll go ahead and close this.

Closing since this was merged. Thanks everyone.

Note that at the very least I need to fix the docs and the tests in the racket/net repository before this can be merged.

While I agree that `string->url` accepts some ill-formed "file://" URLs, but I worry that changing the function to be more strict at this point is going to break something.

Support for broken "file://" URLs on Windows was added in 0153e122b7423d578acc480904f7a0fcfd52f46d. Unfortunately, I hadn't yet learned to write down motivations in comments or commit messages, but by correlating the commit date and my e-mail log, I've tracked down the motivation to this (long) discussion:

http://bugs.racket-lang.org/query/?debug=&database=default&cmd=view+audit-trail&cmd=view&pr=8060

I didn't actualy read that whole discussion again, but I think the gist is that we do something with broken URLs for the same reason that IE 7 does (as noted in the referenced blog post).

As for the original problem, I think the solution is probably to adjust the test suite to take into account the conventions of `url->string` on Windows.

Meanwhile, I think the docs for `url->string` are not quite right, since "file:///..." doesn't produce a path that starts with "/", and "%" escapes are handled as you'd expect.

merged - thanks!

The original problem came up because `(string->url "file://pkg.plt")` produces substantially different results on Windows than on other platforms. I agree that making it reject ill-formed paths is probably a bad idea, but could `string->url` produce consistent results for this URL on Windows?

Also, what's the correct URL to use for all the places that `"file://something"` appears in the pkg tests?

@samth: I don't understand the suggestion. The consistent (with respect to standards and other platforms) treatment of the URL is to make it not refer to a file, while the current Windows-specific treatment of the path is intended to make it refer to a file. So, I think it can't produce consistent results without rejecting (in the sense I meant) the URL as a reference to a file — but maybe you have some other point in the space in mind.

If we go with changing the package tests, I think the URLs doesn't change, but some tests' expected results are dependent on the platform; "file://something" refers to a file on Windows, while it doesn't refer to a file on other platforms.

Ah, ok, I understand what you mean now. One interesting question is if any currently-supported version of IE accepts these URLs.

As for the tests, I'm thinking of tests like this one: https://github.com/racket/racket/blob/master/pkgs/racket-test/tests/pkg/tests-name.rkt#L152 It seems weird to me that the behavior of parsing a package source would differ depending on platform. But maybe the right thing is to be more strict in the pkg name parsing?

The latest I have at hand at the moment is IE 9, which does support some bad URLs, as does Chrome. It's not clear which bad ones are supported, though.

A strict mode that is enabled for package URL parsing sounds like a good option.

One possibility would be to just set `file-url-path-convention-type` to `'unix` when calling `string->url` in the pkg library. Is that likely to be sufficient here?

It would certainly fix those tests. After looking at it further, I don't think those tests are doing anything useful though - they're basically asserting that `(string->url "file://fish.plt")` has no path. Maybe the best thing to do is to parameterize those tests and leave this behavior alone, if those tests even need to exist at all.

(I'm still not convinced this `string->url` behavior is correct though, and other things seem to stick out to me - I would expect turning a UNC path on a server into a URL would produce something with a hostname, and in practice it doesn't round trip at all.)

@bmastenbrook You're right that `string->url` isn't compatible with the IE encoding of UNC paths. (Probably we failed to find any spec back then. As far as I can tell, blog posts are still the closet thing that exists to a spec.)

I guess I'll take it from the top and try to figure out the conventions again. :(

@jeapostrophe can you say more about the goal of the tests in question?

@samth I think I wrote that test; it was to catch problems parsing URLs, so it did it's job in provoking this thread

@rmculpepper What do you think?

Related to this discussion, [this article](https://lwn.net/Articles/657269/) about similar issues in Python is interesting reading.

?

The code looks good. Can you edit the documentation and can you write tests? I imagine that tests will look like this:

Test program side
- Runs the parsing function directly on what would be in the environment

Test program outer
- Sets environment
- Runs system on test program inner
- Captures the output and compares against known good

Test program inner
- Prints out the value of the parameter

Before I get too committed to this code: Is it right that I do this in racket/racket/collects/net repository (where I'll be doing the tests/docs), rather than the racket/net one? What's the difference?

[stupid clicking on "close and comment" sorry]

The docs & tests will be in this repository:

https://github.com/racket/net

in the net-test and net-doc packages

oh, I see... net-lib doesn't have the URL/HTTP client stuff I'm working on

Correct. This part of net is needed to installed packages, so it is here. Everything else in net is in net-lib, but the docs/etc for this part of net are over there in net-doc and net-tests with everything else

@mflatt I'm mostly wondering if there is any other constraint that should be checked here.

member gets around this by returning the tail of the list containing the searched for element, but that's ugly. 

Maybe an optional argument (defaulting to `#false`) that indicates what the "no duplicates" result is supposed to be?

Another possibility is providing a continuation defaulting to `(lambda (x) #f)` which is passed the duplicate element.

It could also return a wrapper value in the manner of Haskell's Maybe. That makes less sense in untyped Racket however. Also, breaks backwards compatibility.

How about something like `hash-ref` 's optional argument?

Right, that's what I was suggesting, and I think it's the simplest solution.

@rmculpepper Thanks!
Merged as https://github.com/racket/racket/commit/4d703fa2e2be0b9a0aa6788696b66afdded4ff24, https://github.com/racket/racket/commit/2acb10a5da1d3b687f665fb12d6e9076f6d0a9d1, and https://github.com/racket/racket/commit/6b93b18a1a5d9eceb521401b94a5c91af77f93ef.

Is TR generating `opt/c` contracts?

This isn't for contracts TR generates, but for contracts on functions used in typed modules.

Are you saying that someone is writing `opt/c` in TR code and then TR uses
that as a contract?

No. @stamourv can give you the actual code that ran into this issue, but what's happening here is that some code in the Racket standard library, unrelated to TR, uses these contract features. Then the function with that contract is used in a typed module, which causes the expander to lift some things. TR attempts to ignore that code while type checking, but the relevant annotation was missing in this case, so TR did the wrong thing.

Ah, got it.

This seems fine to push (please don't use a merge commit -- I can do it if
you want)

FWIW, one of the failing tests was using `~r` and other functions from `racket/format` in TR code. Those functions have contracts, and so their call sites in the typed module triggered some lifts.

Documentation and Testing in racket/net #6

Commits 49dc0625 and 3e2b916f attempt to address your first and second recommendations above, and they will be included in Racket 6.3, to be released soon.

Merged.

merged - thanks!

merged - thanks!

I think the problem you're seeing is a buffer in `tr`, not in Racket.

On OS X, `tr` supports a `-u` option to disable buffering, but I don't see that option for `tr` on Linux. Here's a random web page that suggests using `unbuffer`: http://dbaspot.com/shell/416260-tr-line-oriented-buffer.html

Ah, I think you are right..., thanks. So filters normally buffer unless they are writing to a terminal, OK, closing.

http://drdr.racket-lang.org/32247/pkgs/racket-test/tests/racket/stress/fuzz.rkt

However, it works to do this, and use `character-cat-girl*` uniformly in place of `character-cat-girl`:

```
(require (rename-in 2htdp/planetcute [character-cat-girl character-cat-girl*]))
```

Thanks! This looks like a nice improvement.

Please don't delete those tests (just add new ones). That is, make it so that a one-argument box/c still prints the way it currently does, perhaps by having a different internal struct for one argument contracts or perhaps by putting a #f in a field somewhere.

Also, what should happen with this kind of interaction:

```
(let ([b (contract (box/c integer? string?)
                   (box 0)
                   'pos 'neg)])
  (set-box! b "x")
  (unbox b))
```

I don't think that should be a positive (or a negative) violation. Instead it seems to be some other kind of violation somehow. Well, I'm not certain, but it seems wrong.

One idea would be to insist that the mutation side contract must be `contract-stronger?` than the lookup side.

@mfelleisen @chrdimo any opinions?

Re: Please don't delete those tests:
Where did I delete tests?

Re: write contract stronger than read contract:
Yes, but would that disallow contracts that are actually stronger but that contract-stronger? doesn't know about?

Oh, you mean don't change printing when the two contracts are the same. Ok I'll do that.

Re: deleting. I would say "no minus signs in the diff for the testing
files".

Re: stronger: yes. But we should try to make stronger work better. So if
there are missing cases we should fix them. Except we cannot do that for
predicates (or only to a
Limited extent). Is that the worry?

But if you don't like that plan then can you say what should happen when
the two contracts are legitimately incomparable? Like in the example? Is
that behavior actually right.

I'm pretty sure this is fixed in 6.3.

Fantastic, I wasn't sure if it was since I never followed up with this in an official issue after the initial IRC chat, so I thought I'd document the problem here.

You should at least check, though, before believing me.

Does a write-only reference to a box make sense? I'm not sure. But either way it doesn't seem like box/c can enforce it without being way too restrictive. Originally I thought people would be get around this problem by saying `(box/c (and/c write-ctc read-ctc) read-ctc)`, but `(contract-stronger? (and/c pair? pair?) pair?)` doesn't even work.

I do see that and/c has a fairly naive contract-stronger implementation and
I seem to recall I did that because the obvious improvement is an n^2
search. But maybe it is worth trying that out now.

I think a write-only reference to a box makes sense. Your commit would
allow such a thing, as do chaperones currently.

My concern is with blame assignment. If I say that you may write this box
only with numbers and read it only with strings and then you write number
and I read that number, someone must be blamed. It seems unfortunate to
blame me for that problem with the read and you certainly should have been
allowed -- that's what the contract explicitly says. So what does that
leave? My only conclusion is that it is a bad contract. So we could use
contract-stronger to rule out contracts where this is a problem. We could
also redirect the blame to the contract itself the same way that ->i does.
That would eliminate the need to improve contract-stronger.

Maybe there's another thing we could do, I'm not sure.

Redirecting the blame, how would that work?

When you write an `->i` contract, the contract itself can be blamed for a self-violation. Here's an example.

I see the first line of this contract error message is wrong and needs to be fixed; look at the blaming line.

```
#lang racket

(module contract-lib racket
  (provide a-contract)
  (define a-contract
    (->i ([f (-> integer? integer?)]
          [x (f) (<= (f #f) 3)])
         any)))

(module server racket
  (require (submod ".." contract-lib))
  (provide
   (contract-out
    [app a-contract]))
  (define (app g x) 1))

(module client racket
  (require (submod ".." server))
  (app (λ (x) 0) 0))

(require (submod "." client))
```

What I mean, however, was that the `box/c` contract could pick up the name of the containing module and then assign blame to that when it gets a violation of this kind (where the contract on the "mutate" side of the box passes but the one on the "lookup" side fails).

But now that I say this, I realize this situation isn't quite the same, as we aren't in a situation where the contract is somehow blaming itself.

I'm much less convinced of this "shift the blame" approach now.

The interesting thing is that if we think of a box as a pair of functions (a getter and a setter) then this kind of blame seems totally fine. The issue is somehow solely because the box comes with this promise that there is exactly one place that's being updated.

I think the read/write contracts distinction makes sense.

Also I don’t see any problem with blame.

For instance in Robby’s example, the module (code region) that provides the box with the contract (box/c integer? string?)
 basically says to its clients: “It is your responsibility to write to the box values that satisfy integer? and I promise that when you read from the box you will get values that satisfy string?.” Of course this is hopeless but the provider should know better before imposing on the box a contract that it is impossible for the provider to meet.

This is not indy blame. Indy blame has to do with the contract itself creating a value that violates a contract. Here we do not have such a case.

Another way to see this is to view the box via its second-order interpretation as the values function with contract (->  (-> write/c) (-> read/c)).

@chrdimo : I agree with you that if this were two functions then that's fine. The point is that these are NOT functions. Accessor and getter functions do not provide the same guarantees to the programmer as boxes do. In particular, when you have a box and you know you have the only reference to the box, then you know that what you put in is what you get out.

I think we should be taking into account the semantics of the underlying contract.

It is this "oh this could be modeled by functions"-style of thinking that led to us not realizing we needed chaperones for so long. And this was an error.

But note that it's easy to satisfy this contract by implementing the box with an impersonator.

@samth yes, good point. And so I suppose I should be fine with this contract as an impersonator contract. 

I think you should be fine with it even as a chaperone contract. The impersonator is only needed to implement something that satisfies the contract -- the contract itself doesn't violate the chaperone invariant.

@rfindler,

I disagree. Chaperones and impersonators are necessary to obtain the same interposition points that one would have if boxes were second-order functions. The problem with the previous situation was that boxes were treated as first-order functions.

As for the ownership of the box, I don’t see how the contract reflects it or how the semantics of box/c implies it.

The way I understand box/c with write/c and read/c is that the client of the box/c is obliged to write write/c values and is promised to read read/c values. If read/c and write/c are the same contract content/c then content/c becomes an invariant of what is in the box (the same invariant that box/c enforces currently). A similar invariant exists if write/c implies read/c and so on. But the invariant does not hold in the general case and this is something that the writer of the module that imposes the box/c contract should easily figure out.

I think what you're saying, @chrdimo, is that it is possible to have a contract with incompatible read and write aspects, even with a chaperone contract where a program still can (think it can) succeed. That is, the server could retain the uncontracted version of the box and then when a string/integer is put in from the outside, it can notice that and put a integer/string back into the box before the next time someone looks inside the box. And if it was wrong about it's ability to do this dance then it gets blame. Appropriately.

And, of course, I cannot disagree with this. 

The problem is that there is no useful way to have such a contract, as we cannot give out the "mutate" side of a box without simultaneously giving out the "lookup" side. So such contracts are just stupid.

@rfindler: I agree. But we cannot prevent stupid contracts. Think about the classic example from the Blume-MacAllester paper:

(contract-out [values (-> (-> integer? integer?) any)])

The best we can and should do is to make sure that contracts have clear meaning in terms of what responsibilities they imply. And I think this new box/c has that. 

@chrdimo but that contract is only stupid with a specific value. This variation on `box/c` admits contracts that are stupid for ANY box.

(I suppose at this point you could ask why I put `none/c` into the contract library. Good question!)

@rfindler I think this is a question about pragmatics and not about semantics. Technically, the new box/c does not challenge any of the contracts meta-theory. Now the point you make is whether the extra expressiveness is justified. I would say maybe it is. Yes, you can write many stupid contracts for boxes that you were not able to write before and that may require some extra thought about what you have to do to make sure you live up to the contract (it is intractable to exclude or even detect after failure all such contracts without hampering expressiveness). But at the same time you can write many useful contracts such as the one that allows you to share a mutable box with another module but prevent the other module from writing into the box. Maybe there is a sweet-pot between expressiveness and avoiding stupid contracts but this only practice will reveal.

One question I have is what triggered this modification of box/c?

@chrdimo I think one could ask the semantic question "Are there any contracts for which there is no value that escapes blame?". I think any good semantic question is motivated by pragmatics.

@AlexKnauth submitted this PR; I'm not sure of his motivation.

Motivation: Having coffee with Northeastern PL people, and Brian said something about box/c contracts being invariant, Ben Lerner said something about boxes where reading is co-variant and writing is contra-variant, and I started thinking about that, and I remembered [this](http://lists.racket-lang.org/users/archive/2014-July/063551.html) discussion on the mailing list about unions of vector types in typed racket. 

This PR fixes that for box contracts. Unions of mutable box types will make sense, and this could also be done for vectors and other mutable values like hash-tables in the future. I was also thinking that this would allow better typed racket support for read-only boxes, vectors, etc. without making a completely separate type.

Alright, your motivation to do it is far stronger than my wanking around to try to find a variation on it that avoids this problem I was talking about.

Please push away. (Or I can, if you don't have access.)

I don't have access, so you should push.
But I do think it's a bad thing for a box contract to accept completely unrelated contracts for these; I just don't think it's something we can enforce without being too restrictive.

Okay, I've pushed it: https://github.com/racket/racket/commit/67e3899272792c2e510abdf39865b3a40dfd8a8d

This looks great to me! Not that it is really required, but would it be okay to put those tests into a `(module+ test ...` ?

I actually tried to lift the tests into a test submodule, but it didn't work as expected: because the tests are run in phase 1, they were getting run when required by another module, even though they were in a test submodule. I'm not really sure if there's a good way to handle that, but I just pulled the test back out of the submodule for now and kept the comment.

I'm okay with merging this and I see that Eli's the primary maintainer so shall I do it?

A related issue is that tests in "collects" cannot depend on packages like `eli-tester`. Tests for things in "collects" generally should be in a separate package, like "racket-test-core".

Out of curiosity, @lexi-lambda, did you try `(module+ test (begin-for-syntax ...))` or `(begin-for-syntax (module+ test ...))`? The former would make tests run when compiling the module (which is bad), while the latter should work right.

> I'm okay with merging this and I see that Eli's the primary maintainer so shall I do it?

FWIW, it looks like @stamourv is the author of `multi-in`, if you want some more eyeballs. That said, I'm pretty confident this is good to be merged. The only potential problem is if people were writing really crazy things that expand to `multi-in`... the source location changes could _potentially_ cause behavioral differences. Doing something like that seems incredibly unlikely, though.

> Out of curiosity, @lexi-lambda, did you try `(module+ test (begin-for-syntax ...))` or `(begin-for-syntax (module+ test ...))`? The former would make tests run when compiling the module (which is bad), while the latter should work right.

Aha, you're right, I did the former. The difference doesn't seem super intuitive, but upon further thought, that makes sense. The "collects" point is reasonable, though.

I'll let Vincent do the needful, then. I agree that this commit is pretty
safe and a clear improvement.

Implementation looks good. I'll merge and move the tests.

Merged, thanks!

Upstream issue closed.

Maybe also http://drdr.racket-lang.org/32282/pkgs/racket-test/tests/racket/stress/fuzz.rkt

This looks like it's a result of `list_to_scope_set` getting passed a circular list, but I can't quite tell. @mflatt: what should happen in that case/is there a way to check for circular lists/is that possible here?

LGTM

LGTM

I dont seem to have write access.

LGTM. Why aren't you just pushing those?

I dont have write access.

You should have. Is your checkout pointing to racket/racket, or plt/racket, or pltgit?

@mflatt any thoughts you have here about how I should continue would be great.

I think that `read_compiled_closure()` in "marshal.c" should check that `num_params` is consistent with the size of the vector used for `closure_map` when the `CLOS_HAS_TYPED_ARGS` flag is present.

Were you thinking of a test like this?

```
  if ((SCHEME_CLOSURE_DATA_FLAGS(data) & CLOS_HAS_TYPED_ARGS))
    if (data->num_params != (SCHEME_SVEC_LEN(v))) {
      printf("wrong! %d %d \n", data->num_params, SCHEME_SVEC_LEN(v));
      //return NULL;
    }
```

Because that fails repeatedly on existing bytecode (with either side sometimes larger). Or is there some other consistency check I should try?

Ok, trying to understand `Scheme_Closure_Data` more, that's the wrong invariant. The right invariant is something like:

```
(data->num_params + data->closure_size) * CLOS_TYPE_BITS_PER_ARG == SCHEME_SVEC_LEN(v)
```

But that isn't right either, nor is dividing by `sizeof mzshort`.

are you waiting on me for anything... there was talk of Jay, Matt and (Sam?) deciding whether we go for current-proxy-servers as a parameterised promise (or alt-t)

Ok, now I think (from looking a `boxmap_size`) that the correct invariant is:

```
    int needed_bytes = ((CLOS_TYPE_BITS_PER_ARG * (data->closure_size + data->num_params)) + (BITS_PER_MZSHORT - 1)) / BITS_PER_MZSHORT;
    int actual_size = (SCHEME_SVEC_LEN(v));
    if (needed_bytes != actual_size) {
      printf("wrong! %d %d\n", needed_bytes, actual_size);
      //return NULL;
    }
```

However, this is occasionally violated, usually with the vector one bigger than the computed size, but a few times with it much bigger (ie, 2 vs 12 or 9 vs 80).

I was expecting input from others and it didn't come. So maybe they are
busy or don't see a problem...?

On Wed, Oct 28, 2015 at 10:23 AM, Tim Brown notifications@github.com
wrote:

> are you waiting on me for anything... there was talk of Jay, Matt and
> (Sam?) deciding whether we go for current-proxy-servers as a parameterised
> promise (or alt-t)
> 
> —
> Reply to this email directly or view it on GitHub
> https://github.com/racket/racket/pull/1089#issuecomment-151860287.

## 

Jay McCarthy
Associate Professor
PLT @ CS @ UMass Lowell
http://jeapostrophe.github.io

```
       "Wherefore, be not weary in well-doing,
  for ye are laying the foundation of a great work.
```

And out of small things proceedeth that which is great."
                          - D&C 64:33

I don't have strong feelings either way, and I'm happy to defer to @jeapostrophe.

I've come around a little bit, I feel like backwards compatibility is good,
but I'm not sure there's any actual examples that we'd be breaking by
making the parameter a promise.

On Wed, Oct 28, 2015 at 11:28 AM, Sam Tobin-Hochstadt <
notifications@github.com> wrote:

> I don't have strong feelings either way, and I'm happy to defer to
> @jeapostrophe https://github.com/jeapostrophe.
> 
> —
> Reply to this email directly or view it on GitHub
> https://github.com/racket/racket/pull/1089#issuecomment-151881571.

## 

Jay McCarthy
Associate Professor
PLT @ CS @ UMass Lowell
http://jeapostrophe.github.io

```
       "Wherefore, be not weary in well-doing,
  for ye are laying the foundation of a great work.
```

And out of small things proceedeth that which is great."
                          - D&C 64:33

Well, at least I have an invariant that fixes the crash and seems to work in general.

There's an example in my .racketrc

But that's not getting read when I need it to (e.g. raco). So I won't be disappointed if I broke compatibility (my principles might be, though)

I'll look at the parameterized promise soon.

Tim

On 28 October 2015 15:35:28 GMT+00:00, Jay McCarthy notifications@github.com wrote:

> I've come around a little bit, I feel like backwards compatibility is
> good,
> but I'm not sure there's any actual examples that we'd be breaking by
> making the parameter a promise.
> 
> On Wed, Oct 28, 2015 at 11:28 AM, Sam Tobin-Hochstadt <
> notifications@github.com> wrote:
> 
> > I don't have strong feelings either way, and I'm happy to defer to
> > @jeapostrophe https://github.com/jeapostrophe.
> > 
> > —
> > Reply to this email directly or view it on GitHub
> > https://github.com/racket/racket/pull/1089#issuecomment-151881571.
> 
> ## 
> 
> Jay McCarthy
> Associate Professor
> PLT @ CS @ UMass Lowell
> http://jeapostrophe.github.io
> 
> ```
>       "Wherefore, be not weary in well-doing,
>  for ye are laying the foundation of a great work.
> ```
> 
> And out of small things proceedeth that which is great."
>                          - D&C 64:33
> 
> ---
> 
> Reply to this email directly or view it on GitHub:
> https://github.com/racket/racket/pull/1089#issuecomment-151884763

## 

Sent from my Android device with K-9 Mail. Please excuse my brevity.

I'm generally comfortable with these changes. (I'm not clear on the compatibility issues, but it looks like that issue is getting apprrpriate attention.)

That looks right to me.

To recap for you Matthew:
- Tim's first version is backwards compatible (i.e. existing code that
  parameterize the proxy set works) but causes a global effect the first time
  you call a function that uses the proxy and sets the parameter based on
  parsing the environment variables.
- I think the effect is potentially error-prone and confusing and it would
  be more elegant to break backwards compatibility and change the parameter's
  value to be a promise of an alist rather than an alist. We can't really
  have it both ways because we don't have something that can fake a parameter
  on the lhs of parameter. If we could, then we'd do something like this:

(define new-parameter-name
 (make-parameter (promise (parse-the-environment-variables)))
(define old-parameter-name
 (make-wrapper-parameter
  #:write (lambda (new-value) (values new-parameter-name (promise
new-value)))
  #:read (lambda () (force (new-parameter-name)))))

So that

(parameterize ([old-parameter-name 'some-alist]) ...)

is effectively

(parameterize ([new-parameter-name (promise 'some-alist)]) ...)

and

(old-parameter-name)

becomes

(force (new-parameter-name))

STOP THE PRESSES

I went and read the documentation on parameters to see if we could use
chaperones for this and make-wrapper-parameter exists and is called
make-derived-parameter. Matthew, you're amazing. I wanted this feature and
you went back in time and added it!

Tim, I think you should use it and then we'll have the best of both worlds.

Jay

On Wed, Oct 28, 2015 at 3:58 PM, Matthew Flatt notifications@github.com
wrote:

> I'm generally comfortable with these changes. (I'm not clear on the
> compatibility issues, but it looks like that issue is getting apprrpriate
> attention.)
> 
> —
> Reply to this email directly or view it on GitHub
> https://github.com/racket/racket/pull/1089#issuecomment-151972339.

## 

Jay McCarthy
Associate Professor
PLT @ CS @ UMass Lowell
http://jeapostrophe.github.io

```
       "Wherefore, be not weary in well-doing,
  for ye are laying the foundation of a great work.
```

And out of small things proceedeth that which is great."
                          - D&C 64:33

Sorry, this is just an infinite loop I introduced myself. :(

This doesn't seem to be related to errortrace (turning it off doesn't help), which was my first guess, or to compilation (`raco make` on the file works). It does succeed in compiling in background expansion. I tried using `enter!` on the file, and that worked too.

@rfindler Any suggestions for how to try something smaller than DrRacket that might fail?

_From @rfindler on October 28, 2015 19:54_

I don't see anything obvious. A smaller program might help.

_From @jsmaniac on October 28, 2015 20:15_

Interestingly, if I create a file `second.rkt` which requires a `file.rkt` containing the bug above, the bug does not occur in `second.rkt`.

```
#lang typed/racket
(require "file.rkt")
```

_From @takikawa on October 28, 2015 21:19_

It looks like you can get the same error if you run the macro stepper on that file and step to the end.

Here's a further reduction:

```
(require macro-debugger/model/trace)

(define-values (a d)
  (parameterize ([current-expand-observe void])
    (expand/compile-time-evals #'(module x typed/racket

                                   (module ma typed/racket
                                     (define foo 7)
                                     (provide foo))
                                   (module mb typed/racket
                                     (require (submod ".." ma))
                                     (displayln foo))))))
```

Here's an even smaller version:

```
(eval (expand
       #'(module x typed/racket        
           (module ma typed/racket
             (define foo 7)
             (provide foo))
           (module mb typed/racket
             (require (submod ".." ma))
             (displayln foo)))))
```

This is presumably a macro expander bug for @mflatt. Let me know if I should try to reduce it further.

Here's a much smaller version, with almost all of TR removed:

```
(eval
 (expand
  #'(module x racket
      (module ma racket
        (#%module-begin
         (define x 1)
         (require (for-syntax typed-racket/typecheck/renamer))
         (define-syntax foo (make-typed-renaming #'lambda #'x))
         (provide foo)))
      (module mb '#%kernel
         (#%require (submod ".." ma))
         foo))))
```

And here's one that's just core racket:

```
#lang racket/base

(eval
 (expand
  #'(module x racket/base
      (module ma racket/base
        (#%module-begin
         (require (for-syntax racket))
         (define-values (x) 1)
         (define-syntaxes (foo)  (make-rename-transformer (syntax-property #'x 'not-free-identifier=? #t)))
         (provide foo)))
      (module mb '#%kernel
         (#%require (submod ".." ma))
         foo))))
```

This is the smallest I can do. In particular, changing `racket/private/pre-base` to `'#%kernel` causes the bug to go away.

```
(eval
 (expand
  #'(module x '#%kernel
      (module ma racket/private/pre-base
        (#%module-begin
         (#%require (for-syntax '#%kernel))
         (define-values (x) 1)
         (define-syntaxes (foo)
           (make-rename-transformer
            (syntax-property (quote-syntax x) 'not-free-identifier=? #t)))
         (#%provide foo)))
      (module mb '#%kernel
         (#%require (submod ".." ma))
         foo))))
```

http://drdr.racket-lang.org/32354/pkgs/racket-test/tests/racket/stress/fuzz.rkt

i'll get to it shortly

Thanks for narrowing down the problem! I'm still investigating. (I've fixed the broken module path in the error message, but that turns out to be unrelated to the main error.)

Also:
- that's current with Racket 6.2.1.
- @Toxaris verified this bug also affects creating `.rkt` files — a file created with modern Notepad isn't loaded correctly by DrRacket.
- correct code for working around this bug will keep working after a fix, it will only become unnecessary. BOMs are optional in UTF-8, hence clients already need to handle the lack of BOMs.

This was discovered by @sabauma

http://drdr.racket-lang.org/32369/pkgs/racket-test/tests/racket/stress/fuzz.rkt

I don't get this segfault anymore on HEAD, but the same steps above in a normal Racket REPL produces a macro stepper error.

LGTM

This is what causes most of these failures: http://drdr.racket-lang.org/32402/racket/share/pkgs/compatibility-test/tests/mzlib/test.rkt

FWIW, I should be getting those emails too.

Robby

On Mon, Nov 2, 2015 at 9:38 AM, Sam Tobin-Hochstadt <
notifications@github.com> wrote:

> This is what causes most of these failures:
> http://drdr.racket-lang.org/32402/racket/share/pkgs/compatibility-test/tests/mzlib/test.rkt
> 
> —
> Reply to this email directly or view it on GitHub
> https://github.com/racket/racket/issues/1117#issuecomment-153056121.

Thanks for tracking down the issue. I have a repair (more generally reverting backward incompatibility) that I'm testing.

I agree that this is a bug, and it does look like the best fix is to make the rest of `skip_whitespace_comments` work with readtables. It looks like it should also deal with "specials" that turn into comments. I'll work on it.

Thanks for taking a look at it! I started tinkering with it a little bit myself, but I didn't get very far. I'm guessing it will need to be done with by looking up "effective character" mappings for readtables that remap characters to other readtables as well as handling readtable extensions that return special comments (my initial work-around attempt was to return a `make-special-comment`, before I looked at the C). I realized that I don't really know the C well enough at all to have any idea how to do that, though, especially given that implementing support for arbitrary special comments would involve lookahead.

Anyway, let me know if I can help out on this in any way. Either way, I appreciate your help in approaching this.

@mflatt Looks fantastic, thanks a lot!

Merged, thanks!

After updating to the latest version and doing some more testing, I've found that I don't get this error 100% of the time, but I can get it on a pretty regular basis if I run the code from within a module. I don't _seem_ to be getting the error when running at the REPL, but I was before, so who knows? When it doesn't segfault, it gives me the expected `read: illegal use of `.'` error.

Okay, narrowing things down a little, I've managed to get a segfault when executing this expression (though it seems to happen more intermittently):

``` racket
(read (open-string-input-port ")"))
```

Still only seems to happen with `open-string-input-port`, not `open-input-string`.

It looks like my initial instinct was wrong—I think this is unrelated to 5a8d2e42041ec3e78482c50de85903c767ca0bdd—but it is still a bug. I've traced it back to [`scheme_read_err` in  `error.c`, on line 2178](https://github.com/racket/racket/blob/5cc3059de2fe4abb8a05f4f39b8b794eba9e3558/racket/src/racket/src/error.c#L2178). The `SCHEME_IPORT_NAME` macro just gets the name of a `Scheme_Input_Port` structure, but for whatever reason, this seems to sometimes be garbage, which it apparently sometimes (but only sometimes!) is in the case of R6RS's string input port.

I don't know _why_ this happens, but any segfault seems like a bug, even if this is revealing a bug in r6rs-lib as well. Also, sorry for the noisy bug thread... I probably should have done more investigation myself before filing the bug report rather than just including a running tally of the information I came across. I hope the end result is helpful.

Thanks for tracking down the problem!

FYI, OpenBSD doesn't use "version-less" libraries and openssl/libcrypto works fine. In fact, the actual version of the library is `libcrypto.so.36.1`.

Merged, thanks!

Merged, thanks!

I think that you might have better luck writing with threads and `evt`s instead of using those lower-level syncronization primitives. My experience is that the "incredibly notoriously hard" parts just go away and you're left with more program design problems than correctness problems.

Sure, but sometimes I need to actually write low-level "primitives" for things like the standard library of a #lang. Or because something built-in is horribly poorly implemented (AFAIK the async-channel is implemented with channels and a background thread. My own implementation does everything async-channel does but is way faster, but the whole fiddling with semaphores was really annoying when the implementation with condition variables is obvious)

@takikawa Do you still see the stepper error, or has this been fixed by Racket and macro-stepper changes? (I don't see the crash or error, but I'm not sure I'm trying it correctly.)

merged - thanks!

merged - thanks!

Merged - thanks!

This has not changed in v6.3. I agree that the dependencies could be allowed, but allowing it would require substantial structural changes to the macro expander. I've always imagined it as something to tackle when the expander is no longer implemented in C.

@samth: The `scheme_proper_list_length` function returns -1 for cyclic lists; I'll add a guard

I'm happy to do that, especially since I'm not yet convinced that's the underlying bug.

Changed

LGTM

LGTM

What's wrong with the generic versions of these functions from `racket/dict`?

The `racket/dict` library adds a lot of overhead due to contracts. I'm trying to remove uses of dict functions from TR in favor of specialized operations to speed up typechecking.

@stamourv  Should I be concerned about the continuous integration failures? They both appear related to xml code, and I don't see an obvious direct connection to this pr, but I could test further if they don't look familiar to you....

The XML test failure has been fixed.

I don't see a connection either. If those tests pass on your end with your patches, then I wouldn't worry.
EDIT: nevermind, didn't see @samth's message before replying.

If you just rebase and force-push this PR, it will rerun the CI and pass.

Replaced by https://github.com/racket/racket/pull/1133, which actually fixes the problem.

I am not following how footnote 3 is related here.

But in any case, the contract is applied to the value twice because we need
both the version with the indy blame (for use in the depended-on contract
(result in this case)) and the version with the normal blame.

The contract system cannot currently share those applications because of
the way the inter arrangement of code works.

Why do you need it to?

I thought footnote 3 said: "when we get an argument for a dependent contract, we should apply the domain contract to it once and use that result twice".

In terms of the example, I'd want:

```
(let* ([x+ (incr/c x)]
       [result (unbox x+)]
       [check (integer? x+)])
  result)
```

We can close the issue if it's not possible to fix. I don't need it for anything in particular, and if I did need it (maybe, enforcing affine usage with contracts) I could use lax contracts instead.

Footnote 3 in that paper is about "picky" -- the difference between picky and `->i` is precisely that the two uses are different.

Footnote 3 says that we will apply the contract to the value 2 times, not 1+n times (where n can be zero actually). 

It may be possible to fix, but fundamentally the two values have different blame behavior so it isn't possible in the general case.

In the case where we know there is no negative blame we could probably avoid it, but it isn't a simple change and the performance implications for that are unclear.

(also what sam said)

So, just to add one more self-reply: if there were a footnote like footnote 3 that applied to indy, it would have a let that would apply to only ONE of the "mon"s since the two mons are different.

The reason the footnote is there is technical. We chose the substitution to be able to express all the variants of the semantics concisely in a similar manner. Otherwise we would need a let with one binder for picky and a let with two binders for indy (after some renaming in the range of the contract). Due to this choice we replace x in the range of the contract with an open term --- not a value --- and thus we violate CBV. But it does not matter in the context of the paper; the two variants of the rules are equivalent.

As for affine usage, the effect comes too early in the example above. It should take place when the value is used, not upon application of the contract. For boxes this means the effect should be pushed in the redirection function of the chaperone/impersonator.

@chrdimo I'm not quite sure I'm following: are you saying that this program produces the wrong result?

Thanks @findler @samth @chrdimo for explaining why `->i` needs 2 lets. If I ever need effects in my contracts I'll stick with `->d`.

No.  I am saying that this program behaves as expected and that the paper does not say anything about arbitrary effects that happen during application of contracts on higher-order values (CPCF cannot express them for ho combinators and disallows flat contracts on ho values via types). The footnote of the paper is only there for a reader who would object to the rule on the grounds that the substitution does not involve a value (if we had gone with the let approach, as you said above, for indy we would apply the contract twice with different blame labels each time). 

Also, for the implementation, I can't think of a useful contract combinator where effects upon contract application would matter. The affine contracts that Ben brought up can be correctly expressed with ho combinators that delay the effect until the right moment.\* So I think ->i is fine as is unless if we have a non-contrived example where effects during contract application matter.
- @bennn   ->d is wrong. If you need effects push them at contract checking time not contract application time. If you want to limit them at a certain dynamic scope use contracts that install parameters and use them as flags for the effects you care about.  

@chrdimo what about this contract?

```
(define (checksum-valid? port)
  (string=? (read-line port)
            "Hello,"))

(define with-checked-port/i
  (->i ([port  checksum-valid?])
       [result (port) (port-closed? port)]))
```

I think this is a misuse of  flat contracts. The real solution would be to have contract combinators that describe this kind of protocols. Flat contracts describe first-order invariants of values. Thus the failure would be justifiable since the flat contract is used to describe a property that is variable.

A similar problem showed up in the past with box/c, vector/c etc.

I think a keyword argument might be nicer here.

I was about to write the same as @samth...

Ok done.

The difference between v6.3 and the development branch has to do with changes in the contract system.

The difference between compilation and `expand` paths is due to some non-determinism that seems to be in TR. I tracked it back as far as `generate-contract-def/provide` being called in different orders for `stream`, `stream-first`, etc. It's possible that the order is not picked by TR, but my guess is that there's an unordered hash-table traversal somewhere in the TR compiler.

For me, it was enough to run `racket -l racket/base -l- raco expand` versus `raco expand` to see different outputs for "streams.rkt".

Thanks!

This seems like a good idea.
Is there any danger of quadratic-time behavior due to nested `begin`s? I think probably not, on the grounds that this flattening only cleans up `begin`s introduced by optimizations, but I'm not sure.
For testing. maybe inspect the result for this particular case via `zo-parse` instead of `read`.

I'm not sure exactly what's going on, either. I agree that it has something to do with the `lambda` produced by inlining `proc` in `(proc)`, but it's not clear to me why inlining `proc` fails to decrement the fuel enough.

@AlexKnauth You seem to have added a keyword argument internally, but what I meant (and what I thought Sam meant) was to add an optional `#:newline?` argument to `pretty-print` instead of introducing the name `pretty-print/no-inline`, etc.

Oh, okay, I'll do that then.

This is ok with me.

@tim-brown Just double-checking: you're planning to do something more here?

@jbclements This is a slight abuse of `raise-argument-error`; the second argument is intended to be a contract (but in string form), as opposed to prose

I finally looked at this a little more, and based on just skimming the code, it seems ok.

I intend to.
I'm looking at it now (reprioritising thanks to your prompt) hope to have it ready soon

Tim

On 17 November 2015 15:34:33 GMT+00:00, Matthew Flatt notifications@github.com wrote:

> @tim-brown Just double-checking: you're planning to do something more
> here?
> 
> ---
> 
> Reply to this email directly or view it on GitHub:
> https://github.com/racket/racket/pull/1089#issuecomment-157405148

## 

Sent from my Android device with K-9 Mail. Please excuse my brevity.

@mflatt, @jeapostrophe -- I’ve pushed this up and unless you have any problems with it; it is compatible with the _documentation_ in racket/net PR#6

BUT... now the little monkey is incompatible with the _tests_ in racket/net PR#6; the environment variables are read when net/url is required. And I can’t flange a `putenv` / `set-environment-variable!` in before that (even with a sandbox); so the tests that test whether environment variables have effect fail.

I can manually get individual tests to pass with `plt_http_proxy=... raco test url.rkt` -- but never the whole test suite.

Advice?

I found where the bug is. I'll prepare a pull request for it soon. :-)

I rebased, fix a few parts, and added some tests. 

In a separate commit, I added a new fuel to avoid quadratic behavior. It's almost a copy of `shift_fuel`.

An example of code that will trigger quadratic behavior is

```
(lambda (f)  
  (cdr (cons (f)
             (cdr (cons (f)
                        (cdr (cons (f) (f))))))))
```

I don't know how usual something like this is in real code.

My advice for fixing the tests is to use separate processes and control the
environment they start in.

On Wed, Nov 18, 2015 at 10:01 AM, Tim Brown notifications@github.com
wrote:

> @mflatt https://github.com/mflatt, @jeapostrophe
> https://github.com/jeapostrophe -- I’ve pushed this up and unless you
> have any problems with it; it is compatible with the _documentation_ in
> racket/net PR#6
> 
> BUT... now the little monkey is incompatible with the _tests_ in
> racket/net PR#6; the environment variables are read when net/url is
> required. And I can’t flange a putenv / set-environment-variable! in
> before that (even with a sandbox); so the tests that test whether
> environment variables have effect fail.
> 
> I can manually get individual tests to pass with plt_http_proxy=... raco
> test url.rkt -- but never the whole test suite.
> 
> Advice?
> 
> —
> Reply to this email directly or view it on GitHub
> https://github.com/racket/racket/pull/1089#issuecomment-157740694.

## 

Jay McCarthy
Associate Professor
PLT @ CS @ UMass Lowell
http://jeapostrophe.github.io

```
       "Wherefore, be not weary in well-doing,
  for ye are laying the foundation of a great work.
```

And out of small things proceedeth that which is great."
                          - D&C 64:33

Are there any other components that are tested this way?

Otherwise I'd need details of how to invoke a subprocess (a racket or raco) in the CI environments. How portable is:
(process "racket" "./sub-test-module.rkt")
?

Is there a (load-module-in-new-process ...) form I can use in a cross platform way?

Etc.

Tim

On 19 November 2015 13:32:48 GMT+00:00, Jay McCarthy notifications@github.com wrote:

> My advice for fixing the tests is to use separate processes and control
> the
> environment they start in.
> 
> On Wed, Nov 18, 2015 at 10:01 AM, Tim Brown notifications@github.com
> wrote:
> 
> > @mflatt https://github.com/mflatt, @jeapostrophe
> > https://github.com/jeapostrophe -- I’ve pushed this up and unless
> > you
> > have any problems with it; it is compatible with the _documentation_
> > in
> > racket/net PR#6
> > 
> > BUT... now the little monkey is incompatible with the _tests_ in
> > racket/net PR#6; the environment variables are read when net/url is
> > required. And I can’t flange a putenv / set-environment-variable! in
> > before that (even with a sandbox); so the tests that test whether
> > environment variables have effect fail.
> > 
> > I can manually get individual tests to pass with plt_http_proxy=...
> > raco
> > test url.rkt -- but never the whole test suite.
> > 
> > Advice?
> > 
> > —
> > Reply to this email directly or view it on GitHub
> > https://github.com/racket/racket/pull/1089#issuecomment-157740694.
> 
> ## 
> 
> Jay McCarthy
> Associate Professor
> PLT @ CS @ UMass Lowell
> http://jeapostrophe.github.io
> 
> ```
>       "Wherefore, be not weary in well-doing,
>  for ye are laying the foundation of a great work.
> ```
> 
> And out of small things proceedeth that which is great."
>                          - D&C 64:33
> 
> ---
> 
> Reply to this email directly or view it on GitHub:
> https://github.com/racket/racket/pull/1089#issuecomment-158057752

## 

Sent from my Android device with K-9 Mail. Please excuse my brevity.

FWIW, I don't think that's the issue with the tests, but I'm still looking at the patch and tests

To confirm, I don't think a separate process really helps with the tests. I have a working variant, plus a bug fix for a problem exposed by a test. I'm happy to fix up an merge. 
It looks like the `net/url-proxy` module is not intended to be public. Assuming that's correct, I'll move it to a "private" subdirectory.

On closer inspection, it looks like `net/url-proxy` is dead code. I'm not sure that's as intended, but the latest code seems to be in "url.rkt" and not "url-proxy.rkt", so I will remove "url-proxy.rkt".

Merged. I squashed the commits and made adjustments to the docs; hopefully I didn't mangle anything, but please check. Thanks!

Ok! (I can easily imagine code like that generated from a macro.)

Then I can squash and push them to the main repository, or you want to more time to do a review? 

Nevermind then. I'm personally happier with the current order :smile: 

Matt,

(n.b. the message on GitHub is a bcc: of one I've sent to racket users) 

Sorry, I got diverted to other more “urgent” things (he who pays the piper...).  That's why I took so long finishing the job; and rushing at the end, why I left garbage like net/url-proxy in the commit.

So THANK YOU VERY MUCH for doing all that tidying up.

Re the squashing... I assumed that those incremental pushes (each of which I considered to be a worthy candidate for the enhancement) which you guys commented on were not for squashing, since they'd already been committed and pushed to GitHub.

FYI this is the first step in an attempt to get racket to install through an http proxy. And I'll be revisiting net/url-proxy and friends with an http “CONNECT” tunnel soon.

Thanks again,

Tim

On 20 November 2015 03:11:30 GMT+00:00, Matthew Flatt notifications@github.com wrote:

> Merged. I squashed the commits and made adjustments to the docs;
> hopefully I didn't mangle anything, but please check. Thanks!
> 
> ---
> 
> Reply to this email directly or view it on GitHub:
> https://github.com/racket/racket/pull/1089#issuecomment-158266404

## 

Sent from my Android device with K-9 Mail. Please excuse my brevity.

That's usually a transient error. Running `make install` again should solve the problem.

It most likely appears when doing build from scratch? I did builds with deleting build dir twice and twice got an error.

I'm building rpm package of racket. And having a package that sometimes might be built and sometimes not is not very good... :-)

I agree. I think that particular bug was fixed for the (soon to be released) 6.3 version, though.

Posted the pull request now: #1145.

Merged – thanks!

I don't yet understand the issue. The process should be that the first step of `make install DESTDIR=...` puts bytecode, executables, desktop file, etc., into place. But that step of the process will create references to DESTDIR. The step that runs "unixstyle-install.rkt" should fix the references by removing DESTDIR, leaving just the intended prefix in place.
Are you seeing something different?

Oh, I thought it is adding prefix, not removing.

Yes, I have DESTDIR non-removed in .desktop files.

merged - thanks!

I have the same problem . thanks @samth 

I see that the ".desktop" file fixup is broken for DESTDIR mode, and I'll push a repair. Thanks!

Yes, v6.3 includes a repair for the "attempt to write a readonly database" bug.

I'd phrase this as "any comparison involving NaN returns false", which is more concrete, IMO.
Also, you may want to state explicitly what "a suprising result" may be. I.e., it won't be an error, and it won't be a segfault.

FWIW, the issue arises with double as well, just with larger bignums:
-> (expt -4.e+0 179769313486231510939300000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000)
+nan.0+nan.0i

Essentially, if the second argument converts to infinity, then we get complex numbers.

Oh, and that's the same result as `(expt -4.0e0 +inf.0)`, so at least it's consistent. Maybe it even makes sense?

`(expt -5.0 10000)` is `+inf.0`, so I don't yet see how this makes sense.

`(expt -5.0 10001)` is `-inf.0`. It doesn't converge, so there's no sensible limit for an infinite exponent.

I agree there's no sensible limit, which I think would be an argument for `nan.0` as the answer, but not a complex number.

Guile does the same thing as Racket for the examples producing infinity, with the correct sign, but produces `+inf.0` for the infinite ones.

I think showing an example is really the best thing to do. Probably also to good to add an expected result and an error if the wrong answer comes back so we notice if the sorting algorithm changes?

Gambit has identical behavior to Racket, including the complex NaN, which suggests that this is intentional, but I still don't get it.

Right, I believe we based our behavior on Gambit's.

Maybe @gambiteer can shed light on this then?

> On Nov 24, 2015, at 5:11 PM, Sam Tobin-Hochstadt notifications@github.com wrote:
> 
> Maybe @gambiteer can shed light on this then?

I think about +inf.0 appearing as an argument as a sequence of inexact real numbers -> infinity, which may have nonzero fractional parts.

If you have (expt -4. +inf.0), then for those elements of the sequence -> infinity with nonzero fractional parts, the result of (expt -4. number-with-nonzero-fractional-part) will be complex.

That’s the result that this naive code in lib/_num.scm gives, and I think we were happy with it:

(define (complex-expt x y)
  (##exp (##\* (##log x) y)))

For flexpt, Gambit just uses whatever the libc (or whatever) floating-point function gives as a result.

[Bradley-Luciers-MacBook-Pro:~/text/papers] lucier% gsi
Gambit v4.8.0

> (flexpt -4. +inf.0)
> +inf.0
> (expt -4. +inf.0)
> +nan.0+nan.0i
> ;;; do the different steps of the computation separately
> (log -4.0)
> 1.3862943611198906+3.141592653589793i
> (\* (log -4.0) +inf.0)
> +inf.0+inf.0i
> (exp +inf.0+inf.0i) 
> +nan.0+nan.0i

Brad

In 6.3 there is new problem. I opened bug #1150.

The first part of this issue is a typed racket printing bug, but it isn't actually going to cause any problems.

Ah, yes, if you consider nonzero fractional parts, that behavior makes complete sense. Thanks for the explanation!

It does give rise to confusing behavior when bignums get converted to infinity, since bignums don't have fractional parts, but that's probably not worth special-casing.

In Gambit we do special-case flonum x bignum:

(cond ((##flnan? x)
x)
((##flnegative? x)
;; we do this because (##exact-int->flonum y) is always
;; even for large enough y
(let ((abs-result
(##flexpt (##fl- x) (##exact-int->flonum y))))
(if (##odd? y)
(##fl- abs-result)
abs-result)))
(else
(##flexpt x (##exact-int->flonum y))))

Looks simple enough. I'll look into fixing Racket to do the same thing. Thanks again!

Thanks! I've pushed this commit.

I'll take a look.

`version->list` appears to do something other than crash in the case it gets certain kinds of invalid inputs. I'll change it to error, but that may expose other issues.....

Fixed

Merged, thanks!

I think the note should use `@margin-note{...}` rather that the text "NB".

I rebased and squashed them. The test are ok. Do I push this?

Looks ok to me.

I tried but I got an error. Do my account have the permissions in this repository?

```
git.exe push --progress  "origin-push" 15-11-Nested-Begin:master

ERROR: Permission to racket/racket.git denied to gus-massa.
fatal: The remote end hung up unexpectedly
```

Fixed!

Right – there's no runtime notion of "the current module" to resolve "." against.

You probably want `(quote-module-path worker)`.

Thank you! This works well:

``` racket
#lang racket

(require (only-in syntax/location quote-module-path))

(module worker racket
  (provide worker-place-main)
  (define (worker-place-main self-ch)
    (printf "Worker starting\n")))

(dynamic-place (quote-module-path worker) 'worker-place-main)
(sleep 1)
```

I no longer get an error or segfault from this, so I'll close it. Thanks.

Thanks for the report! I will push a repair soon.

:+1:
Any chance things did settle down?
-- A fellow Racket user

Maybe related: Is it true that macro expansion actually processes a module and its submodules together? If that were true, you probably couldn't allow such cycles.

Why I'm guessing that: Emacs's `racket-mode` doesn't load submodules by default (if you don't press C-c C-c inside them), but trying to load (C-c C-c) the outer module here fails because macro-expansion in the submodule fails on the erroneous `check-equal?` invocation:

``` racket
#lang racket/base
(module test2 racket/base
  (require rackunit)
  (check-equal? 1))

(define a 1)
```

Error:

```
$ racket -t ~/tmp/foo.rkt
/Users/pgiarrusso/tmp/foo.rkt:4:2: check-equal?: bad syntax
  in: (check-equal? 1)
  context...:
   /Users/pgiarrusso/opt/racket/collects/syntax/wrap-modbeg.rkt:46:4
   standard-module-name-resolver
```

I've hit this message too, but I thought it was helpful. Seeing `File exists` led me to check my filesystem. When I saw the destination existed on the filesystem, I went back to the docs. 

(Okay, I might've used `(system (format "mv ~a ~a" ...))` in the meantime, but I eventually went back to the docs.)

This is done as a new mode, to not break code that relies on it only returning let- and lambda- bound variables.

LGTM, though that `if` might be better written as a couple `cond` cases.

> Seeing File exists led me to check my filesystem. When I saw the destination existed on the filesystem, I went back to the docs.

Well, it's always hard to decide whether a message is confusing or whether it was just me being confused.

But I believe "system error" and "errno=17" are hardly appropriate — unless you claim that "rename-file-or-directory" is part of the "system" — the operating system?

Anyway, I'm sure Racket developers have more pressing needs, so I should probably propose a fix.

Addressed comments and merged.

Merged, thanks!

The bug has been fixed in the most recent snapshots, and the fix will be in the next release.

LGTM

LGTM

LGTM

There were many problems here, but probably the main one was that a test intended to catch this problem wasn't properly updated for packages (and it was still checking only the main "collects" tree).

I think the problems are fixed, but I'll double-check after the next snapshot build.

I rebased this and the test passed. I think this still needs a thoughtfully review, because I'm worry that there are any hidden problems with the coordinate shifting of the locals.

Looks good to me.

I tried applying the patch in a fresh build (just `make` at the repo top level), and I got a seg fault. Here's the most interesting fragment of the crash report, and I can send the whole report if it seems helpful – but the crash happened both times I tried, so I expect it's repeatable:

```
Thread 9 Crashed:
0   Racket                          0x0000000100c38936 add_type + 166 (optimize.c:8863)
1   Racket                          0x0000000100c2918b merge_types + 251 (optimize.c:4224)
2   Racket                          0x0000000100c26ec4 optimize_for_inline + 5716 (optimize.c:1946)
3   Racket                          0x0000000100c2a20e optimize_application2 + 1054 (optimize.c:3213)
4   Racket                          0x0000000100c2f9ef scheme_optimize_expr + 2287 (optimize.c:7972)
5   Racket                          0x0000000100c35a97 scheme_optimize_expr + 27031 (optimize.c:4491)
6   Racket                          0x0000000100c2e5fd scheme_optimize_lets + 11677 (optimize.c:6690)
7   Racket                          0x0000000100c311a3 scheme_optimize_expr + 8355 (optimize.c:7988)
8   Racket                          0x0000000100c35b9d scheme_optimize_expr + 27293 (optimize.c:4505)
```

This bug has been there from the beginning (as `unstable/open-place`). :(

I was testing with

```
nmake win32-in-place PKGS="racket-test-core"
```

and a few additional packages like `compiler-lib` to minimize the compilation time. With that I got no error. Neither in Travis or AppVeyor.

I tried again with all the packages of  `main-distribution` and I got an error :). In all runs, the last packages before the error was: 

```
raco setup: 1 making: <pkgs>/compatibility-doc/mzlib/scribblings
```

So I'll try to minimize it to isolate the error.

LGTM. Do you have push access?

I do not.

Merged. Thanks!

I see what you're trying to do, but I think that would work better as a second example. As you wrote it, it gives more visibility to a more advance usage of rename transformers, at the cost of making the simple use cases harder to understand, because there's more stuff in the way. Do you see what I mean?

Okay, I pushed another version.

Merged, thanks.

For whatever it's worth, I agree `true?` would be useful. For two (possibly negligible) reasons:
1. I mean, if we have `false?` one would expect `true?` to be there too. (It's news to me that it's not.)
2. In languages like nanopass (or at least the version of nanopass Andy designed), it expects a `?` to be on the end of a predicate. So if you want a terminal in the language that is only `#t`, then you (currently) need to make it yourself.

Note that your point highlights a potential confusion with `true?`: you seem to expect that it would only return `#t` when given the value `#t`, but this implementation returns `#t` whenever the value is non-`#f`.

Oh, so it's the same as `(not (not ...))`? Okay, so that may or may not be useful. I very much had in mind though something like `(equal? #t ...)`, which is at least what I think of as `true?`. But I could totally be wrong about that. :)

Just a ping, did you like this newer version better, or is there something else you still didn't like?

This should be documented and tested.
Also, _their_.

> This should be documented

It is, this commit extends the documentation

> and tested

So, I don't know if there are any unit tests in the code base itself. But I did test it on some of @soegaard 's poppler packages. And it seemed to work just fine.

Re docs: I should have been clearer. What I meant was that the use case for those should be documented. I.e., "If you want a package that ... then use ..."
Re tests: The pkgs tests are at: `pkgs/racket-test/tests/pkg/`

I think this is the same issue as this old bug tracker PR: http://bugs.racket-lang.org/query/?cmd=view&audit-trail&database=default&pr=12934

I still didn't fix this, but I got a minimized test case to get the error:

```
#lang racket/base

(define {{zz x} y} 0)

(define {ff x}
 {{zz (letrec ([loop (lambda () loop)]) loop)} (car x)})
```

I tried to inline `zz` manualy but I coudn't.

I think the problem is that the PPC JIT is not disabled correctly in v6.3 for 64-bit PowerPC. This patch fixes that problem; unfortunately, the patch didn't make it into the v6.3 release:

https://github.com/racket/racket/commit/e957a7d6557f9718ba8493c20675b75a1145084a

This doesn't handle cycles of length greater than one yet; I'll do that next. (Update: It handles cycles now)

@LeifAndersen It might be ok to add `if`, etc., but I wonder whether you're trying to set up platform-specific dependencies. If so, use the `#:platform` modifier on a dependency, instead of producing a conditional result.

@mflatt Ah, I didn't see the #:platform keyword. Although that doesn't seem to solve all of the problem, because what if I wanted different packages for if I was on a 32 bit vs a 64 bit system? #:platform seems to only give one of 'unix, 'osx, or 'windows.

No, `#:platform` supports more specific platform strings, which is why the `gui-lib` package can call pull in the right Pango implementation for 32-bit Windows versus 64-bit Windows, and so on.

Oh cool, thanks.

Thanks!

A package can provide executables via `racket-launcher-names` plus `racket-launcker-libraries`. For a package installed in user scope, the executable is written to `(build-path (find-system-path 'addon-dir) (version) "bin")`. It can be symlinked.

What about the example above without installing or "raco linking" anything, with just those files, should that work?

I'm not sure that I follow this completely, but wanted to see that stuff
move to regular promises forever, so I looked...
- Why does it still have an implementation of something that looks just
  like `lazy`?
- `stream-eager`, at least in its original version, was doing something
  that is exactly like `delay/strict`.
- You should be careful about uses of `delay`, since they generally have
  a higher cost, and they don't compose as `lazy` does (which, AFAICT,
  this code still re-implements).
- Another important issue for performance is whether exceptions are
  caught or not.  `racket/promise` does, and it's a high penalty in
  cases where you don't care about catching them.

At least in some point in the past, switching to plain promises would
have made it much shorter.

(It didn't because Matthew based that code on Bewig's stream code
(srfi-42), and (IIRC) Bewig insisted on having a separate type, which is
why he didn't switch to using his own srfi-45.)

The reason I thought it might be better to use `delay` for the elements instead of `lazy` was for people who might want a stream of promises. When they might want get an element out of the stream, but don't want to force the promise yet.

It still has something that looks like `lazy` because the rest needs to be a stream, not a promise of a stream. A stream could use promises instead of having a `forced?` field with the second field as either the lambda or the value depending on that, but that might be unnecessary higher cost? I'm not sure.

Should there be a lighter-weight version of `delay` that doesn't try to handle multiple values or store exceptions? Would that help this?

Re your first two comments: what I wanted to see is a simple type that
gets used uniformly, so streams are just lazy lists --- where just the
list spine is lazy, so the values are used as-is.  IOW, `stream-cons` is
just `(lazy (cons ...))`.  If there is some need to delay the values too
then yes, `delay` is the right thing.  And if there's a need to
distinguish such values from other promises, then a new `delay/...`
struct can be used just for that, but otherwise use the same forcing as
`lazy`.

> Should there be a lighter-weight version of `delay` that doesn't try
> to handle multiple values or store exceptions?

That would be _really_ nice if there's a good way to do that.  Where
"good" means that you get something like `lazy*` where it plays nicely
with `lazy` both ways so you can interchange them freely.  (I think that
I started to do that at some point, but got lazy.)

> Would that help this?

That depends on the kind of exception catching that the current code
does.  If it's still similar enough to Bewig's code, then it would help
since he never bothered catching exceptions in either this or in
srfi-45.

(As a side note, the consistency that results from catching exceptions
is that `(lazy (/ 2 (random 2)))` is always going to force to 1 or to an
error, but not change; or

```
(let ([c 0]) (delay (begin0 (/ 9 c) (set! c (add1 c)))))
```

for a less random example.  Yet another variant of `delay`, if you want
to stick your head fully into that bed, is one that would do more work,
and capture parameters too.  Something like that would be very useful
too (for different reasons, of course).)

> On Dec 26, 2015, at 7:40 PM, Eli Barzilay notifications@github.com wrote:
> 
> Re your first two comments: what I wanted to see is a simple type that
> gets used uniformly, so streams are just lazy lists --- where just the
> list spine is lazy, so the values are used as-is. IOW, stream-cons is
> just (lazy (cons ...)). If there is some need to delay the values too
> then yes, delay is the right thing.

So then `(stream-cons a b)` could be `(lazy (cons (delay a) b))`, except that streams and promises are not supposed to be the same thing. 

So `(make-stream (lazy (cons (delay a) b)))`. But if you try to call stream-first on that, it will force it and evaluate the `b` expression, which is not what we want, I think.

So then it could be `(make-stream (lazy (cons (delay a) (lazy b)))`, except that `stream-rest` needs to return a stream. 

So `(make-stream (lazy (cons (delay a) (make-stream (lazy b))))`. But then, the b expression will be a stream itself, so there will be a `(make-stream (lazy ...))` nested inside that in place of `b`. Using `lazy` here doesn't actually help, because of the extra `make-stream` in between. So that's why we would have to reimplement the nested forcing that `lazy` does anyway. 

Instead of `(make-stream (lazy ...))`, this does `(make-stream #false (lambda () ...))`. 

> (As a side note, the consistency that results from catching exceptions
> 
> is that (lazy (/ 2 (random 2))) is always going to force to 1 or to an
> error, but not change;

Oh, that's interesting:

(define s (stream (/ 2 (random 2))))

> (stream-first s)
> . . /: division by zero
> (stream-first s)
> . . /: division by zero
> (stream-first s)
> . . /: division by zero
> (stream-first s)
> 2

(Edit: This was with the old racket implementation. This PR does store the exceptions, so this doesn't happen)

You could use `raco exe -l` to create a launcher script of the same sort created by `racket-launcher-libraries` (but without installing anything). Is that what you mean?

Thanks, that works.  I was used to symlinks because that is the way nodejs does it, but apparently symlinking can break imports in other languages as well.

I’m going to close this because:
1. The desire for such a feature does not seem to be very high.
2. Whether it should be `(eq? #t _)` or `(not (not _))` is not well-defined or agreed upon.
3. Either behavior could be confusing.

I think a `->boolean` function might be useful, but Racket currently seems to avoid general coercion functions (all the existing builtins that start with `->` are contract combinators, with the exception of `->fl` and `->extfl`).

Any reason this hasn’t been merged yet? It would be a nice change.

Why `for/stream` instead of `for/sequence`?

The name `for/stream` makes considerably more sense in the context of Racket’s other for loops—they’re all named after the concrete data structure they produce, so we have `for/hash` instead of `for/dict`, for example. Plus, Racket “sequences” are a very general, fairly vague notion, so I think the name would be a poor description of what this actually does. Streams are lazy, which is fairly unique to streams within the Racket ecosystem of data structures, so communicating that is important.

Merged now, sorry for the delay.

`reify-result` has an `unsafe-cdr` and it is exported. Seems dangerous and worth changing.

It's not really unsafe if it checks `pair?` first though, is it?

@rfindler I agree that there are a bunch of no-longer-needed `unsafe` calls in this library, but I think that's a separate change from this PR.

Oh, yes, sorry: I missed the `pair?` check (despite looking multiple times!)

(But I will note that the optimizer transforms car into unsafe-car in this situation already)

And yes, it is separate.

Where are the tests for promises? I can't find them. I can only find the tests in the `lazy` repository. Should I make a pull request there, or should some of those tests be moved to this repository with the other racket tests? Or?

Looks good to me.

Yes, it looks to me like https://github.com/racket/lazy/blob/master/tests/promise.rkt should be in this repository.

Should that be part of this pull request? If so, where should I put it?

Go for it. And feel free to just push the change.

Does setting the `PLT_GTK2` environment variable allow DrRacket to start?

I don't have push access. :frowning: 

Okay, well let me know when you're happy and I'll push.

I'm happy

Thanks, I've pushed it.

I added the nested syntax/loc you mentioned (in person).

Looks good.

On Thu, Dec 31, 2015, 8:49 AM Andrew Kent notifications@github.com wrote:

> I added the nested syntax/loc you mentioned (in person).
> 
> —
> Reply to this email directly or view it on GitHub
> https://github.com/racket/racket/pull/1184#issuecomment-168195369.

I will check as soon as I have a minute, hopefully tomorrow (Jan 2)

@samth: I've just fixed a few more problems with tests. I think that leaves us now with just the paths in "Typed_Units.html" and "Typed_Classes.html" to fix.

The extension to sequences seems like it should be in a separate function related to sequences, especially because many sequences could implement optimized versions (such as for vectors).

Also, does this change the performance of using `random` from the current behavior?

(In reply to https://github.com/AlexKnauth/racket/commit/69d965a9cb6b7c2bd0a0b442e18bc427d3da668a#commitcomment-15221712)

Ok done. 

However, there's a `link: module mismatch; possibly, bytecode file needs re-compile because dependencies changed` error that I keep getting. At first I thought it would go away like those kinds of errors usually do, but it didn't, and it consistently shows up, even in the travis build.

Any idea what could be causing it?

```
. ../../../../racket/collects/racket/promise.rkt:237:49: link: module mismatch;
 possibly, bytecode file needs re-compile because dependencies changed
  importing module: 'promise
  exporting module: "/Users/Alex/Documents/GitHub/AlexKnauth/racket/racket/collects/racket/promise.rkt"
  exporting phase level: 0
  internal explanation: variable not provided (directly or indirectly) in: delay*
```

(Update: fixed in https://github.com/racket/racket/commit/fdf56dfebf9473f16715657208b598c5054132df, see also https://groups.google.com/forum/#!msg/racket-dev/ZXE74nUwqbg/RSmuhfwXEgAJ)

Re separate function for sequences: I thought about that. But since `random` was already doing double (and now triple) duty, I figured may as well put sequences there too.
Re optimized versions: All my version does is take `sequence-ref` and `sequence-length`, both of which will be specialized for, e.g., vectors. So I doubt it would make much difference.
Re performance: I just ran some quick tests, and there's no observable difference between the two when taking 10M random floats, and about 5% overhead when taking 10M integers.

Did you consider a new function named `random-ref`? (Not sure which I like better.)

I think there is a lot of useful pieces of random-related functionality spread around in various places (the math library has some). 

Should we collect that into `racket/random`?

+1 for `random-ref`, with optional arguments for the number of refs to make and whether sampling should be done without replacement.

Not 100% sold on the name `random-ref`, but can't think of anything much better. (`random-sample`? meh.)

@bennn: Those would be nice additions, but getting close to `math/distributions`. It's a pretty simple utility, though, so the overlap is probably not an issue.

@rfindler: Re `racket/random`: Aside from the math library stuff (which is probably better to leave there, because of the TR dependency), randomness-related functions all seem to be in `racket/base` (or already in `racket/random`). I agree that the new `random-ref` (or whatever we call it) would belong there.

For now, I'll add range support to `random`, and add a new `random-ref` for sequences, with @bennn's suggestions.

Actually, thinking about it more, @bennn's suggestions should be a different function. `random-ref` should return a single element, whereas what @bennn suggests should return a list. I'll implement both, and call the second `random-sample`.

Perhaps I'm missing some detail, but the implementation of `sequence-length` in [for.rkt/R2035](https://github.com/stamourv/racket/commit/f187ae9408199789f0df40fb183b61225fe1d260#diff-c25597d0d3581a6dcf7a184ec78a24a6R2035) looks like O(N), for example `(sequence-length (make-vector 1000000))`.

In [pre-base.rkt/R131](https://github.com/stamourv/racket/commit/f187ae9408199789f0df40fb183b61225fe1d260#diff-13eaec578e818e85ad4749dc69a4dd57R131) should it say "either _max_ and prng" instead of "either _min_ and prng"?

Also, as an easy test, I copied the new function to Racket 6.3

```
#lang racket
...

(define-values (-random) ; more featureful than #%kernel's `random`
  ...)

(collect-garbage)
(time (for ([i (in-range 10000000)])
        (random 7)))
(collect-garbage)
(time (for ([i (in-range 10000000)])
        (-random 7)))
```

and I got

```
cpu time: 13417 real time: 18114 gc time: 0
cpu time: 17488 real time: 23214 gc time: 0
```

@gus-massa

Re `sequence-length`: Oh, that's disappointing. I assumed it was doing something smarter than that. I'll file a PR to improve it.

Re timings: Oh, that's more overhead than I observed. With the sequence stuff out of the way, I think I can reduce some of it. I'll report back.

Ok, with the new version, I get 1414 vs 1261 on 6.3. About 12%.

That seems worth trying to find a new name to me. No?

Ok, Matthew Flatt found that bug and fixed it, and the tests are now passing. 

With `begin-encourage-inline` (and on HEAD as opposed to 6.3), it's down to 6%.

I'm not too worried about that level of overhead for `random`. When I started the FSP work, I looked for programs where `random` was responsible for a significant portion of the running time, and did not find any (even for programs that used it heavily).

I'm more inclined to go with the nicer API. IMO, since `range` already has the max-only case, it should also have the max+min case, but I'm open to other opinions.

That seems okay with me. I'm not following the connection to `range`, tho.

Er, that should have been `random`.

I'll merge.

FYI: Perhaps this post is too late, but I have mostly good news: In the simple case the overhead is reduced during the optimization step.

For this test, I used the definition of `-random` of the initial commit, but I think the result applies to the last version too, especially with the use of `begin-encourage-inline`. 

With this program:

```
(for ([i (in-range 30)])
  (-random 5)) ; <--extended version
```

After decompiling and simplifying the output, I got this program (all the `fx` operations actually are `unsafe`):

```
(print-values
 (let ([for-loop ?])
   (#%set!-rec for-loop (lambda (r n)
                          (if (fx< n 30)
                              (begin
                                (random 5)
                                (let ([n (fx+ n 1)])
                                  (if (fx< n 30)
                                    (begin
                                      (random 5)
                                      (let ([n (fx+ n 1)])
                                        (if (fx< n 30)
                                          (begin
                                            (-random 5) ; <-----
                                            (let ([n (fx+ n 1)])
                                              (if (fx< n 30)
                                                (begin
                                                  (-random 5) ; <-----
                                                  (for-loop #<void> (fx+ n 1)))
                                                #<void>)))
                                          #<void>)))
                                    #<void>)))
                            r))
     (random 5)
     (random 5)
     (random 5)
     (random 5)
     (random 5)
     (random 5)
     (-random 5) ; <-----
     (-random 5) ; <-----
     (for-loop #<void> 8)))
```

So the optimizer reduces most of the uses of `-random` to `random` and in those cases there is no overhead. The problem is that the optimizer unrolls the loop and it has no enough fuel to inline the lasts uses of `-random`. I saw a similar behavior before, but I don't know how to fix it, since the simple solution of increasing the `inline_fuel` would increase the number of unrolls, but would not inline the lasts `-random`.

@gus-massa: Awesome! Thanks for investigating.

I got an advance, but this is still not the final version.

I think I found the error. One of the `merge_types` was shifting in the wrong direction. I want to take one day to review carefully all the other `merge_types` to check if they have the right signs.

Also, after reading many times the commit "Don't add type information twice" I think it must be rewriten, so I'll change it.

@stamourv: won't this break with sequences that don't like to be used more than once unless you're doing the trick-whose-name-I-forget for a single pass?  Something like the (very tempting) use case of a n `in-lines` sequence which would be a quick way to get a random line...

And now the build is passing since it was fixed on master.

@elibarzilay: Yes, as much as `sequence-length` would. Not sure there's anything we can do about it. It's documented, though.

@stamourv, well, `sequence-length` by itself won't break, it's the assumption that the sequence is always fine after using it.  IMO, this is a bigger caveat than getting stuck on an infinite seq (which is the only thing I saw in the docs, but TBH I skimmed through it quickly).

The thing that I was referring to is the known way to choose a random element from a sequence of unknown length (such as an input stream): scan the sequence where you choose the first one, then at a 1/2 chance switch to the second, 1/3 to switch to the third, etc.  Overall you're paying for using many more random numbers and you're getting a single scan in return -- and when your input is a general sequence this seems to me like a good tradeoff.  (But I really like that random selection thing, which is why your commit stood out: I immediately wanted to see if you can do that...)

(BTW, the warning about infinite sequences would still apply, since it still needs to do a full scan.)

@AlexKnauth: one issue is that this duplicates code from the generic force in the private file -- there should be a comment saying that, but it would be much better to move this thing into the private file so both variations can share code.

--BUT--

This is much less important than a cheap _`lazy`_ variation, because that where the composition happens.  Having a `lazy*` would make it possible to have nestings of both kinds of promises (`lazy` and `lazy*`) where you use the latter if you know that no exceptions will happen or if you don't care about them.

In fact, I might be that a `delay*` is almost useless, since (IIRC, I'm half guessing based on vague memories) a `delay` could be implemented with a `lazy` wrapped around a `delay/strict`, but kept since it's a name that most people expect.  Assuming that this is true, then a `delay*` is useless since it can be implemented in a similar way, and there's no legacy name to keep in that case.  (But maybe it's still useful to have it.)

As for the implementation, I think that the best plan I had was something like a `composable-promise*` struct which is a sibling of `composable-promise`, then implement `force/composable*` as a copy of `force/composable` except for the exception catching, and then extend both so that each of them calls the other when it gets an instance of the other.  The problem is that `force/composable` has a loop that is supposed to do the flattened kind of forcing through nested (composable) promises, and each of these two variants needs to do the same.

(Guesstisketched code follows.)

So, first change the structs so that `composable-promise` inherits from `composable-promise*` (which inherits from `promise`):

```
(define-struct promise ([val #:mutable])
  #:property prop:custom-write promise-printer
  #:property prop:force force/generic)
;; Then, a subtype for composable promises that don't catch exceptions
(define-struct (composable-promise* promise) ()
  #:property prop:force force/composable*)
;; And then regular composable promises
(define-struct (composable-promise composable-promise*) ()
  #:property prop:force force/composable)
```

Then, `force/composable` is mostly the same.  In the flat loop it checks for `composable-promise?` which catches both kinds -- it doesn't matter since the loop is already in a handler.  The code is the same, with just one new comment:

```
(define (force/composable root)
  (let ([v (pref root)])
    (cond
      [(procedure? v)
       ;; mark the root as running: avoids cycles, and no need to keep banging
       ;; the root promise value; it makes this non-r5rs, but the only
       ;; practical uses of these things could be ones that use state to avoid
       ;; an infinite loop.  (See the generic forcer below.)
       ;; (careful: avoid holding a reference to the thunk, to allow
       ;; safe-for-space loops)
       (pset! root (make-running (object-name v)))
       (call-with-exception-handler
        (lambda (e) (pset! root (make-reraise e)) e)
        (lambda ()
          ;; iterate carefully through chains of composable promises
          (let loop ([v (v)]) ; does not handle multiple values!
            (cond [(composable-promise? v)
                   ;; this includes `composable-promise*'s since we're
                   ;; already in a handler anyway
                   (let ([v* (pref v)])
                     (pset! v root) ; share with root
                     (cond [(procedure? v*) (loop (v*))]
                           ;; it must be a list of one value (because
                           ;; composable promises never hold multiple values),
                           ;; or a composable promise
                           [(pair? v*) (pset! root v*) (unsafe-car v*)]
                           ;; note: for the promise case we could jump only to
                           ;; the last `let' (for `v*'), but that makes the
                           ;; code heavier, and runs slower (probably goes over
                           ;; some inlining/unfolding threshold).
                           [else (loop v*)]))]
                  ;; reached a non-composable promise: share and force it now
                  [(promise? v) (pset! root v) (force v)]
                  ;; error here for "library approach" (see above URL)
                  [else (pset! root (list v)) v]))))]
      ;; try to make the order efficient, with common cases first
      [(pair? v) (if (null? (unsafe-cdr v)) (unsafe-car v) (apply values v))]
      ;; follow all sharings (and shortcut directly to the right force)
      [(composable-promise*? v) (force/composable* v)]
      [(composable-promise? v) (force/composable v)]
      [(null? v) (values)]
      [(promise? v) (force v)] ; non composable promise is forced as usual
      [else (error 'force "composable promise with invalid contents: ~e" v)])))
```

And finally, `force/composable*` is kind of similar, except that it doesn't catch exceptions.  The problem is that the flat loop might encounter a `composable-promise` so in that case do catch exceptions, and arrange for it to happen just once:

```
;; `force/composable*' is similar to `force/composable' ignoring exceptions,
;; unless running into a `composable-promise`
(define (force/composable* root)
  ;; same as `force/composable*', except that...
  (let ([v (pref root)])
    (cond
      [(procedure? v)
       (pset! root (make-running (object-name v)))
       ;; there is no exception handler here
       (let loop ([v (v)] [wrapped? #f])
         (cond [(composable-promise? v)
                (if (or wrapped? (composable-promise*? v))
                  (let ([v* (pref v)])
                    (pset! v root)
                    (cond [(procedure? v*) (loop (v*) wrapped?)]
                          [(pair? v*) (pset! root v*) (unsafe-car v*)]
                          [else (loop v* wrapped?)]))
                  ;; but if we see a first non-* promise, wrap in a handler
                  (call-with-exception-handler
                   (lambda (e) (pset! root (make-reraise e)) e)
                   (lambda () (loop v #t))))] ; no need for nested wrappers
               [(promise? v) (pset! root v) (force v)]
               [else (pset! root (list v)) v]))]
      [(pair? v) (if (null? (unsafe-cdr v)) (unsafe-car v) (apply values v))]
      [(composable-promise*? v) (force/composable* v)]
      [(composable-promise? v) (force/composable v)]
      [(null? v) (values)]
      [(promise? v) (force v)]
      [else (error 'force "composable promise with invalid contents: ~e" v)])))
```

It's tempting to abstract both things in a single piece of code, but I have no idea if this can work or not.  (Performance is important here, and it's full of tail-context traps.)

"Or something™."

> On Jan 5, 2016, at 6:23 AM, Eli Barzilay notifications@github.com wrote:
> This is much less important than a cheap lazy variation, because that where the composition happens. Having a lazy\* would make it possible to have nestings of both kinds of promises (lazy and lazy*) where you use the latter if you know that no exceptions will happen or if you don't care about them.
> 
> That would be better, but I wanted to see what was involved in the simpler version first. 
> In fact, I might be that a delay\* is almost useless, since (IIRC, I'm half guessing based on vague memories) a delay could be implemented with a lazy wrapped around a delay/strict, but kept since it's a name that most people expect. Assuming that this is true, then a delay\* is useless since it can be implemented in a similar way, and there's no legacy name to keep in that case. (But maybe it's still useful to have it.)

One of the uses that I was thinking of was for the implementation of streams. I'm not sure whether the elements or rests of streams should use this by default, but if catching exceptions and multiple values becomes enough of a problem, there could be a version of streams that used `delay*`. 

(Streams don't catch exceptions right now, but should that be fixed?)

There would also be uses where you know the immediate evaluation doesn't raise an exception, and it could be a safe optimization. Even if somewhere there is an exception, it would be fine if it's wrapped in one normal delay, with everything else outside of that being delay*. That's assuming that they return something that might contain the promise, instead of forcing it.

An implementation in terms of delay/strict would be a bit slower because there's an extra struct wrapped around it, right?

@elibarzilay: You're right, the breakage is slightly different. I'll update the docs.
As for single-traversal sampling: That wouldn't give a uniform distribution, and I don't think that having different distributions for different kinds of sequences is a good idea.

No, it's uniform.  A bit more sensitive to bad random functions, but that's not a problem in this case.  Run the code below, which is actually a special case of [this thing](http://rosettacode.org/wiki/Knuth%27s_algorithm_S#Racket):

```
#lang racket
(define (rand-elt l)
  (let loop ([n 1] [l l] [x #f])
    (if (null? l) x
        (loop (add1 n) (cdr l) (if (zero? (random n)) (car l) x)))))
(define (test n runs)
  (define l (build-list n values))
  (define counts (make-vector n 0))
  (for ([i runs])
    (define x (rand-elt l))
    (vector-set! counts x (add1 (vector-ref counts x))))
  (for/list ([c (in-vector counts)]) (/ (round (* 10000 (/ c runs))) 100.0)))
(for ([i (in-range 1 11)]) (eprintf "~s -> ~s\n" i (test i 10000000)))
```

Oh, interesting. I didn't know about that.
Sure, I'll switch the implementation to use that.

I made a few tests, and the new version of `sequence-length` is 20% slower than the old version. I thought that the overhead of the `for` would cover all the differences. I'm using:

```
(define s (sequence-tail "xx1234567890" 2))
#;(define s (in-range 10))

(collect-garbage)
(time (for ([i (in-range 1000000)])
        (sequence-length s)))
```

LGTM

LGTM

20% is a lot, but:
- the overhead is fixed, so it will matter less for longer sequences
- taking the length of short sequences will be quick no matter what, so 20% more may not matter that much.

Merged, thanks.

Run this command `racket -e '(require setup/dirs) (displayln (path->string (find-user-gui-bin-dir))) (for-each displayln (directory-list (find-user-gui-bin-dir)))'`. It will show where is the launcher.

Merged, thanks!

LGTM

Re search terms: Look up `index` from `scribble/base`.

I think it's nice to have an example relatively early in the section, which you're moving to later.
How about leaving the original example where it is, and referring to it when you introduce the second example? You could even add a link to the original.

I submitted the fix as another PR in https://github.com/racket/racket/pull/1197

I think it would be better to merge now only the fix, and wait until the release branch of 6.3.1 is created to analize these new features.

Do I rebase and merge the first commit?

Simpler version:

```
#lang racket

(define con
  (object/c (field [a* any/c])
            (regenerate (->m (object/c (field [a* (vectorof (object/c))]))))))

(define population%
  (class object%
    (super-new)
    (init-field a*)
    (define/public (regenerate)
      (vector-ref (get-field a* this) 0)
      this)))
(define pop
  (contract con (new population% [a* (vector (new (class object% (super-new))))]) 'p 'n))

(send (send pop regenerate) regenerate)
```

Fine by me.

While I agree that the result is nice, that kind of change kills, e.g., `git blame`, which makes it much harder to figure out the history of a given bit of code.
Because of this, I'll close this PR.
Thanks, though, and I agree with the sentiment! :)

Done.

I'll left the O(1) cases of `sequence-ref` for the future. Hopefuly I or omeone else can implement it elegantly.

Version 6.3 includes a regression specific to El Capitan, and that problem has been fixed for the next release.
Does a snapshot build from http://pre.racket-lang.org behave better on your machine than v6.3?

Not really, I kinda remembered seeing a plist edit associated to the graphics card use on mac, I cannot remember which one and it probably was broken in the release.
I found this https://developer.apple.com/library/mac/qa/qa1734/_index.html. It might be the Open-GL part that has been broken.

I see – thanks. DrRacket uses OpenGL for the GC icon on El Capitan (which is a change from previous versions), so that's probably why this now matters. I'll investigate more.

We've now set up HTTPS for the web pages and the main distribution mirror. There's also a link  from the download page to a page (on the main mirror, via HTTPS) with SHA1 checksums. And we fixed the signing of executables on OS X and added signined for the Windows installer as part of the v6.3 release.

AFAICT, this issue is resolved, correct? If so, let's close it.

It might still be nice to 
- have SHA2 checksums
- have signed linux builds

Great news!  :+1: 
Then why not also change the site URL (in the repo short description) to https://racket-lang.org/? (now it's http://racket-lang.org/)
Also, plain-http version does not redirect to https (it might be useful for less security-aware users, and even better would be to also do https://en.wikipedia.org/wiki/HTTP_Strict_Transport_Security)

Thanks for the feedback, this was really helpful.
(I'd missed `bitwise-bit-set?` earlier; also I didn't realize that `for/fold` is about as fast as `let loop ...`)

Running time is slightly faster now. Here's the average (and standard deviation) for making combinations for `(range 20)`. (Average of 30 runs.)
- before: 150.77ms, (2.77ms)
- after: 143ms, (2.65ms)

I've adjusted the URL in the repo description.
As you might imagine, there have been various wrinkles in the switch to HTTPS, and I think it makes sense to let this first step settle for a few days before turning on HSTS.

Of course, it may be reasonable to wait. I simply wrote it here because I noticed it might be good to do, not necessarily right now.

I finally got a chance to try on a Raspbian installation. I get the same error without setting `PLT_GTK2`, but setting `PLT_GTK2` lets DrRacket start.
I'll work on fixing the Gtk3 binding – hopefully soon.

Much better. LGTM.
Also, what happened to Robby's comment? Looks like github ate it?

(I was just saying that two calls to shuffle in the examples might be nice.
Since you're in the neighborhood.)

We can implement `in-hash` using `hash-iterate-keys` and `hash-ref`, without needing any unsafe code, right?

Yes but it does not improve things, partially because the `hash-iterate-` operations still need to check three different representations (immutable, mutable, or weak).

@rfindler I added a call to shuffle, not sure if this is what you meant.
https://github.com/racket/racket/commit/80767a84e970dfe695cc859bd8e1489103a61396#diff-a52ea0d2b3f1810e2018c2a43bdf48beR1268

No, I was talking about the docs for shuffle. The top line of the link
there. Don't worry about it.

Robby

On Thu, Jan 7, 2016 at 5:24 PM, Benjamin Greenman notifications@github.com
wrote:

> @rfindler https://github.com/rfindler I added a call to shuffle, not
> sure if this is what you meant.
> 80767a8#diff-a52ea0d2b3f1810e2018c2a43bdf48beR1268
> https://github.com/racket/racket/commit/80767a84e970dfe695cc859bd8e1489103a61396#diff-a52ea0d2b3f1810e2018c2a43bdf48beR1268
> 
> —
> Reply to this email directly or view it on GitHub
> https://github.com/racket/racket/pull/1175#issuecomment-169839150.

You just want more shuffle examples?

I shouldn't have brought it up. Sorry for the noise.

On Thu, Jan 7, 2016 at 7:04 PM, Benjamin Greenman notifications@github.com
wrote:

> You just want more shuffle examples?
> 
> —
> Reply to this email directly or view it on GitHub
> https://github.com/racket/racket/pull/1175#issuecomment-169856025.

@bennn: The answer is yes. :)
I agree that this would be an improvement.

Rebased into a single commit. Ready to merge?

I'll merge this, but @stamourv and @rfindler, @bennn doesn't have commit access yet. ;)

Merged, thanks.

@bennn: You should have commit access now.

:balloon: :balloon: :cake: 

For mutable hashes, there is more speedup because they are easier to iterate, ~65%.

I've added the plist entry. Does that make the latest snapshot build (from https://pre.racket-lang.org ) behave better?

Further investigation: explicitly specifying `--scope user` or `-u` works fine.

It still requires the graphics card,  version 6.4.0.1--2016-01-10(417d9b0/a) [3m].

What does `raco pkg config -i catalogs` show?

Ah, I had not realized it was possible for these to be different. That seems to be it.

I see now that there is a `--scope` flag for `raco pkg config`, but I feel like there could be clearer documentation of how the configuration is consulted by other `raco pkg` commands.

I've pushed a repair for this bug: racket/gui@55d0d96dbe073906ca3c77e0d127eba2cd1778d5
If you're interested in patching your build and it's not obvious how to do that, I can provide more information. Or you could try a snapshot build (to be dated 20160113 or later) from http://www.cs.utah.edu/plt/snapshots/
Thanks for the report!

Thank you very much!

On Tue, Jan 12, 2016 at 10:32 AM Matthew Flatt notifications@github.com
wrote:

> I've pushed a repair for this bug: racket/gui@55d0d96
> https://github.com/racket/gui/commit/55d0d96dbe073906ca3c77e0d127eba2cd1778d5
> If you're interested in patching your build and it's not obvious how to do
> that, I can provide more information. Or you could try a snapshot build (to
> be dated 20160113 or later) from http://www.cs.utah.edu/plt/snapshots/
> Thanks for the report!
> 
> —
> Reply to this email directly or view it on GitHub
> https://github.com/racket/racket/issues/1186#issuecomment-170984091.

Do you know which cache file (and its corresponding URL) was creating trouble? If so, can you save a copy of that file?

The first one that gave me the error was `pict3d-die-cut`, but that, `reprovide-lang`, and `jack-scribble-example`, all did this. Here's what it looked like for `pict3d-die-cut`:

```
bash-4.3$ raco pkg install pict3d-die-cut
Resolving "pict3d-die-cut" via http://plt.eecs.northwestern.edu/snapshots/20160111-417d9b0/catalog/
Resolving "pict3d-die-cut" via https://pkgs.racket-lang.org
Using cached14526289971452628997805 for git://github.com/mflatt/pict3d-die-cut
=: contract violation
  expected: number?
  given: #<eof>
  argument position: 1st
  other arguments...:
   31
  context...:
```

Are you talking about `cached14526289971452628997805` ?

Yes. Can you put a copy of that file somewhere where I can look at it?

Where are those cache files?

You can get the path from `raco pkg config download-cache-dir`

Ok I found it, and it was completely empty, with zero bytes.

Do you have other zero-byte cache files, or is it just that one?

About half of them are empty. There are 15 non-empty ones, and 16 empty ones.

If you try installing something from some new Github repo, you should get a new cache file. Is it created ok, or does it also end up as 0 bytes?

I tried two more, and they both ended up as 0 bytes. The `raco pkg install` command also showed this error:

```
bash-4.3$ raco pkg install git://github.com/AlexKnauth/seq-no-order
error reading collection links file #<path:/home/alexknauth/.racket/snapshot/links.rktd>: ill-formed content
Querying Git references for seq-no-order at git://github.com/AlexKnauth/seq-no-order
Downloading repository git://github.com/AlexKnauth/seq-no-order
pkg: failure getting info
  error: "get-info: info file does not contain a module of the right shape in /home/alexknauth/.racket/snapshot/pkgs/seq-no-order/info.rkt"
links: error reading from link file: #<path:/home/alexknauth/.racket/snapshot/links.rktd>: links: content is not a list: #<eof>
  context...:
   /home/alexknauth/racket/2016-01-11/racket-6.4.0.1/collects/racket/private/more-scheme.rkt:163:2: select-handler/no-breaks
   /home/alexknauth/racket/2016-01-11/racket-6.4.0.1/collects/setup/link.rkt:9:0: links25
   /home/alexknauth/racket/2016-01-11/racket-6.4.0.1/collects/pkg/private/install.rkt:592:8
   /home/alexknauth/racket/2016-01-11/racket-6.4.0.1/collects/pkg/private/install.rkt:141:0: install-packages74
   /home/alexknauth/racket/2016-01-11/racket-6.4.0.1/collects/pkg/private/../../racket/private/more-scheme.rkt:261:28
   /home/alexknauth/racket/2016-01-11/racket-6.4.0.1/collects/racket/contract/private/arrow-val-first.rkt:335:3
   (submod /home/alexknauth/racket/2016-01-11/racket-6.4.0.1/collects/pkg/main.rkt main): [running body]
```

Also, `.racket/snapshot/links.rktd` is zero bytes, and so is `.racket/snapshot/pkgs/seq-no-order/info.rkt`.

Hm... It's not that your filesystem is full or otherwise unwilling to write file content in "~/.racket"? File-writing failures should turn into exceptions, of course, but maybe a failure is being masked somehow.

No, because other things in that directory work fine. For example when I tried installing `exact-decimal-lang`, it worked fine, and now that's in `.racket/snapshot/pkgs/exact-decimal-lang` with the correct files.

Hm, now I'm getting that `error reading collection links file` when running `raco setup` as well, where before `raco setup` worked. So that got messed up while I was trying to install those pkgs to look at the cache files. (Edit: I deleted the entire `.racket/snapshot` directory and the `etc/config.rktd` file, and now raco setup works again. Turns out the `etc/config.rktd` file was also a zero-byte file messing things up.)

Unfortunately, there's a second implementation of "config.rktd" reading in "startup.rktl", so 'fallback would need to be implemented there, too.
Can you say more about your use case, though? I think I've implemented this once and decided that it was unnecessary or a bad idea, but I don't immediately recall the details.

There are also sandbox interactions where it's important to read the configuration file early enough, otherwise modules fail when run in a sandbox. So, delaying the read of a fallback configuration file could run into trouble with sandboxes.

Right, I wanted to have at least a strawman implementation to discuss if this was a good idea before fixing things like that.

The use case is that I'd like to create a tool that implements something like Cabal sandboxes in Haskell. I think all the pieces are already there to make this work, but this would make it nicer. The way it would work is as follows:
- A sandbox would basically just be a directory with a `pkgs` subdirectory that would be used as a directory scope for `raco pkg`, and a `config.rktd` file which lists that directory in the `'pkgs-search-dirs` entry. 
- Then, if you run `racket` with the appropriate `config.rktd` file specified on the command line/environment variable, everything would see the pkgs you installed in the sandbox. Otherwise, it would appear as if they weren't there. (This would probably be automated with a shell script.)

That plan would already work today, but to create the new `config.rktd` file you'd have to copy the existing one, and add an entry to the `'pkgs-search-dirs` key. Furthermore, if someone changed some aspect of the configuration, it wouldn't be reflected in the sandbox configuration. Thus this approach.

This change looks right to me.
It does look like the two places that 1 becomes -1 are currently unreachable, since the `SCHEME_LET_STAR` representation mode has become uncommon. I'm not sure what to do about that, though, since it seems that small changes to the optimizer could make them reachable again, and they cover forms that are allowed by the data structure's constraints.

Should I add a

```
Merge to v6.4
```

to the comment before merging?

If you set `'pkgs-search-dirs`, you almost certainly need to set `'links-search-files`, and then `'lib-search-dirs` for installed foreign libraries, and probably a couple of other things. It may be that you end up copying a lot of the configuration, anyway, which suggest that a single `'fallback` field is too coarse-grained.

I wonder whether a sandbox might be better implemented via `PLTADDONDIR`, so that each sandbox instance is something like a separate user, and so anything installed in user scope is specific to the sandbox. That's the direction I ended up going in the distribution-building framework (via the `-A` uses in the top-level `Makefile`). Or did you have in mind a different interaction with user scope?

I had imagined that packages installed in user scope would be accessible to programs running in the sandbox, which I think wouldn't work if using `PLTADDONDIR` the way you suggest. But given that that's not such a big loss, it's probably better to try that direction first, since it wouldn't require core changes.

Can you explain why extending `'pkgs-search-dirs` would require also extending `'links-search-files`? I think I understand the need to changed `'lib-search-dirs` for when pkgs install native libraries.

I think it's unlikely that someone will be able to use packages installed in user scope while switching a wider scope by changing sandboxes. Probably that line of thought is how I gave up on this idea before.

The `'pkgs-search-dirs` configuration field itself doesn't affect the search for collections. The package system updates a file that must be listed in `'links-search-files` when a package is installed.

Yes, please do add "Merge to v6.4".

Merged - thanks!

2016-01-14 8:44 GMT+01:00 Eli Barzilay notifications@github.com:

> (Vincent wanted me to post this here:)
> 
> I had no clue what replacement? means, until I looked at the code. The
> term that I know this feature as is "with repetitions" -- my problem with
> "replacement" is not just whether it's more common or not (google seems to
> agree that "repetitions" are indeed more common), but it's that
> "replacement" doesn't really convey any meaning by itself (and so far I
> still don't know how that word conveys what I know as samples with
> repetitions).
> 
> The samples are drawn from a pool. After a sample is drawn - is it to be
> placed back into the pool or not?
> If it is, repetitions will occur.

I think the replacement/repetition word choice is one of the cases where
two words are in common use.
In statistics (I think) the word chosen is usually "replacement" (check
MathWorld [1] for one).

I kind of like "replacement" better than "repetition" - most likely because
I met that term first :-)

No matter which one is chosen - it is worth mentioning both phrases in the
docs.

/Jens Axel

[1]     http://mathworld.wolfram.com/BallPicking.html

@lexi-lambda Since you were asking about this, you might be interested in this discussion.

> We can implement in-hash using hash-iterate-keys and hash-ref, without needing any unsafe code, right?

On second look, just using `hash-iterate-` does provide some improvement. I'll submit a separate PR with that change while I look into add unsafe versions.

Here are some microbenchmarks

Before:

```
slow first, fast second
immutable --------------------
in-hash
cpu time: 4900 real time: 4912 gc time: 0
cpu time: 4909 real time: 4920 gc time: 0
in-hash-pairs
cpu time: 4904 real time: 4916 gc time: 4
cpu time: 4900 real time: 4911 gc time: 0
in-hash-keys
cpu time: 2676 real time: 2684 gc time: 0
cpu time: 2729 real time: 2734 gc time: 0
in-hash-values
cpu time: 2664 real time: 2674 gc time: 0
cpu time: 2672 real time: 2675 gc time: 0
mutable --------------------
in-hash
cpu time: 720 real time: 725 gc time: 0
cpu time: 724 real time: 725 gc time: 0
in-hash-pairs
cpu time: 708 real time: 709 gc time: 0
cpu time: 704 real time: 707 gc time: 4
in-hash-keys
cpu time: 528 real time: 529 gc time: 0
cpu time: 560 real time: 562 gc time: 0
in-hash-values
cpu time: 524 real time: 522 gc time: 0
cpu time: 520 real time: 525 gc time: 0
weak --------------------
in-hash
cpu time: 1628 real time: 1629 gc time: 0
cpu time: 1628 real time: 1633 gc time: 0
in-hash-pairs
cpu time: 1617 real time: 1621 gc time: 0
cpu time: 1644 real time: 1648 gc time: 0
in-hash-keys
cpu time: 1472 real time: 1478 gc time: 0
cpu time: 1504 real time: 1507 gc time: 0
in-hash-values
cpu time: 1232 real time: 1233 gc time: 0
cpu time: 1216 real time: 1222 gc time: 0
```

After:

```
slow first, fast second
immutable --------------------
in-hash
cpu time: 4056 real time: 4066 gc time: 0
cpu time: 3900 real time: 3910 gc time: 0
in-hash-pairs
cpu time: 4012 real time: 4025 gc time: 0
cpu time: 3925 real time: 3933 gc time: 0
in-hash-keys
cpu time: 2276 real time: 2284 gc time: 0
cpu time: 2008 real time: 2014 gc time: 0
in-hash-values
cpu time: 2332 real time: 2341 gc time: 0
cpu time: 2072 real time: 2076 gc time: 0
mutable --------------------
in-hash
cpu time: 772 real time: 775 gc time: 0
cpu time: 460 real time: 459 gc time: 0
in-hash-pairs
cpu time: 684 real time: 688 gc time: 0
cpu time: 436 real time: 435 gc time: 0
in-hash-keys
cpu time: 572 real time: 574 gc time: 0
cpu time: 308 real time: 309 gc time: 0
in-hash-values
cpu time: 548 real time: 548 gc time: 0
cpu time: 281 real time: 282 gc time: 0
weak --------------------
in-hash
cpu time: 1780 real time: 1784 gc time: 0
cpu time: 1396 real time: 1400 gc time: 0
in-hash-pairs
cpu time: 1804 real time: 1811 gc time: 4
cpu time: 1352 real time: 1353 gc time: 0
in-hash-keys
cpu time: 1616 real time: 1623 gc time: 0
cpu time: 984 real time: 985 gc time: 0
in-hash-values
cpu time: 1096 real time: 1097 gc time: 0
cpu time: 824 real time: 826 gc time: 0
```

Here's the test file:

```
#lang racket
(define big-list (build-list 10000000 add1))

(define big-hash/immut (make-immutable-hash (map cons big-list big-list)))
(define big-hash/mut (make-hash (map cons big-list big-list)))
(define big-hash/weak (make-weak-hash (map cons big-list big-list)))

(define big-hash/immut/seq (in-hash big-hash/immut))
(define big-hash/mut/seq (in-hash big-hash/mut))
(define big-hash/weak/seq (in-hash big-hash/weak))

(define big-hash/immut-pairs/seq (in-hash-pairs big-hash/immut))
(define big-hash/mut-pairs/seq (in-hash-pairs big-hash/mut))
(define big-hash/weak-pairs/seq (in-hash-pairs big-hash/weak))

(define big-hash/immut-keys/seq (in-hash-keys big-hash/immut))
(define big-hash/mut-keys/seq (in-hash-keys big-hash/mut))
(define big-hash/weak-keys/seq (in-hash-keys big-hash/weak))

(define big-hash/immut-vals/seq (in-hash-values big-hash/immut))
(define big-hash/mut-vals/seq (in-hash-values big-hash/mut))
(define big-hash/weak-vals/seq (in-hash-values big-hash/weak))

(collect-garbage)
(collect-garbage)
(collect-garbage)

(displayln "slow first, fast second")
(require rackunit)

(displayln "immutable --------------------")
(displayln "in-hash")
(check-equal?
  (time (for/sum ([(k v) big-hash/immut/seq]) k))
  (time (for/sum ([(k v) (in-hash big-hash/immut)]) k)))
(displayln "in-hash-pairs")
(check-equal?
  (time (for/sum ([k+v big-hash/immut-pairs/seq]) (car k+v)))
  (time (for/sum ([k+v (in-hash-pairs big-hash/immut)]) (car k+v))))
(displayln "in-hash-keys")
(check-equal?
  (time (for/sum ([k big-hash/immut-keys/seq]) k))
  (time (for/sum ([k (in-hash-keys big-hash/immut)]) k)))
(displayln "in-hash-values")
(check-equal?
  (time (for/sum ([v big-hash/immut-vals/seq]) v))
  (time (for/sum ([v (in-hash-values big-hash/immut)]) v)))

(displayln "mutable --------------------")
(displayln "in-hash")
(check-equal?
  (time (for/sum ([(k v) big-hash/mut/seq]) k))
  (time (for/sum ([(k v) (in-hash big-hash/mut)]) k)))
(displayln "in-hash-pairs")
(check-equal?
  (time (for/sum ([k+v big-hash/mut-pairs/seq]) (car k+v)))
  (time (for/sum ([k+v (in-hash-pairs big-hash/mut)]) (car k+v))))
(displayln "in-hash-keys")
(check-equal?
  (time (for/sum ([k big-hash/mut-keys/seq]) k))
  (time (for/sum ([k (in-hash-keys big-hash/mut)]) k)))
(displayln "in-hash-values")
(check-equal?
  (time (for/sum ([v big-hash/mut-vals/seq]) v))
  (time (for/sum ([v (in-hash-values big-hash/mut)]) v)))

(displayln "weak --------------------")
(displayln "in-hash")
(check-equal?
  (time (for/sum ([(k v) big-hash/weak/seq]) k))
  (time (for/sum ([(k v) (in-hash big-hash/weak)]) k)))
(displayln "in-hash-pairs")
(check-equal?
  (time (for/sum ([k+v big-hash/weak-pairs/seq]) (car k+v)))
  (time (for/sum ([k+v (in-hash-pairs big-hash/weak)]) (car k+v))))
(displayln "in-hash-keys")
(check-equal?
  (time (for/sum ([k big-hash/weak-keys/seq]) k))
  (time (for/sum ([k (in-hash-keys big-hash/weak)]) k)))
(displayln "in-hash-values")
(check-equal?
  (time (for/sum ([v big-hash/weak-vals/seq]) v))
  (time (for/sum ([v (in-hash-values big-hash/weak)]) v)))
```

Here a few more votes for "replacement"
- [Wikipedia](https://en.wikipedia.org/wiki/Simple_random_sample)
- [matlab](http://www.mathworks.com/help/stats/randsample.html?requestedDomain=www.mathworks.com)
- [R](https://stat.ethz.ch/R-manual/R-devel/library/base/html/sample.html)
- [Python](https://docs.python.org/3/library/random.html)

LGTM

I'm not sure I understand the fix. Was the problem that closing the port earlier could lead to the input not being sent? A comment explaining why the code has to be this way (as opposed to the "obvious" way it was before) would be nice.

Also, are there tests for this code?

@rfindler and I had a closer look.
Our best theory is that closing the port too early caused some buffer somewhere to block or something, and that closing later fixed it. @elibarzilay, does this look plausible?
It looks like a potentially more robust refactoring would be to have `url->port` return both `o` and `i`, and have the code that reads `i` close `o` after the read to `i`.

I don’t currently understand how exactly scopes work, but for what it’s worth, I would _not_ want packages installed in a user scope to be available within a sandbox. In fact, ideally, each sandbox should be as isolated as possible. Having deps _appear_ to be installed locally, then having them not exist upon deployment because they were globally installed is a frustrating source of dependency hell.

I’m not sure if this is something scopes are capable of solving (as opposed to just having separate installations), but it would be nice if they could.

There are a number of issues with the existing implementation that this _doesn’t_ fix. For example, if the server returns a non-200 status code, the error message is useless: it calls `read-line` without an argument, so it tries to read from whatever `current-input-port` was set to. Even if it was adjusted to `(read-line i)`, it would miss the status line.

I would be willing to try to do a more comprehensive refactor to make some of the code more robust, but since this can’t really depend on anything besides `racket/base` and `racket/tcp`, it’s probably going to have some rough edges, anyway.

(As an aside, it would be very nice to have this fixed in 6.4 so that the DrRacket auto-updater works.)

Slightly offtopic: It's very strange that the immutable version is much slower than the mutable version. (Moreover, I expected a small overhead in the mutable version, for example to ensure that the operations are thread safe.) Do anyone know the reason?

I'm happy with the fix you suggest, Alexis, and slightly happier with one
that at least appears to avoid the same problem happening again. Other
fixes like you suggest would also be great. I also agree that getting
something into 6.4 seems wise.

> immutable version is much slower than the mutable version

They have different representations. Immutable hashes are trees, so are slower to iterate. Mutable hashes appear to use arrays, so iteration is faster but access is probably slower for hash collisions.

@rfindler Do you have something specific in mind when you say you want to “avoid the same problem happening again”? Seems like adding some tests would be an obvious choice, but were you considering anything else?

Sorry: I meant that the fix you suggest is strange and our best (sadly not
very good) theory suggests a slightly different fix and so we should do
that, just in case.

Tests would also be nice. :)

Ah! I see—I’m a little out of the loop. What exactly is that theory and what fix would it imply?

The theory is that there is some buffer that filled up somewhere that
causes blocking and so that's why moving the close later works. But if
that's the case, why not move the close until the point where the data is
actually read?

Even better would be to know why this fix works, tho.

I think closing too early sends an EOF to the server, and if the server gets that EOF early enough it will close its end, too.

I'm not completely sure from reading the code, but it looks like (read i)
producing an eof shouldn't have hung, but we were seeing it hang, not
terminate with an error.

I got "bad reply from server", but I'm not too surprised if the server replies in different ways to an EOFed connection.
See also `tcp-abandon-port`, which closes an output port without sending an EOF.

`tcp-abandon-port` looks like the right fix, I agree.

Why is an API like `read` the best solution here? Why not something like:

```
(checked str number->string #:message "whoops")
```

With this definition

```
(define (checked v conv [pred values] #:message [msg "bad value])
  (define v* (conv v))
  (unless (pred v*)
    (error msg))
  v*)
```

That seems shorter and doesn't involve `read` or contracts that don't have boundaries, and seems like it fits your use case.

Sounds like `tcp-abandon-port` is perfect, and it seems to work correctly. I’ve updated the PR to use that, instead.

I think a comment about why `tcp-abandon-port` is the right thing would be nice there (including a pointer to this issue/discussion).

Ok, added a comment.

Something like `checked` is a better fit right here, but I thought this version of `read` could be useful in other places.

FWIW, this has nothing much to do with version checking...  IIRC, the
`tcp-abandon-port` thing was introduced when some (yahoo?) servers were
misbehaving, and the recent changes to the servers are likely the cause
of this breaking now.

But one thing to note is that I wrote that code assuming that it should
be available in some minimal version of racket where there's none of the
usual libraries for dealing with urls.  Since a minimal racket needs
these things anyway, it might be better to dump that `url->port` thing
for something more complete.  (This would also be more robust against
the no-longer-true quasi-assumption that it works against a specific
server.)

The wikipedia link was useful in that it has a hebrew version, where
"replacement" was translated into a word that means "returns",
supporting Jens Axel's explanation of "place back in the pool".  I
suspect that the thing that bugs me more here is the "substitution"
meaning rather than the fact that in hebrew that "returns" word is
awfully close to the word used for "repeats" (one character difference,
making google useless since it counts both words).

In any case, names in apis in other languages are much more important to
follow, so that does it.

Ok, in that case, I'll close the issue.
Thanks all for the discussion!

@elbarzil: Are you saying that the definition could be replaced with 

```
(define (url->port url) (get-pure-port (string->url url)))
```

as the comment above the current definition says?

Yes, provided that it's not running into any new problems, or the
problem that is mentioned in that comment (that I haven't seen earlier).

It would also be good in making it deal with https, redirections, and
all kinds of other http-isms that might be needed on the way to the web
content now.

(And BTW, "elibarzilay" is much better -- I just still can't remember
that I'm using two github logins...)

@elibarzilay: Sounds good! That's a much more robust solution.

Okay, if that works, sounds like an ideal solution. I’ve updated this to use `get-pure-port`.

Looks good.
Could you add a test submodule, for drdr's benefit?

Ok, added a simple test that actually hits r-l.org.

It looks like you need to add `NSOpenGLPFAAllowOfflineRenderers` to the list of `NSOpenGLPixelFormatAttribute`s, as documented here: https://developer.apple.com/library/mac/technotes/tn2229/_index.html

You may want to look at the [gregor](https://github.com/97jaz/gregor) package instead of srfi/19 BTW. The srfi/19 library is not very Rackety.

Well. There is one procedure to convert date structs to strings with control of how the output should look included. Depending on a third party library should not be necessary.

I just think it might be a good idea to make the date->string from srfi-19 a bit more discoverable, or at least provide something as powerful in the standard Racket/date.

I think the future is the gregor library too and so we try to make it more discoverable, perhaps by pointing people to it from racket/date or other things like that.

Well... I don't doubt you, but currently there is no working documentation for gregor online (403, permission denied) and installing it through raco also does not give a working documentation. 

And isn't it a bit overkill to demand that you install a completely new library (with no less than 7 other deps) to be able to date->string any non-standard string representation of a date? The syntax of gregor for that specific function isn't particularly more clear (from what I gather reading the tests on github) than srfi19 date->string.

Installing an extra 7 packages for just one procedure that is already included seems a bit off to me. I'm just a hobby dev, so what do I know. 

LGTM

LGTM

@lexi-lambda: thanks!
That change is in the latest snapshot build.
@sfpqi Any better?

For me, at least, that seems to have worked—DrRacket is no longer requiring the high-perf graphics card. Thanks a lot!

It WORKED! Thank you!

@linusbergl srfi/19 is itself a third party dependency as well, it just happens to have been written before Racket's new package system was created and thus was included with the full distribution by default (as was the case with a lot of Racket libraries written before the new package system). So it "already being included" is much more an accident of history than a conscious design decision.

Could you use an indirect `other-doc` to point to the Gregor docs if Gregor is already installed?
Re discouraging SRFI 19 (or SRFIs in general): I'm all for it.
Re including Gregor in the main distribution: I talked with @97jaz about that at RacketCon, and he's in favor. We just need to go ahead and do it. :)

LGTM

LGTM

Merged, thanks!

I think the name "gregor" is not conducive to people finding this libray.
Could it be named `date`?

> On Jan 20, 2016, at 2:18 PM, Vincent St-Amour notifications@github.com wrote:
> 
> Could you use an indirect other-doc to point to the Gregor docs if Gregor is already installed?
> Re discouraging SRFI 19 (or SRFIs in general): I'm all for it.
> Re including Gregor in the main distribution: I talked with @97jaz about that at RacketCon, and he's in favor. We just need to go ahead and do it. :)

Gregor docs are a teensy bit scary. Is there any way to make it slightly less confrontational?

John

Pull request with edits?

So should this be merged?

It is now. Sorry, I thought you had push access.

(I don't know how to answer anything but Vincent's first 2 comments in this PR)

@stamourv I haven't been able to figure out `other-doc`. Can you show me what you have in mind?

(How do I reference the local docs for `gregor`? How does `other-doc` know when the local doc doesn't exist? Does the pkg server URL go in the `#:indirect` argument -- if so I haven't figured out how to make it go to the URL on click)

Anyone object to doing unsafe hash iteration in for loops?

Here are some microbenchmarks:

```
$ racket for-benchmarking.rkt
first number: current Racket (no for loop fast path)
second number: (safe) fast path
third number: unsafe fast path
immutable --------------------
in-hash
cpu time: 396 real time: 395 gc time: 0
cpu time: 352 real time: 355 gc time: 0
cpu time: 192 real time: 192 gc time: 0
in-hash-pairs
cpu time: 376 real time: 377 gc time: 0
cpu time: 356 real time: 355 gc time: 0
cpu time: 188 real time: 188 gc time: 0
in-hash-keys
cpu time: 220 real time: 223 gc time: 0
cpu time: 200 real time: 200 gc time: 0
cpu time: 188 real time: 188 gc time: 0
in-hash-values
cpu time: 224 real time: 223 gc time: 0
cpu time: 200 real time: 201 gc time: 0
cpu time: 184 real time: 183 gc time: 0
mutable --------------------
in-hash
cpu time: 96 real time: 98 gc time: 0
cpu time: 52 real time: 53 gc time: 0
cpu time: 28 real time: 26 gc time: 0
in-hash-pairs
cpu time: 80 real time: 80 gc time: 0
cpu time: 56 real time: 58 gc time: 0
cpu time: 28 real time: 26 gc time: 0
in-hash-keys
cpu time: 64 real time: 64 gc time: 0
cpu time: 40 real time: 40 gc time: 0
cpu time: 20 real time: 22 gc time: 0
in-hash-values
cpu time: 64 real time: 64 gc time: 0
cpu time: 36 real time: 38 gc time: 0
cpu time: 28 real time: 26 gc time: 0
weak --------------------
in-hash
cpu time: 164 real time: 164 gc time: 0
cpu time: 112 real time: 114 gc time: 0
cpu time: 64 real time: 61 gc time: 0
in-hash-pairs
cpu time: 152 real time: 153 gc time: 0
cpu time: 104 real time: 107 gc time: 0
cpu time: 64 real time: 61 gc time: 0
in-hash-keys
cpu time: 136 real time: 137 gc time: 0
cpu time: 84 real time: 85 gc time: 0
cpu time: 64 real time: 62 gc time: 0
in-hash-values
cpu time: 108 real time: 110 gc time: 0
cpu time: 76 real time: 78 gc time: 0
cpu time: 52 real time: 50 gc time: 0
```

This is still without inlining (mostly --- I added it for mutable hash keys and values).

Here is the test file:

```
#lang racket
(define big-list (build-list 1000000 add1))
(define big-list2 (build-list 1000000 values))

(define big-hash/immut (make-immutable-hash (map cons big-list big-list2)))
(define big-hash/mut (make-hash (map cons big-list big-list2)))
(define big-hash/weak (make-weak-hash (map cons big-list big-list2)))

(define big-hash/immut/seq (in-hash big-hash/immut))
(define big-hash/mut/seq (in-hash big-hash/mut))
(define big-hash/weak/seq (in-hash big-hash/weak))

(define big-hash/immut-pairs/seq (in-hash-pairs big-hash/immut))
(define big-hash/mut-pairs/seq (in-hash-pairs big-hash/mut))
(define big-hash/weak-pairs/seq (in-hash-pairs big-hash/weak))

(define big-hash/immut-keys/seq (in-hash-keys big-hash/immut))
(define big-hash/mut-keys/seq (in-hash-keys big-hash/mut))
(define big-hash/weak-keys/seq (in-hash-keys big-hash/weak))

(define big-hash/immut-vals/seq (in-hash-values big-hash/immut))
(define big-hash/mut-vals/seq (in-hash-values big-hash/mut))
(define big-hash/weak-vals/seq (in-hash-values big-hash/weak))

(collect-garbage)
(collect-garbage)
(collect-garbage)

(displayln "first number: current Racket (no for loop fast path)")
(displayln "second number: (safe) fast path")
(displayln "third number: unsafe fast path")
(require rackunit)

(displayln "immutable --------------------")
(displayln "in-hash")
(check-true 
  (= (time (for/sum ([(k v) big-hash/immut/seq]) k))
     (time (for/sum ([(k v) (in-hash big-hash/immut)]) k))
     (time (for/sum ([(k v) (in-immutable-hash big-hash/immut)]) k))))
(displayln "in-hash-pairs")
(check-true 
  (= (time (for/sum ([k+v big-hash/immut-pairs/seq]) (car k+v)))
     (time (for/sum ([k+v (in-hash-pairs big-hash/immut)]) (car k+v)))
     (time (for/sum ([k+v (in-immutable-hash-pairs big-hash/immut)]) 
             (car k+v)))))
(displayln "in-hash-keys")
(check-true
  (= (time (for/sum ([k big-hash/immut-keys/seq]) k))
     (time (for/sum ([k (in-hash-keys big-hash/immut)]) k))
     (time (for/sum ([k (in-immutable-hash-keys big-hash/immut)]) k))))
(displayln "in-hash-values")
(check-true
  (= (time (for/sum ([v big-hash/immut-vals/seq]) v))
     (time (for/sum ([v (in-hash-values big-hash/immut)]) v))
     (time (for/sum ([v (in-immutable-hash-values big-hash/immut)]) v))))

(displayln "mutable --------------------")
(displayln "in-hash")
(check-true
  (= (time (for/sum ([(k v) big-hash/mut/seq]) k))
     (time (for/sum ([(k v) (in-hash big-hash/mut)]) k))
     (time (for/sum ([(k v) (in-mutable-hash big-hash/mut)]) k))))
(displayln "in-hash-pairs")
(check-true
  (= (time (for/sum ([k+v big-hash/mut-pairs/seq]) (car k+v)))
     (time (for/sum ([k+v (in-hash-pairs big-hash/mut)]) (car k+v)))
     (time (for/sum ([k+v (in-mutable-hash-pairs big-hash/mut)]) (car k+v)))))
(displayln "in-hash-keys")
(check-true
  (= (time (for/sum ([k big-hash/mut-keys/seq]) k))
     (time (for/sum ([k (in-hash-keys big-hash/mut)]) k))
     (time (for/sum ([k (in-mutable-hash-keys big-hash/mut)]) k))))
(displayln "in-hash-values")
(check-true
  (= (time (for/sum ([v big-hash/mut-vals/seq]) v))
     (time (for/sum ([v (in-hash-values big-hash/mut)]) v))
     (time (for/sum ([k (in-mutable-hash-values big-hash/mut)]) k))))

(displayln "weak --------------------")
(displayln "in-hash")
(check-true
  (= (time (for/sum ([(k v) big-hash/weak/seq]) k))
     (time (for/sum ([(k v) (in-hash big-hash/weak)]) k))
     (time (for/sum ([(k v) (in-weak-hash big-hash/weak)]) k))))
(displayln "in-hash-pairs")
(check-true
  (= (time (for/sum ([k+v big-hash/weak-pairs/seq]) (car k+v)))
     (time (for/sum ([k+v (in-hash-pairs big-hash/weak)]) (car k+v)))
     (time (for/sum ([k+v (in-weak-hash-pairs big-hash/weak)]) (car k+v)))))
(displayln "in-hash-keys")
(check-true
  (= (time (for/sum ([k big-hash/weak-keys/seq]) k))
     (time (for/sum ([k (in-hash-keys big-hash/weak)]) k))
     (time (for/sum ([k (in-weak-hash-keys big-hash/weak)]) k))))
(displayln "in-hash-values")
(check-true
  (= (time (for/sum ([v big-hash/weak-vals/seq]) v))
     (time (for/sum ([v (in-hash-values big-hash/weak)]) v))
     (time (for/sum ([v (in-weak-hash-values big-hash/weak)]) v))))
```

AFAIU, `other-doc` will check whether the package is installed, and point there if it is. I think putting the pkg link in the `indirect` argument should work?

LGTM

> Gregor docs are a teensy bit scary. Is there any way to make it slightly less confrontational?

Perhaps Gregor could benefit from a "Gregor Guide / Gregor Reference" split in the docs?

So, a few issues:

If Gregor is going to be part of the main distribution, I agree that it should have a name more like "date." The reason it doesn't have a name like that now is because Racket already has a date library (`racket/date`), and gregor is incompatible with it. (There are a few questions that need to be answered before Gregor becomes part of the main distribution. More on that below.)

The documentation: I'm open to suggestions and pull requests. For my own part, I think it could use a better (and longer) introduction, and the section named "Time Scale" could stand to be rewritten.

As for including Gregor in the main distribution, there are a few things to work out:
- `racket/base` already provides a `date` struct. Does Gregor's `date` need to be renamed? Similarly, `racket/base` provides `time` syntax, while Gregor provides has a `time` struct. JodaTime's solution to this problem in Java was to call its classes `LocalDate` and `LocalTime`. We could do something like that.
- For localization Gregor currently depends on a number of CLDR data files, which are in their own packages. These files are large, and I think there would be a lot of resistance to including them in the distribution. I'm sure we don't need to ship with support for all of these locales: [https://github.com/unicode-cldr/cldr-dates-modern/tree/master/main]. But I could use some help figuring out which we need to ship with and whether and how users might be able to add more.

I think we should try to find ways to make racket/date cooperate with
gregor. Are the two date structs mutually incompatible, or is there a way
that racket/date's date struct could be seen as a partial view of gregor's
or something like that? (We can change racket/date in a way that preserves
the API, even if it doesn't preserve the implementation.) Otherwise, I
think we should try to find a (short) word that describes the difference
and prefix gregor's date struct with that (don't change the gregor pkg;
make this change in the date pkg).

For the locales, is there a way to make gregor load them dynamically and
have a nice error message pointing to 'raco pkg install <xyz>' or to use
DrRacket's PKG manager to install them when they are asked for but not
present?

Robby

On Thu, Jan 21, 2016 at 8:41 PM, Benjamin Greenman <notifications@github.com

> wrote:
> 
> @stamourv https://github.com/stamourv @97jaz https://github.com/97jaz
> here we are.
> 
> Copied from #1214 https://github.com/racket/racket/pull/1214 :
> 
> If Gregor is going to be part of the main distribution, I agree that it
> should have a name more like "date." The reason it doesn't have a name like
> that now is because Racket already has a date library (racket/date), and
> gregor is incompatible with it. (There are a few questions that need to be
> answered before Gregor becomes part of the main distribution. More on that
> below.)
> 
> The documentation: I'm open to suggestions and pull requests. For my own
> part, I think it could use a better (and longer) introduction, and the
> section named "Time Scale" could stand to be rewritten.
> 
> As for including Gregor in the main distribution, there are a few things
> to work out:
> 
> racket/base already provides a date struct. Does Gregor's date need to be
> renamed? Similarly, racket/base provides time syntax, while Gregor provides
> has a time struct. JodaTime's solution to this problem in Java was to call
> its classes LocalDate and LocalTime. We could do something like that.
> For localization Gregor currently depends on a number of CLDR data files,
> which are in their own packages. These files are large, and I think there
> would be a lot of resistance to including them in the distribution. I'm
> sure we don't need to ship with support for all of these locales: [
> https://github.com/unicode-cldr/cldr-dates-modern/tree/master/main]. But
> I could use some help figuring out which we need to ship with and whether
> and how users might be able to add more.
> 
> —
> Reply to this email directly or view it on GitHub
> https://github.com/racket/racket/issues/1220.

Gregor's date struct really just represents a date. Racket's represents a date, a time, a UTC offset, and a few other things like the day-of-week, which Gregor treats as a function of the data rather than part of it. Racket's date is similar to what Gregor calls a "moment," but the two still aren't quite compatible. Racket will let me construct, for example, a date representing Sunday, January 21, 2016 (at some time or other, etc.), but Gregor keeps to the Gregorian calendar in which January 21, 2016 is a Thursday. Also, Gregor is picky about what will count as a time zone.

I think locales could certainly be loaded dynamically. I'm not sure, however, how to structure the packages. Currently, I'm just following the structure of the unicode-cldr repositories [https://github.com/unicode-cldr]. That is, I've created a package per repository (for those repositories that Gregor needs). If I were to create, instead, a package per locale per repository, that would be an awful lot of packages to maintain. Maybe that's okay. The process of creating / updating packages from the CLDR source would have to be automated.

What if we called the library racket/gdate and had lots of pointers to it
from the racket/date library? And called the gregor struct 'gdate'? Could
something like that work?

I think it seems reasonable to create one pkg that has the most commonly
used locales and another one that has all the others. And as people
complain break things down in finer grain.

Robby

On Thu, Jan 21, 2016 at 10:47 PM, 97jaz notifications@github.com wrote:

> Gregor's date struct really just represents a date. Racket's represents a
> date, a time, a UTC offset, and a few other things like the day-of-week,
> which Gregor treats as a function of the data rather than part of it.
> Racket's date is similar to what Gregor calls a "moment," but the two still
> aren't quite compatible. Racket will let me construct, for example, a date
> representing Sunday, January 21, 2016 (at some time or other, etc.), but
> Gregor keeps to the Gregorian calendar in which January 21, 2016 is a
> Thursday. Also, Gregor is picky about what will count as a time zone.
> 
> I think locales could certainly be loaded dynamically. I'm not sure,
> however, how to structure the packages. Currently, I'm just following the
> structure of the unicode-cldr repositories [
> https://github.com/unicode-cldr]. That is, I've created a package per
> repository (for those repositories that Gregor needs). If I were to create,
> instead, a package per locale per repository, that would be an awful lot of
> packages to maintain. Maybe that's okay. The process of creating / updating
> packages from the CLDR source would have to be automated.
> 
> —
> Reply to this email directly or view it on GitHub
> https://github.com/racket/racket/issues/1220#issuecomment-173806277.

I think your `racket/gdate` idea would work. Do you recommend using the "g" prefix for all of the structs? There are currently five: 
- `date`: a date in the Gregorian calendar (e.g., 2016-01-22)
- `time`: a time-of-day with nanosecond precision (e.g., 11:43:22.076)
- `datetime`: the combination of the previous two (e.g., 2016-01-22T11:43:22.076)
- `moment`: a `datetime` coupled with a time zone or UTC offset (e.g., 2016-01-22T11:43:22.076-05:00)
- `period`: a representation of some period of time (e.g., `#<period of 2 years, 5 months, 47 days, 36 seconds>`)

The name `time`, in particular, conflicts with the very useful `time` syntax from `racket/base`. (In Gregor, `time` is actually exported by a separate `gregor/time` module, since I figure that it's much more rare to need to represent _just_ the time-of-day than either _just_ a date or the combination of the two.)

Your idea for locales sounds like a nice way to start. Now we just have to decide which locales go in the smaller package. I notice that Racket's existing date library supports a few localized formatting options [https://github.com/racket/racket/blob/dfef5b43fc8e87c5038f13429d45e10af77e6092/racket/collects/racket/date.rkt#L10].

Could we just call the library `date`? Or maybe `datetime`? The `g` prefix seems unfortunate.

As this happens, it would also be a good idea to add removing the old date library and renaming `time` to something else to the list of Racket2 ideas, so that in Racket2 Gregor won't need any adaption to be part of the main distribution.

@samth Even if the module is named `date`, there would be a name conflict (as there is currently in Gregor) between the two different `date` structs. In Gregor, the idea is: if you `(require gregor)` then you're using Gregor's `date`. And I think that's fine for a third-party library, but I also think it would be strange for Racket to ship with two different definitions of `date`, and which one you're using depends on whether or not you've required the `date` module.

(Oh, and the same thing applies to `time`.)

re more "g" prefixes: I feel like there is a balance between too many ugly
"g"s and some consistency across the library itself. I feel like you should
start by putting minimal "g"s and then add more until it doesn't seem weird
(keeping mind that "g" should probably stand for "gregorian" I suppose).

I would not use that part of racket/date as representative of anything but
the people who were near me one some random day in the past at Rice,
unfortunately. (Times have changed! Backwards compatibility sucks!)

Is it a big deal if both libraries provide a `date` struct if the one that comes in `racket/base` is adjusted to implement `gen:datetime-provider`? (while ignoring fields that don't make sense for Gregor) Then as long as you stick to Gregor operations it doesn't matter which date struct you use. Compatibility the other way won't work though, but maybe the `racket/base` and `racket/date` operations should be discouraged simultaneously.

@takikawa We can definitely do that. I guess I still feel strange about the main distribution supplying definitions of date that represent different concepts, but if that bothers people less than ugly prefixes, it's okay with me. (But it sounds like @rfindler might share my concerns on this issue.) How about the time identifier?

I think there is a balance of concerns here and there is no great answer. I
think we should think to the future and do things like rewrite the
racket/date docs to explain how to not use those functions but instead use
Gregor. I'm not really clear on which would work out better (renaming or
Asumu's suggestion).

On Fri, Jan 22, 2016 at 1:04 PM, 97jaz notifications@github.com wrote:

> @takikawa https://github.com/takikawa We can definitely do that. I
> guess I still feel strange about the main distribution supplying
> definitions of date that represent different concepts, but if that bothers
> people less than ugly prefixes, it's okay with me. (But it sounds like
> @rfindler https://github.com/rfindler might share my concerns on this
> issue.) How about the time identifier?
> 
> —
> Reply to this email directly or view it on GitHub
> https://github.com/racket/racket/issues/1220#issuecomment-174013603.

Other names I considered for `time`:
- `time-of-day`, which I rejected for its length
- `tm`, rejected for its brevity
- `tod`, rejected for its unfamiliarity
- `Time`, rejected for its non-idiomatic capitalization (and intrusion into TR's lexical convention for types)

Of these, I think `tm` is probably the best.

Edit: I left out `hmsn` (for "hours-minutes-seconds-nanoseconds", which is actually the name of a struct used internally, rejected for excessive weirdness).

Your best bet is to use the PPA that is managed by us: https://launchpad.net/~plt/+archive/ubuntu/racket

None of the Racket devs are involved in managing the package in Ubuntu's official repo, so you'd have to ask the Ubuntu folks about that.

Merged in f52d43e600acf91839106299c2f53534266f7cfe.

Merged in 3620bae6da0c8d315f9aa924ee3eff55e7bb20ee.

Merged in 95c0dfce38a312e4e2c4a99f408ef64d4849ecd5.

Hm, I think the current revision is the right code, but in Scribble it's not very good.

Code:

```
@other-doc['(lib "gregor/scribblings/gregor.scrbl")
  #:indirect @hyperlink["http://pkgs.racket-lang.org/#[gregor]"]{Gregor}]
```

Rendered:
![gregor01](https://cloud.githubusercontent.com/assets/1731829/12546765/08df03d2-c31a-11e5-9ff7-5e61db6f44de.png)

On click, it goes to the local `racket/doc/gregor/index.html`, whether or not `gregor` is installed.

In contrast, leaving out the `#:indirect` argument renders as below, and links to the same location.
- If `gregor` is installed:
  ![screen shot 2016-01-25 at 04 20 37](https://cloud.githubusercontent.com/assets/1731829/12546915/06bfcf04-c31b-11e5-90b7-dab679bdf986.png)
- Otherwise:
  ![screen shot 2016-01-25 at 04 19 02](https://cloud.githubusercontent.com/assets/1731829/12546881/cf8911d0-c31a-11e5-882f-ca14318e1b5d.png)

Should we change `other-doc` to check if the package is installed, or just do a check in this margin-note?

With [cce6235](https://github.com/racket/racket/commit/cce6235a96b0bfc5e866d2e79db60902061b4d38):
- If `gregor` is not installed
  ![g-no](https://cloud.githubusercontent.com/assets/1731829/12547822/7a645e3e-c320-11e5-9b66-2ff28c9ec8f6.png)
- If `gregor` is installed and the reference is rebuilt:
  ![g-yes](https://cloud.githubusercontent.com/assets/1731829/12547824/7f4ac866-c320-11e5-818d-017f6716b049.png)

@bennn I don't think you should make documentation rendering depend explicitly on whether a package is installed.

The intent is that you use

```
 @other-doc['(lib "gregor/scribblings/gregor.scrbl") #:indirect "Gregor: Date and Time"]
```

and then when "gregor" is not installed, the link goes to docs.racket-lang.org.

The missing piece is that docs.racket-lang.org doesn't yet have all package documentation, so the link to docs.racket-lang.org doesn't work as well as it should. I expect to finally move all package documentation to docs.racket-lang.org next week, though.

The original intention behind that is to make the installer robust against all kinds of possible junk that might be on your path, and therefore make its behavior more predictable.  This is especially important for utilities like `tar` that have several slightly different variants that can be installed on a single system.  So the installer assumes the standard FHS directories `/usr/bin` and `/bin` exist and have what it needs.

A quick search got me to [this page](https://nixos.org/wiki/FHS_environments) which might be what you need to do, or if there some other way to know what are the standard directories to find the utilities it needs then maybe that can be used.

Thanks; we're now using the intended `other-doc`.

That solution (FHS environments) seems to be for making a package, and seems rather cumbersome to use when you just want to run `./installer.sh`.

The `$PATH` issue doesn't arise when compiling from source. I'm in the process of fixing a problem with the official package, and adding a package for the nightlies, so that means installing from the racket-*.sh will be less needed.

Still, it seems a bit of a drastic measure, it would be nice if it could be disabled. If you're okay with that, I can submit a PR to add a `--no-reset-path` option to the installer.

Well, TBH, I'm not maintaining that code anymore -- I just explained where that decision came from.  Also, it was pretty common for such sh-based home-cooked installers to set their own PATH, so their behavior is more predictable.

Adding a `--no-reset-path` thing sounds to me like it would be very inconvenient.  One option is to extend the path instead of setting it, as in

```
PATH=/usr/bin:/bin:$PATH
```

which might be OK since it will pick the stable utilities if they're there or whatever you have on your `$PATH` if not.  A possibly more involved tweak would be to look for the utilities in these places in advance, and if one is not found, ask the user where they are, with a default value that comes from the pre-existing PATH (but this sounds like an overkill, so maybe the simpler thing above is better).

@elibarzilay Maybe then we could use `/usr/bin:/bin:$PATH` but print a warning if the utility wasn't found in `/usr/bin` or `/bin` ?

Yeah, that would be roughly equivalent from a UI point of view.  Below is a patch for the actual installer script --- it does two things: (1) save the original PATH in `origPATH`, (2) add another loop that looks through that if the previous search failed and warns if an executable is found there.  This handles all of the utilities that are found via `lookfor`, which still means that random things that people might add to this script is "safe" (but ultimately should go through the same).  This patch should be translated to the Racket code that generates this script though.

```
--- 1   2016-01-25 11:13:18.474793948 -0500
+++ 2   2016-01-25 11:12:59.375962051 -0500
@@ -102,6 +102,7 @@
 ###############################################################################
 ## Utilities

+origPATH="$PATH"
 PATH=/usr/bin:/bin

 if test "x`echo -n`" = "x-n"; then
@@ -137,6 +138,14 @@
       eval "$1=$dir/$1"
       IFS="$saved_IFS"
       return
+    fi
+  done
+  for dir in $origPATH; do
+    if test -x "$dir/$1"; then
+      echo "Warning: $1 found in a non-standrad place: $dir/$1"
+      eval "$1=$dir/$1"
+      IFS="$saved_IFS"
+      return
     fi
   done
   IFS="$saved_IFS"
```

@elibarzilay Thanks a lot, I updated [the racket file in the distro-build repo](https://github.com/racket/distro-build/blob/master/distro-build-client/unix-installer/installer-header) and will submit a PR in a few minutes. I'll also move the issue there.

I thought the issue belonged to this repo because the file [`racket/collects/launcher/launcher.rkt`](https://github.com/racket/racket/blob/6b93b18a1a5d9eceb521401b94a5c91af77f93ef/racket/collects/launcher/launcher.rkt#L295) also contains `PATH=\"/usr/bin:/bin\"`. I guess that's probably one of the reasons why [executables created by raco exe don't work with nix-os](https://github.com/NixOS/nixpkgs/issues/11698), I'll cross-post that there.

This issue was moved to racket/distro-build#1

The switch to hamt's for immutable hashes in 6.3 slows `hash-iterate-key` and `hash-iterate-value`. `in-hash` and `in-hash-pairs` were previously making separate calls to `hash-iterate-key` and `hash-iterate-value` and thus hash iteration slowed considerably from 6.2 to 6.3. 

This refactoring eliminates the unnecessary lookups and improves `in-hash` and `in-hash-pairs` performance by nearly half.

It's not clear that there's any consensus on how/whether naming conflicts between `racket/base` and new new `date` (or `datetime`) library should be resolved. Let me offer a few options and solicit opinions from people who are interested in the outcome:
1. Don't worry about conflicts. If a user requires the new module, they will use the new module's `date` and `time` constructors; otherwise, they'll use the ones from `racket/base`. If they want both, there's always `prefix-in` or `rename-in`.
2.  Rename Gregor's `time` struct but not `date` -- because while a user may want to use both definitions of `time` in the same module, it's far less likely to want to use both definitions of `date`.
3. Rename both structs.

All of these options are compatible with @takikawa's suggestion to make `racket/base`'s `date` implement `gen:datetime-provider`.

Preferences?

Realized that impersonators and chaperones don't work properly. Closing and trying again.

@stchang It looks like `hash_table_index` lost chaperone handling. Am I misreading that change?

I prefer 1 - it's easy to work around naming issues yourself via prefix-in, only-in, except-in, etc. but it's not nearly as easy to work around built in naming prefixes that make the default names for everything noisier and less clear. This sets a good default and precedent, and lays decent groundwork to rework the name of `time` and remove the `racket/date` library in the future. Using name-prefixes feels like it would be a step backwards.

@mflatt You are right.  I moved chaperone handling to each `scheme_hash_iterate_` function. 

With the change to `hash_table_index`'s signature to add multiple return values, it made it cleaner this way, eliminating a few lookups and checks. 

@stchang  Got it, thanks!

The docs need `@history[#:added "6.4.0.5"]`. 

Also, when you update the version number, it also needs to be updated in "pkgs/base/info.rkt". (Unfortunately, having that version updated automatically would defeat the point of the dependency spec, so we manually update the version in both places and use a test to check that they're in sync.)

Let's try again ...

I rebased the old version. The first two commits are unchanged, I'm happy with them.

I rebrote the `add_type` fucntion of the third commit. I don't like the old version. One of the problems is that this commit doesn't have any way to test it, so it's difficult to compare with the old version.

The current version says in [optimie.c#L4225](https://github.com/gus-massa/racket/commit/565556403f472e09d9996b87f66cf221fdf87b08#diff-5e09d7df9102fa81a4736e357a0c3e1aR4225)

```
/* Don't add the type if something is already there, this may happen when no_types. */
if (do_optimize_get_predicate(pos, info, 1)
    || optimize_is_local_type_valued(info, pos)) {
  return;
} 
```

But I'm not sure if it's a good idea to check the local type value, perhaps it's better to just use

```
if (do_optimize_get_predicate(pos, info, 1)) {
  return;
}
```

Finally, I just added the last commit. It adds no new functionality, but it was annoying that the arguments of `optimize_get_predicate` are in the inverse order of all the other similar functions.

Thanks for weighing in, @jackfirth.

LGTM modulo comment and commit squashing.

squashed

@juanfra684 this is what happens when I do that on Mac 10.10.5, Racket 6.3 from latest `brew`, and `raco pkg install --auto drracket`:

```
$ racket -e '(require setup/dirs) (displayln (path->string (find-user-gui-bin-dir))) (for-each displayln (directory-list (find-user-gui-bin-dir)))'
/Users/doppioslash/Library/Racket/6.3/
directory-list: could not open directory
  path: /Users/doppioslash/Library/Racket/6.3/
  system error: No such file or directory; errno=2
  context...:
   /usr/local/Cellar/racket/6.3/share/racket/collects/racket/private/kw-file.rkt:137:4: directory-list
```

@doppioslash try this: `racket -e '(require setup/dirs) (displayln (path->string (find-gui-bin-dir))) (for-each displayln (directory-list (find-gui-bin-dir)))'`.

@juanfra684 tried, it lists everything in my `/usr/local/bin/` but there is no Racket IDE in there.

The problem is that the OS X build can't handle the combination of `configure` arguments used for the Homebrew formula. Some flags force a "unix-style" layout, while parts of the Racket build for OS X currently rely on an "in-place" layout.

I have a repair, I think, but I'm still testing it.

I committed a better patch. `(sleep 1800)` will be only used when the JIT is not enabled.

Here are some numbers for hash tables with 1000000 keys and vals.

```
1st num: non-fast path (current Racket head)
2nd num: (safe) fast path (current Racket head)
3rd num: unsafe fast path
4th num: unsafe fast path (no impersonator check)
immutable --------------------
in-hash
cpu time: 228 real time: 229 gc time: 0
cpu time: 196 real time: 199 gc time: 0
cpu time: 124 real time: 121 gc time: 0
cpu time: 108 real time: 111 gc time: 0
in-hash-pairs
cpu time: 224 real time: 225 gc time: 0
cpu time: 200 real time: 200 gc time: 0
cpu time: 108 real time: 109 gc time: 0
cpu time: 108 real time: 107 gc time: 0
in-hash-keys
cpu time: 212 real time: 209 gc time: 0
cpu time: 184 real time: 185 gc time: 0
cpu time: 84 real time: 86 gc time: 0
cpu time: 84 real time: 85 gc time: 0
in-hash-values
cpu time: 216 real time: 214 gc time: 0
cpu time: 188 real time: 188 gc time: 0
cpu time: 96 real time: 98 gc time: 0
cpu time: 100 real time: 99 gc time: 0
mutable --------------------
in-hash
cpu time: 76 real time: 77 gc time: 0
cpu time: 48 real time: 47 gc time: 0
cpu time: 36 real time: 38 gc time: 0
cpu time: 32 real time: 32 gc time: 0
in-hash-pairs
cpu time: 72 real time: 72 gc time: 0
cpu time: 44 real time: 48 gc time: 0
cpu time: 36 real time: 33 gc time: 0
cpu time: 32 real time: 32 gc time: 0
in-hash-keys
cpu time: 60 real time: 60 gc time: 0
cpu time: 36 real time: 36 gc time: 0
cpu time: 24 real time: 22 gc time: 0
cpu time: 20 real time: 21 gc time: 0
in-hash-values
cpu time: 60 real time: 61 gc time: 0
cpu time: 40 real time: 37 gc time: 0
cpu time: 20 real time: 22 gc time: 0
cpu time: 20 real time: 21 gc time: 0
weak --------------------
in-hash
cpu time: 128 real time: 128 gc time: 0
cpu time: 100 real time: 103 gc time: 0
cpu time: 72 real time: 70 gc time: 0
cpu time: 68 real time: 67 gc time: 0
in-hash-pairs
cpu time: 124 real time: 123 gc time: 4
cpu time: 84 real time: 85 gc time: 0
cpu time: 68 real time: 69 gc time: 0
cpu time: 64 real time: 61 gc time: 0
in-hash-keys
cpu time: 112 real time: 113 gc time: 0
cpu time: 72 real time: 72 gc time: 0
cpu time: 48 real time: 45 gc time: 0
cpu time: 44 real time: 44 gc time: 0
in-hash-values
cpu time: 116 real time: 116 gc time: 0
cpu time: 72 real time: 75 gc time: 0
cpu time: 44 real time: 44 gc time: 0
cpu time: 40 real time: 41 gc time: 0
```

This is the test file.

```
#lang racket
(define big-list (build-list 1000000 add1))
(define big-list2 (build-list 1000000 values))

(define big-hash/immut (make-immutable-hash (map cons big-list big-list2)))
(define big-hash/mut (make-hash (map cons big-list big-list2)))
(define big-hash/weak (make-weak-hash (map cons big-list big-list2)))

(define big-hash/immut/seq (in-hash big-hash/immut))
(define big-hash/mut/seq (in-hash big-hash/mut))
(define big-hash/weak/seq (in-hash big-hash/weak))

(define big-hash/immut-pairs/seq (in-hash-pairs big-hash/immut))
(define big-hash/mut-pairs/seq (in-hash-pairs big-hash/mut))
(define big-hash/weak-pairs/seq (in-hash-pairs big-hash/weak))

(define big-hash/immut-keys/seq (in-hash-keys big-hash/immut))
(define big-hash/mut-keys/seq (in-hash-keys big-hash/mut))
(define big-hash/weak-keys/seq (in-hash-keys big-hash/weak))

(define big-hash/immut-vals/seq (in-hash-values big-hash/immut))
(define big-hash/mut-vals/seq (in-hash-values big-hash/mut))
(define big-hash/weak-vals/seq (in-hash-values big-hash/weak))

(collect-garbage)
(collect-garbage)
(collect-garbage)

(displayln "1st num: non-fast path (current Racket head)")
(displayln "2nd num: (safe) fast path (current Racket head)")
(displayln "3rd num: unsafe fast path")
(displayln "4th num: unsafe fast path (no impersonator check)")
(require rackunit)

(displayln "immutable --------------------")
(displayln "in-hash")
(check-true 
  (= (time (for/sum ([(k v) big-hash/immut/seq]) (+ k v)))
     (time (for/sum ([(k v) (in-hash big-hash/immut)]) (+ k v)))
     (time (for/sum ([(k v) (in-immutable-hash big-hash/immut)]) (+ k v)))
     (time (for/sum ([(k v) (in-immutable-hash* big-hash/immut)]) (+ k v)))
     ))
(displayln "in-hash-pairs")
(check-true 
  (= (time (for/sum ([k+v big-hash/immut-pairs/seq]) (+ (car k+v) (cdr k+v))))
     (time (for/sum ([k+v (in-hash-pairs big-hash/immut)]) 
             (+ (car k+v) (cdr k+v))))
     (time (for/sum ([k+v (in-immutable-hash-pairs big-hash/immut)])
             (+ (car k+v) (cdr k+v))))
     (time (for/sum ([k+v (in-immutable-hash-pairs* big-hash/immut)])
             (+ (car k+v) (cdr k+v))))
     ))
(displayln "in-hash-keys")
(check-true
  (= (time (for/sum ([k big-hash/immut-keys/seq]) k))
     (time (for/sum ([k (in-hash-keys big-hash/immut)]) k))
     (time (for/sum ([k (in-immutable-hash-keys big-hash/immut)]) k))
     (time (for/sum ([k (in-immutable-hash-keys* big-hash/immut)]) k))
     ))
(displayln "in-hash-values")
(check-true
  (= (time (for/sum ([v big-hash/immut-vals/seq]) v))
     (time (for/sum ([v (in-hash-values big-hash/immut)]) v))
     (time (for/sum ([v (in-immutable-hash-values big-hash/immut)]) v))
     (time (for/sum ([v (in-immutable-hash-values* big-hash/immut)]) v))
     ))

(displayln "mutable --------------------")
(displayln "in-hash")
(check-true
  (= (time (for/sum ([(k v) big-hash/mut/seq]) (+ k v)))
     (time (for/sum ([(k v) (in-hash big-hash/mut)]) (+ k v)))
     (time (for/sum ([(k v) (in-mutable-hash big-hash/mut)]) (+ k v)))
     (time (for/sum ([(k v) (in-mutable-hash* big-hash/mut)]) (+ k v)))
     ))
(displayln "in-hash-pairs")
(check-true
  (= (time (for/sum ([k+v big-hash/mut-pairs/seq]) (+ (car k+v) (cdr k+v))))
     (time (for/sum ([k+v (in-hash-pairs big-hash/mut)]) 
             (+ (car k+v) (cdr k+v))))
     (time (for/sum ([k+v (in-mutable-hash-pairs big-hash/mut)]) 
             (+ (car k+v) (cdr k+v))))
     (time (for/sum ([k+v (in-mutable-hash-pairs* big-hash/mut)]) 
             (+ (car k+v) (cdr k+v))))
     ))
(displayln "in-hash-keys")
(check-true
  (= (time (for/sum ([k big-hash/mut-keys/seq]) k))
     (time (for/sum ([k (in-hash-keys big-hash/mut)]) k))
     (time (for/sum ([k (in-mutable-hash-keys big-hash/mut)]) k))
     (time (for/sum ([k (in-mutable-hash-keys* big-hash/mut)]) k))
     ))
(displayln "in-hash-values")
(check-true
  (= (time (for/sum ([v big-hash/mut-vals/seq]) v))
     (time (for/sum ([v (in-hash-values big-hash/mut)]) v))
     (time (for/sum ([k (in-mutable-hash-values big-hash/mut)]) k))
     (time (for/sum ([k (in-mutable-hash-values* big-hash/mut)]) k))
     ))

(displayln "weak --------------------")
(displayln "in-hash")
(check-true
  (= (time (for/sum ([(k v) big-hash/weak/seq]) (+ k v)))
     (time (for/sum ([(k v) (in-hash big-hash/weak)]) (+ k v)))
     (time (for/sum ([(k v) (in-weak-hash big-hash/weak)]) (+ k v)))
     (time (for/sum ([(k v) (in-weak-hash* big-hash/weak)]) (+ k v)))
     ))
(displayln "in-hash-pairs")
(check-true
  (= (time (for/sum ([k+v big-hash/weak-pairs/seq]) (+ (car k+v) (cdr k+v))))
     (time (for/sum ([k+v (in-hash-pairs big-hash/weak)]) 
             (+ (car k+v) (cdr k+v))))
     (time (for/sum ([k+v (in-weak-hash-pairs big-hash/weak)]) 
             (+ (car k+v) (cdr k+v))))
     (time (for/sum ([k+v (in-weak-hash-pairs* big-hash/weak)]) 
             (+ (car k+v) (cdr k+v))))
     ))
(displayln "in-hash-keys")
(check-true
  (= (time (for/sum ([k big-hash/weak-keys/seq]) k))
     (time (for/sum ([k (in-hash-keys big-hash/weak)]) k))
     (time (for/sum ([k (in-weak-hash-keys big-hash/weak)]) k))
     (time (for/sum ([k (in-weak-hash-keys* big-hash/weak)]) k))
     ))
(displayln "in-hash-values")
(check-true
  (= (time (for/sum ([v big-hash/weak-vals/seq]) v))
     (time (for/sum ([v (in-hash-values big-hash/weak)]) v))
     (time (for/sum ([v (in-weak-hash-values big-hash/weak)]) v))
     (time (for/sum ([v (in-weak-hash-values* big-hash/weak)]) v))
     ))
```

:)

Visual Studio don´t like [hash-c#L4226](https://github.com/racket/racket/pull/1229/files#diff-90d2fa46e6ddf69604e1a60db1e1dcffR4226). What about:

```
- Scheme_Object *obj = argv[0], *res[0];
+ Scheme_Object *obj = argv[0], *res[2];
```

I don't undetnd what is a "pointer" into the tree. What happens if someone prints it? It creates a segfault? Is the pointer encoded as a fixnum? What happens if there is a gc and the hash is moved (or collected)?

How is this visible? I tried this, but I didn't get an error:

```
#lang racket/base
(require racket/unsafe/ops)

(define h #hash((1 . 1) (2 . 2) (3 . 3) (4 . 4) (5 . 5) (6 . 6)))
#;(define h (make-hash '((1 . 1) (2 . 2) (3 . 3) (4 . 4) (5 . 5) (6 . 6))))
(let loop ([hi (unsafe-immutable-hash-iterate-first* h)])
  (when hi
    (displayln hi)
    (loop (unsafe-immutable-hash-iterate-next* h hi))))
```

>  hash-c#L4226

Oops, typo. Thanks! Strange that the tests didnt segfault

> "pointer"

The signature of `unsafe-immutable-hash-iterate-first*` is `ImmutableHash -> UnsafeIndex` where

An `UnsafeIndex` is one of:
- `(list ImmutableHash ExactNonNegInt)`
- `(cons ImmutableHash (cons ExactNonNegInt UnsafeIndex))`

where the hashes in the list are subtrees of the input and an index in the list is a position in the corresponding subtree.

Printing an UnsafeIndex should print a list of valid Racket hash and int values.

OK, it's a litte strange but not dangerous. I like this. For the record, the smallest example I found was with:

```
(define l (build-list 33 add1))
(define h (make-immutable-hash (map cons l l)))
```

Now I have the inverse question: Why can't this be used for the safe version of `hash-iterate-first`? I guess the problem is that `hash-iterate-first` has already the wrong signature.  

Would be it a good idea to define all the new `unsafe-X-hash-iterate-first` as (X . -> . any/c) like `dict-iterate-first`, in case someone wants to change the implementation later?

> the smallest example I found was with

Yes, since the nodes are 32 bits wide, any immutable hash of size 32 or less will not have any subtrees.

> Why can't this be used for the safe version of hash-iterate-first

Yes it could, though as you mentioned it would technically be backwards-incompatible. It may not be so bad though since you can't do anything with the result of `hash-iterate-first` and `-next` other than to give it to the other `hash-iterate-` functions.

> Would be it a good idea to define all the new `unsafe-X-hash-iterate-first` as `(X . -> . any/c)` 

Yes I think that's a good idea. I'll change the docs.

 Just another question. For small hashes (<= 32?), is it posible to use only the number? I think that in many ocations the hash has only a 10 or 20 elements, and it would be nice to iterate without producing garbage. Does this change make the implementation much harder?

Perhaps this idea can be extended to the first iterations of any hash. If current code returns `(#hash((1 . 1) ...) n)` then return just `n` instead. (This will make no difference for big hashes, but I guess this is easier to implement than a special case for small hashes.)

> small hashes

That might be worth looking into. You bring up a good point in general about space usage. Maybe I could switch to a mutable data structure and reuse it when calling `next` within the same subtree. That would make it log space instead of linear. 

Does it make sense to just have a completely separate path for hashes that are below a certain size? You'd have to have some kind of a test at the start of the for loop, but that seems like it could be in the noise, even for small hashes

> completely separate path for hashes that are below a certain size

I can do some experiments but my guess is that small hash iteration will be quick enough that it might not matter

I see what you mean. I haven't built your commit, but I'm seeing that small immutable hashes are about 2x slower than vectors right now and if you've already sped them up by 2x, then it seems unlikely that you'd get better results that the vector case. Here's my test code:

```
#lang racket
(define v (make-vector 30 #f))
(define ht (apply hash (apply append (build-list 30 (λ (x) (list 1 #f))))))
(define N 2000000)
(collect-garbage) (collect-garbage) (collect-garbage)
(time
 (for ([x (in-range N)])
   (for ([e (in-vector v)])
     e)))

(collect-garbage) (collect-garbage) (collect-garbage)
(time
 (for ([x (in-range N)])
   (for ([(k v) (in-hash ht)])
     v)))
```

A small correction the last test case:

```
(define ht (apply hash (apply append (build-list 30 (λ (_x_) (list _x_ #f))))))
```

I guess that the time difference was only in the large hashes, were the old algorithm needed a lot of pointer chasing to reach the actual vale and calculate the next one. In small hashes I guess the difference was smaller. (I really need to measure this to be sure.)

About mutable structures: I prefer immutable structures. Can an intermediate index be saved and the sequence replayed later (for example, using a continuation)?

I think that adding a special case to replace for `(original-hash pos) ==> pos` will be enough to solve the space problem for small hashes without changing too much the algorithm.  

I wrote my idea and pushed it to one of my branches: https://github.com/gus-massa/racket/tree/16-1-E-stchang%2Bunsafe-hash-iterate-try2

It's an advance draft (I hope all the tests finich correctly). If you want you can copy and squash it and fix the details. Or if you prefer I can send it as a PR after this is finished.

I coudn't run "make export" in Windows. (Is it necesary to add scheme_unsafe_hash_tree_start/next to schemef.h? Isn't it better to add it to schpriv.h? I'm not sure about the difference.)

I think it would be good to add test for bigger hashes in hash.rktl. IIUC it only test a hash with 10 elements. Do the other hashes have some internal magic numbers bigger than 32?

@gus-massa Have you run timing experiments with your additions? On my current branch, small immutable hash table iteration takes negligible time, suggesting that it's not worth it to special case them.

> schemef.h vs schpriv.h

I wasn't sure where to put the declarations either but I just followed the other `hash_tree_` functions.

And yes, tests with larger hash tables would be helpful. I'll add them before I merge.

I think this is actually exponential runtime, and not an infinite loop. If you change it to `java.lang.S` and then slowly add back the characters in `Serializable`, you'll see increaisng run times.

Modifying the iteration index structure "in place" shaves another 10-20% off iteration time for immutable hashes. Here are some updated numbers:

```
1st num: non-fast path (current Racket head)
2nd num: (safe) fast path (current Racket head)
3rd num: unsafe fast path
4th num: unsafe fast path (no impersonator check)
immutable --------------------
in-hash
cpu time: 228 real time: 227 gc time: 0
cpu time: 200 real time: 201 gc time: 0
cpu time: 96 real time: 94 gc time: 0
cpu time: 92 real time: 92 gc time: 0
in-hash-pairs
cpu time: 228 real time: 229 gc time: 4
cpu time: 200 real time: 202 gc time: 4
cpu time: 96 real time: 94 gc time: 0
cpu time: 88 real time: 90 gc time: 0
in-hash-keys
cpu time: 208 real time: 209 gc time: 0
cpu time: 184 real time: 186 gc time: 0
cpu time: 68 real time: 68 gc time: 0
cpu time: 68 real time: 69 gc time: 4
in-hash-values
cpu time: 208 real time: 212 gc time: 0
cpu time: 192 real time: 190 gc time: 0
cpu time: 80 real time: 82 gc time: 0
cpu time: 80 real time: 81 gc time: 0
```

Is that safe for continuation grabs?

No probably not. 

Which means we can't use it, right? :(

Right, unless we have an unsafe iterator

But even if we had that unsafe iterator, we couldn't use it in `for` loops, so it doesn't seem that valuable.

Unsafe `for`? :)

Another idea could be to return the index and sub tree using multiple values. That would eliminate both the mutation and the excess pair allocations. 

I think it's better to keep the x2 improvement of the first version, and keep it safe for continuations. Using `values` will make it more difficult to use, and actually `values` are slower than `cons`.

I don't have a benchmark for the use with small hashes. It's just a gut feeling. Usually the non allocating version is faster. With small hashes, both run times are negligible, but if you have an `unsafe-immutable-hash-next` inside a hot thigh loop, I guess it would be possible to see a measurable the difference.

(I have some ideas to extend the non-allocating version to medium hashes (with a few hundreds of elements), but I want to think carefully about the details. My idea is to use essentially your implementation so it's fast, but encode the tree differently. I hope to have working prototype and benchmarks for next week.)  

Thanks! Do you think it would be better to use `check-duplicates` from racket/list so there's no allocation? Also, do any existing tests break?

I see. Then it is probably an instance of the worst case behavior for
backtracking regexp algorithms that is described on the Wikipedia page
on regexp matching (https://en.wikipedia.org/wiki/Regular_expression#Implementations_and_running_times). 

Perl seems to be able to cope with the given case, but python has the same problem (cf attachments.. also the previous perl version was bogus). It seems like I just have to be more careful when writing regexes. I'm closing the issue.
[racket-rx-loop-bug.zip](https://github.com/racket/racket/files/114258/racket-rx-loop-bug.zip)

> `values` will make it more difficult to use

Hmm, it seems like the `for` forms don't support multiple values anyways (because there's no named `let-values`). I guess I'll have to revert.

LGTM

This looks good to me.

Setting `APPN_FLAG_IMMED | APPN_FLAG_SFS_TAIL` looks right.

I'm not sure about `eq?` versus `unsafe-fx=`. Keeping `unsafe-fx=` may communicate to parts of the optimizer that the arguments are expected to be fixnums, but I think that kind of expectation only matters currently for flonums (for unboxing).

Lots of good work here!

I don't understand how this is safe for mutable hash tables. It seems
like on thread could use `in-mutable-hash` (which is supposed to be
safe) while another thread mutates the hash table, and then the
`in-mutable-hash` thread can crash. Am I missing a guard somewhere?

Not related to this patch: Does iteration through a weak hash table
currently make sense? It looks like a GC during iteration could cause
`hash-iterate-value` to raise a "bad index" error even if the index was
derived from `hash-iterate-next`.

Related to this patch: Instead of an error, I think you get a seg
fault, because the weak reference is replaced with NULL.

The "for.rkt" changes look like a lot of new and repetitive code. Does
it make sense to abstract more? Specifically, I worry about increasing
the footprint of "for.rkt". Is it much bigger with these changes?
Creating a new macro that expands to `define-sequence-syntax` would not
address that issue, but moving the content of the function that
generates `:do-in` to a compile-time function might make both the
implementation and compiled format smaller.

Please stick to `/* ... */` comments in the C code, so that we can
continue to support old compilers.

I think you meant to fill in the `""`s to `chaperone_hash_key`.

I agree that the new function declarations generally belong in "schpriv.h" instead of "schemef.h". The "schemef.h" file is for functions that we want to make visible via the FFI or to C embeddings/extensions.

This looks ready to merge.

Managed to cut another 10-20% from immutable hash iteration by decrementing the index instead of incrementing. (compare to the top set of numbers above)

```
1st num: non-fast path (current Racket head)
2nd num: (safe) fast path (current Racket head)
3rd num: unsafe fast path
4th num: unsafe fast path (no impersonator check)
immutable --------------------
in-hash
cpu time: 228 real time: 229 gc time: 0
cpu time: 200 real time: 202 gc time: 0
cpu time: 104 real time: 105 gc time: 0
cpu time: 104 real time: 101 gc time: 0
in-hash-pairs
cpu time: 228 real time: 229 gc time: 0
cpu time: 200 real time: 201 gc time: 0
cpu time: 80 real time: 78 gc time: 0
cpu time: 76 real time: 79 gc time: 0
in-hash-keys
cpu time: 208 real time: 208 gc time: 0
cpu time: 188 real time: 190 gc time: 0
cpu time: 76 real time: 75 gc time: 0
cpu time: 76 real time: 76 gc time: 4
in-hash-values
cpu time: 216 real time: 214 gc time: 0
cpu time: 188 real time: 191 gc time: 0
cpu time: 88 real time: 85 gc time: 0
cpu time: 80 real time: 84 gc time: 0
```

> I don't understand how this is safe for mutable hash tables

Yes, you are right. I need to put the guards back in for mutable hash tables and bucket tables.

> Does iteration through a weak hash table currently make sense? It looks like a GC during iteration could cause hash-iterate-value to raise a "bad index" error even if the index was
> derived from hash-iterate-next.

Yes this can happen but I think an exception is the best we can do. Unless `iterate-next` returns a promise? 

And I'll add a check to make sure it throws an exception instead of segfaulting.

> The "for.rkt" changes look like a lot of new and repetitive code

I agree it needs abstraction! I was going to work on it after I got the primitives stable.

> Please stick to /\* ... */

Ah ok, I didn't realize one was newer.

> I think you meant to fill in the ""

Oops. Thanks.

> I agree that the new function declarations generally belong in "schpriv.h"

I'll try to clean things up a little.

updated.

One of the CI failed, it report `raco test -l tests/db/all-tests` failed.
But in my branch, it all passed, I don't know why, the db tests unstable?

That test has been failing intermittently recently, so it's not your fault.

On Wed, Feb 3, 2016, 5:43 AM Chen Xiao notifications@github.com wrote:

> updated.
> 
> One of the CI failed, it report raco test -l tests/db/all-tests failed.
> But in my branch, it all passed, I don't know why, the db tests unstable?
> 
> —
> Reply to this email directly or view it on GitHub
> https://github.com/racket/racket/pull/1231#issuecomment-179159095.

I'll rebase+merge this as is, and later I´ll try to think if it's better to add a few `APPN_FLAG_IMMED | APPN_FLAG_SFS_TAIL` here and there.

I rebased this, but I got errors in the CI.

The error in Travis is a common error in previous commits, sometimes fail gcc and sometimes clang. It's unrelated so I'm ignoring it.

The error in AppVeyor is new. It fails randomly approximately one half of the times. The error is in random places and is not repeatable. The error is so weird that I guess it's a bad interaction with the garbage collector????? I'll try to bisect and repeat the test, to try to find the problem. Test history: https://ci.appveyor.com/project/gus-massa/racket/history

Awesome, thanks so much!

That's expected, and I'll try again at improving the docs. (I'm not sure why I ended up with such a weak warning the last time I tried.)

@mflatt Do you think the non-chaperone-supporting unsafe variants are necessary here? They don't really improve performance and they add a lot of code and primitives.

@stchang Dropping them sounds fine to me.

Does anyone know if I can restart the AppVeyor tests?

New pushes should cause it to run again.

Almost all the error were related to alams ans similar code. I guess the fix goes elsewhere.

The only case where I got another error was:

```
FAILED ->i-values17 rewrite-to-add-opt/c
  got "y-dom-blame: undefined;\n cannot reference undefined identifier"
  expected no-exn-raised
FINISHED arrow-i.rkt
```

I tried to reproduce the error in my computer and AppVeyor, but I was unsuccesaful.

If you agree, I'll rebase and merge this as is. 

Yes, I agree with merging.

That error is most likely an intermittent macro expander bug that we've seen before but not been able to track down.

This doesn't look like a bug, but it probably needs clarification in the docs.

A delay provided to `sync/timeout` is merely a lower bound on the duration of the sync attempt. Similarly, an alarm event becomes ready at a given time, but there's no guarantee that `sync` sees the time between two alarm events becoming ready. More generally, there's no guarantee that an event will be selected before another event that becomes ready later; the intended guarantee is something more along the lines of "eventually, some ready event will be selected".

I expect that the difference with this example is more visible on Windows because the system clock is so coarse (around 15ms), but a sufficiently loaded Linux installation should produce the same result.

Just to clarify: I think the failing tests in "sync.rktl" are bad.

The only idea I have for making them work in practice is to make the long delays (i.e., the ones that are not meant to be selected) orders of magnitude larger than the delays that are meant to be selected. Then, then tests should pass in all but the most unfriendly environments.

Agree. I think that something like

```
(test 0.15 sync/timeout 18 (make-delay 0.15) (make-delay 2))
```

will work.

Am I missing something? Why would duplicate attribute definitions trigger an error?

“an XML processor may at user option issue a warning when … more than one attribute definition is provided for a given attribute, **but this is not an error**.”

https://www.w3.org/TR/xml/#attdecls

I think duplicate attributes deliver a ambiguous meaning, it’s a error indeed.

> 在 2016年2月5日，下午3:01，Matthew Butterick notifications@github.com 写道：
> 
> Am I missing something? Why would duplicate attribute definitions trigger an error?
> 
> “an XML processor may at user option issue a warning when … more than one attribute definition is provided for a given attribute, but this is not an error.”
> 
> https://www.w3.org/TR/xml/#attdecls https://www.w3.org/TR/xml/#attdecls
> —
> Reply to this email directly or view it on GitHub https://github.com/racket/racket/pull/1231#issuecomment-180228567.

merged

Well, if the XML spec explicitly says otherwise, there’s nothing to argue.

Still, it's not hard to see why the spec doesn’t insist on unique attributes. Suppose you had a million attributes. Every time you added another, you’d have to search through the whole list looking for a duplicate, and if found, remove it. This could be costly. 

Instead, the XML spec treats the attribute list as a LIFO stack, where you can push new attributes onto the front in the usual `cons` style (without worrying about duplicates). 

Moreover, duplicate attributes are not ambiguous — the spec also says “the first declaration is binding.” Thus, you can read attributes by using a `memq` style first-match heuristic (again, instead of searching the whole list, removing duplicates in advance, etc.)

Erratum: said `memq`, meant `assq`

Thank you.

I understand, find duplicate may be costly.
Yours opinion is ignor the duplicate attribute, right?

I google a few online xml validator, like:

http://codebeautify.org/xmlvalidate

http://www.utilities-online.info/xsdvalidation

http://www.xmlvalidation.com/documentation.html

If I use duplicate attributes, it all report the error.

So I won't change the piece of code and want to see more people to join this argument.

Btw, another interesting question is :
The opensource project like racket, if have different opinion on some feature, who decide to do or not do?

> 在 2016年2月6日，上午2:00，Matthew Butterick notifications@github.com 写道：
> 
> Erratum: said memq, meant assq
> 
> —
> Reply to this email directly or view it on GitHub https://github.com/racket/racket/pull/1231#issuecomment-180471570.

This change looks right to me.

I named the sequences `in-immutable-set`, `in-mutable-set`, and `in-weak-set`. Will merge unless there are objections.

Here's some microbenchmark numbers for `in-set` vs the new sequences for set size = 1000000

```
immutable
cpu time: 216 real time: 214 gc time: 0
cpu time: 84 real time: 83 gc time: 4
mutable
cpu time: 60 real time: 60 gc time: 0
cpu time: 32 real time: 31 gc time: 0
weak
cpu time: 128 real time: 127 gc time: 0
cpu time: 80 real time: 80 gc time: 0
```

I think Matthew brings up an important point. Let's see if I understand
things correctly...

1) Old versions of `xml` de-duplicate and sort the attributes. This means
that for old code, string->xml and xml->string are not inverses. Changing
either could potentially change existing system behavior.

2) The spec does not require unique attributes, but it also does not seem
to require allowing duplicates because it seems to say that libraries may
only see the first.

3) We could make the parser go faster by following the spec and just
`cons`ing every attribute and not looking at anything

4) A few online checkers flag errors with duplicate attributes... perhaps
because it may be confusing to some people which will take effect.

I feel that we should look at what other popular libraries do. It seems
like the standard may not really be authoritative here. In particular, I'm
curious what libxml and Java's XML libraries do on these points.

On Fri, Feb 5, 2016 at 7:32 PM, Chen Xiao notifications@github.com wrote:

> Thank you.
> 
> I understand, find duplicate may be costly.
> Yours opinion is ignor the duplicate attribute, right?
> 
> I google a few online xml validator, like:
> 
> http://codebeautify.org/xmlvalidate
> 
> http://www.utilities-online.info/xsdvalidation
> 
> http://www.xmlvalidation.com/documentation.html
> 
> If I use duplicate attributes, it all report the error.
> 
> So I won't change the piece of code and want to see more people to join
> this argument.
> 
> Btw, another interesting question is :
> The opensource project like racket, if have different opinion on some
> feature, who decide to do or not do?
> 
> > 在 2016年2月6日，上午2:00，Matthew Butterick notifications@github.com 写道：
> > 
> > Erratum: said memq, meant assq
> > 
> > —
> > Reply to this email directly or view it on GitHub <
> > https://github.com/racket/racket/pull/1231#issuecomment-180471570>.
> 
> —
> Reply to this email directly or view it on GitHub
> https://github.com/racket/racket/pull/1231#issuecomment-180634741.

## 

Jay McCarthy
Associate Professor
PLT @ CS @ UMass Lowell
http://jeapostrophe.github.io

```
       "Wherefore, be not weary in well-doing,
  for ye are laying the foundation of a great work.
```

And out of small things proceedeth that which is great."
                          - D&C 64:33

I've been experimenting a bit with the packaging of CLDR data. The approach I'm working on right now still has a single package for the `cldr-core` library. Its data is about 100k compressed. But for the locale-specific data, instead of creating a package per unicode-cldr repository, I'm making a package per locale. Each locale's package (e.g., `cldr-locale-en`) contains all of the CLDR data specific to that locale, and each tends to have about 80k of data, compressed.

So, if the `datetime` library used this approach and shipped with a modest number of locales, it would use considerably less space than Gregor's current dependencies (over 13MB, compressed).

The downside of this approach is that it generates a whole lot of packages. I'm thinking that the best way to deal with this problem is to register only the core package with a package catalog server but have it supply a `raco` tool that can install additional locale packages (e.g., `raco locale install en de fr es`).

Opinions on this approach? In particular, @samth, since we discussed the data size problem at RacketCon, what do you think?

One approach I'm avoiding is just extracting from CLDR _exactly_ the data that the `datetime` library needs. That would minimize the data requirements but at the expense of making the data far less useful for other libraries or programs that might want to use it.

Just from my own naive point of view, it seems quite strange that a
generally useful date/time library needs to come with 100k of (compressed)
data, let alone 14 megs.

Is there a way we can factor things differently so that this dependency is
necessary only for people who are doing more fancy things? Or is there some
inherent complexity that I'm missing somehow?

A couple thoughts:
1. I think serving the packages from the regular pkg server would still be the right thing to do, but maybe a tool like `raco locale install` would be a good addition, and be simpler since it would just install `cldr-locale-en` or some other package. In particular, the pkg system has a lot of mechanism for handling multiple installs of Racket, appropriate directories, network retries, and so on, and re-implementing that would seem like a bad idea.
2. Right now, Racket contains about 560k of Unicode data for string manipulation, so 100k seems like a reasonable addition (it would be about 0.1% of the full distribution), and 13MB doesn't seem so reasonable. 

@rfindler The 100k bundle is this data: [https://github.com/unicode-cldr/cldr-core]. Of course, the `datetime` library doesn't need all of it -- or even most of it -- but as I mentioned, I'm reluctant to extract just the parts that it needs, because this data is broadly useful for localization. Some other library or program that wants to provide localization is likely to need a different, but possibly overlapping, slice of the same dataset.

Anyhow, let me give you some examples of what the library needs just from _that_ repository (and keep in mind that the library needs data from _several_ of the `unicode-cldr` repositories):
- `supplemental/windowsZones.json` is used, not directly by Gregor, but by `tzinfo` to map Windows time zone names to IANA/Olson names. [https://github.com/97jaz/tzinfo/blob/87788643ca35f0b61d946877342a70c3fb4b66f1/tzinfo/private/os/windows.rkt#L28]
- `supplemental/primaryZones.json` is used to implement time zone formatting: [https://github.com/97jaz/gregor/blob/1e065b00f353bf62bf67cf113bc81d36b75373e3/gregor-lib/gregor/private/pattern/l10n/zone-loc.rkt#L46]
- `supplemental/numberingSystems.json` is used for parsing and formatting date/time strings. (When formatting in Arabic, we use the digits "٠١٢٣٤٥٦٧٨٩" instead of "0123456789.") [https://github.com/97jaz/gregor/blob/1e065b00f353bf62bf67cf113bc81d36b75373e3/gregor-lib/gregor/private/pattern/l10n/numbers.rkt#L68]
- `supplemental/metaZones.json` is used to implement time zone formatting (CLDR has some pretty annoyingly complicated rules for time zone formatting; if you're interested and have a strong stomach, see [http://www.unicode.org/reports/tr35/tr35-dates.html#Using_Time_Zone_Names].) [https://github.com/97jaz/gregor/blob/1e065b00f353bf62bf67cf113bc81d36b75373e3/gregor-lib/gregor/private/pattern/l10n/metazone.rkt]
- `supplemental/likelySubtags.json` is used to try to find a suitable CLDR locale based on whatever locale string the user happens to enter. So, for example, if someone sets their locale as "fr_US" (meaning something like "French, as it is spoken in the United States") and there is no such data corresponding to that, we'll just use "fr."

@samth I was definitely planning on making the locales proper packages. I'm just not sure if there's a benefit to registering them with the package catalog server. Then again, my reasons are pretty superficial:
- I don't know if there's a way to automate the registration of packages with the package server, and I'm certainly not going to register each locale package by hand. That said, there _could_ be a way to automate this.
- The current UI of pkgs.racket-lang.org wouldn't handle a huge number of `cldr-locale-XX` packages very well. That said, it wouldn't handle a huge number of packages well, period.

@rfindler To answer your question more directly ("Is there a way we can factor things differently so that this dependency is necessary only for people who are doing more fancy things?"). There's definitely no good way to reduce the data burden _just_ by making certain features (say, localized formatting and parsing) require a separate package. This is because data from `cldr-core` is required regardless of whether you want this feature (to say nothing of the fact that parsing and formatting are pretty basic functions of a date/time library). The only way to reduce the data burden and retain the data's general usefulness is to slice up the repos into even more fine-grained packages. Specifically, we could divide the data from `cldr-core` into multiple packages, maybe even one per JSON file. For the locale-specific data, there could be a package per locale per repository. (Or even one per locale per JSON file.) The downsides of this approach are:
- Even more multiplication of packages.
- A more difficult way of handling locale data dependencies. (Well, this is true only if we divide up the locale-specific repos.) What I mean is, instead of saying, "I want to install the locale data for the following locales," you'd have to say, "I want to install the number, date, and locale name data for the following locales."

Okay, thanks for filling me in. I agree that separate packages (that other
pkgs might also depend on) is the way to go.

Why not `~s`, `~v`, and others?

Whoops, those are implemented but not documented: `(~a ~s ~v ~e ~.a ~.s ~.v)`

Originally discovered with @david-christiansen.

LGTM

Not really needed anymore, due to https://github.com/racket/racket/pull/1073

What's the invariant that this breaks?

Also, this primitive would be useful in the contract system, even without the automatic optimization.

Perhaps the right word is not "invariant", but this example will get an strange result if one of the `(immutable? v)` is optimized beause it's the result should not change:

```
(define (f v) (unsafe-vector*->immutable-vector! v))

(let ([v (vector 1 2 3)])
  (let ([x (immutable? v)]
        [y (f v)]
        [z (immutable? v)])
    (eq? x z)))
```

Just to clarify, my idea is that the previous code is an _unsuported_ use of `unsafe-vector*->immutable-vector!` so the result is unspecified and compiler is free to generate any result (including a segfault).

In any sensible implementation, I expect the result to be `#f` or `#t`.

For example, the naive implementation just run the code as written and the result is `#f`. This is the current behavior in Racket and I guess it will not change during this year, but I wish to keep the possibility of an improvement for later. I don't know if Typed Racket currently does something smarter.

A sufficient smart compiler could realize that `z` is equal to `x`, because the immutability of the vectors never changes, so the result will be `#t`.

@rfindler I'm considering the one-package-per-JSON-file scenario. This seems unproblematic for the data in the `cldr-core` repository, but it raises a new problem for the per-locale JSON files. My original `raco locale install fr` idea doesn't work so well in this scenario, since a locale is no longer represented by a single package but by a collection of them, and a given program will probably only depend on some of them. We could always do `raco locale install --locales fr es --files numbers ca-gregorian`, but that places a lot of burden on the user to know exactly which locale-specific files need to be installed to get a certain program to work.

Would it be possible / advisable to have packages specify in their `info.rkt` what their locale-specifc dependencies are? Like so:

``` racket
(define cldr-locale-deps '("ca-gregorian" "numbers" "localeDisplayNames" "territories"))
```

Then when you do `raco locale install es`, the raco tool first collects dependencies from installed packages so that it knows which `es`-specific packages it needs. However, this means that installing or uninstalling packages can change those dependencies. I suppose the packages could also use the `setup-collects` field in `info.rkt` to cause the `cldr` package to rebuild the dependencies. (I don't know if this would also work when a package is uninstalled; the documentation only mentions installation.)

I'm not sure if this would work, and I'm also not sure it's worth the space savings, but I'm interested to know what you (and others) think.

Bug found by @sabauma, and taken from the OOPSLA '12 chaperone benchmarks.

This behavior appears to date from the introduction of `prop:rename-transformer`, in this commit: https://github.com/racket/racket/commit/2109cec2f4d89f820647ae75e81b0d7b6a70f4a1#diff-23bb48bf312b57d2acf00f748a5bfd50R1290 and to be intentional at the time. I suppose there's a sense in which erroring on that line instead of doing what it currently does would be backwards incompatible, but it's hard for me to imagine a real program that would break.

Merged!

**Seventh commit: Reduce `(if (let (...) x y #t) K _) => (let (...) x y K)`**

This fix the problem with the unnecessary `#<void>` added in the fifth commit, for expressions like `(not (if (let ([r (random)]) #t) #t #f))`. It's slightly more general so it will make smaller a few additional expressions like `(if (let ([r (random)]) #t) 0 1)`.

Also, I found and fixed a bad interaction between two of the reductions. The problem was that in this example, it recognized the test condition as an expression with a `#f` as a result, and then it reduced

```
(if (begin (random) #f) 1 2) 
  => (if (begin (begin (random)]) #f) #f) 1 2)
  => (begin (begin (random) #f) 2)
```

This behavior is actually documented (though I also thought it was a strange behavior when I first read these docs):

> [Reference](http://docs.racket-lang.org/reference/stxtrans.html#%28def._%28%28quote._~23~25kernel%29._prop~3arename-transformer%29%29)
> If the property value is an integer, the target identifier is extracted from the structure instance; if the field value is not an identifier, then an identifier ? with an empty context is used, instead.

Thank you for finding these helpful test cases!

The code is in this other repo, however: https://github.com/racket/gui/blob/master/gui-lib/scribble/private/indentation.rkt

Oh, but I don't agree about this example:

```
#lang scribble/lncs

@emph{Some more
 text}
```

I think this is the correct indentation. Consider this example:

```
@paragraph{This is me typing some stuff and then I want two @bold{bold
 words}. I don't want the "word" to appear way right.}
```

Oh derp...facepalm. Sorry, for some reason I thought I was in that repo. Oh well, thanks anyway.

As for your third example, I guess that's fair. It also looks like the semantics of at-expressions are also what I would hope for. (Namely, it doesn't put a space before the `word` on the second line.

Although I should point out that the default auto-indent for the expression you posted there is different then what you posted. Namely, by default it is:

```
@paragraph{This is me typing some stuff and then I want two @bold{bold
  words}. I don't want the "word" to appear way right.}
```

Because you are it two nested at-exps when that happens. While I absolutely agree that this is a nice thing to have it format that example like that, It does feel like this to me:

```
(quote (this is a sentence that (is built
  entirely using) quote))
```

On the other hand, I guess you could make the argument that this might be what you want if you were building strings. So fair enough.

Actually, after thinking about it a bit more, I'm okay with the indentation you used. (Obviously with one extra space).

Oh wait: I did it wrong. You're absolutely right that two spaces is what it is currently intended to do.

It does that for different examples, basically because it can't tell if it has a function like @bold or if has something where one generally doesn't treat it as part of a paragraph, but instead writes things like:

```
@function1{
 @function2{
  some stuff
 }
}
```

PS: I think it's great that someone looks more closely at that code. There is a good set of test cases, so I'm optimistic that we won't regress :)

I think you know way better than me, @97jaz ! 

But as I read over your message and think about it, I'm struck by how much of these issues are the same ones that the pkg system is aiming to solve too.

Just in case you weren't aware, there is some support for scripting package creation and maintenance, like this: http://docs.racket-lang.org/pkg/lib.html

I'm not sure there is support for uploading and modifying the pkg system at the Racket level, but maybe that's something that @jeapostrophe would consider adding? Or maybe it's there and I just don't know about it?

Just a general comment about the syntax (that is, what the reader reads, not the semantics): it is generally intended to be accomodating for all kinds of tex-like uses, which is why Robby's `@bold` example is indented properly.  But in general, there is obviously difference between those kind of things, and things like `@defproc`, so a full indentation might actully depend on the semantics of the actual form that gets used.

Also, in case it wasn't obvious, since this is generally similar to tex variants, Emacs can be used for comparisons and inspiration too...  (In one of its tex/latex/infotex modes.)

So far, the indentation mode for the at-reader has managed to avoid special casing things in the way that the Racket-mode indentation hasn't (it looks at keywords (without considering their lexical content)). 

Since we have the chance to establish an indentation mode that doesn't require this, I thought it best to try so we don't have to suffer with bad indentation like this:

```
#lang racket
(let ([steps '(begin
                middle-bits
                end)])
  (for ([step (in-list steps)])
    (printf "I'm doing the ~a step!\n" step)))
```

I don't understand the question. Uploading and modifying the pkg system? Do
you mean scripting the catalog we run? It does have a fairly simple JSON
REST API (grep define-jsonp on
https://github.com/racket/pkg-index/blob/master/official/dynamic.rkt) but
there is not yet any pkg/etc module that exposes it.

On Sat, Feb 13, 2016 at 8:18 PM, Robby Findler notifications@github.com
wrote:

> I think you know way better than me, @97jaz https://github.com/97jaz !
> 
> But as I read over your message and think about it, I'm struck by how much
> of these issues are the same ones that the pkg system is aiming to solve
> too.
> 
> Just in case you weren't aware, there is some support for scripting
> package creation and maintenance, like this:
> http://docs.racket-lang.org/pkg/lib.html
> 
> I'm not sure there is support for uploading and modifying the pkg system
> at the Racket level, but maybe that's something that @jeapostrophe
> https://github.com/jeapostrophe would consider adding? Or maybe it's
> there and I just don't know about it?
> 
> —
> Reply to this email directly or view it on GitHub
> https://github.com/racket/racket/issues/1220#issuecomment-183785825.

## 

Jay McCarthy
Associate Professor
PLT @ CS @ UMass Lowell
http://jeapostrophe.github.io

```
       "Wherefore, be not weary in well-doing,
  for ye are laying the foundation of a great work.
```

And out of small things proceedeth that which is great."
                          - D&C 64:33

@jeapostrophe That's one question: whether I can write s script to upload packages to the package server. It looked looks like I should be able to do that. Another issue is that we're talking about a _lot_ of packages; just how many depends on the exact way of splitting up the CLDR data that I eventually adopt, but we're talking hundreds or (maybe) thousands.

The other question has to do with the feasibility of managing locale data if a locale's data is split among multiple packages. See my previous message for details. If it's not clear, I'll be happy to restate it in more detail. (One thing I want to make clear, since it sounds like both @samth and @rfindler seem to think that I'm considering side-stepping the package system, is that neither of my proposals do that. In both cases I'm talking about using standard Racket packages.)

Personally, I think one-package-per-locale is better than a finer-grained solution where you have to specify (and thus know) much more. We already have issues with people specifying pkg dependencies accurately, and I worry that overly fine-grained dependencies would make it worse. 

Yes, that's what I think too.

Yeah, I know...  And I do think that it's probably not going to be as bad if the indentation rules ignore the command part -- if only because the rules that people might have can vary much more in scribble than in code.  So it's kind of a suggestion thing, to-be-adjusted by the author anyway, rather than what you get in racket code where diverging from the indentation is much more often a bad idea.

Perhaps the package catalog UI could use some support for collapsing multiple packages into one UI element? for instance `foo`, `foo-lib`, `foo-doc`, and `foo-test` all showing up as one `foo` row which expands upon clicking into multiple entries. Then tons of locale packages would be far more manageable from a UI perspective.

Note: the CI failures in "modprot" are due to the mismatch between the old "zo-lib" package (as updated by the PR in the "compiler" repo) and these changes.

Looking at this, the last two lines look to me like:

```
(define-opt/c (f) (begin <do-some-stuff> (f)))
(f)
```

Why should this terminate?

(I agree it terminates in 6.3 (and I believe you about 6.4), but that seems like the bug? --- is this a backwards-compatibilty-based argument?)

On the backwards-compatibility front, the chaperone benchmarks from our OOPSLA paper no longer run correctly. 

Here's a direct copy-and-paste from the code accompanying that paper (the "binomial-heap-contract.rkt" file). It has the same infinite loop (and the comment about the contract being wrong is in the original).

``` racket
#lang racket

(define-struct h:kons (hd tl) #:transparent)
(define-struct h:node (rank val obj children) #:transparent)

(define-opt/c (binomial-tree-rank=/scon r v)
  (or/c #f
        (struct/dc h:node
                   [rank (=/c r)]
                   [val (>=/c v)]
                   [children (rank val) #:lazy (heap-ordered/desc/scon (- rank 1) val)])))
(define-opt/c (binomial-tree-rank>/scon r)
  (or/c #f
        (struct/dc h:node
                   [rank (>=/c r)]
                   [val any/c]
                   [children (rank val) #:lazy (heap-ordered/desc/scon (- rank 1) val)])))
(define-opt/c (heap-ordered/desc/scon rank val)
  (or/c #f
        (cons/c (binomial-tree-rank=/scon rank val)
                (heap-ordered/desc/scon (- rank 1) val))))
(define-opt/c (binomial-trees/asc/scon rank)
  (or/c #f
        (cons/c (binomial-tree-rank>/scon rank)
                (binomial-trees/asc/scon -inf.0)))) ;; this contract is wrong

(define binomial-heap/scon (binomial-trees/asc/scon -inf.0))
```

I guess the question is whether we screwed this up in the paper, or if there's now a bug.

Note that we didn't actually include the numbers from this variant in the results we presented.

Which paper are you talking about?

The OOPSLA 2012 paper on chaperones. The file I mention is in the zip file you can download here: https://www.cs.umd.edu/~sstrickl/chaperones/index.html

Ah. I think it is safe to say that I agree with the comment "this contract is wrong". Here's a shorter program that behaves differently in 6.3 and git head:

```
#lang racket/base
(require racket/contract)
(define-opt/c (binomial-trees/asc/scon)
  (cons/c any/c (binomial-trees/asc/scon)))
(void (binomial-trees/asc/scon))
```

I'll keep poking around to get more clarity.

It appears that the change was because `opt/c` believes it cannot tell that something is going to be a chaperone contract, so it generates some code to check and that code triggers the infinite loop in the program.

This program is still incorrect (in that it doesn't loop):

```
#lang racket/base
(require racket/contract)
(define-opt/c (binomial-trees/asc/scon)
  (binomial-trees/asc/scon))
(void (binomial-trees/asc/scon))
```

and `opt/c` seems to have decided that it knows that it is a chaperone contract.

Also, I'm curious what the worst design flaw is, now that the second-worst is going away. :)

@samth: ".c"

The revised commit fixes a problem that disabled closure conversion in some cases.

I have thought about this some more and I am not seeing how to implement `define-opt/c` in a way that correctly handles programs that loop like this (in the sense that `define-opt/c` behaves like `define`, except it improves performance for functions that return contracts). I could just be missing something, but for now I'm inclined to say that this code is buggy and we now have a better response to it and to update the documentation for `define-opt/c`.

Does that seem ok?

Are you proposing to change my examples to not loop, your latest example to loop, or leaving everything as is? 

What do you think we should do about the code for the paper? Ask @sstrickl to update that zip file to take out the now-infinite loop?

I am proposing to change the implementation not at all (at least until I figure out a way to change it) but to document this flaw in the current implementation.

As for the code in the paper, I could try looking into providing a revised version of it that actually checks that contract correctly. Would you like me to do that?

Since that code isn't really relevant to the paper, just taking it out seems like the right choice. Do we still have that paper etc in version control somewhere?

I can't recall!

Well, let me know if you find the code and I'll try to take a look at making a version that works properly.

The code is all in the zip file here: https://www.cs.umd.edu/~sstrickl/chaperones/index.html

I'll let you know if I find the version control.

```
sstrickl@liverpool:~/papers/chaperones {➋➀} $ git remote -v
origin  git-plt:sstrickl/papers/chaperones (fetch)
origin  git-plt:sstrickl/papers/chaperones (push)
```

So it's on the old internal git server.

Thanks. I went and looked at the code and sure enough, it says right there:

```
;; this doesn't work because the cons/c aren't lazy
```

And yes, I think I agree with that comment.

So I don't know what else we should do. Remove it, I suppose.

In any case, this is now officially off of my "TODO" list. :)

Right, I think we should just remove all traces of that case in the benchmark, and then update the .zip file.

The URL is malformed. The correct URL is: https://travis-ci.org/racket/racket/jobs/87703589#L1730-L1776

@mflatt This should be closed.

This is still an issue. The URL parser should look for square brackets. There are currently no pull requests involving the URL parser. The string->url function is defined [here](https://github.com/racket/racket/blob/e6a0caa1471820ae1f8a76985858b197a35763a3/racket/collects/net/url-string.rkt). I'll try and see if I can learn enough racket to fix it, but I'm still rather new to the language.

It's like meeting an old friend after five years ...

I'm still reading here and there, but I like the changes. It's nice to see that all the offsets and deltas disappeared.

I only found that three lines are not necessary: [optimize.c#L4192-L4194](https://github.com/mflatt/racket/blob/72b5206f67b492d03738cf757d3395e9fec0758e/racket/src/racket/src/optimize.c#L4192-L4194)

The link to Wikipedia should be in the source code.

We currently have a mass upload API that is restricted to package curators,
we could open it up a little. However, the normal API should be adequate
for your needs, it just needs to be Racket-ized a bit.

Jack: That's a good idea, would you like to try it out as a purely UI
thing? The Javascript should hopefully be readable.

On Sun, Feb 14, 2016 at 12:12 AM, Jack Firth notifications@github.com
wrote:

> Perhaps the package catalog UI could use some support for collapsing
> multiple packages into one UI element? for instance foo, foo-lib, foo-doc,
> and foo-test all showing up as one foo row which expands upon clicking
> into multiple entries. Then tons of locale packages would be far more
> manageable from a UI perspective.
> 
> —
> Reply to this email directly or view it on GitHub
> https://github.com/racket/racket/issues/1220#issuecomment-183822739.

## 

Jay McCarthy
Associate Professor
PLT @ CS @ UMass Lowell
http://jeapostrophe.github.io

```
       "Wherefore, be not weary in well-doing,
  for ye are laying the foundation of a great work.
```

And out of small things proceedeth that which is great."
                          - D&C 64:33

Added [wiki link](https://github.com/racket/racket/pull/1242/files#diff-607ab65a73af9b2046acf4cfbb443282R624)

This info.rkt file also causes DrRacket to issue internal errors, with an identical message.

Link to PR: https://github.com/racket/net/pull/8

As an outsider fellow user, unfamiliar with the codebase: it feels bad that tests are in another repo, but I'm not familiar enough with the codebase to judge this. But that's certainly not your responsibility.

I've added some comments on the PRs themselves — I'm sure this needs more test. (Again, as an outsider fellow user).

Just another nitpick, there is a typo in the title of the commit: repeRsentation -> repResentation

@Blaisorblade It does not, in fact, match IPv6 addresses in the previous implementation. The capture for hosts excludes the ability of having a colon in the host name, which is required for IPv6.

Yeah, I should use the | operator in regex. I had forgotten it existed; still a little new to all of this. I'll update the PR tonight.

@Blaisorblade Yes, it's unfortunate that some of `net` is in this repo, and some in `racket/net`, and that therefore either the tests have to be split up, or some of the implementation is separate from the tests.

Perhaps there's a better compromise here to be found -- I'm open to suggestions.

> @Blaisorblade It does not, in fact, match IPv6 addresses in the previous implementation. The capture for hosts excludes the ability of having a colon in the host name, which is required for IPv6.

I meant that the regexp from the RFC does match IPv6, unlike the code. The previous code explains the mismatch:

> the user@host:port is parsed here

Parsing that needs to find the `:` separating the host and the port, hence the change, which is only correct for IPv4 but not IPv6.

@samth I moved the discussion to #1245, since it shouldn't block this PR.

@Blaisorblade I'm not sure I follow. Are you saying that I need to put more stuff in my PR to recognize ipv6, or are you just commenting on why the current implementation is the way it is?

First, it continues to be important to have test packages, so that code using `net/url` doesn't need `rackunit`. However, that doesn't meant that we couldn't have the tests for the part of `net` in this repository couldn't be in the `racket-test` package, which is in this repository (and has the same dependencies).

I'd like to have @mflatt's perspective, since he originally created the split between the core and `net-lib`, which led to this.

Sorry.

> are you just commenting on why the current implementation is the way it is?

Yeah. The point is, that might help to figuring out how to best change it.

In particular: could you please update the comment to match the new code?

> Are you saying that I need to put more stuff in my PR to recognize ipv6

Not necessarily. But we do need more tests to know this actually recognizes IPv6.

Alright. I'll do both those things tonight. Thanks for clarifying ^w^

> First, it continues to be important to have test packages, so that code using net/url doesn't need rackunit

Makes sense, I see. Other systems deal with this by having separate _test_ dependencies — but that's yet another discussion, and even if you liked that it's a nontrivial infrastructure change.

Agree on everything else :+1: 

I just pushed something that seems to do it.

I think that `shift_fuel` and similar can be removed. They are defined in [optimize.c#L76](https://github.com/mflatt/racket/blob/optimizer/racket/src/racket/src/optimize.c#L76) and [optimize.c#L102](https://github.com/mflatt/racket/blob/optimizer/racket/src/racket/src/optimize.c#L102).

They are copied multiple times from one to another, but they are never used for something interesting now.

Unrelated to this specific pr, just playing around with the optimizer. Would it make sense to optimize (binary) `=` to `eq?` for some cases?

@stchang : I think I added that last week, see [optimize.c#L3875](https://github.com/racket/racket/blob/master/racket/src/racket/src/optimize.c#L3875)

It changes `=` to `unsafe-fx=` when the optimizer knows that both arguments are fixnums. It is not posible to do this if one argument isn't known, because `=` may rise an error.

For example

```
(lambda (s) (= (string-length s) 0))  ==>  (lambda (s) (unsafe-fx= (string-length s) 0))
```

@gus-massa Ah nice, ok, makes sense.

Since the latest version passes tests and benchmarks, I plan to merge it (as a squashed commit) tomorrow.

What about something like

```
(check-equal? (number? (equal-hash-code (tuple 5)) #t)
(check-equal? (equal-hash-code (tuple 5)) (equal-hash-code (tuple 5)))
[...]
```

and perhaps also these additional tests that may fail if you re unlucky

```
(check-not-equal? (equal-hash-code (tuple 5))) 0)
(check-not-equal? (equal-hash-code (tuple 5)) (equal-hash-code (tuple 6)))
[...]
```

Perhaps you can piggyback a change: `start_simltaneous --> start_simUltaneous`.

I think that `optimize_info_lookup` still does too many things, but the new code is much shorter than the previous, so it will be easier to refactor. (In particular, I'm thinking about splitting the `register_use_at` at the last line, but I still have to think about the details...)

LGTM :)

Looks good – thanks!

Note that http://drdr.racket-lang.org/34007/pkg-src/build/make has two other warnings for possibly-uninitialized variables -- they looked ok to me, but I wasn't sure what the best way to silence the warning was.

@samth If you'd like to fix those, I think the right changes are https://github.com/mflatt/racket/commit/6961c3734adacca735d18d102988990e467a49fc

Why have whole new functions for, e.g., upcasing immutable strings. Why not add an `#:immutable?` keyword argument to existing functions? That would also remove the need for a dedicated library.

Re: `#:immutable?` keyword argument:
Since functions like `string-upcase` are provided by the kernel, and the kernel doesn't support keyword arguments, I don't think that would work. I guess there could be a module somewhere below `racket/base` that re-defined them and delegated to the old versions ... would that be better than this?

That's the usual strategy -- see the keyword-accepting IO functions, for example.

reproducible with:

```
~/sw/plt/racket/src/build/racket/racket3m  -l  redex/examples/delim-cont/randomized-tests -- --seed 1743146354 --rules 2250 --size 3
```

Unfortunately the log gets truncated when it crashes, but it's at https://gist.github.com/d92d7318cb6f2e57e133

Ah nice. I forgot you can still use the original hash argument. 

I haven't looked at the changes in detail, but why do you need the extra `1` flag between the indices, ie, cant you just keep masking and shifting by 5 until you get 0?

More:
- `make_syntax_compiler` -> `make_primitive_syntax`
- `scheme_syntax_compiler_type` -> `scheme_primitive_syntax_type`

Each index is between 0 and 31 (both extremes inclusive). The flag is necessary to distinguish between 

```
(#hash 0 #hash 3)  -->  (+ (<< 0 6) (<< 1 5) 3) = 35
(#hash 3)  --> 3
```

I was copying the previous implementation blindly ... I didn't think too much about this, so I'll think out loud: 

In both cases, `scheme_unsafe_hash_tree_next` goes to `(#hash 2)` or if it's necessary to `(#hash <count> #hash 2)` or deeper if needed, so for this function they are equivalent.

The difference is in `scheme_unsafe_hash_tree_key/value/...`. In `(#hash 3)` they just read whatever is in the third slot, but in `(#hash 0 #hash 3)` it takes the tree that is in the third slot and reads it's zeroth slot. One possibility is to add a check of `(HASHTR_SUBTREEP(ht->els[i]) || HASHTR_COLLISIONP(ht->els[i]))` to all this functions, but I think that the current implementation with the flag is easier.

With the current proposal that use 5+1 bits, we could group up to 5 levels in a fixnum in all platforms. Without the flag we could group up to 6. Anyway, I think that it's better not to add support for more levels, because the I don't see any improvement and I expect that at some point it will be worst to go from the original hash that using the last subtree.

I can try to implement the version for the next level and see if there is an improvement in the hash with 1000 elements. I guess that when the hashes are big the structure is unpredictable and this additional deep will not help too much.

Would we lose information by collapsing the first three to `lambda`? As in, are the current distinctions useful?

More:
- `Scheme_Let_Header` -> `Scheme_IR_Let_Header` (since it's IR-only)
- `SCHEME_COMPILED_CLOS_CODE` -> `SCHEME_CLOSURE_CODE`
- `SCHEME_COMPILED_CLOS_ENV` -> `SCHEME_CLOSURE_ENV`
- `..._CLOSURE_DATA_FLAGS` -> `..._LAMBDA_FLAGS`

@stamourv No, they're all synonyms for "lambda" in different namespaces (type tag, function name, and data structure)

Sounds good then!

You are right, thanks. I was not accounting for the 0 case.

More:
- `CLOS_...` -> `LAMBDA_...` (e.g., `CLOS_IS_METHOD`)

- `Closure_Info` -> `Scheme_IR_Lambda_Info`

Also change the `closure_map` field of `Scheme_Lambda` to be a union with a new `ir_info`, which points to a `Scheme_IR_Lambda_Info`.

> Maybe define `#defines` for these constants?

I agree, but I can't find where is defined the original `32`. Where is it?

I had a hard time finding it as well. I believe it's `mzHAMT_LOG_WORD_SIZE` and `mzHAMT_WORD_SIZE` in hash.c.

https://github.com/racket/racket/blob/master/racket/src/racket/src/hash.c#L2402

I have to think about this, now I only have a no-example. One that always bothers me is:
- `scheme_eq_prim` ->  `scheme_eq_proc`
- `scheme_eqv_prim` ->  `scheme_eqv_proc`
- `scheme_equal_prim` ->  `scheme_equal_proc`

I think they are named in this way since historic time and are in the public API. Is it possible to define an alias for internal use? Something like

```
#define scheme_eq_proc scheme_eq_prim
```

in schpriv.h

Good idea – and `scheme_values_func` -> `scheme_values_proc`. These are not in the public API, and changing them should be fine.

Oops – I didn't meant to push that just yet. I guess it was ready enough, anyway.

I tried using `simple-form-path` but it doesn't actually remove trailing slashes on directory names. I suppose another solution is to change the regexp in the helper (say, to require at least one character before the slash) but I worry there are more corner cases.

I agree that the regexp-based path manipulation is bogus. (I never noticed that function.)

Digging back through the history at https://github.com/jeapostrophe/galaxy, it appears that the slash-removal was added to make `file-name-from-path` work to get the package name, but I think that wasn't the right choice, either, and it's not how things are parsed now. So, maybe the right repair is to get rid of `directory-path-no-slash`?

@gus-massa @stchang I think part of the problem is that anything that relies on the representation of a hash-table variant was originally meant to be in "hash.c", while "list.c" combined those variants with generic operations and Racket primitives. That's why `mzHAMT_WORD_SIZE` is defined only for "hash.c".

I also tried getting rid of the slash removal too (by taking out that let expression there) but one of the package update tests fail. Basically it fails to detect that an update with the same package and checksum should be a no-op, because in one case the path has a slash and doesn't in the other. Probably this can be fixed, but I didn't investigate too closely yet.

My next guess: normalize via `path->directory-path` (which makes the slash always there, instead of trying to remove it).

I tried @mflatt's suggestion to add `path->directory-path`, but I added it to `desc->orig-path` instead and took out the normalization in the staging code entirely. This now passes all the tests.

(I would like to add a test for `raco pkg install -n foo /` but I'm not sure there is a good way to test that without using chroot)

This was merged already.

I added the next two levels, and for my surprise the time of the benchmarks decreased (except for the hash with 1000000 elements that is too big and needs more levels). The code was very repetitive, so I reimplemented it using real loops instead of the hand unrolled version. The final version has too many changes, so I rebased and squashed all of them.

Following the suggestions, I created a function `scheme_unsafe_hash_tree_subtree` to reconstruct the tree from the arguments. I put it in "hash.c" so it can use the constant `mzHAMT_LOG_WORD_SIZE`. I marked it as `XFORM_NONGCING`, is that correct? I'm happy with this because now all the logic to save and load the subtrees is very close in case someone wants to improve it.

One detail that I don't like is that this functions takes a `Scheme_Object *` as first argument to extract the tree from a chaperones, but the other functions use a `Scheme_Hash_Tree *` and the chaperone logic is in "list.c". It's a small inconsistency I don't like.

I created a new internal constant `mzHAMT_MAX_INDEX_LEVEL` in "hash.h". It regulates the longest lists that are compressed to fixnums. I finally defined it as `4` because it the maximal number that guaranty that the result enters in a fixnum in 32 bits. For some of my tests, it was useful to change it to `2`, to get small examples of hash that need the index represented as a link. I'm slightly worried that this code will be not tested under normal circumstances.

[Suggestions about better names are welcome.]

Presumably some large test hash tables will exercise the code you're worried about?

The easy solution is to add the case of a hash with `1000000` elements in [pkgs/racket-test-core/tests/racket/hash.rktl](https://github.com/racket/racket/blob/master/pkgs/racket-test-core/tests/racket/hash.rktl) . I just added it. But I estimate that each test adds .1 seccods, and it has many tests with each hash. (I think it's good to have keep the small `10` test to use other code paths. I added the `100`, `1000`, `10000` because they are almost free.)

One alternative solution is to keep the current test in core, and add the bigger test in a new file [pkgs/racket-test/tests/racket/hash-big.rkt](https://github.com/racket/racket/blob/master/pkgs/racket-test/tests/racket/hash-big.rkt)

If there is some structure to this repetitive code, could you think of
designing a little Racket language and a compiler from it to (a small
subset of) C? Then you could control which sizes are the special ones and
you could design the code in such a way that it is unlikely to have a bug
in a large table unless there is also a bug in a small table?

> why do you need the extra 1 flag between the indices?

Sorry, still thinking about this. Could you use only 1 bit overall instead of 1 bit between each index? 

Specifically, add `1 << (mzHAMT_LOG_WORD_SIZE * level)` before returning the index.

And then when extracting the indices, you could do `while(i)` instead of `while (i & (1<<mzHAMT_LOG_WORD_SIZE))`.

I merged this change, but with an extra flag on duplicated `lambda`s to prevent the infinite-loop problem.

The problem happens because inline-fuel decrements affect only more nested expressions, and the outer call for `((proc))` is not nested in the inner one. The new flag on `lambda`s causes the outer application to see a function that, despite being a literal `lambda`, it doesn't count as single-use.

:)

I'll send my idea to burn less fuel with small functions in few days.

@rfindler : It was a straightforward repetition, like:

```
i1 = something(i0)
i2 = something(i1)
i3 = something(i2)
i4 = something(i3)
```

where `something` was actually a few lines of code with `if`s and some logic, so I replaced it with

```
#define MAX 4
for (n =0; n < MAX, n++)
  i[n+1] = something(i[n])
```

I initially expected that `MAX` will be `2` or `1` or `3`, so it was easier to cut and paste, especially because the first and last case are special. But if `MAX` is `4` it becomes a bad idea.

## 

The code is doing a depth first traversal of the internal representation of the hash, and saves the "stack" in a `list` to implement the `start/next` operations and be able to continue the traversal later. Here I'm replacing the `list` with local `C` variables to avoid allocating the list in the `C` heap, and the result of the `start/next` operations is an encoding of the values in the bits of a fixnum.

So the internal storage are very different and I think it's not possible to make a code that automate this. Moreover, the transition from variables to list is very error prone, and I have to fix it many times. (The transition from list to variables is also problematic, but am I only using the simplest case, that is when the traversal goes to the upper node. For this aplication, it's enough and easy to implement.) 

For testing, I changed the value of the constant `MAX`, so the transition from the short representation to the long representation is with hashes of a few hundreds or thousand of elements, so it's easy to test. With `MAX=4` the transition is with hashes of about one millon elements. (It depends on the internal details and collisions, so the number is only an aproximation.)

@gus-massa Could you create a custom hash table, or a struct with a custom hash function, to generate more collisions and thus test the code with fewer elements?

I'm don't know too much of the details of the hashs, perhaps @stchang or @mflatt can build an example of a table with more problems. Perhaps they can use as keys an `struct` with a very bad election of `gen:equal+hash`?

I think this structure will always collide, no matter what instances you give it: 

```
(struct x (a)
  #:property prop:equal+hash
  (list (λ _ #f) (λ _ 1) (λ _ 1)))
```

Is that what you need?

With this bad hashing function, all of them go to the first slot in the first node of the tree. So it's like reducing one level in the test. So probably the `1000000` case would be enought, if all those structs don't use too much memory. 

(But I'm thinking about @stchang idea to reduce the flags, this can add room for an aditional level. I'll try a litle and reply later.)

The error message says exactly what the problem is... the regexp you put in
had an error. What did you expect?

On Sat, Feb 20, 2016 at 3:53 PM, Asumu Takikawa notifications@github.com
wrote:

> Here's an example that should produce a nicer error message:
> 
> $ raco pkg show --rx +
> Installation-wide:
> regexp: `+' follows nothing in pattern
>   context...:
>    /home/asumu/plt/racket-git/racket/collects/racket/private/list.rkt:103:2: memf
>    /home/asumu/plt/racket-git/racket/collects/pkg/private/show.rkt:30:4: for-loop
>    /home/asumu/plt/racket-git/racket/collects/pkg/private/show.rkt:13:0: pkg-show15
>    /home/asumu/plt/racket-git/racket/collects/racket/contract/private/arrow-val-first.rkt:401:3
>    /home/asumu/plt/racket-git/racket/collects/racket/file.rkt:378:8
>    /home/asumu/plt/racket-git/racket/collects/racket/file.rkt:367:0: call-with-file-lock42
>    /home/asumu/plt/racket-git/racket/collects/pkg/main.rkt:406:13: for-loop
>    (submod /home/asumu/plt/racket-git/racket/collects/pkg/main.rkt main): [running body]
>    /home/asumu/plt/racket-git/racket/collects/pkg/raco.rkt: [traversing imports]
> 
> —
> Reply to this email directly or view it on GitHub
> https://github.com/racket/racket/issues/1251.

## 

Jay McCarthy
Associate Professor
PLT @ CS @ UMass Lowell
http://jeapostrophe.github.io

```
       "Wherefore, be not weary in well-doing,
  for ye are laying the foundation of a great work.
```

And out of small things proceedeth that which is great."
                          - D&C 64:33

The explanation is good, but we shouldn't be reporting error messages from the internals of the implementation to the user.

It's not the implementation. The error is with the regexp, which is what it
says

On Sun, Feb 21, 2016 at 3:44 PM, Sam Tobin-Hochstadt <
notifications@github.com> wrote:

> The explanation is good, but we shouldn't be reporting error messages from
> the internals of the implementation to the user.
> 
> —
> Reply to this email directly or view it on GitHub
> https://github.com/racket/racket/issues/1251#issuecomment-186911683.

## 

Jay McCarthy
Associate Professor
PLT @ CS @ UMass Lowell
http://jeapostrophe.github.io

```
       "Wherefore, be not weary in well-doing,
  for ye are laying the foundation of a great work.
```

And out of small things proceedeth that which is great."
                          - D&C 64:33

Are you saying it should call `regexp` sooner and pass in the compiled
regexp?

On Sun, Feb 21, 2016 at 3:45 PM, Jay McCarthy jay.mccarthy@gmail.com
wrote:

> It's not the implementation. The error is with the regexp, which is what
> it says
> 
> On Sun, Feb 21, 2016 at 3:44 PM, Sam Tobin-Hochstadt <
> notifications@github.com> wrote:
> 
> > The explanation is good, but we shouldn't be reporting error messages
> > from the internals of the implementation to the user.
> > 
> > —
> > Reply to this email directly or view it on GitHub
> > https://github.com/racket/racket/issues/1251#issuecomment-186911683.
> 
> ## 
> 
> Jay McCarthy
> Associate Professor
> PLT @ CS @ UMass Lowell
> http://jeapostrophe.github.io
> 
> ```
>        "Wherefore, be not weary in well-doing,
>   for ye are laying the foundation of a great work.
> ```
> 
> And out of small things proceedeth that which is great."
>                           - D&C 64:33

## 

Jay McCarthy
Associate Professor
PLT @ CS @ UMass Lowell
http://jeapostrophe.github.io

```
       "Wherefore, be not weary in well-doing,
  for ye are laying the foundation of a great work.
```

And out of small things proceedeth that which is great."
                          - D&C 64:33

No, I'm saying that it should check if the regexp is valid, and `raco pkg show` should produce the error.

A different way of putting it is that if `regexp` had a contract, the contract error would blame the `raco pkg show` implementation, and thus the `raco pkg show` implementation should be fixed.

I was thinking about a more evil list of keys. After skiming over the code and some time minimizing the initial idea, I got this:

```
(define evil (for/list ([j (in-range 1 3)])
               (arithmetic-shift j (* 6 5))))
(define old (map (lambda (x) (cons x (number->string x))) evil))   
(define h (make-immutable-hash old))
```

The hash code are different, but they colides at all the first levels, so the internal tree is very deep.

I'll try to cleanup it and add it to [pkgs/racket-test-core/tests/racket/hash.rktl](https://github.com/racket/racket/blob/master/pkgs/racket-test-core/tests/racket/hash.rktl)

Looks good to me. A test added to "pkgs/racket-test-core/tests/racket/foreign-test.rktl" would make it even better.

Thanks for the report! I've pushed a repair as https://github.com/racket/gui/commit/be30bf721d4d6782c6fba4feeacd7c471b875157

I think it would make sense to give the handler the string describing the problem with the given string, so that tools like `raco pkg show` can report it back to the user.

The thread-local variables are not great, but they're consistent with the way things are implemented now. The `regerrorproc` and `regerrorval` hold a GCable values, so they need to be registered (once per place) with `REGISTER_SO`, like `regparsestr`.

This looks like the right strategy to me.

Fixed in 619ef41f7df83cda0e5.

Unfortunately, this fix changes the behavior of the source column as well. Looks like larger changes to the `table-display` function are needed to fix this correctly.

The table limits the display to 80 in long mode. The checksum is 41 characters. That gives 39 for everything else, including spacing and all that. I think the output is ridiculously un-useful. If you have such strong feelings about it, do whatever you'd like.

In that case, we should take out the `--full-checksum` option, instead of making it just an alias for `--long`.

Long doesn't show it all either

Jay

On Monday, February 22, 2016, Sam Tobin-Hochstadt notifications@github.com
wrote:

> In that case, we should take out the --full-checksum option, instead of
> making it just an alias for --long.
> 
> —
> Reply to this email directly or view it on GitHub
> https://github.com/racket/racket/issues/1252#issuecomment-187214781.

## 

Jay McCarthy
Associate Professor
PLT @ CS @ UMass Lowell
http://jeapostrophe.github.io

```
       "Wherefore, be not weary in well-doing,
  for ye are laying the foundation of a great work.
```

And out of small things proceedeth that which is great."
                          - D&C 64:33

So should the documentation for `--full-checksum` say that it implies `--long`?

It could

On Mon, Feb 22, 2016 at 9:53 AM, Sam Tobin-Hochstadt <
notifications@github.com> wrote:

> So should the documentation for --full-checksum say that it implies --long
> ?
> 
> —
> Reply to this email directly or view it on GitHub
> https://github.com/racket/racket/issues/1252#issuecomment-187216665.

## 

Jay McCarthy
Associate Professor
PLT @ CS @ UMass Lowell
http://jeapostrophe.github.io

```
       "Wherefore, be not weary in well-doing,
  for ye are laying the foundation of a great work.
```

And out of small things proceedeth that which is great."
                          - D&C 64:33

Looks like `#:saved-errno 'posix` doesn't work on Windows. Shouldn't it?

@stchang : Sorry for the delay I was testing your idea of using only one flag, and I think I have a version of it, but it still has a small bug.  I had to use `while(i >= (1 << (mzHAMT_LOG_WORD_SIZE * 2)))` instead of `while (i)` because the last value of `i` is the position in the internal array. I feel that this new repreentation is slighty faster than my representation, but the difference is small (2% or 3%) and I didn't have enought patience to measure it carefully. I'll finish this and send an update.

The not so good new is that with this representation is not posible to increase the number of levels stored in a fixnum in 32 bits, because they only have 30 bits + 1 sign bit. If we compress a list of 6 levels and the stop bit, it would use `6*5+1=31` bits. And I am not confident that `SCHEME_INT_VAL(scheme_make_integer(1<<31))` does the right thing. So this change doesn't increase the `mzHAMT_MAX_INDEX_LEVEL` constant.

I also tried to add some test with almost-collisions, so the hash has to use a deeper representation. I get some segfaults (in window, 32 bits) in the master branch. I guess it's a problem with the weak hashes when one of the elements is garbage collected at the wrong moment, but I'm not sure. I made a branch with the additional tests in case you want to take a look [gus-massa/16-2-W-Hash-Error](https://github.com/gus-massa/racket/tree/16-2-W-Hash-Error) (See: [Travis](https://travis-ci.org/gus-massa/racket/jobs/111002075#L1711), [AppVeyor](https://ci.appveyor.com/project/gus-massa/racket/build/1.0.405#L3327) )

I updated the commit with the new representation that uses only one flag, some tests an some tweaks in `scheme_unsafe_hash_tree_start`.

Thanks. I'll fix it. I probably introduced the bug when I tried to abstract all the definitions into a macro.

Hmm, actually I'm confused. 

The fallback is the same for all the sequences because it falls back to the generic `hash-iterate-` functions. 

I guess the behavior is still wrong, since `in-immutable-hash-` suggests that it should error when given a non-immutable hash, but I'm not seeing where it could segfault. Do you have an example?

With the outer check of the `for`, this code:

```
(define h (make-hash '(1 . 2)))
(for ([v (in-immutable-hash-values h)])
  (display v))
```

is effectively equivalent to 

```
(define h (make-hash '(1 . 2)))
(unless (and (hash? h) (immutable? h))
  ;let the default version generate the error
  (default-in-immutable-hash-values h))
(for ([v (unsafe-in-immutable-hash-values h)])
  (display v))
```

With some hashes, the code runs anyway. I got error using the wrong combination of hash and iterator in [PR/hash.rktl#L221](https://github.com/gus-massa/racket/blob/548de61c85bcecd63a6dfeb6894a18457bb2a0ad/pkgs/racket-test-core/tests/racket/hash.rktl#L221)

I think this is an issue with `string->url`:

```
> (url->string (string->url "git://github.com:takikawa/taglib-racket.git"))
"git://github.comtakikawa/taglib-racket.git"
```

At a minimum, I think the URL regexp mistakenly allows zero digits for a port number, instead of requiring 1 or more digits. It's possible that clients of `string->url` also need to be more careful about accepting a result URL that has #f for the `path-absolute?` field.

Ok, I didnt realize the sequence continues when the outer check fails. I thought it was wrapped around everything. The right thing to do then is to throw the exception immediately when the outer check fails. I'll push a fix.

I think it' better the current behaviour because it get consistent error messages for free. Probably most of the other sequence use this method.

Sorry, I didnt fully understand. You think we should not throw the exception immediately, but continue to let the fallback generate the exception?

Yes, I think it's better that only the fallback generate the exception. For example `in-vector` does that [for.rkt#L906](https://github.com/racket/racket/blob/master/racket/collects/racket/private/for.rkt#L906).

I rebased this over the two major changes, and now it's compiling without error over HEAD. I squashed the changes to rebase mere easily, but the questions are still there.

Ok I see. `in-range` does this as well. I will make the modification.

I like it. @samth, you happy?

Awesome, thanks @bennn.

cool :)

Looks good to me.

I need to change my name and email in the commit. Doing so now. Please don't merge until I get a chance to.  :-)

I need to change my name and email in the commit. Doing so now. Please don't merge until I get a chance to.  :-)

Also, looks like I mistakenly removed a couple parens in closures.c. I'll replace those once I fix my commit info.

Hi @mmcco – I just took a look at your changes for the first time. I'm happy to remove Racket-specific code for OS/2. The "libffi" and "gc" directories are really third-party libraries, though, and I think it makes less sense to remove code there.

Ok finally fixed this. It took longer than expected because I had to refactor the macros to get the err msgs right (and ran into some macro-defining-macro debugging fun). But I think the code is cleaner as a result.

Oh, right. This was my first time working with the Racket codebase, so I didn't notice. All of the instances were in libffi or gc, so I'll close this PR.

I'm not sure if the second sentence helps without an example. Maybe better to delete it?

I like it.

(Oh, and I checked with a 6.2.1 I had lying around, and saw the same bug, so it's been around for a while.)

LGTM
Please close PR15251 when you push.

Switched to use a margin note and merged.

Frustratingly, this goes away with the JIT off.

Hi Quartz,

You want to look at the second argument to read-line:

http://docs.racket-lang.org/reference/Byte_and_String_Input.html?q=read-line#%28def._%28%28quote._~23~25kernel%29._read-line%29%29

There are lots of examples including ones directly about your kind of
workload.

Jay

On Fri, Feb 26, 2016 at 4:26 AM, Quartz Li notifications@github.com wrote:

> This is a simple test (using Racket v6.1):
> 
> #lang racket
> 
> (when (file-exists? "test.txt")
>   (delete-file "test.txt"))
> 
> (define out (open-output-file "test.txt"))
> (display "abc\rdef" out)
> (close-output-port out)
> 
> (define in (open-input-file "test.txt"))
> (read-line in)
> (read-line in)
> (close-input-port in)
> 
> (delete-file "test.txt")
> 
> It returns:
> 
> "abc\r"
> "def"
> 
> If change (display "abc\r\ndef" out) to (display "abc\rdef" out), it
> returns:
> 
> "abc\rdef"
> #<eof>
> 
> —
> Reply to this email directly or view it on GitHub
> https://github.com/racket/racket/issues/1267.

## 

Jay McCarthy
Associate Professor
PLT @ CS @ UMass Lowell
http://jeapostrophe.github.io

```
       "Wherefore, be not weary in well-doing,
  for ye are laying the foundation of a great work.
```

And out of small things proceedeth that which is great."
                          - D&C 64:33

Sorry, I should read the documentation before open an issue.

merged :tada: 

Merged

merged :tada: 

Merged, thanks!
https://github.com/racket/racket/commit/bc99eb0eef51a96f627cf15d018b4b8b0902982e

Thanks for the report!

@stchang JFYI: Looking back at this commit, it looks like you took "new functions in 'schpriv.'h" to mean that all functions should be moved there. It's not backwards-compatible to move functions out of "schemef.h", though, because it means that they functions are not necessarily accessible to embeddings, extensions, or FFI uses. Although that level of compatibility is not super-important in practice, I think the old functions probably should have stayed in "schemef.h", and I will investigate moving them back.

Along similar lines, I think #1248 moves toward restoring the split between implementation details in "hash.c" and Racket interface in "list.c". I imagine moving even more back in that direction.

One concrete thing that went wrong is `hamt_popcount()` as an non-static function. All non-static bindings are supposed to start with `scheme_` (to avoid potential collisions at the level of C linking). That rule probably isn't written down anywhere, and I'll start writing down things like this in the "README" file.

This is ready to merge, right?

The first commit looks good to me.

I wasn't able to construct example to expose the change in the last commit.

Ok sorry for the misunderstanding. I'll try to stick to the conventions in the future.

Adding them to the README would be good. I'll try to think of other things to add if that would be helpful. Relatedly, another thing I wasn't sure about is the flags on primitives. Are these written down somewhere?

For example, what is the difference between between `UNSAFE_OMITABLE` and `UNSAFE_FUNCTIONAL`? From what I can tell `OMITABLE` is used for references to mutable data structures, while `FUNCTIONAL` is for immutable data structures?

Right: a reference to a mutable data structure is itself omittable, since it has no side-effects, but it doesn't always give the same answers for the same inputs. So, unsafe-functional implies unsafe-omittable, but not vice versa.

I think those descriptions are best written next to the flag definitions.

I've added comments for the `SCHEME_PRIM_` flags, to be pushed later.

I think so. 

Do I rabase and merge this now?

Yes

I put `SCHEME_LAMBDAP` there and in a few more places. If this pass the test I'll rebase and merge.

Just another small question about the name of the new function: `optimize_info_lookup_closure` or `optimize_info_lookup_lambda`?

`..._lambda`, since it's about the expression form, as opposed to a value.

Makes sense, thanks!

Sorry, one more question @mflatt. 

My use of the `FUNCTIONAL` flag for mutable hash `-iterate-first` and `-iterate-next` is wrong?  eg, 
https://github.com/racket/racket/blob/master/racket/src/racket/src/list.c#L896

I find it hard to evaluate this change. Do you have some programs where this revised heuristic improves performance? Does it have any effect on the traditional benchmarks (in "common")?

Nope, just gut feelings. I'll try the benchmarks ...

FWIW
https://github.com/soegaard/racket-highlight-for-github

Contains the grammar (and the program used to make it) used for Racket on Github. The grammar was tested on Sublime but I think it can be used in Atom as well. 

/soegaard

> Den 1. mar. 2016 kl. 16.45 skrev Alex notifications@github.com:
> 
> The Racket language package for the increasingly popular Atom text editor is extremely old, and hasn't been updated in over a year. I and several others have opened issues trying to fix it, but the otherwise-active maintainer is completely ignoring us and neglecting the package. I'd fork it myself and try to claim the package on https://atom.io/packages, but I'd rather see this done in a GitHub organization where the package can be maintained (and PRs accepted) by a large community of fellow Racket users, and where there's thus much less chance that it will be abandoned again (hey, I take GitHub hiatuses sometimes).
> 
> So, Racket should fork (or clone and push as a new repo) the https://github.com/vito/language-racket and host it in this organization.
> 
> As a follow-up, I'd probably begin sending regular PRs to that repo to update it with various Racket grammar fixes as I run into them.
> 
> Note: I couldn't find a repository for "GitHub-organization-wide" issues, so I've opened this here.
> 
> —
> Reply to this email directly or view it on GitHub.

I think the best thing to do here would be for you to create a fork or a new repository which Atom recognizes as official, and then we could adopt that repository into the organization or add the @plt user as a committer, or something else like that.

I got this semi-articficial case:

```
With differential fuel burning:
  cpu time: 30295 real time: 31214 gc time: 0
With constant fuel burning:
  cpu time: 40342 real time: 41069 gc time: 0
```

Program: It's a variation of [collatz-q.sch](https://github.com/racket/racket/blob/master/pkgs/racket-benchmarks/tests/racket/benchmarks/common/collatz-q.sch)

```
#lang racket/base
(require racket/unsafe/ops)

(define (cycle-even n)
  (unsafe-fx+ 1 (cycle-length (unsafe-fxrshift n 1))))

(define (cycle-odd n)
  (unsafe-fx+ 1 (cycle-length (unsafe-fx+ 1 (unsafe-fx* 3 n)))))

(define (unsafe-fxodd? n)
  (unsafe-fx= 1 (unsafe-fxand n 1)))

; Max value for 32bits, but divided by 10 to get some warnings
(define almost-outside-fixnum 100000000)

(define (cycle-length n)
  (when (unsafe-fx> n almost-outside-fixnum)
    (displayln n))
  (cond
    [(unsafe-fx= n 1) 1]
    [(unsafe-fxodd? n) (cycle-odd n)]
    [else (cycle-even n)]))

; modify to get a rutime of half a minute
(define repetitions 1000)

; keep this constant so all the numbers are fixnums
(define bigest-case 10000)

(time (let loop ([r 0] [t #f])
        (if (unsafe-fx= r repetitions)
          t
          (loop (unsafe-fx+ r 1)
                (let loop ([i 1] [v #f])
                  (if (unsafe-fx= i bigest-case)
                    v
                    (loop (unsafe-fx+ i 1)
                          (cycle-length i))))))))
```

Idea/history of the modifications:
- split the main function into many smaller functions to burn fuel unnecesarily
- use `unsafe-fx` so the time differences look bigger
- segfault???
- Add a `displayln` to try to understand where is the problem.
- I know the Collatz conjeture, but the sequence was more unexpected than what I expected (Obligatory xkcd: https://xkcd.com/710/ )
- Reduce the number so it enters in a fixnum
- Add a second loop to get a run time of 10-20 secconds.

After this, I only added a name and explanation for each constant. I didn't modify the code to increase the difference, so it's posible to get a higer ratio.

@samth Do you mean that the old version of the package depended on something that's no longer in the catalog, and the new version doesn't (and that should work)? Or that even a new version of the package, if any, depends on another package that can't be found (in which case I don't immediately see an alternative to failure)?

Removing the configurations from "sconfig.h" would be ok with me. I don't think the configuration is particularly in the way, though, and it's at least possible that a record of things that worked in the past would be useful to someone in the future.

Or maybe you originally had in mind some code in "gc" and/or "libffi", which we concluded (in #1261) should be left alone.

It appears that I misdiagnosed the error: it's actually that I had the `xdr` package installed from a catalog, and it's no longer available on any catalog, so the issue isn't a dependency.

I think in this case `raco pkg update -a` should just skip updating `xdr` and continue (otherwise it's harder to use and doesn't compose well with tools like `make`).

I'm reluctant to make `raco pkg update -a` always ignore catalog failures, but I think it could make sense to add a `--skip-on-catalog-fail` flag and use it in `make`.

That seems like a reasonable compromise.

(Low content comment for now.)

Not sure if it's related, but I'm still getting segfaults after a few minutes of an infinitely expanding macro.

I can reliably reproduce but not with a small example so I will keep working on it.

I've half implemented this, and after thinking about it more, I don't think it would be a good idea to add `--skip-on-catalog-fail` to the makefile.

The problem is that there are many ways for things to go wrong, and quiet failure (even if some printout means that it's not entirely silent) will be a bad idea most of the time. Many bad states will be indistinguishable from a package name being not registered at a catalog; normally, automation built around package updating should fail if any of its service dependencies go wrong.

I think a more reliable approach would be a way to mark a package installation as "frozen". Operationally, updating would treat the installed checksum of a frozen package always as the current checksum for that package. If you want to have something installed by name that is not provided by the current set of catalogs, or if you want to install from a remote package source that will later go away, then you can switch the package to frozen mode.

Besides providing a solution to the immediate problem, I think the notion of a frozen package could be useful for other purposes. It's possible to implement freezing from the outside by updating a package installation to point to a local copy as its source, but adding specific support for freezing an installation looks easy, useful, and more clear to have as an explicit feature.

On the one hand, I agree with you that mostly-silent failure is a bad idea.

On the other hand, this is a failure in the default `make` target for Racket, which requires some non-trivial hacking (even if there's a way to mark a package as frozen) to fix. 

My opinion is still that updating arbitrary packages in the default `make` target is the wrong default, but given that it's the default, I think it should be more resistant to failure. If this was about `make update-all` then I'd agree entirely.

@mflatt Thanks you for fixing the bug, now I can instrument binaries generated by raco.

What version of Racket does arc currently use? I can't seem to reproduce the problem with a recent version (>= 6.1) of Racket.

Racket 6.2 on Ubuntu Wily 64-bit.

The number of max characters before hang is slightly higher in **arc** than in **racket**, maybe because the function name `len` is shorter than `string-length`. In fact, the length of the expression that causes the hang is 4096 in both **racket** and **arc**. Maybe **racket** has a problem parsing expressions with a length of 2^12 or above ?

Ok thanks. Does it also hang if you run it as a program, or only with the repl? Also, are you using xrepl?

It only fails in the REPL. And in the REPL it works after running `(require xrepl)`.

Ok I realized I had xrepl installed as well when I was doing my prior experimentation. If I turn off xrepl, interestingly I cannot type more than 4096 chars.

6.2 switched from using libreadline to libedit. I wonder if that's related to this issue.

I understand your position that `make` would be better as an alias for `make as-is` instead of `make update-all`. I don't agree, but it seems like a reasonable position.

Given that `make` does mean `make update-all`, and given that we agree on mostly-silent failure as a bad idea for `make update-all`, it seems like we should agree that adding `--skip-on-catalog-fail` to `make` would be a bad idea.

It seems possible that there's a third default for `make` that you have in mind, but I don't see what that third point might mean in general. We seem to agree that "update unless there's a problem with the catalog" wouldn't be a good general meaning.

I think it's probably a terminal issue. This link may help:

http://stackoverflow.com/questions/18015137/linux-terminal-input-reading-user-input-from-terminal-truncating-lines-at-4095

Useful with the **xrepl**; fixes the problem for **racket**. Can't start an **arc** REPL with **xrepl**, but that is an **arc** issue, I guess.

Merged, thanks!
8039a759f4724606e0aea689ef4c458d55bb74cc

A few thoughts:
1. The default `make` target shouldn't put users in a position where they have to work hard to fix their system.
2. Silently (or almost-silently) erroring is a bad idea, unless someone asks for it explicitly. 

I don't, given those preferences and the current defaults, have a definitive better suggestion than the current defaults. 

Other possibilities (that I'm not really suggesting): prompt the user, skip the update step but run `raco setup`, maybe something else.

I need a fix for this bug. I changed the compiler for the OpenBSD port to GCC 4.9 because I would like to enable places and futures for the architectures with JIT support. I'm holding off the update to 6.4 due to this bug. If you can't fix it just tell me and I will disable places and futures for this architecture.

I'm unsure of how exactly to fix this right now, but I do believe I found the root cause.

In [file.c](https://github.com/racket/racket/blob/master/racket/src/racket/src/file.c#L4540) at the definition of `do_resolve_path`, the behavior of the internal variable `expanded` isn't working as intended (it seems). Here's my understanding of what's happening:
- [`expanded`](https://github.com/racket/racket/blob/master/racket/src/racket/src/file.c#L4547) is declared as an int (and is uninitialized)
- a reference to [`expanded`](https://github.com/racket/racket/blob/master/racket/src/racket/src/file.c#L4559) is passed to [`do_expand_file`](https://github.com/racket/racket/blob/a0f7b618f7f201b9f2299afc7f41c91a7995a9fd/racket/src/racket/src/file.c#L1852)
- the very first statement in `do_expand_file` [sets the value the reference to `expanded` is pointing to to 0](https://github.com/racket/racket/blob/a0f7b618f7f201b9f2299afc7f41c91a7995a9fd/racket/src/racket/src/file.c#L1857)
- [a reference to `expanded` is passed to `remove_redundant_slashes`](https://github.com/racket/racket/blob/a0f7b618f7f201b9f2299afc7f41c91a7995a9fd/racket/src/racket/src/file.c#L1955), which will set the value [`expanded` is pointing to](https://github.com/racket/racket/blob/a0f7b618f7f201b9f2299afc7f41c91a7995a9fd/racket/src/racket/src/file.c#L1844) to 1 [_iff_ there are extra slashes](https://github.com/racket/racket/blob/a0f7b618f7f201b9f2299afc7f41c91a7995a9fd/racket/src/racket/src/file.c#L1827).
- back to `do_resolve_path`, there is again a [check on `expanded`](https://github.com/racket/racket/blob/master/racket/src/racket/src/file.c#L4620), and at this point there seems to be two possible situations:
  1. The path has no extra slashes, which means `expanded` is 0.
  2. The path has extra slashes, which means `expanded` is 1.

In the first situation, the `if` statement will be true (`!0` is truthy), which means the value passed to `resolve-path` will be returned unchanged (which, then, means that currently `(resolve-path "/foo/bar/baz")` is the same as `(identity "/foo/bar/baz")`). In the second situation, the `else` branch will be taken, which will then return the correctly-"pathified" value.

So the quick fix (with minimal testing) is to remove that branching and just use the [`else` branch](https://github.com/racket/racket/blob/master/racket/src/racket/src/file.c#L4623) for a return statement. But clearly this is not the right way to fix this problem. It seems as though this whole file situation got a bit complicated and now the behavior doesn't really make sense. I'm not sure how to fix it or what to try to simplify or abstract or what.

More interestingly, when calling `resolve-path`, if the string (or path) given to it _does_ have extra slashes, the behavior is correct (I think). So in your example, you could do:

```
> (resolve-path "//usr/share/zoneinfo")
#<path:/usr/share/zoneinfo>
```

This is a very silly and hacky "fix," but if you need this to work and don't want to use `string->path` for some reason, just add a bunch of slashes!

I intend to try to "decomplect" this further, but I don't expect to gain much ground. Maybe someone smarter than me can use this information to fix this error.

Note: I noticed that in this case the call to `do_expand_file` (on Unix-like systems, anyway) from `do_resolve_path` actually only calls `remove_redundant_slashes` because of the parameters passed to it. I don't know what all should be changed, and my C is very very bad.

This looks good to me.

> Is it important/intentional that setting these flags was lost in the case of list_? Maybe list_ is replaced by values somewhere else?

I think that with `list*` those flags are setted automatically, so I think it was not necessary to set them again. But `values` doesn't set them because it not true when it has more than one argument. I´ll set them for both functions anyway.

It makes sense that the flags are already set for `list*` – so, whichever variant you think is best is fine with me.

@harrisi Thanks for the analysis! I think the solution in this case is to check whether the argument was a string (as opposed to a path), and not return the argument in that case. I'm running a build with that change, and I'll push it if things work out.

(The only problem I can imagine is that some existing code might accidentally rely on the old behavior of returning a string.)

Thanks for the report, but I haven't been able to replicate this problem – even when I set up "scrib_test" and "mod.rkt".

I wonder if the program above is the one you were running, or maybe you meant to paste a different program?

hmm, I double checked and don't see any discrepancies (it really is just two lines). I'm using racket 6.4.0.12 FWIW.

I don't see the problem either, as a standalone file or inside a `scrib_test` package.

There are two parts to this. First, the order of the parameters. Second, the behavior of `set-map`.

First:

It does seem unfortunate that the signature for `set-map` is opposite of other `*-map` functions, but it seems consistent with other `set-*` functions (such as `set-for-each`). At this point, it seems like a bad idea to change it to swap the two parameters. I don't think there's any solution or change necessary for this.

Second:

`set-map` returning a list may be better off returning a set, but I don't know the best way to go about this. Internally, it seems like [`set-map` is really](https://github.com/racket/racket/blob/master/racket/collects/racket/private/set.rkt#L456) just [calling `map` through `list-map`](https://github.com/racket/racket/blob/master/racket/collects/racket/private/set.rkt#L46)*. I don't know if this is undesired behavior, however. Perhaps it should wrap the returned list in a call to `set`, but, again, it's a bit late for that. If that's the behavior needed, one can just do `(set (set-map (set 1 2 3) add1))`, as much as that might seem superfluous.

*: The actual code running in this case might be [`fallback-map`](https://github.com/racket/racket/blob/master/racket/collects/racket/private/set.rkt#L218); I'm unsure, but they both have the same behavior.

Note: if the difference in order for the various `*-map` functions is frustrating, use of the [generic collections package](https://docs.racket-lang.org/collections/index.html) might be helpful, although there is some behavior changes.

It is unfortunate that the various collections functions in Racket are confused, but it’s worth noting that this behavior isn’t even specific to sets. The `hash-map` function frustratingly always produces a list, especially annoying given that it is often reasonable to simply want to map over values. Less obviously wrong but perhaps even more dangerous due to its subtlety, `vector-map` will always produce mutable vectors even when the input vector is immutable.

The ship has unfortunately sailed on the consistency of Racket’s current collections APIs. It is something that should almost certainly be thoroughly reassessed whenever such an overhaul is possible, but currently, the APIs are probably doomed to be a little rough in places.

I won’t plug the generic collections package too hard, given that I am its author, but if you are frequently feeling this kind of pain, give it a look: it was more or less specifically designed to accommodate this kind of problem.

This is indeed inconsistent, but it's not something that can change at this point, since we don't want to break code that uses any of these functions. I agree with @lexi-lambda that the best way forward is to build new libraries with nicer interfaces, and use them in new code you write.

I think the primary implementation should have the fixed name, so that error messages and printouts have the right name.

Maybe I'm misunderstanding, but this does have that behavior, doesn't it?

```
> (julian/scalinger->string '())
julian/scalinger->string: contract violation
  expected: exact-integer?
  given: '()
  in: the 1st argument of
      (-> exact-integer? string?)
  contract from: <collects>/racket/date.rkt
  blaming: top-level
   (assuming the contract is correct)
  at: <collects>/racket/date.rkt:22.2
  context...:
   /Users/ian/dev/racket/racket/collects/racket/contract/private/blame.rkt:156:0: raise-blame-error16
   /Users/ian/dev/racket/racket/collects/racket/contract/private/arrow-val-first.rkt:363:18
   /Users/ian/dev/racket/racket/collects/racket/private/misc.rkt:87:7
> (julian/scaliger->string '())
julian/scaliger->string: contract violation
  expected: exact-integer?
  given: '()
  in: the 1st argument of
      (-> exact-integer? string?)
  contract from: <collects>/racket/date.rkt
  blaming: top-level
   (assuming the contract is correct)
  at: <collects>/racket/date.rkt:23.2
  context...:
   /Users/ian/dev/racket/racket/collects/racket/contract/private/blame.rkt:156:0: raise-blame-error16
   /Users/ian/dev/racket/racket/collects/racket/contract/private/arrow-val-first.rkt:363:18
   /Users/ian/dev/racket/racket/collects/racket/private/misc.rkt:87:7
>
```

Also, sorry about the merge being added to this pull request. I don't know what can be done about that. I really am a lot worse with git than I realized.

Ah, the contract changes the name of the procedure, so my worry is moot.

It seems like the problem is that it doesn't highlight contract violations, but other errors are correctly highlighted. For example:

```
#lang honu
1 + x
```

x is highlighted (unbound identifier error), but if it's just a contract violation (such as your example), there is no highlighting. I have no idea how to fix this. I am not sure where such highlighting or error reporting or what would live in Honu/DrRacket.

Although not specifically related to this error, I propose this issue is moved to the [racket/honu](/racket/honu) repository to go along with racket/honu@e0967c070f27e7afcc44d81dc4970baceb8f5c6c

I had some trouble installing 6.0.1 (on Fedora, which is relevant below), but 6.4 seems fine.

On @mflatt's note, I did run into a similar error as this (as well as #769) due to running out of either memory or storage space (I ran into both). In both cases, Racket itself built fine but raco wasn't fully made. However, increasing both the memory and the storage resolved errors. Without more information on OS and racket version, I don't know how much more could be done with this issue.

EDIT: Also #832

On Fedora 23 trying to compile 6.1-src-builtpkgs leads to this error (for me):

```
ranlib libracket.a
make[5]: Leaving directory '/home/ian/racket-6.1/src/racket'
make[4]: Leaving directory '/home/ian/racket-6.1/src/racket'
make racketcgc 
make[4]: Entering directory '/home/ian/racket-6.1/src/racket'
gcc -I. -I./include -g -O2  -Wall   -pthread   -DINITIAL_COLLECTS_DIRECTORY='"'"`cd ./../../collects; pwd`"'"' -DINITIAL_CONFIG_DIRECTORY='"'"`cd ./../..; pwd`/etc"'"' -c ./main.c -o main.o
gcc -o racketcgc main.o  libracket.a libmzgc.a  -pthread -ldl -lm  -ldl -lm -rdynamic 
make[4]: Leaving directory '/home/ian/racket-6.1/src/racket'
make[3]: Leaving directory '/home/ian/racket-6.1/src/racket'
cd gc2; make all
make[3]: Entering directory '/home/ian/racket-6.1/src/racket/gc2'
mkdir xsrc
make xsrc/precomp.h
make[4]: Entering directory '/home/ian/racket-6.1/src/racket/gc2'
env XFORM_PRECOMP=yes ../racketcgc  -cqu ./xform.rkt --setup . --cpp "gcc -E -I./.. -I./../include -pthread    "  --keep-lines -o xsrc/precomp.h ./precomp.c
mprotect for generate-code page failed; aborting
mprotect for generate-code page failed; aborting
mprotect for generate-code page failed; aborting
mprotect for generate-code page failed; aborting
Makefile:202: recipe for target 'xsrc/precomp.h' failed
make[4]: *** [xsrc/precomp.h] Segmentation fault (core dumped)
make[4]: Leaving directory '/home/ian/racket-6.1/src/racket/gc2'
Makefile:172: recipe for target 'all' failed
make[3]: *** [all] Error 2
make[3]: Leaving directory '/home/ian/racket-6.1/src/racket/gc2'
Makefile:95: recipe for target '3m' failed
make[2]: *** [3m] Error 2
make[2]: Leaving directory '/home/ian/racket-6.1/src/racket'
Makefile:57: recipe for target '3m' failed
make[1]: *** [3m] Error 2
make[1]: Leaving directory '/home/ian/racket-6.1/src'
Makefile:51: recipe for target 'all' failed
make: *** [all] Error 2
```

However, I can install Racket 6.4 just fine on Fedora 23 (provided I have enough memory and storage).

This should be closed thanks to racket@8615b2b6fcc88fd27562867afb3168300412a39f, I believe.

I don't know if I can run RHEL7, but it seems like this can be closed (based on @samth's last comment). Racket 6.4 works fine for newer versions of Fedora, and I can only hope this would hold true for RHEL.

I have no idea, but I don't really have the time to track or solve this. Sorry. :-(

This issue was moved to racket/honu#17

Moved!

This was a bug in TR, which has been fixed, so closing this is the right thing.

Seems like this should be handeld by the `DIRENT_NO_NAMLEN` configure variable, but I guess it didn't find it correctly.

Given the lack of feedback, and the successful build of 6.4, I'm closing this.

Merged, thanks!

I think this belongs on this repo? https://github.com/racket/redex

You're right, my mistake. I'll move it over.

Thanks!

Disclaimer: I don't know much of anything about anything.

I'm interested in this because I can get this to type check with a default argument, but I don't understand how I would use that or how it could be well-typed. I can't possibly call that and use the default value (unless I call it with the default value anyway) and have it still be well-typed.

``` racket
(: foo (All (A) (-> (Real -> A) Boolean (Listof A))))
(define (foo f [b #t])
  (list (f 0.1) (f 0.2)))
```

This type checks just fine, but I still have to call it with two arguments:

```
> (foo add1 #t)
- : (Listof Real)
'(1.1 1.2)
> (foo add1)
. Type Checker: Polymorphic function `foo' could not be applied to arguments:
Wrong number of arguments - Expected 2, but got 1

Argument 1:
  Expected: (-> Real A)
  Given:    (-> Number Number)
Argument 2:
  Expected: Boolean
  Given:    -none-
 in: (foo add1)
```

I very well may be missing something, but without having an additional type or struct involved (see: [Haskell](http://stackoverflow.com/questions/7781096/is-there-a-better-way-to-have-optional-arguments-in-haskell), [Racket](http://stackoverflow.com/questions/10871275/how-do-you-initialize-a-struct-with-default-values-in-typed-racket), [more Haskell](http://neilmitchell.blogspot.com/2008/04/optional-parameters-in-haskell.html)), I don't see how I can have the function application adhere to the type you defined.

So in conclusion, I think the error message given is a bit odd, but also I think that the expected behavior isn't well-defined in this issue.

@mflatt, Matthias suggests this is your bailiwick. Would you like me to make a pull request, or would you prefer to try out the change in your own repo, or some combination of the two?

@tonyg, there's a branch in this repo that has the history back to the beginning if you want to investigate. But I bet the code was added in a big commit with the message ".". :)

Thanks, Sam! I checked: and yes, it cropped up with message ".". The `frexp()` based hash function is the second floating-point hash function Racket had for equal?-tables; the first was based on `((long *)&d)[0]`. The equal?-hashing code for floats was committed initially in August 2001.

;;--

It's interesting that the frexp() algorithm gives bad results for close-together large floats, and OK results for close-together smaller floats, while the just-take-the-bits algorithm (which I tried before reaching for the "fasthash" hack) gives good for large floats and bad for small.

@tonyg Do values like 0.0, -0.0, and +nan.0 need to be handled specially?

(Gradually paging this back in... I think the answer is "no" for zeros but "yes" for +nan.0.)

Just looking at `double_eqv`, and testing `(equal? (- 0.0) 0.0)`, it looks like negative zero is expected to be different to positive zero, which is covered by the bit-pattern comparison in the proposed new hash function. Regarding NaN, though, it looks like any two NaNs are expected to compare equal (!) so yes, looks like a NaN special case is needed.

Perhaps simply leaving `v==0` on NaN would do the trick:

``` c
XFORM_NONGCING static uintptr_t dbl_hash_val(double d) 
  XFORM_SKIP_PROC
{
  /* Customized special-purpose fasthash variation */
  const uint64_t m = 0x880355f21e6d1965ULL;
  uint64_t h = (16 * m);
  uint64_t v = 0;

  assert(sizeof(double) == sizeof(uint64_t));
  if (MZ_IS_NAN(d)) {
    /* do nothing -- leave v==0 as a special hash code for any NaN */
  } else {
    memcpy(&v, &d, sizeof(d));
  }

#define mix(h) ({                   \
      (h) ^= (h) >> 23;                 \
      (h) *= 0x2127599bf4325c37ULL;         \
      (h) ^= (h) >> 47; })
  h ^= mix(v);
  h *= m;
  return mix(h);
#undef mix
}
```

Yes, I think this will work. There are some details to make it work with MSVC and probably other old compilers, but just local changes.

Reassuringly, it looks like getting the bytes and using Racket's byte-string hash function works just as well in terms of collisions, but using 64-bit numbers is a little faster.

Here's a small reproduction recipe:

```
#lang racket            
(require racket/place)
(define c2 (place c (eprintf "starting\n")
                  (dynamic-require 'typed-racket-test/succeed/mandelbrot #f)
                  (eprintf "done\n")
                  (place-channel-put c #t)))
(module+ main
(sync c2)) 
```

Running this program segfaults about 1 in 10 times.

Note that I did get this to segfault (less often) with `#:no-optimize`, so it's unlikely to be a TR bug.

I had to use a GC stress mode to provoke a crash, so I'm not sure I'm seeing the same one as you. Commit 0b7c8e0b2efc fixes the crash that I saw. Does it improve things for you?

It still seems to crash for me, but less often. I've gotten it to happen twice.

How many "starting"s do you see in your runs?

I see about 4 on OS X on a 2-core+hyperthreading machine. In my 2-core Linux VM, I see about 10 before the program runs out of memory (since the example is a fork bomb).

I see 4 or 5 on my 8-core linux machine, but it never runs out of memory, and I thought the `main` module was making it not a fork bomb.

Also, when I took TR out of the mandelbrot file, the extra "starting" goes away.

You can make it not be a fork bomb by putting `place` inside a function called from `main`. (But how many "starting"s did you expect?)

Can you tell how much memory is being used at the crash point?

For a non-fork bomb example, `racket -l typed-racket-test/main --int` provokes the crash much more consistently for me.

I've captured this crash in RR, and the stack trace etc still looks the same as in the first comment.

Oh, and I only expected 1, and it only produces 1. But that may just be the startup time overhead of TR allows the fork bomb to get going.

It's hard to tell the memory at the crash point externally -- all of rr with gdb is using about 785 MB right now. But if there's a command I can run gdb to check, I can do that.

I haven't been able to replicate the crash on my machines. It may depend on timing details or the number of available processors. Any next suggestions?

That definition looks correct to me. Am I missing something?

It should recur, no?​ That definition is okay for BSL. But maybe it is just
not well-named instead of being wrong? Is there a problematic use?

As fas as I know, it's unused, so there are no bugs here.

I wanted to use it, but I was not sure if it existed, and I found this definition.

The problem is that it doesn't distinguish between proper and improper lists.

```
(SCHEME_LISTP (cons 1 2)) ;==> #t
```

 but I expect it to be `#f`

 The actual C code is somemething like this (I didn't test this, so it may not compile!!!)

```
 Scheme_Object* test()
 {
   if (SCHEME_LISTP(scheme_make_pair(scheme_make_integer(1),
                                     scheme_make_integer(2))) {
     return scheme_true;
   } else {
     return scheme_false;
   }
 }
```

I think that the correct definition is 

```
#define SCHEME_LISTP(obj)     scheme_is_list(obj)
```

This function is used in all the other places. But I'm worry that it's not posible to change this because this definition may be backward compatible with the old times when pairs were mutable. (Perhaps we can add a comment.)

@robby: Ah, yes. I knew I was missing something. :)

Writing programs that use `syntax-local-lift-expression` don't seem to have this problem, which makes me think it's likely a bug in the contract `dict` is using, rather than a bug with `racket-mode`.

Namely, the following program does not seem to have the same behavior:

```
#lang racket

(define-for-syntax lifted-value #f)

(define-syntax (foo stx)
  (syntax-case stx ()
    [_ (begin
         (unless lifted-value
           (set! lifted-value (syntax-local-lift-expression #'42)))
         lifted-value)]))

foo
```

Sounds good. Probably easiest to leave it as-is for now.

This looks generally good to me.

I don't have a strong opinion on whether to export `list-pair?`. I would probably leave support for it in the JIT but remove it from the docs and the set of things in `#%kernel` that are exported by `racket/private/pre-base`, but I'm also ok with leaving it as exported by `racket/base` (and documented).

I hide it. 

In optimize.rktl and basic renamed it as `k:list-pair?` to so it's clear that it's defined in the `#%kernel`, but I'm not sure if this is a good idea.

Getting the same error in 6.4-src-builtpkgs on RHEL5:

```
...
raco setup: --- building documentation ---
raco setup: docs failure: sqlite3_clear_bindings: implementation not found; arguments: #<cpointer:sqlite3_statement>
raco setup: --- installing collections ---
raco setup: --- post-installing collections ---
raco setup: post-installing: <pkgs>/gui-lib/mred
raco setup: post-installing: <pkgs>/gui-lib/racket/gui
raco setup: post-installing: <pkgs>/mzcom
raco setup: post-installing: <pkgs>/mzscheme-lib/mzscheme
raco setup: post-installing: <pkgs>/racket-doc/help
raco setup: --- checking package dependencies ---
call-with-file-lock/timeout: contract violation
  expected: (>=/c 0.0)
  given: -1546188227.0
  context...:
   /prefix/share/racket/collects/racket/file.rkt:313:0: call-with-file-lock/timeout33
   /prefix/share/racket/collects/pkg/private/pkg-db.rkt:176:2: for-loop
   /prefix/share/racket/collects/racket/contract/private/arrow-val-first.rkt:335:3
   /prefix/share/racket/collects/setup/private/pkg-deps.rkt:110:2: get-immediate-pkg-info!
   /prefix/share/racket/collects/setup/private/pkg-deps.rkt:238:2: init-pkg-internals!
   /prefix/share/racket/collects/setup/private/pkg-deps.rkt:457:2: for-loop
   /prefix/share/racket/collects/setup/private/pkg-deps.rkt:26:0: check-package-dependencies
   /prefix/share/racket/collects/setup/setup-core.rkt:70:0: setup-core
   /prefix/share/racket/collects/setup/setup-go.rkt: [running body]
   /prefix/share/racket/collects/setup/main.rkt: [running body]
make[2]: *** [install-3m] Error 1
make[2]: Leaving directory `/build'
make[1]: *** [install] Error 2
make[1]: Leaving directory `/build'
```

@mflatt, if you log into my machine, and attach to tmux with `tmux at`, you'll be in an rr session at the abort for the bug.

@samth Do you have a seg-fault error that prints in a non-rr run?

Looks good, and I think importing as `k:list-pair?` for tests is a good idea.

I really don't understand what's going on with this, and I'm not good enough with git to try to narrow down changes that have happened in the last couple releases, but maybe something I say here can help someone smarter than me figure it out.

The line highlighted in DrRacket is the `eval` line. However, if either the `eval` line _or_ the `is-a?/c` line are commented out, there is no error. The order doesn't matter, although if `eval` is after `is-a?/c`, you get the output from `is-a?/c` before the program crashes. The byte code doesn't seem to help too much (not for me, anyway), but that might be because of eval. Without eval expanding, I don't know where to look.

Note: I tried a number of substituted values for both `is-a?/c` and `bitmap-dc%` (using similar values) and they all gave the same error. So I don't think that the problem is something specific to either `is-a?/c`or `bitmap-dc%`. Unfortunately this made it harder for me to snoop around.

I would like to try to narrow down two versions where this does and doesn't happen, although that sounds like a lot of compiling. Maybe there's a quick way to test several commits between each other for this error which would be helpful.

I have no justification for this, but I believe this is related to #1282, and going deeper with one or the other will solve both.

I think it's fine to change the `SCHEME_LISTP` macro. The current macro is misleading, and it's unlikely that any code uses it, much less uses it and expects the bad behavior.

@sk1e Thanks for the report!
@harrisi Thanks for investigating!
The bug was related to some compromises for the (hopeless) top level not lining up as well as they could.

I appreciate the example that speeds up, but none of the benchmarks I've tried speed up without modifications. Meanwhile, the total size of bytecode files in "collects/racket/private" grows by 5% (and I think those sources tend to representative). Since a larger bytecode size tends to have a corresponding effect on run-time footprint, and since the performance benefits so far seem elusive, this change isn't looking like a good direction.

I see this error:

```
C:\projects\racket\racket\src\worksp\gc2>..\..\..\racketcgc -G ..\..\..\..\build\config -cu make.rkt 
C:\projects\racket\racket\collects\racket\contract\private\arr-i.rkt:10:9: module: identifier already imported from: "arrow.rkt"
  at: raise-wrong-number-of-args-error
  in: "arrow-higher-order.rkt" 
  context...:
   standard-module-name-resolver 
   standard-module-name-resolver 
   standard-module-name-resolver 
   standard-module-name-resolver 
   C:\projects\racket\racket\src\racket\gc2\xform.rkt:97:24 
   retry 
   C:\projects\racket\racket\src\racket\gc2\xform.rkt: [running body] 
   C:\projects\racket\racket\src\worksp\gc2\make.rkt:117:8 
error xforming 
  context...:
   C:\projects\racket\racket\src\worksp\gc2\make.rkt:96:0: try 
   C:\projects\racket\racket\src\worksp\gc2\make.rkt: [running body] 
Copying tree...

C:\projects\racket\racket\src\worksp\gc2>if errorlevel 1 exit /B 1 
NMAKE : fatal error U1077: 'C:\windows\system32\cmd.EXE' : return code '0x1'
```

Are there test cases that make sure that the syntax parameter resetting works properly (i.e. functions syntactically inside methods that don't themselves turn into methods)?

I see it in the CI logs, but don't see it on my end. Haven't tried a from-scratch build, though.
I'll try a from-scratch build once I'm done with the rest of the cleanup. Until then, any comments on the code changes proper?

It seems good, just the other comment I made. 

Ah, yes I missed it.
Yes, there are tests that catch that. I'm hoping to get rid of the syntax parameter altogether, though.

@rfindler any thoughts?

I agree that this change should be made. Probably good that someone checks the output, just in case.

I manually checked the output, but double checking wouldn't hurt :smile: 

I'm working in the contract docs right now. Will push this when I push the rest.

For the record:

![screen shot 2016-03-30 at 18 04 29](https://cloud.githubusercontent.com/assets/1731829/14159080/e993551c-f6a1-11e5-8946-703c0cc189ee.png)

Excellent thanks!

I still think that this is useful, especially for code with a lot of small functions. For example functions that are only a thin wrapper or error check of the real function that does the heavy lift.

So I tried the original `collatz` example in `r6rs`and `htdp-advanced` (with minimal changes) and ... the difference is negligible. Probably less than a 5% of the run time, but I'm not sure in which direction because I was too lazy to repeat this until I get a statistically significant result, and it's too noisy to be sure.

So I'll close this, and I'll try again in a few years if I get some new idea.

Merged, thanks!

Merged.

Thanks for the feedback and for merging my pull request.

For the reference, here's the commit https://github.com/racket/racket/commit/05292b7e6926e39ff78b4f9d98dc32013aeca41d.

Best.

Thank _you_ for improving Racket! :)

Sounds reasonable to me. Want to give it a shot?

Merged - thanks!

Sure.

Thanks for raising this issue.

~~Do you know anything about know how other systems that mix libffi (for callbacks) and OS-level threads handle W^X? I wasn't able to find any hints by searching, so far.~~ It looks like `ffi_prep_closure()` has been replaced with `ffi_prep_closure_loc()`.

Can you send me a crash report? (Run "Console", look in "User Diagnostic Reports", and you should see a like that starts "slideshow" or "Slideshow" and the date that it crashed.)

[Slideshow_2016-04-02-104323_skip.txt](https://github.com/racket/racket/files/200884/Slideshow_2016-04-02-104323_skip.txt)

It seems to start up ok (after doing the one-time "unidentified developer" dance) via double-clicking on Slideshow.app, but `slideshow` in Terminal is still SEGVing.

These changes make sense to me.

LGTM

Merged

FYI: I tried to expand the macro and got the following result:

`(match (list 2 2 #t) [(list-no-order asd asd dsa) "Do some stuff"])` expands to:

```
(let
 ((temp1 (list 2 2 #t)))
 (define
  (fail2)
  (match:error
   temp1
   (list (srcloc 'unsaved-editor405 '5 '21 '75 '74))
   'match))
 (let
  parse-loop14
  ((x4 temp1)
   (asd5 null)
   (asd6 null)
   (dsa7 null)
   (rep11 0)
   (rep12 0)
   (rep13 0)
   (failkv15 fail2))
  (cond
   ((pair? x4)
    (let
     ((unsafe-car19 (unsafe-car x4))
      (unsafe-cdr20 (unsafe-cdr x4)))
     (let*
      ((f23
        (lambda
         ()
         (syntax-parameterize
          ((fail (make-rename-transformer (quote-syntax failkv15))))
          (let
           ((x4 unsafe-cdr20))
           (let
            ((dsa10 unsafe-car19))
            (let
             ((dsa7 (cons dsa10 dsa7)))
             (if
              (< rep13 1)
              (let
               ((rep13 (add1 rep13)))
               (parse-loop14
                x4
                asd5
                asd6
                dsa7
                rep11
                rep12
                rep13
                fail))
              (begin (fail)))))))))
       (f24
        (lambda
         ()
         (syntax-parameterize
          ((fail (make-rename-transformer (quote-syntax f23))))
          (let
           ((x4 unsafe-cdr20))
           (let
            ((asd9 unsafe-car19))
            (let
             ((asd6 (cons asd9 asd6)))
             (if
              (< rep12 1)
              (let
               ((rep12 (add1 rep12)))
               (parse-loop14
                x4
                asd5
                asd6
                dsa7
                rep11
                rep12
                rep13
                fail))
              (begin (fail))))))))))
      (syntax-parameterize
       ((fail (make-rename-transformer (quote-syntax f24))))
       (let
        ((x4 unsafe-cdr20))
        (let
         ((asd9 unsafe-car19))
         (let
          ((asd5 (cons asd8 asd5)))
          (if
           (< rep11 1)
           (let
            ((rep11 (add1 rep11)))
            (parse-loop14
             x4
             asd5
             asd6
             dsa7
             rep11
             rep12
             rep13
             fail))
           (begin (fail))))))))))
   ((null? x4)
    (syntax-parameterize
     ((fail (make-rename-transformer (quote-syntax failkv15))))
     (cond
      ((< rep11 1) (fail))
      ((< rep12 1) (fail))
      ((< rep13 1) (fail))
      (else
       (let
        ((asd (car (reverse asd5)))
         (asd (car (reverse asd6)))
         (dsa (car (reverse dsa7)))
         (fail-tail16 fail))
        (syntax-parameterize
         ((fail (make-rename-transformer (quote-syntax fail-tail16))))
         (let () "Do some stuff")))))))
   (else (failkv15)))))
```

As you can see, `asd8` is an unbound id.

Same issue as #562. Also found in [another Racket bug tracker](http://bugs.racket-lang.org/query/?cmd=view&pr=10083).

Merged - thanks!

Is there any issue with mutable toplevels and `scheme_ir_duplicate_ok()` being used by `scheme_ir_propagate_ok()`?

I think there is no direct problem with mutable toplevels, but perhaps I'm missing some case.

For `scheme_ir_propagate_ok()`, I moved `scheme_ir_duplicate_ok()` to the bottom of the function and I added a `return 0;` (in [R5820](https://github.com/racket/racket/pull/1305/commits/a6cd58a95dc0c0c9160875a3c4f3662e46e256e4#diff-5e09d7df9102fa81a4736e357a0c3e1aR5820)) to ensure that all the `scheme_ir_toplevel_type`s are handled by the special case in the `if` and they don't fall through to the `scheme_ir_duplicate_ok()`.

This all looks fine to me, including the third commit.

Ah, ok – looks good to me.

I've worked through a refinement of the `PLTADDONDIR` idea, but I'm currently ambivalent about it. See
mflatt/racket@c3f1805552a0528354ba415d37cb2c3adab8fe18.

That commit adds `raco setup`-level infrastructure to support something like

```
  raco sandbox init
```

which would set up the current directory as a kind of sandbox for further user-scope package installations, etc., and it would create a "bin" directory to hold variants of `racket`, `raco`, etc., that use the sandbox. Instead of relying on a `PLTADDONDIR` environment variable, which would leak to subprocesses and and have to be wrapperd around any use of the sandbox (including launchers created from the sandbox), the generated `racket` would be more directly tethered to the enclosing directory as its addon directory.

I'm ambivalent, because I'm not yet sure the use case is worth the extra support in `raco setup` and related tools. I also know that there are a few more gaps to fill, such as making `find-exe` locate the tethered `racket` and making `raco exe -l` preserve the addon directory, and probably there are other little gaps I didn't think of.

A small number of packages would need to change to cooperate with `raco setup` and addon tethering, because the packages generate executables manually as an installation step. Here's an example: mflatt/gui@d4b90761725f6a5752dccb7fe6c9a16f47f04b25.

> Instead of relying on a `PLTADDONDIR` environment variable, which would leak to subprocesses 

Could you elaborate on why this would be a bad thing? I could imagine a Racket program that shells out to `raco my-custom-command`, or just shells out to `racket` and assumes the existence of the sandbox-installed dependencies, so my first instinct is that I would _want_ that environment to propagate to subprocesses.

@lexi-lambda I think you should fix such a program to use `find-exe` if it wants to run the same Racket as the one running your program. Otherwise, that program doesn't run in a Racket installation that's not in `PATH` or isn't the first one that's in `PATH`.

I suppose that setting environment variables seems bad to me because I'm so frequently working on build tools or shell-like programs that perform externally supplied commands. A shell-like program might be implemented in Racket X, but if it's running commands that say `racket`, then the commands surely intended Racket Y as in my path when I started. In those situations, environment variables don't compose well for the same reason that dynamic binding in general doesn't compose as well as lexical binding.

If someone wants to parameterize a computation with a new `PATH` or `PLTADDONDIR` setting, then that's certainly fine, but `parameterize` should be separate and explicit – perhaps through a `raco sandbox exec` tool.

After thinking about it more, I'm inclined to merge the changes in mflatt/racket@c3f1805 (with a few updates). I think it's probably close enough to the right track to be worth keeping.

> If someone wants to parameterize a computation with a new `PATH` or `PLTADDONDIR` setting, then that's certainly fine, but parameterize should be separate and explicit – perhaps through a `raco sandbox exec` tool.

This makes sense to me. (I think I was imagining that kind of tool, but you’ve made me realize that’s a separate concept.)

@samth Do you want to keep this PR open, or should we close it? The idea of chaining "config.rktd"s still makes sense, and I ended up generalizing tethering in a way that would play well with it, but chaining still looks to me like it would be difficult to work with.

I'm just going to close it -- I wanted the chaining for the sandbox feature that we're moving toward.

This looks like a good change, but "id" and "name" seem redundant in `#:extra-id-name`. How about just `#:extra-name`? Should we also add `#:name` (analogous to `#:constructor-name` and `#:extra-construct-name`)?

@Phlosioneer The discussion gives me the impression that you intend to make more changes. Is that right, or is this pull request ready to be merged in your view? Thanks!

I agree that `filename-extension` should not treat a leading "." as an extension separator, but I worry about backward compatibility. There's also `path-replace-suffix` and `path-add-suffix`, which have the same problem and same compatibility issues.

(Aside: why "extension" versus "suffix"? The root of this mismatch is ancient history and reflected in the function name `add-extension-suffix`. Outside of Racket, he term "extension" seems clearly to be the preferred one.)

One possibility is to introduce `path-replace-extension`, path-add-extension`, and`path-extension` that do the right thing, and then document the old functions as deprecated. How does that sound?

The handling of `'none` is indeed a bug, and I'll push a repair.

I also agree that `open-input-file` should be more clear about failure modes, and in particular that `exn:fail:filesystem` is raised for errors from the filesystem. A complication is that a security guard might get called and that security guard can raise other sorts of exceptions – but that can be documented, too.

Finally, I agree that the `for-module?` argument is ad hoc, but catching exceptions to report a derived error is distressingly tricky. For example, if a security guard has a bug and raises a `exn:fail:filesystem` error, it could be misinterpreted as the originally requested file being missing. That's a general problem, and it would be great to have a general solution. In this case, I was especially worried about misinterpreting exceptions, and (lacking a general solution) I opted for a reliable but highly specialized solution; maybe it wasn't the right choice.

I was never able to replicate this problem. It seems like it might be an issue with the way `racket/gui` initializes the `NSApplication` instance to make the process a GUI process – maybe a race condition in the initialization? I'm stumped for now.

I think the example works as expected when run via `racket`, which uses the default print handler. DrRacket, in contrast, uses a custom print handler. In other words, it's one of those few places where DrRacket intentionally behaves differently for `racket`.

I'll fix the docs, but see also #1307. If we go with `path-add-extension`, probably it should behave more like the documented currently suggests for `path-add-suffix`.

This is an old function, and changing its behavior will likely break things. I think the documentation should explain and wrapping a call in `with-module-reading-parameterization`, so I'll do that.

Very good, thank you.

BTW not to induce mission creep, but why do these functions treat the extension/suffix as a byte string? It seems peculiar when everything else is geared toward Unicode. 

``` racket
#lang racket
(path->string (string->path "foo.λ"))
(filename-extension (string->path "foo.λ"))
> "foo.λ"
> #"\316\273"
```

Unfortunately, paths are not composed of characters in general. On Unix variants, paths are composed of bytes. On Windows, they're composed of UTF-16 code units. Using a byte string accommodates both of those.

It's functionally ready, and follows the IPv6 standard to the letter. It needs better commenting / code style. I lost interest in coding in racket, and thus didn't finish this. Sorry. You can probably fork the request, add the 3-5 comments needed, and pull-request that instead. I have no intention of returning to this.

> This looks like a good change, but "id" and "name" seem redundant in #:extra-id-name. 
> How about just #:extra-name? 

Agree #:extra-name is better.

> Should we also add #:name (analogous to #:constructor-name and #:extra-construct-name)?

I thought about that, but since the name is specified in `(struct name ...)` it seems to
that #:name  is redudant?

Thank you very much for your contribution!

After thinking about this more, I remember why the newly documented behavior was the implemented one. The idea is that `path-add-suffix` should avoid mapping differently names files to a same-named file. If all "."s were replaced with "_", then adding ".fail" to "a.tar.gz" and "a_tar.gz" would produce "a_tar_gz.fail" in both cases. So, I think `path-add-extension` should stick with the old behavior, after all (but not count a leading "." as an extension separator).

DrRacket does this because it uses current-print to print values to the "value port" in the DrRacket interactions window (REPL). That is, DrRacket is making a finer distinction that we can in the command-line racket: it has three interesting ports: the port where values are printed (blue), the port where other output goes (purple), and the port where errors go (red).

It seems reasonable to print values to the value port only when the current-output-port is set to the output port of the interactions window. I'll push that change.

I have in mind that `#:name` would override the binding of `name` to static information. I now see that you had made the combination of `#:extra-id-name` and `#:omit-define-syntaxes` provide an alternate name, but I think it's more consistent to add `#:name` and make `#:omit-define-syntaxes` suppress all bindings to static information.

Yes, thanks! I have a revision that uses `|` as @Blaisorblade suggests and also makes `url->string` work, and I expect to merge it tomorrow.

Fixed by f7182e7a5cbf75954f713c7e447c75eeb935b4dc

Zero digits for a port number is apparently ok (e.g., Firefox and Chrome are happy with "http://github.com:/takikawa/taglib-racket"), but not a relative path combined with an authority (i.e, host plus optional user and port). I'll adjust `string->url` and `url->string` to reject that case.

Closing, since the issue is really about terminals, instead of Racket I/O.

This problem happens with "net" and "compiler" packages (including "zo-lib"), and it's a persistent hassle.
I think that moving those packages back to the main repo is probably a good idea, but the hassle of moving them has always been much greater than the immediate hassle of dealing with multiple repos...

@AlexKnauth Have you seen anything like this again? If not, I'm inclined to chalk it up to mysterious filesystem failure and close the issue.

Closing because the issue seems likely to be concurrency-related and could be solved by `#:async-apply`. We can reopen if further info suggests that something else needs to be fixed.

Yes, I think we split too much, and the compiler and net repositories should move back. I'll look into it. Are there any others where this is an issue?

No, but this issue was on one of the Northeastern computers, and I haven't tried on one of them since.

It would probably be good to at least fail with a better error message though, right?

Is this still a problem? I was not able to observe the problem on a fresh Fedora 20 installation for x86_64 with sources as old as v6.1.

As of v6.4, Racket headers to detect `__linux__` instead of `linux`. There's some chance that fixed the problem in the environment for the original report.

I think we've sorted out problems with phantom bytes along the way to v6.4.

The _general_ solution on Linux is to use a memory-mapping trick to map _two_ views of the same memory: one writable and one executable, such that writes to the writable mapping affect the executable mapping.

I never investigated this combination of version of platform. We used to get a handful of reports like this, and repairs for GC and places (for parallel builds) made during 2015 seem to have taken care of the problems. So, I'll close this issue for now, but we can certainly reopen if v6.4 or later still have a problem.

Looks like this was fixed by bfc2611ff24293aa1f7442acd4ef087a89ddd2b6

@drbo Thanks! I should have added a link here to the discussion at https://groups.google.com/d/topic/racket-users/MtUMGmAacn0/discussion, which includes comments along those lines.

That's a fair point. I'll make untgz and gunzip report unexpected end-of-file errors.

Sorry for not getting back to you sooner. Futures and places do not currently work with PPC, so disabling them is the right choice.

It's possible that places could be made to work with a modest effort. Making futures work would be much more difficult, I think, because lots more synchronization is needed for a non-TSO platform.

I think it's just the "compiler" and "net" repos.

@drbo Doesn't page aliasing defeat much of the mitigation? Full W^X prevents people from, for example, using out-of-bounds writes to directly change JIT-compiled code that is being executed. With page aliasing, attackers may be able to find the location of the aliased writeable page, at which point we're back where we started. The last chunk of this email has a good discussion of aliasing:

https://marc.info/?l=openbsd-misc&m=145944191229033&w=2

I'm pretty new to these topics, though, so I don't have much of value to offer.

I restored the `XXX`. 

(I don't know that "XXX" has any meaning here, but I'm interested to hear if someone specifically wants to keep it.)

I thought that `//` comments would create trouble for the MSVC build, but they didn't. Maybe it was a problem back with MSVC 2005 (instead of 2008). So, even though I still prefer using only `/* ... */`, maybe enough time has passed that we should start allowing `//`.

OK, let's close this.

Thanks for the info. I thought that the "error" was something more simple. Don't waste your time working in places/futures for powerpc, in my experience very few users use a openbsd/powerpc machine for real work. Anyway, I updated the OpenBSD package to 6.4 just 5 days after posting my problem here.

I have some problems with Racket 6.5 with JIT enabled on powerpc. Do you know how to fix this error in `number.rktl`?:

```
(#<procedure:floor> +inf.0) ==> +inf.0
(#<procedure:ceiling> +inf.0) ==> +inf.0
(#<procedure:round> +inf.0) ==> +nan.0
  BUT EXPECTED +inf.0
(#<procedure:truncate> +inf.0) ==> +inf.0
(#<procedure:floor> -inf.0) ==> -inf.0
(#<procedure:ceiling> -inf.0) ==> -inf.0
(#<procedure:round> -inf.0) ==> +nan.0
  BUT EXPECTED -inf.0
(#<procedure:truncate> -inf.0) ==> -inf.0
(#<procedure:floor> +nan.0) ==> +nan.0
(#<procedure:ceiling> +nan.0) ==> +nan.0
(#<procedure:round> +nan.0) ==> +nan.0
(#<procedure:truncate> +nan.0) ==> +nan.0
```

I will open new bug reports in the next weeks for the other problems.

Unfortunately, the name `path-extension` created conflicts for the "grip" package. I've renamed it to `path-get-extension`.

I'm not sold on the name. `pattern` describes only half of what `define-simple-macro` does (`template` being the other half).
Some more ideas: `define-syntax-rewrite`, `define-syntax-clause`.

Would `define-syntax-parse-rule` make sense?

I think the docs should be a little clearer: `chaperone-procedure*?` returns #t for any impersonator of a value produced by `impersonate-procedure*` or `chaperone-procedure*` (or something like that).

Otherwise, this looks good to me.

Merged, with improved docs.

@harrisi The way to write your code is:

```
(: foo (All (A) (->* [(Real -> A)] [Boolean] (Listof A))))
(define (foo f [b #t])
  (list (f 0.1) (f 0.2)))
```

That's the best way to work around this issue, but there's a real problem with the scoping in `#:forall`.

A patch would be great!
The relevant docs are at `pkgs/racket-doc/scribblings/foreign/types.scrbl`.

Merged, thanks!

found a typo ... will resubmit

`chaperone-opaque-struct` seems like it would be better as a modification to `chaperone-struct`, or as a different version with the same API but fewer restrictions.

Do you need impersonator versions of these?

Yes, I think a nice alternative to `chaperone-opaque-struct` would be to relax the restrictions in `chaperone-struct` to allow you to create chaperones/impersonators of any struct as long as you only add properties. As far as chaperones vs impersonators, I thought a chaperone was always usable where an impersonator was expected. But IIRC that isn't actually the case?

Seems good to me, but maybe have more of the information about this change in the commit message (such as the reasoning that's in the PR, and a link to the discussion).

okay, added info in commit message. I'll wait for the automatic tests to run, then merge this.

Looking into this further, it looks like the only change that would be necessary in `chaperone-struct` is to remove the explicit witness check. It looks like that check (and thus the optional `struct-type` argument) is only included to explicitly rule out the functionality I want to introduce with `chaperone-opaque-struct`. As far as I can tell, removing this check has no other effect, since supplying redirects also require additional arguments that serve as a witness

Should chaperones and impersonators require a witness for adding properties but not otherwise interposing on structs?

Should (chaperone-struct 3 ...) work?

Not sure what you're proposing Robby, but I would say no since 3 is not a struct. 

I'm proposing that `(chaperone-struct someStruct someProp #t)` return a chaperone for `someStruct` that does not change its behavior in any way but adds the specified impersonator property, as long as `someStruct` is a struct (of any structure type).

Are you referring to the `struct?` predicate? Are you saying that chaperone-struct should work only when that returns `#t`?

This program prints `#f`

```
#lang racket
(struct s (x))
(struct? (s 1))
```

Stepping back, what I'm saying is that ALL values in Racket are structs. The only question is if the accessors (and whatnot) are available to you. You don't have access to the struct selectors for 3 (and indeed, they are specially optimized representations in the runtime for that particular value, but for this one: `73786976294838206464` you will find something very close to what you think of as struct if you could poke around in the guts of the pointers and whatnot in the runtime system).

So if you want this to work for arbitrary values, then there is the monumental task of adapting all of the primitive operations in the runtime system so they accept values with chaperone properties on them.

Thanks for the clarification Robby. I meant "is a struct" in the sense of being represented as a struct in the runtime system, not in terms of `struct?` returning true (in which case I could of course provide the necessary witness). As you point out, this test isn't good.

It sounds like the `chaperone-opaque-struct` primitive I suggest is in fact unsafe, even for user-created structure types (which we could presumably treat differently from built-in structures): those user-created structure types may have operations implemented in native code that do not support chaperones.

I'm not sure of the best way forward here. The functionality I actually need for the contracts is to add an additional property to structs that already have a chaperone or impersonator. In that case, it's clearly safe to add a chaperone or impersonator since the value already has one.

Does it make sense to weaken the witness requirement in the case where the value being impersonated is already an impersonator?

As a matter of principle, there are no non-struct values in Racket and we cannot make that distinction. I think that probably it would be doable, however.

I think that would make sense, but it would be weird. 

Can you say more about the structs that you actually to be chaperoned? Presumably you never need to chaperone the number 3. Is there something more specific, that can be phrased positive to characterize the structs that you do need to add properties to?

In the implementation of bounded polymorphic contracts, the user may specify a "bound" contract that is a contract for a particular type of opaque struct (pseudo-code here):
`(bounded-> ((forall X <: (object/c ...)) X X)`

Under the hood, when the a value passes into the function through the first `X`, I apply the projection of the object contract to it. In addition, I need to record what the original value and the contracted value in a property. Then, when the value is returned from the function through the second `X`, I can retrieve this information from the property and use it to remove this contract, leaving any additional chaperones/impersonators that were added during the body of the function.

In this scenario, it is safe to add a chaperone or impersonator since we must have already added one when attaching the contract bound. However, we don't want to break abstractions by making it possible for the implementation of these contracts to get access to the struct-type info for objects, for example.

Thinking about it some more, I could probably implement this with clever use of `make-weak-hasheq` at the cost (probably small) of performance and memory. Thoughts?

Any thoughts about `remove-impersonators`? Because it removes all impersonators between the one specified and the witness provided, I think it avoids the possible issues we discussed earlier related to patterns that use multiple layers of impersonators.

I think that you really want the ability to do (chaperone-struct 3 ...), after all, right? Otherwise you couldn't specify something like (between/c 0 10) as a bound?

Hm. Maybe we should add a `can-be-chaperoned?` predicate (with a better name, of course) and just say something like "this procedure returns #f only when the runtime system is, sadly, limited". As we move more and more stuff up into Racket maybe we can even decrease this set. 

I'm not really sure we would want to commit to a strategy like this, where we are essentially promising a feature that we probably won't ever be able to actually implement tho. :)

The mechanism described above is what I do for bounds that specify higher-order contracts. For flat contracts, the wrapping and unwrapping steps are not needed, you just do the first-order-check on both the way in and out. (I haven't actually implemented that yet---currently, I just reject non-higher-order contracts as bounds.)

Oh, of course. (I think you must have explained this to me once before. It seems quite elegant.)

If the further thoughts on this are about the changes to Racket proposed by @thinkmoore, can we keep them in this discussion so that they're archived/accessible to others of us who are interested?

Updated to include @mflatt’s simple explanation & example from [“Binding as Sets of Scopes”](http://www.cs.utah.edu/plt/scope-sets/implementation.html).

This looks very nice!

@thinkmoore Would it help to allow an impersonator-property predicate/accessor as a witness?

(As you suggest, if you can demonstrate that an impersonator property was added before, then that should be enough to know that another can be added.)

> I'm not sold on the name.

Nor I. A syntax pattern is a distinct thing in Racket (and it's already nettlesome that `syntax/parse`  supports syntax patterns that `syntax-case` does not, so to introduce a third meaning of the phrase ...)

> `define-syntax-parse-rule`

= best, by analogy to `define-syntax-rule`

I think you mean to point out that the source location in the error message is for `racket/unit`, as opposed to the source program. I agree that should be fixed, although I'm not certain offhand how much it's about errortrace and how much the problem is with `racket/unit`.

(I was confused by the mention of the letrec pass and `letrec-values+syntaxes`, neither of which are directly relevant here. The `unit` form implements its own checking for use-before-defined.)

I'd prefer changing `record-disappeared-uses` to take either a list of identifiers or a single identifier rather than adding a new procedure.

@stamourv Updated the docs with the tweak I mentioned.

@rmculpepper Okay, I removed `record-disappeared-use` and implemented the change you suggested. I was mostly just following the pattern set by `generate-temporaries` / `generate-temporary`, but I guess this is different since `record-disappeared-uses` already comes from `racket/syntax`.

Looking at the previous function [read.c#L3117](https://github.com/racket/racket/blob/master/racket/src/racket/src/read.c#L3117), I think that the curly brackets are missing. 

The code is equivalent, because the other branch has a `return`, but it's confusing. 

Perhaps you can send this as a PR. (If Matthew doen't fix this inmeditely.) 

Merged, thanks!

I’d be fine with `define-syntax-parse-rule`. It’s a bit wordy, but it’s probably the only name I’ve seen so far without any significant problems. Any opposed?

This build is only failing because of what looks like random planet failure on one of the seven Travis builds. Should this build be restarted?

Related: http://thread.gmane.org/gmane.os.openbsd.ports/79903

I restarted that build.

Now passed. @mflatt, any thoughts on these additions?

This seems fine to me.

Extend [this doc page](http://docs.racket-lang.org/guide/stx-phases.html?q=phase) about compile- and run-time phases to include an example of the negative phase levels that are alluded to (but not demonstrated) at the end.

Thank you Spencer!

As a way of creating unhygienic bindings, would it be worthwhile to contrast `syntax-local-introduce` against the more traditional `(datum->syntax calling-site-stx 'id-name)`? 

After further experiments, it seems to me that the identifier created by `(syntax-local-introduce (datum->syntax #f 'id-name)` is in a sense “more” unhygienic because it sits higher in the scope hierarchy (and thereby captures more uses)

From what I understood from discussions like [this racket users list thread](http://lists.racket-lang.org/users/archive/2013-October/059737.html) is that the `calling-site-stx` usually isn't what you want, particularly because another `outer` macro could expand to a use of your `inner` macro, and then the `calling-site-stx` would point to the parens in the definition of the other `outer` macro. 

So, in examples like [this](http://lists.racket-lang.org/users/archive/2013-October/059736.html), `syntax-local-introduce` can make it work even in cases where other macros expand to uses of `inner` or `outer`.

(Edit: What I meant to say was that I don't think it's really accurate to say that one is "more unhygienic" than the other, but it might be useful to show how they affect the "compose-ability" of these macros, meaning how they work when different macros expand to uses of these macros in different ways.)

Fair enough — probably past time for me to give up on this mystery. FWIW here’s an example of how a `syntax-local-introduce` identifier seems to be able to capture an identifier in another macro in a way that a `datum->syntax` style identifier cannot. But notice that this unhygienic identifier doesn’t work inside `rackunit`. I have to conclude this is some kind of accidental scope leakage, not a by-design attribute of `syntax-local-introduce` — if `(invoke-sli-id-macro)` fails in one circumstance, it ought to fail in the other.

``` racket
#lang racket

(module macros racket
  (provide (all-defined-out))

  (define-syntax (make-use-site-id-macro stx)
    (syntax-case stx ()
      [(_)
       (with-syntax ([use-site-id (datum->syntax stx 'use-site-id)])
         #'(define (use-site-id) 'use-site-id-success))]))

  (define-syntax-rule (invoke-use-site-id-macro)
    (use-site-id)) ; a default macro-introduced identifier

  (define-syntax (make-sli-id-macro stx)
    (syntax-case stx ()
      [(_)
       (with-syntax ([sli-id (syntax-local-introduce (datum->syntax #f 'sli-id))])
         #'(define (sli-id) 'sli-id-success))]))

  (define-syntax-rule (invoke-sli-id-macro)
    (sli-id)))  ; a default macro-introduced identifier

(require 'macros rackunit)
(make-use-site-id-macro)
(check-equal? (use-site-id) 'use-site-id-success)
(check-exn exn:fail? (λ () (eval #'(invoke-use-site-id-macro))))

(make-sli-id-macro)
(check-equal? (sli-id) 'sli-id-success)
;; works here, despite relying on a macro-introduced identifier, but ...
(invoke-sli-id-macro) 
;; ... not inside rackunit
(check-exn exn:fail? (λ () (eval #'(check-equal? (invoke-sli-id-macro) 'sli-id-success)))) 
```

Thank you!

Merged, thanks!

Merged, thanks!

Would it make sense to have a `create-immutable?` parameter (or probably separate `create-immutable-string?`, `create-immutable-bytes?`, and `create-immutable-vector?` parameters) for this?

``` racket
(parameterize ([create-immutable-string? #true])
  (string-append "Hello" " " "from an immutable string!"))
```

Confusing indeed.
Dropping the else clause altogether and moving its contents in the function body would be clearer, IMO, and more in line with the style used elsewhere in the runtime.

I agree, but the code of the previous function [read.c#L3117](https://github.com/racket/racket/blob/master/racket/src/racket/src/read.c#L3117) is very similar and has this format.

Perhaps I can change both.

Sounds like a good plan.

So the macro expanding to a nested `begin-for-syntax` doesn't change the problem?

It doesn't change the problem, which was purely a phase-shifting issue in `dynamic-require`.

Ok. I originally came across this problem wondering if macros could expand to definitions at higher phases than themselves. So if you add the macro bit back in, it still works? Does the dynamic-require of a phase 2 `x` also run the macro code (which is at phase 1) first?

Really – it still works after the repair. :)

A `dynamic-require` of a variable export will never run a macro implementation. It's working in terms of expanded (and compiled) modules. If the export accessed by `dynamic-require` is a variable in some module, then that module will have the definition already expanded.

In your example, "lib.rkt" is compiled to have a definition at phase level 2, then "lib2.rkt" is compiled to re-export the defined variable, and then `dynamic-require` instantiates the module (with a phase shift of -2) and accesses the variable (at phase 0, which is phase level 2 shifted by -2).

Ok. So does that mean the macro code at phase 1 has to run before phase 2 is finished? I had thought phase 2 always had to happen before phase 1. Also, thanks!

Evaluation of phases can certainly be interleaved at compile time.

If you haven't already, you might want to take a look at the mflatt/expander repo, especially the "exand/module.rkt" module: https://github.com/mflatt/expander/blob/master/expand/module.rkt

You'll see the interleaving that I think you're asking about in the `pass-1-and-2-loop` part, where `begin-for-syntax` can move the recursive expansion process to an arbitrarily deep phase, and that can happen both before and after `define-syntaxes` or `begin-for-syntax` triggers evaluation at some other phase (> 0).

FWIW, this new implementation of the expander worked right on your example in the first place.

New version, without the `else` branchs.

I've make a separate pull request here (https://github.com/racket/racket/pull/1341) for adding an optional `#:immutable?` keyword argument to everything.

Unfortunately, this is significantly slower.

On dynamic:

```
[samth@huor:~/.../racket/benchmarks/common (mpair) plt] r dynamic.rkt 
cpu time: 633 real time: 632 gc time: 181
[samth@huor:.../racket/benchmarks/common racket-6.5.0.5] r dynamic.rkt 
cpu time: 460 real time: 459 gc time: 207
```

On peval:

```
[samth@huor:~/.../racket/benchmarks/common (mpair) plt] r peval.rkt 
cpu time: 2760 real time: 2758 gc time: 40
[samth@huor:.../racket/benchmarks/common racket-6.5.0.5] r peval.rkt 
cpu time: 1181 real time: 1181 gc time: 45
```

This is therefore on hold for the time being.

This might be my fault. I'll see what I can do post-POPL.

Merged, thanks!

@mflatt improved this with e887fa56d1f4c, but there now appears to be a performance issue with GC. 

This program shows the problem:

``` racket
#lang racket
(define v (make-vector 1000000))

(struct mp (a d) #:transparent #:mutable)
'cons
(collect-garbage)
(collect-garbage)
(collect-garbage)
(time
 (for ([i (in-range (vector-length v))])
   (vector-set! v i (cons 1 2))))

(collect-garbage)
(collect-garbage)
(collect-garbage)
'struct
(time
 (for ([i (in-range (vector-length v))])
   (vector-set! v i (mp 1 2))))  
```

On my machine, I get about 9 ms for the first look, and about 45 for the second, with the difference almost all GC time.

However, despite that issue, there's still something else going wrong for peval, which spends only 3% of its time in GC.

I was analyzing the problem with the tests. The optimizer can't inline keywords procedures, so it can't see that `(verctor? (make-vector 5))` is `#t` with the new version of `make-vector`.

A real fix is difficult. It's necessary to force the inlining of the internal procedure `make-keyword-procedure`, and allow the inlining of struct-procedures. And then, fix a few minnor details, like adding the type of `vector->immutable-vector` to the optimizer. I guess it's a few months away.

(Perhaps it's possible to fix these issues with some macros. Instead of creating a function `make-vector`, create a macro that looks for keywords and that transform itself into a function when it's not in application position. But it's a problem is the bind is mutated.)

My easy alternative is to modify the test meanwhile. I wrote a commit that changes `make-vector` to `k:make-vector` that is the renamed version of the primitive in the `#%kernel`. I also made a few similar renaming, so the commit is long, but the relevant lines for this are only a few. It can be merged before or after your commit if necessary.

Commit: https://github.com/gus-massa/racket/commit/5a9a467e8329b74d3eac68b05bdecf2425307bee ( [travis](https://travis-ci.org/gus-massa/racket/builds/138524703) )  (look near [optimize.rktl#L1359](https://github.com/gus-massa/racket/commit/5a9a467e8329b74d3eac68b05bdecf2425307bee#diff-a8685fee6f723d6d819bd4bc48120725L1359) ) 

By the way, you forgot [struct->vector](https://docs.racket-lang.org/reference/structutils.html#%28def._%28%28quote._~23~25kernel%29._struct-~3evector%29%29) .

Oh, okay. Would it make sense to make it a non-keyword argument somehow? But then what about functions like `string-append` that take rest arguments?

I think it's better to keep your version with the keywords because it looks better for usability, but I don't know the opinion of the rest.

I hope it's possible to fix the optimization details later.

## 

As a proof of concept, I wrote a version of `make-vector` that can be (almost) reduced by the current optimizer. The code is horrible, I should have used `syntax-protect` and `syntax/loc`, ... 
And another side effect is that this is backward incompatible because `make-vector` is a macro that transforms into a function, not a real function.

```
#lang racket
(require (only-in '#%kernel (make-vector k:make-vector)))

(define (make-vector/noval/nokeyword len immutable?)
  (if immutable?
    (vector->immutable-vector (k:make-vector len))
    (k:make-vector len)))

(define (make-vector/nokeyword len val immutable?)
  (if immutable?
    (vector->immutable-vector (k:make-vector len val))
    (k:make-vector len val)))

(define-syntax-rule (define/rename name (rename args ...) body ...)
  (define name
    (let ([rename (lambda (args ...) body ...)])
      rename))) 

(define/rename make-vector/proc (make-vector len (val 0) #:immutable? immutable?)
  (if immutable?
    (vector->immutable-vector (k:make-vector len val))
    (k:make-vector len val)))

(define-syntax make-vector
  (make-set!-transformer
   (lambda (stx)
     (syntax-case stx ()
       [(_ len)
        #'(k:make-vector len)]
       [(_ len val)
        #'(k:make-vector len val)]
       [(_ len kw:immutable? immutable?)
        (eq? '#:immutable? (syntax-e #'kw:immutable?))
        #'(make-vector/noval/nokeyword len immutable?)]
       [(_ kw:immutable? immutable? len)
        (eq? '#:immutable? (syntax-e #'kw:immutable?))
        #'(make-vector/noval/nokeyword len immutable?)]
       [(_ len val kw:immutable? immutable?)
        (eq? '#:immutable? (syntax-e #'kw:immutable?))
        #'(make-vector/nokeyword len val immutable?)]
       [(_ len kw:immutable? immutable? val)
        (eq? '#:immutable? (syntax-e #'kw:immutable?))
        #'(make-vector/nokeyword len val immutable?)]
       [(_ kw:immutable? immutable? len val)
        (eq? '#:immutable? (syntax-e #'kw:immutable?))
        #'(make-vector/nokeyword len val immutable?)]
       [(_ . any) #'(make-vector/proc .  any)]
       [_  #'make-vector/proc]))))

(vector? (make-vector 5))
;==optimized==> #t

(vector? (make-vector 5 #:immutable? #f))
;==optimized==> #t

(vector? (make-vector 5 #:immutable? #t))
;==optimized==> (vector? (vector->immutable-vector (make-vector 5)))
```

But this wouldn't work if I made the optional argument default to the value of a `(create-immutable-vector?)` parameter, would it? Unless the optimizer could know the value of that parameter, it wouldn't be able to know which branch it was.

I totally missed the part about parameters. In my example, it can be fixed with something like

```
[(_ len val)
 #'(make-vector/nokeyword len val (create-inmmutable-vector?))]
```

Now the reductions are not perfect, but `make-vector/nokeyword` can be inlined and with some work in the future they can be optimizad away. The difficult part is optimizing the keyword machinery.

## 

IMHO, it's a bad idea to use parameters in a function like `make-vector` because it's too low level. I'm slightly worried about the performance, but I also don't like that parameters are too similar to a global flag. (I don't have this objection for high level functions like `display`, because they do a lot of crazy stuff and have a lot of options, so it's impossible to write all the details as explicit arguments.)

In this case, I'd like to have a fixed default. I'd like to make the immutable version the default, but it's backwards incompatible, so I think this change should be delayed to Racket2. So, I think that the next best option is to add the keyword but keep the mutable version as the default. This can make some calculations slower, but the difference can be fixed.

## 

Another comment about my horrible code: It has a few wrong corner cases, for example

```
(void (make-vector #:immutable (display "X") 7 (display "Y"))) 
; ==show==> YX instead of XY
```

Ok, so for lower-level functions like `make-vector` to avoid the parameter, does it make sense to have immutable versions be provided by a `racket/immutable` library like in my other pull request? (https://github.com/racket/racket/pull/1219)

I found a small problem in your implementation with the message of the error when a function has an implicit argument, for example in:

```
(make-vector -1)
```

The error is 

```
make-vector: contract violation
  expected: exact-nonnegative-integer?
  given: -1
  argument position: 1st
  other arguments...:
   0
  context...:
    [...]
```

Instead of 

```
make-vector: contract violation
  expected: exact-nonnegative-integer?
  given: -1
  context...:
    [...]
```

## 

I was looking at the implementation of keyword procedures. [kw.rkt#L1026](https://github.com/racket/racket/blob/master/racket/collects/racket/private/kw.rkt#L1026)

The implementation binds the identifier in the definition to a macro that expands to a hidden procedure. So I guess it's possible to change the implementation of all the keyword procedures to something like the macro that I wrote before (fixing all the details, corner cases and errors :)). But it's out of scope of your commit, perhaps I should send a feature request to the mailing list, to try to convince someone that knows the details to fix it.

I'd like that in some code like 

```
(define (f x #:y (y 0)))
  (list x y))
```

At least `(f 5)` is expanded to a direct application of a (hidden) function, not a call to `checked-procedure-check-and-extract`. So it's adding an unused keyword to a procedure doesn't prevent the optimizations and reductions, and probably doesn't increase the run time.

Extra points for expanding `(f 5 #:y 3)` to a direct application of a function. This looks more difficult, because the keywords can be reordered (see my previous comment).

I made a few small tests, and apparently the problem is only with optional keywords, all the other cases seams to be already written in the more efficient way. :)

No, I don't think this has anything to do with keyword arguments. It's because I'm doing the equivalent of this:

``` racket
(define (my-make-vector n [v 0])
  (make-vector n v))
(my-make-vector -1)
```

And that means that the core `make-vector` is actually getting two arguments. 

Do you have `--enable-futures` or `--enable-places` in your `configure` line? I think that error happens when you try to enable future or places on ARM, where they're not currently support. (If that's it, I should add something to provide a more help error message at build time.)

Yes I have `--enable-futures` and `--enable-places` both enabled. I'll try building again with both disabled and if that is the problem I'll note that in the Gentoo build.

```
./configure --prefix=/usr --build=armv7a-hardfloat-linux-gnueabi --host=armv7a-hardfloat-linux-gnueabi --mandir=/usr/share/man --infodir=/usr/share/info --datadir=/usr/share --sysconfdir=/etc --localstatedir=/var/lib --libdir=/usr/lib --enable-gracket --disable-docs --enable-shared --enable-jit --enable-foreign --enable-places --enable-futures --enable-pthread
```

I agree that there are two different problems.

One is that the optional keyword arguments are expanded in a way that is not friendy to the optimizer. This has to be fixed elsewhere.

The other problem is that after using the automatic optional argument, the distintion between a missing argument and one that coincides dissapears, so in case of an error, the end user can get confused by the ghost argument.

I was thinking in something like:

```
(define missing-argument (gensym 'missing))

(define (my-make-vector len (val missing-argument))
  (if (eq? val missing-argument)
    (make-vector len)
    (make-vector len val)))
```

   (my-make-vector -1)

(It's not 100% optimizer friendly, but it raise the same errors that the `make-vector` in the kernel.)

My understanding is that Racket uses [Pango](http://www.pango.org/) for its text rendering, which uses platform-specific backends and doesn't offer a general way to install fonts. I ran into this issue with portable slideshow presentations as well so have looked into it a bit.

On Linux and similar unix systems, you can use fontconfig to temporarily load external font files for an application. (I have FFI bindings for it here: https://github.com/takikawa/racket-fontconfig) On Windows, it is also possible (and I have some code that I'm planning to put somewhere which does the same). I'm not sure if there is a good solution for OS X.

Awesome. I'll merge when the CI passes.

But the `fontconfig` library is part of the OS X Racket distribution, right? What is different about OS X?

That was the issue. `racket` and `raco exe` work just fine after disabling both those flags.

Oh, so it is. I hadn't actually tried using fontconfig on OS X since I don't have a Mac. Unfortunately when I just asked @bennn to try it, it seems to segfault (possibly a bug in the FFI lib?). If you want to try it, there's a test file here that will display a pict when run: https://github.com/takikawa/racket-fontconfig/blob/master/test.rkt (you will want to change the font file path appropriately and you may need to edit the call to `ffi-lib` in the `fontconfig.rkt` file)

Hmm yes, I got a segfault too. 

But see [`cairo-lib.rkt`](https://github.com/racket/draw/blob/master/draw-lib/racket/draw/unsafe/cairo-lib.rkt), which contains both 

1) cross-platform code for loading `fontconfig` and 

2) a “Racket-specific patch to Fontconfig” that seems to specify the location of the font directories. 

I will investigate this more later, but perhaps this could be adapted so that Fontconfig “boots” into the source directory, rather than the shared system fonts directory?

LGTM

Fixed in https://github.com/racket/racket/commit/9978696991d04f8bc8aed34aa02fa39cd7b9b3f3

Thanks for the report.

I forgot to note: the error occurs only if `typed/racket/base` or `typed/racket` is used in `foo`, if instead `racket/base` is passed, everything works fine.

@mflatt: are the functions in your [patch to FontConfig](https://github.com/racket/racket/blob/master/racket/src/native-libs/patches/fcdirs.patch) used to change the default directory from which `racket/draw` loads its fonts? (FWIW I have been fiddling with it but not succeeded in doing this.) If so, can this capability be exposed in the `racket/draw` interface? (e.g., with a `current-font-directory` parameter)

Should this be mentioned in the docs?

@mbutterick I think I added that specifically for the "natipkg" Linux builds Those builds bundle fontconfig, Pango, etc., similar to the OS X and Windows builds, but even more configuration is needed in an environment that doesn't provide fonts at all. So, that patch won't be present on typical Linux environments.

Meanwhile, on OS X and Windows (where the OS always provides font support), probably platform-specific calls are needed. Something like the second answer here may be needed on OS X: http://stackoverflow.com/questions/5283572/custom-font-in-a-cocoa-application

What about the technique [you used in `gui-lib`](https://github.com/racket/gui/blob/master/gui-lib/mred/private/wx/cocoa/font.rkt#L55) to “register a family manually”? Is that technique adaptable here, or is that a distinct situation?

That's a distinct situation.

OK, so what I’m gathering is that even though `fontconfig` is bundled with Racket on all platforms, it’s not actually involved in the font-loading machinery on each platform in a consistent way. 

@takikawa: maybe we should try to shave this yak and PR it, so future generations will regard us as heroes, etc. Since you have the Linux and Windows pieces, I will look into the OS X angle. 

Perhaps; but again, I think improving the documentation can be a separate issue.

I'd like one more set of eyes on this (given it's horrible C string-parsing code) before I merge this. @mflatt, could you take a quick look?

Since we're changing the semantics, I think it should be mentioned in the docs.

How do I find out if futures are disabled? (I'm using racket-6.5-src-builtpkgs.tgz)

You can run this program to check:

``` racket
#lang racket
(require racket/future)
(futures-enabled?)
```

Also, can you report the result of running this program?

``` racket
#lang racket
(require typed-racket/utils/any-wrap rackunit)
(contract any-wrap/c '(def) 'a 'b)
(require/expose typed-racket/utils/any-wrap [base-val?])
(base-val? 'def)
```

`(futures-enabled?)` gives `#f`

The other program stops at

```
(contract any-wrap/c '(def) 'a 'b)
```

and says:

```
 make-fsemaphore: contract violation
  expected: exact-nonnegative-integer?
  given: '(def)
```

which looks a lot like the original exception...

Indeed it does. What if you comment out that line, so that the next one runs?

That gives me a `#t` for `(base-val? 'def)`.

Ok, what about `(base-val? '(def))` (which is what I intended to write in the first place, sadly)?

Trying this:

```
#lang racket
(require typed-racket/utils/any-wrap rackunit)
(require/expose typed-racket/utils/any-wrap [base-val?])
(base-val? '(def))
```

->

```
make-fsemaphore: contract violation
  expected: exact-nonnegative-integer?
  given: '(def)
```

But then I forced futures with --enable-futures, and I have this:

```
#lang racket
(require racket/future)
(futures-enabled?)
```

->

```
#f
```

And

```
#lang racket
(require typed-racket/utils/any-wrap rackunit)
(require/expose typed-racket/utils/any-wrap [base-val?])
(base-val? '(def))
```

->

```
#f
```

I also get the doc arrow in the upper right corner, which was what I hoped.

It looks like the FreeBSD build is not picking up futures by default?

Can you try one more thing on your original (broken) install?

``` racket
#lang racket
(fsemaphore? '(def))
(define (base-val? e)
  (or (number? e) (string? e) (char? e) (symbol? e) (semaphore? e) (fsemaphore? e)))
(base-val? '(def))
```

Also, can you try compiling that file (with `raco make`) and then decompiling it with `raco decompile file.rkt` and pasting the output somewhere?

Thanks a bunch for all the testing!

Checking...

```
#lang racket
(fsemaphore? '(def))
(define (base-val? e)
  (or (number? e) (string? e) (char? e) (symbol? e) (semaphore? e) (fsemaphore? e)))
(base-val? '(def))
```

->

```
#f 
#f 
```

Then I got a dump here: https://gist.github.com/olgeni/ef3d068680cb8d077f9cfbc1f8e82f2e

Oh, interesting, that didn't error. What if you try the whole implementation of `base-val?` from [here](https://github.com/racket/typed-racket/blob/master/typed-racket-lib/typed-racket/utils/any-wrap.rkt#L16-L34) (copied below)?

```
(define (base-val? e)
  (or (number? e) (string? e) (char? e) (symbol? e)
      (null? e) (eq? undefined e) (path? e) (eof-object? e)
      (regexp? e) (pregexp? e) (byte-regexp? e) (byte-pregexp? e)
      (keyword? e) (bytes? e) (boolean? e) (void? e)
      (bytes-converter? e)
      (impersonator-property? e)
      (inspector? e)
      (logger? e)
      (module-path? e) (resolved-module-path? e)
      (pretty-print-style-table? e)
      (pseudo-random-generator? e)
      (semaphore? e) (fsemaphore? e)
      (thread-group? e)
      (udp? e)
      ;; Base values because you can only store flonums/fixnums in these
      ;; and not any higher-order values. This isn't sound if we ever
      ;; introduce bounded polymorphism for Flvector/Fxvector.
      (flvector? e) (fxvector? e) (extflvector? e) (extflonum? e)))
```

I got the missing `require`s:

```
#lang racket

(require racket/match racket/contract/combinator
         racket/class racket/unit
         racket/fixnum racket/flonum racket/extflonum
         racket/set
         racket/undefined
         (only-in racket/async-channel async-channel?)
         (only-in racket/future future? fsemaphore?)
         (only-in racket/pretty pretty-print-style-table?)
         (only-in racket/udp udp?)
         (only-in (combine-in racket/private/promise)
                  promise?
prop:force promise-forcer))

(define (base-val? e)
  (or (number? e) (string? e) (char? e) (symbol? e)
      (null? e) (eq? undefined e) (path? e) (eof-object? e)
      (regexp? e) (pregexp? e) (byte-regexp? e) (byte-pregexp? e)
      (keyword? e) (bytes? e) (boolean? e) (void? e)
      (bytes-converter? e)
      (impersonator-property? e)
      (inspector? e)
      (logger? e)
      (module-path? e) (resolved-module-path? e)
      (pretty-print-style-table? e)
      (pseudo-random-generator? e)
      (semaphore? e) (fsemaphore? e)
      (thread-group? e)
      (udp? e)
      ;; Base values because you can only store flonums/fixnums in these
      ;; and not any higher-order values. This isn't sound if we ever
      ;; introduce bounded polymorphism for Flvector/Fxvector.
      (flvector? e) (fxvector? e) (extflvector? e) (extflonum? e)))
```

Which compiles to https://gist.github.com/olgeni/f2e7584722a01239af407614f3e61c31 (!)

@olgeni does that produce `#f` for you with `(base-val? '(def))`, or give an error?

I tried from the IDE and got an `#f`.

By default I have the precompiled any-wrap.rkt - could it be related somehow?

I think it's related to it being in a separate file.

Merged, thanks!

We moved these repositories back in.

Thanks! I just found details in #1332.
- So the racket/net and racket/compiler repos should be ideally... marked as deprecated or closed?
- Should sth. happen on the the open PRs there? There's a few. You might want to take a look and migrate/close/merge them somehow.
  The one which triggered this issue (tests for https://github.com/racket/racket/pull/1243) is still open as https://github.com/racket/net/pull/8, was never merged, but it seems it was taken care of. Dunno about the other open PRs at https://github.com/racket/net/pulls and https://github.com/racket/compiler/pulls.

Afraid I won't be able to contribute anything here for now—my current projects are not in Racket. 😢 

@Blaisorblade thanks for reminding me to do that. I've dealt with everything except https://github.com/racket/compiler/pull/7 and marked those repositories as obsolete.

@mflatt ping, can you look at this and https://github.com/racket/scribble/pull/45 before the v6.6 release?

The build is failing because https://github.com/racket/scribble/pull/45 isn't merged. The command `racket -l tests/pkg/test -- -q` exits cleanly on my fork.

From what I understand talking to @rmculpepper, this change is _necessary_ and packages broken by the change only worked by chance.

However, those packages did work, and making a backward incompatible change without much announcement/prep time seems like bad idea.

Can we disable the optimization that makes this error necessary, and change the error to a warning for this release?

What do you mean by "by chance"? Is there a use of `random` in `syntax/parse`?

I’ve figured out how to translate the [technique suggested by @mflatt](http://stackoverflow.com/a/5283609/1486915) into the FFI. 

I can successfully add local fonts, which show up in the Cocoa `NSFontManager`. 

But they don’t show up in `get-face-list` from `racket/draw`. (i.e, they apparently remain inaccessible to Cairo/Pango, and thereby `racket/draw`). 

Is there a simple way of forcing a refresh of the Cairo/Pango font database from Cocoa? Or is it more elaborate surgery? It’s not obvious to me how, under the hood, Cocoa & Cairo/Pango cooperate.

My understanding is that they only worked because the implementation did not perform an optimization that ought to have been valid. Ellipsis-head patterns that might match an empty sequence could result in an infinite search dependeing on how the search is performed, so it ought not to have been allowed from the start. "It just so happens" that the old implementation didn't infinitely search when someone used such a pattern.

My feeling is that there are two possible cases here:
1. the semantics of `syntax-parse` relies on not searching in these cases (for example, if you wrote this, then it would behave differently in different places, and do the wrong thing sometimes). Then it seems like there's a hard question about what to do.
2. the semantics of "old `syntax-parse`" allowed these things, but wasn't intended to, and gave them a reasonable meaning. But since that wasn't intended, it breaks an equality that @rmculpepper wanted to use for optimization. In that case, I think we should just stick with the old semantics and skip the optimization.

This looks nice and simple to me. @mflatt or @jeapostrophe?

@wilbowma I'm not sure if this is where you're going with that, but that is not a suitable rationale to declare the problem in the pkgs (as opposed to being in syntax-parse). The change in syntax-parse broke these packages. If we had the "go back in time" capability, then we could use a rationale like that to decide to change the original syntax-parse.

As for how we proceed with the release, I think that unless Ryan (or someone) comes up with a fix that makes these programs continue to work while supporting the new features, we should revert this change to syntax-parse. We technically have a week before we have to make this decision, so there is time to avoid reverting the change if someone figures something out.

To put this another way: there is a specification that syntax-parse was supposed to be living up to, but that spec wasn't checked. So that means it is NOT FAIR to expect clients of syntax-parse to live up to that specification, as the authors of those clients had no help in knowing that they didn't abide by the specification.

That's a good point. I'll wait for Ryan to weigh in; maybe I misunderstood, or maybe I mis-explained what I understood.

Should this be added for version 6.6?

Perhaps this only bears on Linux, but  [“How to use custom application fonts with Pango”](http://mces.blogspot.com/2015/05/how-to-use-custom-application-fonts.html)

Details and clarifications: The change concerns the behavior of patterns like `(a (~seq) ...)`. syntax-parse is a backtracking parser, and ellipses are greedy, so parsing this pattern "should" diverge ("ok, I was able to parse one iteration of no elements, let's try to parse another... ok, that worked too!...").

Previously, there was a bug (an unsound optimization) that made some bad programs parse successfully instead of diverging.

Now syntax-parse does a dynamic check and raises an error if an ellipsis head pattern matches zero elements instead of diverging. (If it can detect that the ellipsis head pattern is nullable, it issues a static warning. I plan to turn that into a static error sometime after the next release.)

Following the [suggestion here](https://bugzilla.gnome.org/show_bug.cgi?id=347237#c25), I tried using `pango_cairo_font_map_new_for_font_type` with `pango_cairo_font_map_set_default` to update the font list seen by `racket/draw` (because `get-face-list` relies on `pango_cairo_font_map_get_default`). But that didn’t work.

A workaround I hadn’t considered before is to just bypass `racket/draw` entirely and instead rely on Quartz in OS X for font management, text measurement, and PDF generation. Not my first choice. But for `quad`, it seems that Pango/Cairo has now revealed itself to have two major shortcomings (= dynamic font loading, and PDF generation).

Closing this issue as impracticable.

@rmculpepper is there a change that would allow some small set of such programs to continue to parse successfully for now? If so, is this a change that would be reasonable to maintain for the forseeable future? If not to the latter, but yes to the former, do you think you can do something that you'd be okay with for a little while to give the pkg authors whose code is currently broken time to respond?

Are there programs that this unsound optimization broke? As in, some syntax-parse pattern that's parsed incorrectly before but correctly now?

Investigating the failure

Okay, this should work. Also, added a test case for it.

Looks like previous failure had to do with hashes, not something I changed; rebasing to master.

So it's not clear to me that your expected behavior is in fact expected, since the final "-p" isn't considered a flag, but part of the arg.

Nevertheless, I created a patch that fixes this. It passed all my tests locally, so might be okay.

Does this affect any of the uses of command-line in our various tools?

Not that I saw when testing, but I'll let Travis do a more thorough test.

## 

Sent from my phoneamajig

> On Jul 5, 2016, at 20:35, Robby Findler notifications@github.com wrote:
> 
> Does this affect any of the uses of command-line in our various tools?
> —
> You are receiving this because you authored the thread.
> Reply to this email directly, view it on GitHub, or mute the thread.

Well, it would have to be something where you'd look at the uses, I think.
From the discussion on the PR this closes, it sounds like it could make it
so that, eg 'raco exe -o "My Program" -o' would no longer treat '-o' as a
source file. Maybe we don't care about that? But maybe there is a situation
where something similar would turn out to matter?

I'm not sure how to check for this kind of thing in an automated way, tho.
Ideas welcome. :)

(also, please don't change the whitespace in a line if that's the only
change you're making as I find the 'git blame' handy and that obscures it)

> On Jul 5, 2016, at 20:48, Robby Findler notifications@github.com wrote:
> 
> Well, it would have to be something where you'd look at the uses, I think.
> From the discussion on the PR this closes, it sounds like it could make it
> so that, eg 'raco exe -o "My Program" -o' would no longer treat '-o' as a
> source file. Maybe we don't care about that? But maybe there is a situation
> where something similar would turn out to matter?
> Yeah I wasn't quite sure this wouldn't break something, but no one had voiced concerns yet and I wanted to write some Racket code so I wrote the patch. :)
> 
> (also, please don't change the whitespace in a line if that's the only
> change you're making as I find the 'git blame' handy and that obscures it)
> Sorry; artifact of my editor config. I separated it into a different commit afterwards in case of this concern. I can remove it before merging.

Writing Racket code: I LOVE IT. :)

See also the discussion in #1364 

All tests pass! Going to drop the whitespace changes, per concern about `git blame`.

(FWIW, I wish that whitespace wasn't there in the first place and I remove
it when I edit lines and thanks to Max, DrRacket doesn't include it anymore
.... sigh)

I replaced the original code that recognices `make-bytes` with code that recognices `bytes-append`, because I think it's much mure used. I also added the ability to check/save the types of the arguments of `bytes-append`.

Could you add some tests that would fail with the current implementation?

That looks like a pretty conservative change to me, so I'm fine with it going into 6.6.
@mflatt? Others?

Can do

So all tests pass, but I can still imagine situation where this is not the desired behavior. Robby gave a good example on the pull request. What if instead we added something like `#:args-checked-flags`, or `#:args-no-flags` that gets this new behavior?

(I'm thinking `#:args-no-flags` raises an error if any flag is found, while `#:args-checked-flags` does what's in the pull request)

I like that approach. 

Also: it may make sense to go poke around at the various `raco XYZ` things we have and change some of them to one of those new keywords.

LGTM

Actually, I think a better interface might be to restrict individual flags, e.g., `#:once-each/args` would prevent the flag from showing up more than once even in the args list; that might introduce a combinatorial problem, as you might want the "no args" modifier for every kind of flag.

While we're at it, how about we make this new form implicitly quasisyntax its template? (as opposed to syntax, which is what `define-simple-macro` does).
I just wrote a bunch of code that used `define-simple-macro` and explicitly quasisyntaxed the template, which it turns out does not work. Now I have to use the full-fledged `syntax-parse` instead, which is a bummer. Quasisyntaxing would have solved my problem.

Why not take it a step further? What about using `template` from `syntax/parse/experimental/template` instead of `syntax` or `quasisyntax`? And while we’re at it, what about getting that out of its `experimental` directory?

+1

On Wednesday, July 6, 2016, Alexis King notifications@github.com wrote:

> Why not take it a step further? What about using template from
> syntax/parse/experimental/template instead of syntax or quasisyntax? And
> while we’re at it, what about getting that out of its experimental
> directory?
> 
> —
> You are receiving this because you are subscribed to this thread.
> Reply to this email directly, view it on GitHub
> https://github.com/racket/racket/pull/1310#issuecomment-230921279, or mute
> the thread
> https://github.com/notifications/unsubscribe/AAOM-u2rSemxCSXHYgXpFejW-4IKNA9Xks5qTCZ1gaJpZM4IIz39
> .

## 

Jay McCarthy
Associate Professor
PLT @ CS @ UMass Lowell
http://jeapostrophe.github.io

```
       "Wherefore, be not weary in well-doing,
  for ye are laying the foundation of a great work.
```

And out of small things proceedeth that which is great."
                          - D&C 64:33

Doesn't the built in `--` flag cover the case where you want to pass a flag as an argument rather than a flag? `command -- foo -b bar -p` would interpret "foo", "-b", "bar", and "-p" as the list of arguments.

Yes. But there may be scripts out there that don't already have the -- in
them.

On Wednesday, July 6, 2016, Jack Firth notifications@github.com wrote:

> Doesn't the built in -- flag cover the case where you want to pass a flag
> as an argument rather than a flag? command -- foo -b bar -p would
> interpret "foo", "-b", "bar", and "-p" as the list of arguments.
> 
> —
> You are receiving this because you commented.
> Reply to this email directly, view it on GitHub
> https://github.com/racket/racket/issues/1342#issuecomment-230926782, or mute
> the thread
> https://github.com/notifications/unsubscribe/AAYWsJbh1ggBYEN9Y77KaJ3FqSxOQHZDks5qTCyVgaJpZM4I0gyC
> .

What if the EH-pattern has a `~once` pattern or something similar, and that matched an empty sequence? Would this display an error then too?

Just to be clear, this isn't an abstract backwards compatibility problem
and if we cannot get those package authors to unbreak their packages, that
seems problematic for the release.

We do NOT want to break cKanren!

Branch day is today. We need to resolve this issue.
Otherwise, I'll revert the commits that introduced the regression.

Sounds great!
@rmculpepper: Any blockers to moving templates out of experimental?

@stamourv We definitely need to resolve the issue before the release, but it doesn't seem like it has to be today.

Well, we need to do something with the branch, right? I think making the branch be before those commits (are they are the latest ones?) is a good starting point.

No, the problematic commits are quite a while ago. In particular, fb5c1310d8a28d058f16eae969965169ae7204a7 from May introduces the dynamic error.

@samth: I'd rather avoid having regressions (that we know about) on the release branch, that we'd have to fix before the actual release. Fail safe, and all that.

@stamourv but reverting commits (which might break other packages) and the un-reverting them again later along with the fix seems like a more-dangerous solution.

It sounds like we need some help from @rmculpepper here. It has been two days since his last comment.

After discussion with @rmculpepper, here's the plan.
- @rmculpepper will undo the problematic changes (but not by reverting commits) for this release. This does not block release branch creation.
- Between 6.6 and 6.7, @rmculpepper will fix the packages that were broken by the changes, then reintroduce the changes.

Added search option `R:` for `#reader` modules. Cancelled the travis build because CI will fail until https://github.com/racket/scribble/pull/48 is merged.

Might be worth mentioning in this release, so people who have potentially buggy code that is not on the pacakge server or public GitHub know about it.

Good idea.

Good thing you made me do that. I missed a case. Now actually fixed, with tests as evidence.

LGTM

The `module+` form collects module bodies and assembles them one a single `module*` form for a given submodule name. (The `module+` form also promises to order the generated `module*` forms based on the initial use of each submodule name with `module+`.) The `module+` form can't expand the submodules piecewise, so putting a use of `foo` later than the initial `(module+ main ....)` doesn't help.

libffi doesn't actually support union types, and there's a problem with the hack that Racket uses to try to make it work, anyway. I may have a repair, but I'll have to test it more.

Seems ok to me. I agree that it's unlikely to be a performance problem.

LGTM

First two commits seem fine. I'm not sure the third is a worthwhile direction; is there a specific motivation for it?

Thank you
(merged https://github.com/racket/racket/commit/4650a123505e5cc37954c913c944c7e89166909b)

I accidentally stumbled upon this issue over a year later, but I’d like to say that I agree this behavior is annoying. I use the search box a lot, but when I link people to documentation I always have to manually strip the query string off of the URL. I personally don’t think it’s a worthwhile feature, but I would imagine some people might find it to be a better user experience, so I wouldn’t mind too much if it were kept as-is.

That makes sense, and thinking about this more I'm not sure how else the submodule system could work. Closing as intended behavior.

You can use `(->* () (number? #:b number?) number?)` for the contract. Or
you could do this:

```
(->i () ([a (or/c #f number?)]
         #:b [b (or/c #f number?)])
     #:pre (a b) (or a b)
     [result number?])
```

Doesn't help with TR, of course.

​

I think I need to use `->i` here because I require one of the two arguments to be supplied, so I’d need to use `#:pre (xor a b)`. Ultimately, though...
- ...misusing `case->` should still report a useful error message.
- ...it would be nice if `case->` could handle keyword arguments (and it would also be nice if `case-lambda` could handle them, too, but that’s a separate issue) because I would imagine it would produce nicer error messages than `->i`.

Thanks for suggesting `->i`, though; I didn’t think to use it here.

Oh, I misread the part about the syntax error. I've pushed a fix for that.

I think it makes sense to try to generalize the current implementation of `->` so that it supports those case things, but it doesn't seem easy and the value seems relatively small compared to that effort so I've just never gotten to it.

I merged the two first commits, and left the last one here.

The idea for the third commit is to minimize the overhead of the immutable package https://github.com/racket/racket/pull/1341 when it's merged as a part of Racket or used as an independent package. It will add a lot of implicit `vector->immutable-vectors` everywhere. 

It's not very optimization friendly, but I think the optimizer can be improved to fix most of the spots. (And `keyword-lambda` needs some improvements too.)

Anyway, I think that marking the `vector->immutable-vectors` as ommitable as in this commit is not very useful. I think that I can write some microbenchmarks that show a big difference in the run time, but I don't imagine too many realistic programs with a big difference in run time.

I think that https://github.com/racket/racket/pull/1237 is better, because it can decrease the allocations and reduce the run time in realistic programs. But the idea is too weird, so I still prefer to wait and think about it.

Maybe it would be more useful to think of these as separate targets: 1) generating PDFs of Racket docs without LaTeX and 2) having a generally useful PDF typesetting engine in Racket. Target (1) is less flexible, but relies only on `racket/draw` (and is thus cross-platform) and target (2) has more capability, but also depends more on platform-specific services.

This change caused the following error: http://drdr.racket-lang.org/35906/pkgs/net-test/tests/net/ftp.rkt

To see it, this should be enough:

```
$ racket -l tests/net/ftp
UNKNOWN: : read (compiled): ill-formed code [../../../racket/gc2/../src/validate.c:1389]
  context...:
   (submod /home/samth/sw/plt/extra-pkgs/net/net-test/tests/net/ftp.rkt main): [running body]
```

After this commit the optimizer marks in some cases string-append as omittable, for example in

```
(lambda (x y)
  (when (and (string? x) (string? y))
     (string-append x y)))
```

If that is removed, then the ftp test pass: https://travis-ci.org/gus-massa/racket/builds/143739213

I think the problem is that the validator don't agree, because the validator doesn't check the types of the arguments. But I don't have a minimal test yet, so I'm guessing. I'll try to see if it's possible to improve the validator.

An intermediate update. I made a minimized version of _ftp.rkt_. It's difficult to recognize because the functions are renamed, and for example `thread`is replaced by a function `call`defined in the module. 

```
#lang racket/base

(define (call f)
  (display (list 1 2 3 4 5)) ;something to avoid inlining
  (f))

(define (indirect-show x)
  (call (lambda () x)))

(define (test)
  (indirect-show proc-0))

(define ignored-AA (string-append "A" "A"))
(define ignored-BB (string-append "B" "B"))
(define (proc-0) 0)

(module+ test (test))
```

To get the error I run:

```
raco make ftp2.rkt
raco test ftp2.rkt
```

I think that it's necesary to write the bycode and read it again to trigger the bug.

Any suggestions to reduce this example or aboid the _.zo_ are wellcome.

Here's a further-reduced program:

``` racket
(module ftp2 '#%kernel
  (define-values (test) (lambda () proc-0))
  (define-values (ignored-BB) (string-append "B" "B"))
  (define-values (proc-0) (lambda () 0))
  (module* main #f (proc-0)))
```

Update: The issue I had expected to work around was already worked around (for the `generic-bind` package). The regressions in `cKanren` and `seq-no-order` appear to be fixable by avoiding the empty match check if the pattern is already bounded (eg by `~once`, as @AlexKnauth pointed out).

Thanks @ryanc!
IIUC, this means we're all set for the release as far is this issue is concerned. Is this correct?

Yes, I think so. (BTW, ryanc is someone else on github.)

I agree that the problem is a mismatch between the optimizer and the validator. This problem hasn't shown up before, because the new functions are the first ones to be omittable only under certain circumstances, but also non-foldable. (All other functions that are treated as omittable are either always omittable or foldable. And when I try to construct an example with a foldable operation but non-foldable arguments, I can't do it at the level of a module definition, in part because of the `NULL` on line 7928 of "optimize.c" that is there to prevent a mismatch between the optimizer and validator.)

I think tweaking the validator to recognize `string-append` and `bytes-append` on literals would solve the immediate problem, due to many little constraints. That seems fragile, because small improvements to the optimizer could again confuse the validator, but I don't have a better idea.

FWIW, I'm certainly tempted again to throw out the validator; keeping it in sync with the optimizer has been a pain. But it has also been a valuable tool for maintaining the optimizer, and keeping the validator on all the time is the only way to ensure that it stays in sync.

Assuming @gus-massa hasn't already done it, I'll try changing the validator.

After further thought: slightly inhibiting the optimizer's decision for module-level definitions is a more direct and general repair, and it only barely affects the optimizer's results.

:)

I reached a similar conclusion and I was trying to understand more the details and fix it, but I was unsuccessful.

I agree that adding a special case for `(string-append "X" "Y")` in the validator is a bad idea. In particular, I still don't understand why `(string-append "X" (string-append "Y" "Z"))` doesn't generate the error.

I tried to trigger the bug with the other foldable functions, but again I couldn't get the error. I though that

```
(define exp2-120 (* (expt 2 30) (expt 2 30) (expt 2 30) (expt 2 30))
```

was very promising (or the version with `1073741824`), but luckily it doesn't generate an error.

This is now done.

LGTM
Also, since those identifiers were (accidentally) being exported by TR, I would recommend including this as part of the release. That way, no one can start depending on that. Any objections?

They are in fact accidentally exported by `racket` as well.

The accident started just 5 days ago, with https://github.com/racket/racket/commit/4650a123505e5cc37954c913c944c7e89166909b. These were never exported as part of a release -- so I don't think an announcement is necessary.

@stamourv the commit this fixes is not on the release branch.

@samth: Ah, no problem then.

Potentially relevant: https://github.com/libffi/libffi/issues/33

(`in-mutable-hash` and `in-weak-hash` seem fine)

@bennn Thanks for the report!

I see no problem with these changes.

A list's length is always a fixnum, because there are no encoding tricks that allow a list of length N to be represented by less than N pairs, and a fixnum can always hold the number of words (and therefore pairs) available in the virtual address space.

How about making the implementation accept path strings? That would be more flexible.

For lazy-requiring non-functions, it would be reasonable to add a keyword argument that made lazy-require "thunkify" its imports: bind the local name to a function that when applied forced the require and fetched the exported value. For example:

```
> (module lib racket (printf "running lib\n") (define x 12) (provide x))
> (require racket/lazy-require)
> (lazy-require ['lib #:thunk (x)])
> x
#<procedure>
> (x)
running
12
```

The variable-like macro idea is too much magic for my taste.

The problem was with `(-)`, because `-` has a weird combination of flags that I think is the only way to trigger a bug in my commit.

I made a PR with a fix: https://github.com/racket/racket/pull/1381

Thank for the report.

This was an easier PR to make, that's all. If we like #1382 better we can close this.

:tada:
LGTM

Okay, will merge as soon as the CI tests pass.

Merged, thanks!

Merged, thanks!

merged

FWIW, I think it is better not to swallow errors. (cf: my dissertation and lots of pain over the years in the DrRacket REPL implementation)

I personally somewhat like the magic, mostly because I almost always use `lazy-require` to help break circular dependencies, and the variable-like macro allows me to swap out a `require` with a `lazy-require/value` and not update any other code (as long as all lazily imported references are not used directly in the module top level). I’ve actually been using something like that for a little bit, which [exists here](https://gist.github.com/lexi-lambda/515c9f67de102489dbe79797dd68ea35).

On the other hand, I recognize the feeling that might be a bit too magical, given that it could be pretty unintuitive for people who don’t expect evaluation of a value to have side effects. I imagine it wouldn’t be too terribly difficult to adjust the existing `lazy-require` macro to do what you describe.

@dfeltey do you think your refactoring tool (combined with check syntax) could do the needful to insert the parens around the variable references here so that @lexi-lambda has a smooth path but using @rmculpepper 's preferred api?

(I'll also note that introducing a thunk where none was also a certain, if not magical, ethereal quality to it.)

@rfindler I think that should be possible and probably a straightforward extension of the kinds of refactorings we can currently do. Since it's basically just wrapping an identifier in a pair of parentheses all of the source location info we need should be in the syntax objects already.

OK, I've updated the PR:
- docs describe the old and new behaviours
- the code now uses `isspace` (C89, `ctype.h`) instead of directly comparing against `' '`
- (minor doc typo fix bundled in too)

@samth, look ok to you? If so I will merge.

Yes, `~or` is interpreted differently in front of ellipses, and it currently requires the attributes of the disjuncts to be distinct. I could imagine relaxing that in some cases, but it gets tricky with patterns like

```
((~or (~once (#:a x)) (~optional #:b x)) ...)
```

If you want the single-term version of `~or` in front of ellipses, you can wrap an `~and` pattern around it, like you mention above.

@LeifAndersen Thanks for doing this! Here are a few issues that I noticed:
- `racket/interactive` starts with `#lang racket`; a library module
  should always start `#lang racket/base`, instead
- `racket/gui/interactive` should also use `#lang racket/base`
- Need a cast to `(Scheme_Hash_Tree *)` on line 146 of "main.c"; there
  shouldn't be any warnings when compiling Racket on Unix
- The "config.rktd" shouldn't have to exist to get the default start
  path, and `'interactive-file` shouldn't have to be in the
  configuration table; make `'racket/interactive` the default
- Docs: scheme_make_hash_tree actually takes 0 or `eq?`, 1 for
  `equal?`, or 2 for `eqv?`; I've been meaning to add `#define`s for
  those
- In the `history` note for the REPL, use `@elem{...}` instead of
  `"..."` so that you can write `@racketmod[racket/interactive]`
  and `@filepath{.mzschemerc}` --- but
  don't write `@filepath{.mzschemerc}`, and instead use
  `(find-system-path 'init-file)`, since the answer varies among
  platforms; also, use a period at the end of the note
- The `racket/gui/interactive` module is documented in the wrong
  place; it belongs in the "gui-doc" package, and the `history` note
  there should refer to that package's version (which should be
  incremented)
- The docs should specify the symbol key expected in "config.rktd";
  consider putting that information in both the startup description
  and the "config.rktd" docs

Incidentally, I discovered this because I was using the following in a script:

``` sh
export PLTSTDERR="$PLTSTDERR debug@syndicate-broker"
exec racket server.rkt 2>&1
```

... which fails when `PLTSTDERR` is empty. This didn't seem right to me.

I would write just the current behavior, and use @history to note the change. Otherwise, looks good.

Closed by 1ba42bb70d.

@LeifAndersen Thanks for doing this! Here are a few issues that I noticed:
- `racket/interactive` starts with `#lang racket`; a library module
  should always start `#lang racket/base`, instead

Done
- `racket/gui/interactive` should also use `#lang racket/base`

Done
- Need a cast to `(Scheme_Hash_Tree *)` on line 146 of "main.c"; there
  shouldn't be any warnings when compiling Racket on Unix

Done
- The "config.rktd" shouldn't have to exist to get the default start
  path, and `'interactive-file` shouldn't have to be in the
  configuration table; make `'racket/interactive` the default

Fair enough, done.
- Docs: scheme_make_hash_tree actually takes 0 or `eq?`, 1 for
  `equal?`, or 2 for `eqv?`; I've been meaning to add `#define`s for
  those

Ah, okay, thanks. Done Also `#define`s added.
- In the `history` note for the REPL, use `@elem{...}` instead of
  `"..."` so that you can write `@racketmod[racket/interactive]`
  and `@filepath{.mzschemerc}` --- but
  don't write `@filepath{.mzschemerc}`, and instead use
  `(find-system-path 'init-file)`, since the answer varies among
  platforms; also, use a period at the end of the note

Done
- The `racket/gui/interactive` module is documented in the wrong
  place; it belongs in the "gui-doc" package, and the `history` note
  there should refer to that package's version (which should be
  incremented)

While I agree the documentation is a bit odd there, I put it there because that's where racket/gui/init is also documented. Do you think we should move that as well?

Also, I'm not sure what you mean by the package's version should be incremented? Is the gui-lib on version 6.8 rather than 6.7?

Thanks
- The docs should specify the symbol key expected in "config.rktd";
  consider putting that information in both the startup description
  and the "config.rktd" docs

Done

Thanks for the feedback.

Thanks! I added some small comments to the commits.

Good point about `racket/gui/init` docs. I do think those should move. The current version of the "gui-lib" package is 1.26.

Great, thanks for the additional feedback. Sorry about missing the period, I should have caught that. I'd be happy to move the `racket/gui/interactive` and `racket/gui/init` docs to the `gui-lib` package.

Hmm...actually, it's not entirely obvious where the best place to put the documentation for `racket/gui/interactive` and `racket/gui/init` is. Do you have any suggestions?

Actually, never mind. I just decided the right thing to do here was to create a new section.

Ok – push when you're ready.

Okay, I also added a PR to https://github.com/racket/gui/pull/37

I'll push them both as soon as the tests finish here. Thanks.

The `#:opaque` option is intended to hide all internal information about the causes of failures.

You can get something closer to the behavior you describe by wrapping the patterns (but not the side-clauses) with `(~describe #:opaque #f [ ])`. Note the `#f` is the description argument, not an argument to the `#:opaque` keyword.

Ah, that’s a decent solution—I didn’t realize `~describe` could be marked `#:opaque`. I think I still wish the behavior were different, but I’m willing to consider that a reasonable workaround.

The implementation in racket/private/sort also used an inplace vector sorting algorithm (in some cases). Should these perhaps be compared directly and then use the best one for both?  (There may be some dependency problems that make this too painful, tho.)

@rfindler I perused racket/private/sort again, I don't think there's much interesting code to be shared. They both use insertion sort as a helper for small vector subsections, but they're not very large (code wise) or complex.

I do think, however, It would be nice at some point to use (pretty much verbatim) the code in racket/private/sort to implement and provide a `vector-stable-sort` function from racket/vector (at which point `sort` could be defined in terms of the internal implementation of `vector-stable-sort`).

The non-uniformity between list and vector sort re stability is unfortunate. Is there no way around it?
As is, if someone switches from using lists to vectors in their program, its results may change. And with generic sequences, where your code doesn't even know/care whether it's processing lists or vectors, that would be even more surprising.

The solution to this is to provide a vector-stable-sort.

It's unfortunate that stability was baked into the spec for the one and
only standard list sorting algorithm.

On Wed, Jul 27, 2016, 8:45 AM Vincent St-Amour notifications@github.com
wrote:

> The non-uniformity between list and vector sort re stability is
> unfortunate. Is there no way around it?
> As is, if someone switches from using lists to vectors in their program,
> its results may change. And with generic sequences, where your code doesn't
> even know/care whether it's processing lists or vectors, that would be even
> more surprising.
> 
> —
> You are receiving this because you authored the thread.
> Reply to this email directly, view it on GitHub
> https://github.com/racket/racket/pull/1398#issuecomment-235573685, or mute
> the thread
> https://github.com/notifications/unsubscribe-auth/ADfg6qZNIxHUhSIv-2mYAAZJNNtADjFpks5qZ1LNgaJpZM4JVw0b
> .

I can port the vector-based stable sort over to racket/vector today if
people feel this is important.

On Wed, Jul 27, 2016, 8:54 AM Andrew Kent sgtamk@gmail.com wrote:

> The solution to this is to provide a vector-stable-sort.
> 
> It's unfortunate that stability was baked into the spec for the one and
> only standard list sorting algorithm.
> 
> On Wed, Jul 27, 2016, 8:45 AM Vincent St-Amour notifications@github.com
> wrote:
> 
> > The non-uniformity between list and vector sort re stability is
> > unfortunate. Is there no way around it?
> > As is, if someone switches from using lists to vectors in their program,
> > its results may change. And with generic sequences, where your code doesn't
> > even know/care whether it's processing lists or vectors, that would be even
> > more surprising.
> > 
> > —
> > You are receiving this because you authored the thread.
> > Reply to this email directly, view it on GitHub
> > https://github.com/racket/racket/pull/1398#issuecomment-235573685, or mute
> > the thread
> > https://github.com/notifications/unsubscribe-auth/ADfg6qZNIxHUhSIv-2mYAAZJNNtADjFpks5qZ1LNgaJpZM4JVw0b
> > .

I don't think it is unfortunate that stability is part of the spec of the built-in `sort` function. I think it is the right default.

I also agree with @stamourv that vector-sort should be stable. Perhaps you want to add a `vector-unstable-sort` function?

_Skippable, possibly unneeded tangent:_ IMHO, if stability is a part of the correctness criteria of your program (or is desired for some other reason), (1) it should be made explicit and call a function named something like`stable-sort` rather than eliding that detail and allowing someone to unknowingly introduce a subtle bug at some point in the future, and (2) users who do not require stability should by default get a faster sort that uses less memory -- obviously different languages (and people) have different opinions about this =) (a perusal of respectable languages sees both defaults, for example).

Perhaps Racket---in specifying in the docs that `sort` is stable for quite some time now---has _already_ committed to `*-sort` functions being stable by default?

Anyway, that's all I've got to say about that and I'll shut up =)

So then, how does the room feel? Would people be most happy if `vector-sort` is a stable sort and the standard library also provides `unstable-sort` and `vector-unstable-sort` as list/vector sorts which provide no stability guarantee but are free to attempt to work in less space and be faster in general?

If that's the case, I'll go ahead and change this PR to just be the unstable-sort additions, and the stable `vector-sort` will be a different PR.

Your argument "if something is part of the requireents for correctness, it should be explicitly documented" along the lines you write suggests that we should write "safe-will-signal-an-error-on-non-numbers-+" instead of "+" and other such abominations.

I think sort stability and throwing an error when trying to add non-numbers are apples and bananas. To each there own fruit I suppose.

(in reality it is a judgment call exactly what guarantees get put into what primitive operations in a language design. It is my judgment that stable sorting is a good choice and my main evidence for that is that large number of subtle bugs that have crept in due to hash-table ordering implicit dependencies. My guess is that unstable sorting would also tend to produce such subtle bugs.)

Fair enough =)

Your comments did not seem to be specific to sorting in any way. 

The comments were not meant to be only about sorting, but were _also_ not meant to be a universal truth equally applicable to all program features =)

Anyway! I am happily making this PR implement `vector-unstable-sort` -- thanks for all your feedback and insight. It is much appreciated.

> I perused racket/private/sort again, I don't think there's much interesting code to be shared.

This is a weird thing to say, given that the private/sort converts lists to arrays for sorting:
- For the `vector-sort` case, using private/sort would be very easy:
  - the trivial 0/1 cases are the same
  - the `cache-keys?` case needs different (and simpler) conversion steps
  - the already sorted case is also similar except for a different (simpler) loop
  - the <=3 case could be implemented with almost the same code (I'd use an internal macro which abstracts over pulling the values with car/cadr/caddr and over the constructor for the result)
  - and the last case is also similar with a different (simpler) pre/post conversion bits
- Related nit: regardless of how it's implemented, it's wrong for a functional `vector-sort` to be documented as "returns a new vector".  Instead, the documentation should just say that it does not mutate the input vector — this way it is still possible to return the same vector in case it's already sorted.
- I'm guessing that you'd have hard time beating the performance of the result of doing this.
- For `vector-sort!` the story is probably different — both due to very different performance when you can mutate the input, and also because of the human factor that makes it something that is rarely used (in racket).  Therefore, a practical approach might be building on the above to keep it simple, and on the conversion back to an output vector simply bang the elements into the input vector.  It will probably be slower, but probably not as much, and possibly within a factor of "hukairs" given that it's the destructive version.  Or have some traditional destructive (but stable) sort done in that case.

> They both use insertion sort as a helper for small vector subsections, but they're not very large (code wise) or complex.

The code is not too large, but the result of compiling it is pretty big since a few different versions are compiled to make it perform better, and it takes care to optimize some common cases in a jit-friendly way.  That part of the implementation is much trickier than the actual sorting, so IMO is's definitely worth it to avoid doing it all from scratch.

As for the stability issue:

> allowing someone to unknowingly introduce a subtle bug at some point in the future

The thing is that a stable sort is _unsurprising_, or IOW, it's more defined, and therefore it cannot introduce subtle bugs.  It's the other direction (having an unstable sort) that can lead to subtle bugs.

The main challenge is speed, and when I looked at a whole pile of sorting algorithms, among the generic ones (ie, not very specialized ones like radix sort) the runtime cost was negligible to non-existent.

Finally, an even bigger reason that the plain `sort` is stable (and explicitly so!  IIRC, the previous might have had both a sort and a stable sort) is that it's common across the scheme and the bigger lisp world to have stable sorts.  And the reason for _that_ is similar to what Robby said: a stable sort is more defined, and therefore less surprising, and therefore a better default.

---

(BTW, `i≤` is easy to confuse with `i<=` so IMO it's over-unicoded.  Also, the `while`s make my eyes tear.)

> Related nit: regardless of how it's implemented, it's wrong for a functional vector-sort to be documented as "returns a new vector". Instead, the documentation should just say that it does not mutate the input vector — this way it is still possible to return the same vector in case it's already sorted.

I'm worried bout this possibility. If it's an immutable vector, I don't mind that the result is the same vector. But if it is a mutable vector I think that the possibility of returning the same vector can be confusing. (If the input vector is immutable but not sorted, should the return vector be immutable?)

(This is not a problem with lists, because lists are always immutable.)

For example, is this code correct?

```
;imagine something like a genetic algorithm
(lambda (make-new-generation old-generation)
  (define new-generation (vector-sort old-generation > #:key points))
  (vector-set! new-generation
               (sub1 (vector-length new-generation))
               (mix (vector-ref new-generation 0)
                    (vector-ref new-generation 1))))
```

I think it makes the most sense to have functions that return mutable datastructures be clear about when they return the same (in the sense of a mutation in one will mutate the other) vector.

Here's the initial performance I'm seeing sorting lists with the vector-backed `sort` and `unstable-sort`:

https://gist.github.com/andmkent/71e4ada23d8e221ab254f07b68869546

So yah, not hugely different (some of the improvement are a few things I could tweak in private/sort as well).

whoops (didn't mean to close -- buttons are so clickable =)

@gus-massa

> I'm worried bout this possibility. If it's an immutable vector, I don't mind that the result is the same vector. But if it is a mutable vector I think that the possibility of returning the same vector can be confusing. (If the input vector is immutable but not sorted, should the return vector be immutable?)

This would only be a problem when you're mixing mutable and immutable things...

> For example, is this code correct?

... as in this example, where you're using the functional `sort` but then expect the result to be a copy and therefore fine to mutate.  But yeah, there's a point, so maybe it should also say that it (`sort`) always produces an immutable result and that makes it possible to return the input in case it's sorted and immutable.  (I'm thinking about a loop that keeps sorting the same thing which is already sorted.)

But in any case, that was a minor nit.

@rfindler

> I think it makes the most sense to have functions that return mutable datastructures be clear about when they return the same (in the sense of a mutation in one will mutate the other) vector.

So I think that the above should work for this.  The thing that seems wrong to me is to guarantee a fresh copy, since there are plenty of cases where you're sorting a list that can already be sorted, so it's a big win to allow retuning it without copying it.

@andmkent

> Here's the initial performance I'm seeing sorting lists with the vector-backed sort and unstable-sort:
1. I don't know how you measured it, or which versions you compared, but some of these numbers seem wrong.  For example, there are large differences in the sorted section, where the two should have the same behavior (since they both should test that the input is sorted).  But in any case, if you take from this that the difference is minor enough to not keep an unstable version then I'm happy.
2. However, the first point was more important: I think that this is a case where it is much better to keep a single version of the code.  Not because the sorting code is complicated, but because stuff around it (as the multiple precompiled-via-macro versions, and the unsafe bindings) are very important since that's where most of the optimizations happen -- and it's not trivial and it's likely to change with things like new optimizations and jit strategies.

This issue appears to have been introduced by fc345ed249c7393bce77b31f5f5812d487ef6958, given that I cannot reproduce it before that commit.

There is still some tidying up to do, obvious bugs/typos to fix, testing, etc... but I just wanted to push now to show how I have shared the sort and unstable sort code to get any feedback on that aspect (i.e. the general layout of sort.rkt if anyone wanted to look at and comment on that).

Merged, thanks!

Merged, thanks!

@stamourv ping, can we merge this and close #1378 ?

It looks fine to me, but I'd prefer if @mflatt or @rmculpepper could comment.

Looks good to me.

I see no problems, and I agree that this is the better alternative

thanks! https://github.com/racket/racket/commit/ba8b848f9425e385b5c698a1d14018d8ec369929

we like #1382

@rmculpepper ping, can you proofread (or close this & make your own change) ?

Looks good to me.

I added docs, but I rewrote them to be more precise about what `this-syntax` can produce and to emphasize that `#:auto-nested-attributes` is deprecated.

Wonderful; thank you. :)

After tinkering around with different options a bit, I decided for now to just put a vector front end on the code already in private/sort.rkt, which adds `vector-sort` and `vector-sort!` to racket/vector.

(just fixed a typo and deleted a file I didn't mean to add -- I believe it's ready unless more tweaks are desired from the general audience)

LGTM

I think it would be good to go back and make sure that the changes in the diff are all substantive (i.e., no reformatting changes). If the reformatting is important, maybe make it a separate commit? 

Just in general, when going back over the history of some file I find it very very helpful to correlate certain version and certain changes with specific lines when I'm trying to figure out what's going on and when there are lots of whitespace changes, it makes it very difficult to do that effectively.

I'll see if I can tidy up sort.rkt w.r.t. white space. I was trying to stick with DrRacket indenting defaults but the file was indented in a way to minimize right creep... I need to work on my white
space foo.

Thanks. I know it is a pain to keep this old, crappy whitespace around.

Merged, thanks!

I don't think that's intentional. It's probably an accident due to fallbacks having been added later on.
Would you like to try filing a PR for that?

Sure, though it may take some time (I'm not sure if I'll have time this week).

No rush. Thanks for spotting this!

Fixed by e3ae0103af8b152d37d19a36f6ec15abb3887280.

I would also recommend improving (though I will not attempt it myself) the error message that arises when you try to use a `#lang foobar` and no reader is found:

``` text
standard-module-name-resolver: collection not found
  for module path: racket/foobar/lang/reader
  collection: "racket/foobar/lang"
  in collection directories:
   /path/to/Racket/development/collects
   ... [207 additional linked and package directories]
  no packages suggestions are available .
```

I understand that Racket looks in two locations for a reader — `(submod foobar reader)`, and then `foobar/lang/reader` — so this error message is not wrong. 

But here's the problem. Let's suppose you're trying to make a `reader` submodule for your language and you goof it up somehow, e.g., you misname your `reader` submodule as `rader`. This is the error message you get, which suggests that your problem has something to do with a file you haven't made (and indeed, the `lang` subdirectory is now something of an obsolete technique). 

In my experience, you see this error a lot when you're starting out with languages in Racket, and it is confusing. The failure to find a reader would ideally have its own special message, not just a generic error from `standard-module-name-resolver`, for instance:

``` text
#lang: no read-syntax function provided
  for language: foobar
  by either (submod foobar reader)
  or foobar/lang/reader
```

(per discussion with @mflatt and @LeifAndersen)

Mostly looks good to me. Although do you think it would be a bad idea to keep some of the information about the legacy way to do it in there? (Maybe with a note saying that is legacy?)

Otherwise it looks great to me.

> bad idea to keep some of the information about the legacy way to do it in there?

Fine with me, I just didn’t know whether the `foobar/lang/reader` approach is now considered alternative, obsolete, or deprecated. AFAICT it’s something that was necessary only because submodules hadn’t been invented.

(Can this PR be closed, given that it looks like the relevant commits have been merged?)

I found myself wanting this today, is there any hope for revival?

There shouldn't be any white space changes for the sake of white space changes in the second commit now. The first commit moved an encompassing "(let () ..." to be on it's own line so the body of the file had sane indenting defaults even with the no-indenting style the top of the file uses (without moving the let, every time DrRacket attempts to place the cursor in the correct place it was way off, and that got real old real quick -- I think the current spacing is a nice compromise)

@howell: can you say more about the model where you found you needed it and why you needed it?

I am getting even more hesitant to add it because it is a performance maintence burden in the future and it doesn't seem like it translates well into something you'd typeset in a paper. So I'd like to hear more about why you wanted to use it to better understand why it seems useful to you.

Oh: and I just now noticed that this isn't on the redex repo. @samth: do you know if that's fixable?

And one other request for @howell: would it work for your usecase if the poisoning was syntactic instead of dynamic? So if one metafunction calls a poisoned one, then it wouldn't be cached, but otherwise it would (use the current-cached-metafunctions parameter)?

https://github-issue-mover.appspot.com/ is the best thing you can do for
moving issues.

Looks like it requires authorization. Is that something we can revoke after doing the move?

Yes, you can.

Okay, that didn't work. How do I deauthorize it?

In your github settings.

My model is pretty similar to STLC. I wanted something like this when I implemented type inference to generate fresh type variables. I don't think `variable-not-in` is suitable because I want the variables to be unique even across parts of the term I don't currently have a handle on. My next thought was to have a `fresh` metafunction that uses racket `gensym`, which is when I posted here. Ultimately I wound up calling out to gensym without going through a metafunction.

And to answer the other question, I think a static/syntactic approach would suffice.

I wasn't sure that I'm looking at the right thing, so I ended up going to your repo, so this is based on what I see there, after commit 33307ab.  (Also, this came out very long, I think that it's better to start from the existing file and add the new functionality instead of trying to backtrack things.)
1. You added a dependency on `qqstx.rkt`, which looks fishy to me.  All of the uses of `#`` and `#,` are simple enough to be easily eliminated.  Having minimal dependencies was important to be able to use sorting early enough, so I'd try to avoid adding dependencies even if it looks like it works now.  (More on these uses below.)
2. "note, these are the raw interfaces to --- user-facing definitions" -- something's wrong with this sentence.  Maybe there's a missing `sorting` before the `---`?
3. You dropped the "Note that there is no error checking on the arguments" comment, which seems wrong, since the new code still doesn't check things (and more on your keyword arguments later).
4. The code is still shifted by two spaces.  I've seen your description of this being a compromise, but the result that Robby is complaining about is that by default this commit looks like the whole file is rewritten.  (The reasons for the weird indentation is that the `define-values` and `let` expressions are kind of global annotations for being able to use local macros that are not needed in the resulting zo after expansion.  Whether that is a good idea or not is an unrelated discussion...)  (Another unrelated discussion is how DrR indents these -- it looks like it's aligning each `(define` with where it thinks it should be wrt the surrounding expression rather than adopting the preceding `(define` which is what Emacs does -- that's probably the source of the editing annoyances.)
5. `;; end of module` at the end is redundant.
6. You've kept my helper definition of `define-syntax-rule`, but there's a bunch of macros that should use it instead of the more verbose form: `sort-internal-body`, `precomp`, `list-sort-body`, `vector-sort-body`.
7. A repeated conception mistake (IMO!) that I see is seen in `sort-internal-body`: you define a pattern with a `#:maybe-key` "keyword argument".  But this is not a keyword argument, just part of a pattern that must appear exactly in that place.  This is even worse when there are more than one of these things.  So (again -- IMO) it would be much better to drop it to avoid confusion that these are keywords in the usual sense.
8. Also, there are macro uses that are not needed.  An example of this is the `<?` helper: in your version you're using a nested (unquoted) macro code to apply key or not -- compare that with my version that just has plain code that is wrapped in a `(if has-getkey? ...)`.  The idea is to let the Racket optimizer deal with the fact that `has-getkey?` is a literal that is known at compile-time.  I've spent considerable time making these things work, so in general I think that you should be very careful in removing them only if you know what it's doing now, and that the optimizer indeed fails on some things that require using more complicated macros.  (I'm guessing that in this case there's no need for the more complicated code.)  That's the complex part that I was referring to earlier, BTW.
9. Also, in the same dept as changing the indentation, you have lots of litte name changes, like `n` → `index`, `v` → `A`, and more.  (My naming scheme was intentional, BTW, I intensly hate long-but-trivial names like `index`.)  I'm no longer maintaining this code -- but if you want to be in that position, then I think that it would be much better to have a bunch of no-op commits.  For example, one commit that will only change the indentation, and another that will change the names.  (But only if you want to become the parent of this code...)
10. There is a new `swap!` macro definition that is not used at all.
11. Then there's `let*` for `n/2-` and `n/2+` which is at a weird place (and a redundant change from my code, again), with a comment above it that is now duplicated from the one left at the beginning of the file.
12. Then you swapped `copying-insertionsort` and `merge` for some reason (more unnecessary changes).  (BTW, not that at this point you're already way more indented than my code -- due to various things mentioned above.)
13. As a side-note, I also dislike big ";; Foo" comments that precede a "(define foo ...)" without adding more information.  (You're actually reducing information from `copying-mergesort` to `Mergesort`.)  Also, `start the sorting!` is kind of a similarly redundant `main body` comment.
14. Another reundant change is `(i>> n 1)` → `(i/2 n)` (in the same spirit as above, I'd categorize this in the renames dept).
15. The `for standard data types` comment is misleading -- it sounds like implementing sorting for multiple types of sequences, but it's only for multiple types that are being sorted over.
16. You've added a bunch of precompiled sorts there -- any reason?  I was specifically stingy on these since they'd all generate code in the zo, so I wanted to keep it minimal, and have it resort to the usual runtime in exceptions.  For example, I avoided `char`s since IME sorting a list of characters is extremely rare in practice.  For the same reason I avoided the `string>` variants.  Are you sure that you want to add them?
17. You're converting the whole thing into an immutable hash table at the end -- did you time it and it was faster?  Otherwise this is mutability in a place that is not user-visible, so speed should be preferred.
18. I don't get the point behind `generic-sort` and `generic-sort/key`.  All they seem to do is translate the old no-keyword style to the new "keyword-like argument" style.  And if so, then the keywords are not doing anything at all (besides making the code hard to read...).
19. The `if we know statically` comment seems to be something that you wanted to do but didn't...  That `syntax-case` is always going to end up in the second branch.  (BTW, it looks like what you wanted to do is again something that the racket optimizer is better at doing, as in the above case.)
20. You lost the `(< n 2)` case??  Instead, you check it in the `(i<= n 3)` case where it couldn't happen (since it's always sorted).  (And, of course, you end up redundantly checking that it's sorted...)
21. You've moved/copied the `<?` helper further down which makes for more indentation -- it's a macro so there's no need for that (other than, I'm guessing, macro-based optimization that racket could do).
22. In the `General note` comment I had some clever comment that Jay took on and implemented a macro-expanded sort, it would be a shame to lose it.  (Also, you have a case of a bunch of trailing spaces at the end of that comment block.)
23. Comment about _my_ code: looks like I ended up with a duplicated `let` for the same bindings (`([a (car lst)] [b (cadr lst)] [c (caddr lst)])`).
24. Ummm...  So I reach the end of this, and I see that there's nothing on vectors, and then I see that the next section duplicates a bunch of code...  I'm too tired to follow that, but my intention in one of the earlier comments was to use the same toplevel function to deal with both cases instead of duplicating it.
25. Also, I didn't check the current code, but at least in the PR it looks like you copied the sorting tests to the vector tests.  I think that it's better to create a new test suite that will do both at the same time -- just run each test once as a list and once as a vector.

Ah, yes. That can be problematic. In this particular case, however, you do not need the "poisoning" aspect, right? It would be enough to simply disable caching for the one metafunction that creates the fresh variables?

Also: did you consider using `#:binding-forms` ?

I don't have much free time to tinker with this any more and I've made due without it for my own purposes. I'd be happy to make some minor changes at some point in the future, but if it's nowhere near what we want for Racket's standard `vector-sort` then someone else is welcome to tackle the need when they see fit (starting from this code or from scratch, whatever is easier).

@elibarzilay -- IMHO, using the inlined commenting feature that Github provides is very helpful when you have comments about specific places in code.

> Ah, yes. That can be problematic. In this particular case, however, you do not need the "poisoning" aspect, right? It would be enough to simply disable caching for the one metafunction that creates the fresh variables?

In my case the metafunction would only be called from the type judgment, so I believe this is correct.

> Also: did you consider using #:binding-forms ?

I belatedly wondered if using this might have made things work out right auto-magically. I'm not very familiar with it, though (I haven't used it in a model yet). I'll take a closer look and see.

After perusing the docs, I'm not sure `#:binding-forms` will help me because there is no binding form for type variables. (This is STLC).

Why do you need variables to type check STLC?

for type inference.

We're a bit off topic here, but STLC doesn't require inference. Anyway.

I made some comments. Can you also look into putting in tests?

@jeapostrophe Your option #2 for testing: "Fake a proxy server" will take a short while to complete, but I'm on it.

I've updated this to add optional `#:newline?` keyword arguments to `pretty-print`, `pretty-write`, and `pretty-display`. I'll add documentation once the `make` is done.

Maybe in the docs point out that passing `#t` means that `printing-port-print-line` isn't called with `#f` any more?

What do you mean? It isn't being called at all, in my current code...

I see what you mean, okay.

Yeah: I just mean that in addition to the high-elvel description of the new argument, also include the technical note as to how it changes which callbacks are called back.

Thanks for this, btw.

Does that documentation look good?

It's a bit weird because the `#:newline?` argument determines whether `pretty-print-print-line` is called, but `pretty-print-print-line` doesn't always print a newline. I'm not sure what to do about that though.

Generally these functions don't accept booleans, but accept `any/c` and treat non-`#f` values as true (eg `pretty-print-show-inexactness`).

I think the convention for documenting such things is to write "a true value" and "@racket[#f]", but I see a few other places in those docs where that convention is violated.

The sentence "If it is supplied with false, the @racket[pretty-print-print-line] callback is not called." doesn't seem right. I think it is just not called with `#f` anymore, but it is still called on all the other line breaks.

Also the second paragraph of `pretty-print-print-line`'s docs needs adjusting.

I meant that it's not called for the last newline, which the previous sentence mentions, but you're right, it's not clear.

I've modified it to clarify that if `newline?` is supplied with false, the `pretty-print-print-line` callback is not called after the printed value. I don't want to confuse people by saying "not called with false".

That is better, I agree.

Logically, it's good to think of it as a boolean, and if we ever want to put a third setting in there, like `'just-internal` or `'just-end`, it might be better to document it as a boolean for now. Does it make sense to leave it as `boolean?` for that?

In that case,  you'll want to add a check?

One further note... The test cases don't cover “exotic” SSL installations (win32, OSX, OSX old). I haven't the hardware to test that.

Okay, I've added the check

Does this look good now?

Commits 1bfa0c5292679ec66271839417eb5afb8b1c7098 and
203dbf78d9deb3999a8eea236410b55a6d8f4456 look good to me, except that I
don't see any test suites. I didn't look over the others.

Robby

Oh, right. Where are the pretty-printing tests?

Grep suggests pkgs/racket-test-core/tests/racket/pretty.rktl.

Tests look good to me.

For some reason they error on my machine

```
Section(namespaces)
Section(collects)
Section(modprot)
ERROR: UNKNOWN::79: read (compiled): ill-formed code [../../../racket/gc2/../src/read.c:5585]
```

But they're passing on Appveyor and Travis

It's possible that something weird is happening with my compiled files, since I've been working with both a snapshot version a few weeks old and the git HEAD version. So should this be merged?

It is okay with me to push those three commits (although do you see a
reason not to squash them?). Do you want me to do it?

I don't have push access. So this shouldn't include the re-formatting stuff?

I think I see why this problem will happen at the end of `raco setup`, and I'll get a repair in place. Meanwhile, if I'm right about the problem, then your build otherwise completed and should work ok. You should be able to install the the "racket-lib" package to avoid the error happening again.

Thanks for the report!

thanks for the quick response :) I will try it later

Just to make sure, does your program include the `scheme_register_tls_space()` that's needed specifically on Windows?

I have to admit the I missed that...sorry for my impatience.I changed the main function to:

```
int main(int argc, char *argv[])
{
    static __declspec(thread) void *tls_space;
    scheme_register_tls_space(&tls_space, 0);
    return scheme_main_setup(1, run, argc, argv);
}
```

But similar exception thrown when I add a commandline arguments "(display \"123\")",

Looking again at the error message, I see that it says "libracket3m", but you meant to link to the CGC variant of Racket, which is the one without "3m" in its name. Does changing your program's linking help?

I looked for this one but failed to find it. Good job!

that's it :) what a fool I am. Sorry for bothering you with such a stupid problem.

Sorry Tim, there's now a conflict because Tony fixed an error around the same code that you touched. Once that's fixed I'll merge this in.

Thanks Jay

On Mon, August 15, 2016 2:37 pm, Jay McCarthy wrote:

> Sorry Tim, there's now a conflict because Tony fixed an error around the same
> code that you touched. Once that's fixed I'll merge this in.
> 
> ## 
> 
> You are receiving this because you authored the thread.
> Reply to this email directly or view it on GitHub:
> https://github.com/racket/racket/pull/1411#issuecomment-239803558

## 

Tim Brown | Mobile +447771714159

No problem – glad it's working!

After doing a tiny bit of digging, it looks like `expr/c` just defers to `wrap-expr/c` from `syntax/contract`, which produces a syntax object that uses the `contract` form directly. Because of this, the wrapped expression’s value is the positive party, which causes the aforementioned error message.

I personally think that the behavior should be reversed—that is, blame parties should be swapped when using `wrap-expr/c`. However, this is a little bit tricky, because it could be wrong depending on how the macro uses the value. For example, something that expands into a _definition_ (that is, something that is semantically similar to `define/contract`) would want the current behavior, but something that uses the expression as a _value_ (all the cases I’ve used `expr/c` so far) would want the blame to be swapped.

Therefore, it seems like this is something that should probably be exposed to the user, but I’m not completely sure how to do it. @rfindler and @rmculpepper, do you have any suggestions?

I don't know the right thing here, but a recent paper (mostly written by @chrdimo) captures the right way to think about this kind of problem well, in my opinion:

  http://www.eecs.northwestern.edu/~robby/pubs/papers/icfp2016-dnff.pdf

I did read that paper a couple days ago (and it was very interesting 🙂), and I just looked over it again. I’m not completely sure if you had a specific part of it in mind related to this or if you would just generally recommend it.

I think the key part here, though, is that macros that expand into expressions can act conceptually like functions. That is, in a (somewhat silly) macro like this one:

``` racket
(define-syntax-rule (prefix-hello str-expr)
  (string-append "Hello, " str-expr))
```

…the provided expression is used in a way that a user would likely conceptualize as similar to function invocation. Obviously, the above macro would be better as a real function, but some more complicated macros use expressions in similar ways (such as [monadic `do`](http://docs.racket-lang.org/functional/interfaces.html#%28form._%28%28lib._data%2Fmonad..rkt%29._do%29%29)).

Other macros, however, use expressions in ways that are _not_ “function-like”:

``` racket
(define-syntax-rule (with-strings ([id expr] ...) body ...)
  (local [(define/with-contract id string? expr) ...] body ...))
```

In this case, the contracted expressions are bound to identifiers rather than used as part of an internal expression. An equivalent implementation to the above macro that uses `expr/c` would want the current behavior, not the “function-like” behavior described above.

This isn’t something that can be detected automatically, since it’s impossible to know how a particular expression will be used, but I think the current behavior often misaligns with a user’s conceptual model (or at least it does with mine). I’m just not sure if the behavior should be controlled by yet _another_ keyword parameter or if it should be something else (and I’m also not sure what the correct default should be).

LGTM

Thanks!

Pushed a fix to the `pict` repo. If you update your installation of the `pict` package, the problem should go away.

Looks good, but could you de-indent the body of with-disappeared-uses to minimize the "changed" lines? Or introduce a helper function (`do-template*`?), if misindented code would bother you.

There's a preliminary version at https://github.com/rmculpepper/iracket. See the README for installation instructions. It is not quite ready as a package because it needs some changes to the zeromq library, and I haven't had a chance to deal with those yet.

@rmculpepper Yep, that makes sense; I’ve de-indented the body.

I didn't check over the formatting stuff. I can see how, tho, in this case my usual objections to formatting changes don't apply (this is old code that is almost never touched so the lost 'git blame' information is minor compared to the readability).

Thanks, I've pushed the commits (except that I combined the three commits that were all pieces of the same change)

Jay, did Tony’s fix get merged in?

Yes, his is merged, so now your pull has a small conflict.

sick. thanks. i love it when stuff works!!

Jay, so what? do you need me to resolve the conflict?

Yes, I can't merge the commit because of it.

Jay, when you have a mo ;-)

Thanks so much!

Bumping this… though I’m not completely sure who would be the best person to review these changes. @mflatt, could you perhaps take a look?

These look like good changes to me

Were the multiple merge commits really necessary here?

LGTM

LGTM

I didn't know that this function exists.

@stamourv, "optimization-coach" has the only use of `syntax->string` that I find. Ok with you?

Thanks! Should I now make pull requests to use this in `errortrace` and `2d`?

that would be great, thanks!

This needs documentation, then I'll merge it.

Yes.

This appears to be a bug in the docs for the "grommet" package, which has

```
  @declare-exporting["../../crypto.rkt"]
```

I think it must be a leftover, because the path doesn't make sense relative to the ".scrbl" document in its repo, much less in the rendered documentation.

(The "Hash" and "HMAC"  sections have good `defmodule` declarations, so the `declare-exporting` form applies only to the "Base64" section.)

I have just send a PR to the package to fix this. https://github.com/RayRacine/grommet/pull/7

Looks like `test/no-error` is strictly worse than `test/spec-passed` to me.

Thanks: 

https://github.com/racket/racket/commit/07718022b4815b774b8c04a5ccd6e747ee4a25c1

https://github.com/racket/racket/commit/2e5b4a65150afc9517d5e344aaa6abaa63751e91

Shouldn't we be able to have this in the stack trace, rather than in the message?

Why does this say `match-let-values` when there is no `match-let-values` in
the program?

@rfindler it seems match-let is defined in terms of match-let-values in a way that causes this to happen

You make it sound like this isn't software or something. You know we can
change programs to make them do what we want, right?   :)

In this case, one might have both match-let-value and match-let expand into
a third form that accepts a "name to use in error messages" argument or
something like that.

@rfindler I couldn't agree more. Are you suggesting that I add that fix to this PR? Or that I submit another one to fix that issue next? I'm not sure what you're suggesting with that comment TBH =)

I had interpreted this PR as coming from a desire to fix the error message associated with match-let and was pointing out another way that it was wrong. Your time is your own, as far as I'm concerned and I'm grateful for whatever contributions you choose to make to Racket. Sorry if I stepped over the line.

@rfindler I used match-let here, but in practice the (avoidable) lack of location information is a frustration with _every_ match form (they all use the same internal code eventually). I agree with your suggestion that it's dumb for it to report an error for `match-let-values` in this case, but I'm still developing a feel for how narrow/broad PRs to `racket` should be and wasn't sure what would be a better approach for the issue you mentioned. It's a trivial fix I'm happy to do, I just wanted to clarify if you thought it fit in this PR or should appear in a different one.

@samth pointed out that `class` has a similar issue to deal with. I'm changing the match message to look more like theirs.

now the error message looks more like what `class` does in similar circumstances (where a dynamic error can provide precise source location information):

``` racket
% racket foo.rkt
match-let-values: no matching clause for 42
  location: foo.rkt:3:0
  context...:
   /Users/amk/Repos/plt/match-error/racket/collects/racket/match/runtime.rkt:24:0: match:error
   /Users/amk/Desktop/foo.rkt: [running body]
```

I'll address the match-let-values issue in another PR.

That's a surprisingly easy change! What are the other srclocs in that list?

that's the only entry in the list -- match:error is given the result of syntax-srclocs

which is defined here:
https://github.com/racket/racket/blob/master/racket/collects/racket/match/runtime.rkt#L64

and called here: 
https://github.com/racket/racket/blob/master/racket/collects/racket/match/gen-match.rkt#L43

I think this is the wrong approach, but I'm disagreeing with with the racket documentation here. (https://docs.racket-lang.org/reference/exns.html?q=exn#%28part._err-msg-conventions%29)

There already is [prop:exn:srclocs](https://docs.racket-lang.org/reference/exns.html?q=exn#%28def._%28%28quote._~23~25kernel%29._prop~3aexn~3asrclocs%29%29) which exceptions must set to get good integration with DrRacket (link to the problematic code). The issue is that the error display handler in the command line program doesn't display it.

Previous discussion:
http://lists.racket-lang.org/dev/archive/2014-March/013988.html

I currently have a custom error handler which deals with this nicely enough for me and never got the time to improve it and push it upstream.

```
(let ((old-error-display-handler (error-display-handler)))
    (error-display-handler
      (λ (str exn)
        (when (exn:srclocs? exn)
          (for ((srcloc ((exn:srclocs-accessor exn) exn)))
            (displayln (source-location->string srcloc))))
        (old-error-display-handler str exn))))
```

The solution @endobson suggests does seem nicer.

In the meantime, though, this change would be extremely useful and is in line with what `class` does today.

The docs for the new functions should have a `@history` annotation saying when they were added. Otherwise, looks good to me.

# Rationale / usage example

This would help when developing complex pattern expanders. For example, I am writing a few pattern expanders which allow matching clauses in no order, with restrictions on what combinations of clauses are possible:

```
(~no-order (~optional (~and a #:a))
           (~optional (~and b #:b))
           (~optional (~and c #:c
                            (~post-fail "Can't use #:c and #:a" #:when (attribute a))
                            (~post-fail "Can't use #:c and #:b" #:when (attribute b))))
           (~optional (~and d #:d)))
```

The above expands to:

```
(~delimit-cut
 (~and (~seq (~or (~optional (~and a #:a))
                  (~optional (~and b #:b))
                  (~optional (~and c #:c))
                  (~optional (~and d #:d)))
             ...)
       ~!
       (~fail #:when (and (attribute c) (attribute a)) "Can't use #:c and #:a")
       (~fail #:when (and (attribute c) (attribute b)) "Can't use #:c and #:b")))
```

My implementation works by lifting the `~post-fail` patterns outside of `(~seq (~or . pats) ...)`. To achieve this, the `~no-order` expands its contents. When expanded, a `~post-fail` calls a dynamically scoped function set up by `~no-order` to register the post-check.

This is however not possible currently, as `syntax/parse` does not export some version of its [`parse-single-pattern`](https://github.com/racket/racket/blob/471f37158a1b8dba4293d0462fdc1826c11aeeab/racket/collects/syntax/parse/private/rep.rkt#L419) and [`parse-head-pattern`](https://github.com/racket/racket/blob/471f37158a1b8dba4293d0462fdc1826c11aeeab/racket/collects/syntax/parse/private/rep.rkt#L423) functions (there should be some kind of `parse-eh-pattern` too)

For now I am using in my implementation a custom expander, created using @jackfirth's [generic syntax expanders](http://docs.racket-lang.org/generic-syntax-expanders@generic-syntax-expanders/index.html), which solves the problem, but this could be a useful feature in other cases.

For reference I think this is the last discussion on this issue: http://lists.racket-lang.org/dev/archive/2014-March/013988.html

Merged, thanks!

Maybe it would be sensible to add a `(~either a b c)` pattern, which would be equivalent to `(~and (~or a b c))`? Or maybe name it `~xor`?

Even if it's not part of the library, I'm open to naming suggestions as it is already in my `phc-toolkit` library (albeit undocumented for now) under the sub-optimal name `~or-bug` :)

(Just wondering, have you seen the [seq-no-order](http://docs.racket-lang.org/seq-no-order/index.html) package?)

@AlexKnauth I had forgotten about it, thanks for the heads-up! The fact that it accepts a "rest ..." catch-all is especially nice :) .

However, I don't think there is a way to declare some "global" conditions within a clause, like I'm doing above? My goal is to declare many optional fragments with something similar to [`define-eh-alternative-set`](http://docs.racket-lang.org/syntax/Experimental.html#%28form._%28%28lib._syntax%2Fparse%2Fexperimental%2Feh..rkt%29._define-eh-alternative-set%29%29), and then declare several macros which accept some combination of these patterns. Manually copying the "global" conditions in each macro would be repetitive and error-prone, so I prefer to attach them to the corresponding clause. If this feature ends up being stable enough, would you mind me sending a PR? :)

(@jsmaniac No, that sounds like a great feature!)

@samth I was wrong about it changing DrRacket printing -- that was the change from #1430 (doh!). DrRacket printing is unaffected by this change (at least as far as I can tell).

To do list pieced together from previous [mailing list discussion](http://lists.racket-lang.org/dev/archive/2014-March/013988.html):
- [x] DrRacket prints correctly (i.e. is unaffected by this change) when
  debugging is on/off.
- [x] Are there other program whose harness is worse off with the default display
  error handler starts showing source locations?
- [x] Investigate whether the handler should not print the first returned
  source location for `exn:fail:read`, `exn:fail:syntax`, and
  `exn:fail:contract:variable` exceptions (because that location is
  supposed to be built into the error-message text, unless the
  `error-print-source-location` parameter has a false value).
- [x] Print all available source locations

Also: it would be nice to find a way to get multiple source locations
printed when there are multiple to show.

Robby

Should it print `location...:` instead of `location:` like the context? (to account for the possibility of there being more than 1?)

is it time to close the issue?

Oh, yes! The ellipsis is a good idea. That'll help smooth the DrRacket integration.

The ellipsis doesn't mean "many", btw. Here's some info about it and other related things that you might want to check out:

  http://docs.racket-lang.org/reference/exns.html#%28part._err-msg-conventions%29

[racket-bug] all/15343
https://bugs.racket-lang.org/query/?debug=&database=default&cmd=view+audit-trail&cmd=view&pr=15343

Thanks, fixed.

Thanks, fixed.

It should be a read error similar to one raised by `raise-read-eof-error`, right? It shouldn't produce a `(#%dot x)` for the `#%dot` macro to catch.

Yes, you're right. That was dumb.

On Mon, Aug 29, 2016 at 8:32 AM, Alex Knauth notifications@github.com
wrote:

> It should be a read error similar to one raised by raise-read-eof-error,
> right? It shouldn't produce a (#%dot x) for the #%dot macro to catch.
> 
> —
> You are receiving this because you modified the open/close state.
> Reply to this email directly, view it on GitHub
> https://github.com/racket/racket/issues/1439#issuecomment-243110826, or mute
> the thread
> https://github.com/notifications/unsubscribe-auth/AAOM-uhHHMhdI9JSWVcToHG1HQ1XQXrAks5qktFlgaJpZM4JtvOp
> .

## 

Jay McCarthy
Associate Professor
PLT @ CS @ UMass Lowell
http://jeapostrophe.github.io

```
       "Wherefore, be not weary in well-doing,
  for ye are laying the foundation of a great work.
```

And out of small things proceedeth that which is great."
                          - D&C 64:33

ping

anyone who wants to try the search options, here's a copy of the docs that supports `H:` and `R:`
http://www.ccs.neu.edu/home/types/racket-doc/index.html

LGTM

+1 for `(a.b).c`

The interpretation is on purpose. You can see that in the default implementation of `#%dot` --- https://github.com/jeapostrophe/remix --- the `a` binding is a "dot-transformer" that looks over the rest of the binding and interprets it. In fact, the default binding flattens any sequences of dots into `(#%dot a b c)` so that `a` can see the whole context and expand appropriately.

So this is okay because remix flattens it? But what about other languages that would want to use this?

For example languages that define `#%dot` to transform `a.f` into `(f a)` or something would want `w.world-player1.player-paddle.paddle-x` to transform into `(paddle-x (player-paddle (world-player1 w)))`. Other languages that define `#%dot` to transform `a.x` into `(dict-ref a 'x)` would want `a.x.y.z` to transform into `(dict-ref (dict-ref (dict-ref a 'x) 'y) 'z)`. 

And `remix`'s `#%dot` form would just need a rule where `(#%dot (#%dot a x) y)` would recognize that the inner part isn't a dot-transformer, so it would flatten it to `(#%dot a x y)`, which it would have ended up doing anyway.

If it is on purpose, then it should be part of `read-cdot`'s documentation. C-style is left-to-right associativity.
(e.g. Table 2-1 on p51 of [K&R](https://hassanolity.files.wordpress.com/2013/11/the_c_programming_language_2.pdf))

It just so happens to flatten it for struct accessors. Other languages can expand it however they want.

It is documented.

http://docs.racket-lang.org/reference/reader.html?q=cdot#%28part._parse-cdot%29

That doesn't specify whether it's left- or right- associative, it only gives a low-level process that may or may not produce something that makes sense. _Other_ language implementors will be expecting left-associativity, and that current low-level explanation won't undo that expectation for them.

It clearly says that it reads X then DOT then reads Y and turns it into `(#%dot X Y)`.

So if you read "X.Y.Z" then you get X, then DOT, then you read "Y.Z" so you get `(#%dot Y Z)`, so you get `(#%dot X (#%dot Y Z))`

If you think you can make it more clear, submit a pull request.

cdot follows the racket principle of things on the left/above determining the interpretation of things to the right/below. `(#%dot X (#%dot Y Z))` lets `X` control what the inner `#%dot` means. 

> It clearly says...

Someone with a left-associative bias in their heads (from every other language, and from their hopes as a language implementor) would interpret that as meaning it reads X then DOT then Y and turns it into `(#%dot X Y)`, then DOT then Z, and turning that into `(#%dot (#%dot X Y) Z)`. So it doesn't clearly say \* **THIS IS RIGHT-ASSOCIATIVE WHICH IS PROBABLY NOT WHAT YOU EXPECTED** *.

> The racket principle of things on the left/above determining the implementation of things to the right/below

If I'm a language implementor whose never heard of your `remix`, I won't be thinking of dot-transformers. I'll be thinking of the value of the `X` controlling what the `Y` means (through dynamic dispatch or something similar), and then of the value of `X.Y` controlling what the `Z` means.

``` racket
(define-syntax-rule (#%dot obj (method-id arg ...))
  (send obj method-id arg ...))
```

This seems to work perfectly fine...

``` racket
my-object.(m x y)
```

Yay!!! The value of `my-object` determined what the `m` meant, and the combination of the two determined what `my-object.(m x y)` meant.

``` racket
my-object.(m1 x y)
  .(m2 x y)
  .(m3 x y)
```

```
. m1: unbound identifier in module in: m1
```

Um... What? 

``` racket
(define m1 #f)
(define m2 #f)
(define m3 #f)
...
my-object.(m1 x y)
  .(m2 x y)
  .(m3 x y)
```

```
. . ../../Applications/Racket/2016-08-30/Racket v6.6.0.4/collects/racket/private/class-internal.rkt:4610:0: 
send: no such method
  method name: #%dot
```

Again, I've never heard of remix, I'm just a language implementor. All I wanted was a simple rule for converting `o.(m x ...)` into `(send o m x ...)`, and the documentation _never told me_ that it was going to behave differently from how it always does in every other language.

This talk of "associativity" makes no sense to me in this context. There is no operator parsing, precedence, associativity, etc. `read-cdot` enables the following behavior of `read`: After `read`ing a datum, call it X, if the next non-whitespace character is `.`, then call `read` again and call it Y, then return `(#%dot X Y)`. This recursive specification clearly implies that any additional dots would be found during the `read` of Y.

I think "clearly implies" is the only thing that's being disagreed with
here. Why not write the docs for people (and all their baggage) instead of
machines (or "clean slate" people)?

A) Alex can propose a change.

B) Read the rest of that page and see if my docs don't fit the style:

"Racket’s reader is a recursive-descent parser that can be configured through a readtable and various other parameters. This section describes the reader’s parsing when using the default readtable." 

1.3.8 - "When the reader encounters ', it recursively reads one datum and forms a new list containing the symbol 'quote and the following datum."

1.3.9 - "A #| starts a nestable block comment. When the reader encounters #|, it skips past all characters until a closing |#. Pairs of matching #| and |# can be nested."

The documentation for the reader doesn't give a grammar, precedence rules, etc; it describes the reading algorithm. One improvement to match the style would be to use the word "datum" rather than "value".

Alex. I think I am blinded by having written it. Can you suggest a few tweaks to the text to improve how it reads?

Some examples would go a long way. If you just give an example that `x.y` reads equal to `(#%dot x y)`, and that `x.y.z` reads equal to `(#%dot x (#%dot y z))` that would help a lot.

Would it be a bad idea to change the implementation to match expectations though?

@AlexKnauth maybe you have time to add some examples yourself? Or try to experiment with the implementation to see how the various things that Jay has built on top of #%cdot go wrong or don't go wrong with the change you have in mind?

FYI/update: at the moment, things like `raise-syntax-error` end up getting some location info double printed =(

```
test.rkt:4:2: cond: bad syntax (`else' clause must be last)
  at: (else 1)
  in: (cond (else 1) (else 2))
  location...:
   test.rkt:4:2
  context...:
   /Users/amk/Repos/plt/racket/racket/collects/racket/private/cond.rkt:31:18: loop
   /Users/amk/Repos/plt/racket/racket/collects/racket/private/cond.rkt:21:13: go
   /Users/amk/Repos/plt/racket/racket/collects/syntax/wrap-modbeg.rkt:46:4
   standard-module-name-resolver
```

I prefer to not use that word because I think it suggests something incorrect about dot as "operator" and so on, but instead show examples as Alex suggests and refine the explanation to match the algorithmic style of the rest of the document.

What word?

Associative

On Wednesday, August 31, 2016, Benjamin Greenman notifications@github.com
wrote:

> What word?
> 
> —
> You are receiving this because you commented.
> Reply to this email directly, view it on GitHub
> https://github.com/racket/racket/pull/1444#issuecomment-243821935, or mute
> the thread
> https://github.com/notifications/unsubscribe-auth/AAOM-mz334YkM3Eh3CE4uK26smWe-MKoks5qlaxxgaJpZM4JxxbD
> .

## 

Jay McCarthy
Associate Professor
PLT @ CS @ UMass Lowell
http://jeapostrophe.github.io

```
       "Wherefore, be not weary in well-doing,
  for ye are laying the foundation of a great work.
```

And out of small things proceedeth that which is great."
                          - D&C 64:33

Ok. I'm not going to remove "associative" from this suggestion because I think it's exactly the word for "how the parentheses get inserted into something like `x.y.z`". If other people agree, we can re-open this.

(I'm guessing that "dot is not an operator" will be a less confusing thing for most people than "dot adds parentheses from right-to-left".)

Okay, so for the exceptions affected by [error-print-source-location](http://docs.racket-lang.org/reference/exns.html?q=error-print-source-location#%28def._%28%28quote._~23~25kernel%29._error-print-source-location%29%29) there is special casing to not print the source location they are already printing in their error message.

This means the above error message (for cond) now prints like this:

```
test.rkt:4:2: cond: bad syntax (`else' clause must be last)
  at: (else 1)
  in: (cond (else 1) (else 2))
  context...:
   /Users/amk/Repos/plt/racket/racket/collects/racket/private/cond.rkt:31:18: loop
   /Users/amk/Repos/plt/racket/racket/collects/racket/private/cond.rkt:21:13: go
   /Users/amk/Repos/plt/racket/racket/collects/syntax/wrap-modbeg.rkt:46:4
   standard-module-name-resolver
```

Happy to make tweaks and incorporate further suggestions -- if others are happy with it I think it might be good to ship.

You could say "Racket's dot notation is not left associative, like you might expect", probably. :)

@rfindler He he, nice. Although it still has 'associative' in the word. ;)

Anyway, I'm reopening this because being right associative is a big enough difference from pretty much any language that uses them that it's quite important to have this notice here. I'm fairly ambivalent towards the use of the word associative. If anyone can come up with a word better than associative I'm fine with that though. On the other hand, if no one can, I think it's important enough to have the note there even if it means using associative.

Where should I put tests for the `read-cdot` option?

@LeifAndersen It may behoove you when talking with this code's author to not claim that it is right associative, especially since he has tried to explain a few times why it isn't. There is a much less strong reason to disagree with "not left associative".

Related: https://github.com/racket/racket/pull/1446

Yes, very much this.

@rfindler Ah, didn't notice the 're' link in Ben's issue. (Was very confused because I only saw one message from Jay. ;) )

You should update `read-cdot`'s existing clients because this is a backwards-incompatible change.

Here's the OS X error info (running/crashing 'file2.rkt' from DrRacket) in case it's useful:
https://gist.github.com/andmkent/718a02b2eaffea031b139f836eec4dc8

Once you are happy with the docs, it is fine to launch by me

Hey @jeapostrophe , since we're breaking backwards compatibility, do you have any opinions on changing the name to something other than cdot? As cdot doesn't make sense as a name unless you know much about c-style languages. Also, cdot means something completely different in say latex, which might confuse things.

Here's a single-file version that crashes:

```
#lang racket/load

(module m1 racket/base
  (require (for-syntax racket/base))
  (provide f)
  (define-syntax f (make-rename-transformer #'values)))

(module m2 racket/base
  (define f (dynamic-require ''m1 'f))
  (f))

(require 'm2)
```

Adding the `'not-free-identifier=?` syntax property makes the crash go away.

And here's the line that does, in module.c, line 1283:

```
                          if (SCHEME_FALSEP(srcm2->me->rt->provide_srcs[j])
```

This patch fixes the immediate problem, and follows the pattern from earlier in the same function, but I don't know what's going on well enough to know if it's the right thing:

```
diff --git a/racket/src/racket/src/module.c b/racket/src/racket/src/module.c
index 3d67114..2e2e5c3 100644
--- a/racket/src/racket/src/module.c
+++ b/racket/src/racket/src/module.c
@@ -1280,7 +1280,8 @@ static Scheme_Object *_dynamic_require(int argc, Scheme_Object *argv[],
                     srcm2 = module_load(srcmname, env, errname);

                     for (j = srcm2->me->rt->num_var_provides; j--; ) {
-                      if (SCHEME_FALSEP(srcm2->me->rt->provide_srcs[j])
+                      if (srcm2->me->rt->provide_srcs
+                          && SCHEME_FALSEP(srcm2->me->rt->provide_srcs[j])
                           && SAME_OBJ(srcname, srcm2->me->rt->provide_src_names[j])) {
                         /* simple re-export applies: */
                         srcm = srcm2;
```

Thanks for the report!

Sorry for the long delay! (It seems that I've stopped getting e-mail when new issues are posted.) I've had trouble with MzCOM on Windows 10, too, and I'm not sure what is wrong. I should have time to investigate in the next few days.

This looks ok to me.

Do we know whether MSVC provides all of these, too, so that the functionality will be the same with both MSVC and MinGW?

@LeifAndersen how about `read-#%dot` ?

That can be a separate change. I would rather do one thing at a time

@AlexKnauth ok. Are you planning to update the existing clients in this PR?

@bennn Yes, there's a pull request ready here: https://github.com/jeapostrophe/remix/pull/1
(I've searched Github for `read-cdot`, and it's the only thing that sets it to true.)

@bennn I'm fairly ambivalent on read-#%dot.  I'm not aware of anything else in our standard library that follows a convention like that though.

Some suggestions (with help from Ben) might be: `read-dot-notation`, also `read-dot-operator` would be nice too, although I guess that very much goes against Jay saying dot is not an operator, so maybe not the second one.

Since dots already mean 3 different things in racket without this, those would all be confusing. The name `cdot` at least differentiates it from the more lisp-based uses of dots.

Ya, that's fair.

I don't think we should change the name and I don't think we should stress about the backwards-incompat given that there is one use and no one uses it. I'm good to commit.

Okay. Can you look over the doc changes and see if there's anything else that should be changed?

Ya, I'm inclined to agree with @jeapostrophe here. As sad as it is, I can't think of anything better then cdot, oh well. :( We should probably not change the name, as its not really that important.

VS 2010 and later define the following codes that MinGW does not:
- `ENODATA, ENOSR, ENOSTR, ETIME`: marked as optional in POSIX.1
- `ENOLINK`: described as "reserved" in POSIX.1
- `ENOTRECOVERABLE`: not in the 2004 version of POSIX.1
- `EBADMSG, EIDRM, ENOMSG, ETXTBSY`: no explanation I found

VS pre-2010 defined a much smaller list.

I think everything is good and I can merge it.

Good luck:D

LGTM

(I don't have push access)

I've pushed the commit. Thanks!

@AlexKnauth: Re commit access: that should be fixed now.

@rmculpepper Is this ok with you?

Does the documentation need to change for this?

@mflatt is this similar to what you had in mind (from your previous [comments](http://lists.racket-lang.org/dev/archive/2014-March/013992.html) on the topic)?

Did you mean to push the changes to the `syntax-parse` docs?

I pushed an update to the docs, and included a small fix in the syntax/parse docs.

I noted the change using  `@history[#:changed "6.6.0.5" "description"]`, since the current version is 6.6.0.4. Is that okay, or should I indicate the change for 6.6.0.4?

Usually we put the current version (unless the commit changes the version as well).

Updated :)

@samth, I'm assuming that you have seen my detailed comments, which I spend a good amount of time writing to make them useful and easy to follow, as well as the "not-gonna-do-it" reply.

Using a four letter word would have been more polite.

Almost all of your comments were addressed in the final commit.

On Tue, Sep 6, 2016, 10:53 PM Eli Barzilay notifications@github.com wrote:

> @samth https://github.com/samth, I'm assuming that you have seen my
> detailed comments, which I spend a good amount of time writing to make them
> useful and easy to follow, as well as the "not-gonna-do-it" reply.
> 
> Using a four letter word would have been more polite.
> 
> —
> You are receiving this because you were mentioned.
> 
> Reply to this email directly, view it on GitHub
> https://github.com/racket/racket/pull/1398#issuecomment-245160335, or mute
> the thread
> https://github.com/notifications/unsubscribe-auth/AAO781_We_ActsMf7UmhQ5us07Y9Jp7rks5qnicOgaJpZM4JVw0b
> .

Should this doc fix be merged?

It looks like maybe the commit that got merged is this one? I'm sure we are all open to continuing to work on Racket here so (I hope) that further feedback would be read and thought about and probably acted on?

https://github.com/racket/racket/commit/42f478473583519048602b6e7563dbb57b3c51d9

And maybe even a high-level explanation of what did & didn't get followed from Eli's earlier comments?

As a closing remark on this PR, here is a brief high level summary of 
the changes:
- new `vector-sort` and `vector-sort!` functions were added to
  racket/vector (w/ supporting code added to racket/private/sort.rkt).
  these functions, like `sort`, provide a _stable_ sort.
- The vector and list sorting algorithms use the same back end, with
  slightly different front ends (the front ends are similar but are
  specialized to handle lists/vectors before calling the common back
  end).
- The set of precompiled sorts was expanded to include all of the
  standard comparators from racket/base

Thank you to all those who helped w/ suggestions and comments
(especially @elibarzilay). I tried to incorporate all the suggestions
in the final product (only intentionally ignoring some
cosmetic/stylistic suggestions that seemed arbitrary in the big
picture, and I didn't do anything fancy to shrink the tests down).
More specifically, all of the following suggestions were incorporated:
- no unnecessary dependencies (e.g. qqstx.rkt were added)
- several redundant/unnecessary macros/special casing on constants
  from the earlier draft were removed
- the generic-sort/key functions were removed
- other small corrections were made

LGTM

My reading of the docs is that "gibberish" is a perfectly valid jsexpr. Perhaps I'm misunderstanding you?

Certainly it's clear from the docs since any string is a valid jsexpr. I'm
just questioning whether that's optimal behavior.

Then again I am very new to Racket so I may not be familiar with how
predicates are supposed to work.
On Thu, Sep 8, 2016 at 3:53 PM John Clements notifications@github.com
wrote:

> My reading of the docs is that "gibberish" is a perfectly valid jsexpr.
> Perhaps I'm misunderstanding you?
> 
> —
> You are receiving this because you authored the thread.
> Reply to this email directly, view it on GitHub
> https://github.com/racket/racket/issues/1455#issuecomment-245737148, or mute
> the thread
> https://github.com/notifications/unsubscribe-auth/AJEEcbNBnpWsWYMH2JthOiffq41_opnYks5qoHXPgaJpZM4J4b8R
> .

Let me take a guess... are you looking for a predicate that tells you whether 'string->jsexpr' will signal an error on some input? In that case, the best I've got for you is

``` racket
#lang racket

(require json)


(define (valid-json-string? s)
  (with-handlers ([exn:fail? (λ (exn) #f)])
    (string->jsexpr s)
    #t))


(valid-json-string? "gibberish")
```

I think you're confusing the jsexprs with their json encodings?

Specifically, 

"gibberish"

is a jsexpr whose json encoding is 

"\"gibberish\""

Let me know if I'm still not understanding you.

Ah, I think I understand now: a `jsexpr` enumerates the possible Racket datatypes that can be encoded into json values, and `jsexpr?` asks whether such a thing can be encoded as json. 

As for `valid-json-string`, yes I was aware of the `with-handlers` function, and that's what I've been using. I was just puzzled by the purpose of `jsexpr?`. 

Probably the most common use for `jsexpr?` would be as a contract. So, for instance, I'm writing a function that accepts a number and produces a piece of data that's going to be sent over the wire as json. The most reasonable contract for this thing would probably have `jsexpr?` in the positive position, like this:

``` racket
(-> number? jsexpr?)
```

okay if I close this?

Makes sense! Yes go ahead and close.

In the new commit, I marked the struct and struct property predicates as `boolean?`s. I'm still not sure about the details, in particular if it's necesary to check that `SCHEME_PROC_SHAPE_IDENTITY(shape)` is a  pair in [optimize.c#L2998](https://github.com/gus-massa/racket/blob/39ea2dce5cae4ed1d31a3d2065d9e939fddbaeeb/racket/src/racket/src/optimize.c#L2998).

(I'll squash this with "add boolean? to the list of relevant predicates".)

Closing, as I believe this was addressed by https://github.com/racket/racket/commit/42f478473583519048602b6e7563dbb57b3c51d9.

I’m going to close this, since the main issue I had was addressed.

Closing this, since it looks like this was fixed in 31fdac87730f8532cc39942f28826fd2c4211716.

@samth:

> Almost all of your comments were addressed in the final commit.

Apologies!  I completely missed the additional commit.

@rfindler:

> I'm sure we are all open to continuing to work on Racket here

I certainly hope that this code won't become orphan...  (And unfortunately, the kind of time requirement for suggesting a pull request for such things is way more than I can afford...)

@andmkent:

> As a closing remark [...]

Thanks for updating it; there are still some things that are bugging me, below is quick list up to the point where I gave up...

But one major thing which you list as a feature is the addition of precompiled versions.  Are these actually needed?  I'm guessing that sorting characters is pretty rare and not a performance bottleneck, and the same goes for things like `string-ci>?` and `i>`.  The resulting zo file that I see is about twice bigger than the previous one, and this library is loaded very early and therefore probably used in a bunch of places where load times and bytecode sizes are important.

I wasn't sure that I'm looking at the right thing, so I ended up going to your repo, so this is based on what I see there, after commit 33307ab.  (Also, this came out very long, I think that it's better to start from the existing file and add the new functionality instead of trying to backtrack things.)

The rest of the list, in case you want to improve it:
1. The code is still shifted by two spaces and still has different structure that leads to a much deeper nesting, and still has a bunch of redundant renamings.  But the damage from all of these is already done, too late to seperate these into no-op commits.
2. `;; end of module` at the end, and some other comment headers that are redundant (ie, a big "foo" comment before a definition of "foo").
3. Macros are still bogusly using keywords which look like regular keyword arguments but are not: `sort-internal`, `list-sort-body`, `vector-sort-body`, `vector-sort-case-lambda`.
4. `list-sort-body` and `vector-sort-body` should use `define-syntax-rule`.
5. There are still macros that are not needed like `<?`, as well as slight changes in the code that might lead to changes in how its optimized (the `<?` comes with a higher-order mention of the key function, and I vaguely remember this having a negative effect).
6. `i*2` and `i/2` are unsafe, but they're not mentioned in the list of things to uncomment to get a safe version of the code.
7. The `swap!` macro is redundant since it's used just once, so the code could just move.
8. The `for standard data types` is still misleading.

What about `cpointer?` itself? Should that be a safe predicate?

Yes, I have some code to fix that as well.

On Tue, Sep 13, 2016, 12:34 AM Alex Knauth notifications@github.com wrote:

> What about cpointer? itself? Should that be a safe predicate?
> 
> —
> You are receiving this because you modified the open/close state.
> 
> Reply to this email directly, view it on GitHub
> https://github.com/racket/racket/pull/1368#issuecomment-246571095, or mute
> the thread
> https://github.com/notifications/unsubscribe-auth/AAO789qOe2_UC6IKkl5DSQSa6EfWKKfjks5qpifBgaJpZM4JICxJ
> .

Docs?

Oh ... yep, wrote docs, didn't include them. Hang on.

okay, docs added. Thanks for catching that!

Thanks for catching this!

After an extensive minimization, I got this:

```
#lang racket/base
(letrec-values ([() (list (3) the-val)]
                [(the-val) 42])
  777)  ;==> #f 
```

(I replaced the last `42` by `777`.)

I think that the optimizer realizes that `(3)` will generate an error and replaces the rest of the expression by `#f` because it will never be executed. But later the optimizer thinks that the first part has no side effects and removes it.

A similar change may break some of the internal clocks in your example, so the effect is very different but I think that the root casue is the same.

I'm guessing a little, and I still don't have a fix, [optimize_lets](https://github.com/racket/racket/blob/d4158c2b04b71d193ab32e43396b62b865ec2df6/racket/src/racket/src/optimize.c#L6878) is very complex.

I think that the example blow might, maybe be in reach of a random
expression generator. But I don't know how to formulate a predicate. Is
there a way to evaluate an expression with and without the optimizer that
could be used to try to help find such bugs?

Robby

On Wed, Sep 14, 2016 at 9:11 PM, gus-massa notifications@github.com wrote:

> After an extensive minimization, I got this:
> 
> #lang racket/base
> (letrec-values ([() (list (3) the-val)]
>                 [(the-val) 42])
>   777)  ;==> #f
> 
> (I replaced the last 42 by 777.)
> 
> I think that the optimizer realizes that (3) will generate an error and
> replaces the rest of the expression by #f because it will never be
> executed. But later the optimizer thinks that the first part has no side
> effects and removes it.
> 
> A similar change may break some of the internal clocks in your example, so
> the effect is very different but I think that the root casue is the same.
> 
> I'm guessing a little, and I still don't have a fix, optimize_lets
> https://github.com/racket/racket/blob/d4158c2b04b71d193ab32e43396b62b865ec2df6/racket/src/racket/src/optimize.c#L6878
> is very complex.
> 
> —
> You are receiving this because you are subscribed to this thread.
> Reply to this email directly, view it on GitHub
> https://github.com/racket/racket/issues/1461#issuecomment-247213676, or mute
> the thread
> https://github.com/notifications/unsubscribe-auth/AAYWsBG8ADRQbstFgEQ8UUjF_A8ccrdgks5qqKlBgaJpZM4J9NfS
> .

Currently the optimizer has two objectives:
- collect some information for the resolve and sfs steps of the compiler
- apply some optimizations

(And there are a few optmizations scatered in other steps of the compilation, but (probably) all the optimizations outside optimize.c are small and foolproof.)

I think that it's posible to make two copies of optimize.c, and keep in one copy all the optimizations and in the other the only keep the necesary parts to save the info for the following steps.

Perhaps this can be enable extending the meaning of 

```
set PLT_RECOMPILE_COMPILE=0
```

## 

To test for error between **one** and **two** optimizations you can try an improved version of 

```
#lang racket

(define (test-reoptimization stx)
  (equal? (eval (compile stx))
          (eval (compiled-expression-recompile (compile stx)))))

(test-reoptimization #'(+ 1 2))
(test-reoptimization #'(let ([x 5]) (+ x x)))
(test-reoptimization #'(let ([x (* (random) 0)]) x x))
```

But the transfomations are complex (in particular the resolve/unresove part). So I think it's  difficult to make `(compiled-expression-recompile (compile/0-optimizations stx))` equivalent to `(compile/1-optimization-as-usual stx)`.

Are there arguments I could pass to the build process that would disable
the relevant parts of the code? And then I could just compile two versions
and test them against each other?

Hm. I just tested this on OSX 10.11 with Chrome and it works for me, jumping straight to the `for/list` documentation. Maybe try a racket session on another computer if possible to double check your setup? 

I just notice it works if web browser is not already opened, otherwise, the anchor part will not be passed to the web browser.

@gus-massa Thanks for mostly tracking down the problem! I think the issue is that the `found_escapes` test on line 7139 is not right for letrec mode. Changing the test to `(!is_rec && found_escapes)` avoids the bug and passes existing tests (i.e., no tested optimization is lost). I'll check more to be sure that's the right repair.

Thanks for the report!

This crash is a regression relative to v6.4 caused by a refactoring of the compiler between v6.4 and v6.5. The refactoring lost information about `letrec`s that are converted internally to `let*` when a mutable variable is involved. The crash happens in DrRacket and not in plain `racket`, because DrRacket's extra debugging constraints prevent the optimizer from further actions that happen to avoid the crash. I'm still deciding on the best way to fix the problem.

I bumped the version number in the docs to 6.6.0.5 (the new "current" version of Racket), and rebased the commits on top of the latest HEAD.

This is great!

I still can’t believe that I forgot to add `eq?` to the list of primitives that return a `boolean?`. 

Currently one of the tests is failing because the optimizer reduces:

```
(boolean? (equal? x y))  ==>  (begin (values (equal? x y)) #t)
```

I think that the `values` is unnecessary, but perhaps I’m missing a corner case.

The easiest solution is to add a `values` in the test to make it pass.

A more difficult solution is to add a special case for `equal?` in `ensure_single_value`.

An even more difficult solution is to fix `ensure_single_value` because it calls `single_valued_noncm_expression` so it checks unnecessarily that it’s `non_cm`, but in this case it will be necessary to check all the use places of `ensure_single_value` to be sure that they only care about the single value and they don’t expect the `non_cm` check too.

1. "implements Unix-style wildcards" -- globs are mostly independent of unix.  Maybe just the dot-prefix thing...  (Also at the top of the code.)
2. The documentation uses a bunch of `@racket`s that look wrong and should probably be `tt` or similar.
3. It would also be _very_ useful to have `**` (which can match path separators too).
4. But note about {}s: they are _not_ a globbing tool.  In shells they get expanded before the globbing stage.
5. Using globs in path strings to represent globs sounds dangerous to me.  I'm guessing that you don't want "?:\" on windows to expand to all drives or do local network searches for "\\*\stuff".
6. I really dislike the global `*glob-capture-dotfiles?*` parameter -- it would be much nicer if it were a property of the glob itself.
7. I'm not sure that `in-glob` is the only useful thing -- stuff like `glob->list` etc could still be useful.
8. But in any case, it's often useful to specify several patterns so they get `or`ed (roughly) -- so it would be useful for `in-glob` to get multiple inputs to do that.  Then it might make sense to add braces as a shorthand for multiple strings, similar to what shells do.
9. Either the implementation or the description of `glob-match?` seems problematic: it looks like `(glob-match "foo" "foo")` will only be true if there is a file/directory named "foo" in the current directory.
10. It's not clear to me whether something like "_/_/*" would work -- I hope it does, but then the docs should say that.
11. In case it helps -- I used to have some old globbing code for meta-stuff which was working pretty well but it probably died with the move from svn to git.  I put it at http://tmp.barzilay.org/tree.ss (there are also some tests for it if you're interested).  The main thing there is a function that turns a glob to a regexp (and from that to a predicate), and the test cases try a bunch of edge cases.
12. The code has a mistaken comment saying "? makes the previous character/pattern optional,"

Well, `raco pkg install xrepl-lib` will install what you probably wanted. 

More broadly, I think there are a few possible choices here:
1. The status quo.
2. `racket-doc` doesn't reference Typed Racket/the web server/anything that's not in a minimal install.
3. `racket-doc` gets split up into multiple packages, and the reference avoids having so many external links.
4. The links are changed so that they use some indirect link form that avoids a build-time dependency. This means not just using `@racket[]` and `for-label` in the relevant docs.
5. `raco pkg install xrepl` installs built versions of everything and thus doesn't install the build-deps. 
6. Doc links automatically do some form of 4 so that `xrepl-doc` doesn't have a build-dep on `racket-doc`. 

I'm actually surprised that 5 didn't just happen. But which one (or combination) are you thinking of?

(Found the tests at http://svn.plt-scheme.org/plt/trunk/ )

I’m not sure what the ideal solution is, but I’d personally like to be able to have the `xrepl` docs installed without needing most of the main distribution to be installed, too. It also seems unlikely that it would actually be possible to decouple the guide and the reference since they’re so commonly cross-referenced, which is a good thing.

I’d personally be okay if `racket-doc` referenced fewer packages, but it could probably harm discoverability, and it would make the documentation worse for people who just install the main distribution anyway (which I would assume is probably the majority of Racketeers, but I could be wrong). I think the idea of a sort of “weak link” between pieces of documentation sounds like a good compromise to me, since it wouldn’t negatively impact anyone who has those pieces of documentation installed, anyway. The only significant question is how the links would render when the relevant documentation isn’t installed.

As an aside, I think (5) didn’t happen because the package server is not currently configured to distribute built versions of packages, so it always installs sources.

With respect to (5): For a release, the release-specific package catalog does distribute built packages for anything in the main distribution. Still, "built" means "sources plus built artifacts", so all dependencies are installed for the "sources" part. Use `--binary` or even `--binary-lib` for a binary install from a built package, which will skip build-time dependencies.

> I really dislike the global `*glob-capture-dotfiles?*` parameter -- it would be much nicer if it were a property of the glob itself.

What about replacing it with a keyword arguent for `glob` / `in-glob` / `glob-match?` ?

Also, I think that any of the current parameters in racket have the `*___*` in their names.

I believe this is the code that would have to change:
https://github.com/racket/racket/blob/master/racket/collects/racket/private/stxloc.rkt#L38-L45

``` racket
(-define (relocate loc stx)
  (if (or (syntax-source loc)
          (syntax-position loc))
      (datum->syntax stx
                     (syntax-e stx)
                     loc
                     stx)
      stx))
```

The only thing that would have to change would be the `(or (syntax-source loc) (syntax-position loc))` condition. I'm guessing its purpose is something analogous to the [`source-location-known?`](http://docs.racket-lang.org/syntax/Source_Locations.html#%28def._%28%28lib._syntax%2Fsrcloc..rkt%29._source-location-known~3f%29%29) function in `syntax/srcloc`. 

Thanks, Matthew; I'm closing this issue now, because I fixed this (in tonyg/racket-send-exp@94a8101bc410101327b0e65722512e5e8d0b1599) a couple of months ago.

Thanks for the report!

The problem is a 10-year-old bug in the pattern matcher's optimizer, which notices that "a*" might be expensive to match (due to backtracking), so it attempts to find a substring that must appear in matching input as a quick pre-test on the input. Unfortunately, the optimizer takes "b" as the substring that must appear — incorrectly treating a must-not-match part of the pattern as a must-match part of the pattern.

I'll push a repair soon.

Subsumed by #1472.

I can't give much help for this because my lack of related knowledge. I do want to provide one more information: After upgrading my old Macbook Air, on which I have installed Racket 6.5, from El Captain to Sierra, the app still works. New installs on Sierra does not work for both 6.5 and 6.6.

Actually I installed it directly from freebsd ports (compiled it from source).
As you can see in sconfig.h freebsd on ppc gives a "Unported platform" error.

On 30 Sep 2016, at 00:03, jcmdln <notifications@github.com<mailto:notifications@github.com>> wrote:

There is a Unix variant on the downloads page, did you attempt to install it? If so, what errors did you get?

—
You are receiving this because you authored the thread.
Reply to this email directly, view it on GitHubhttps://github.com/racket/racket/issues/1471#issuecomment-250604243, or mute the threadhttps://github.com/notifications/unsubscribe-auth/AKWE8fFfssFylCX4cd2cmwIoBekhEZGxks5qvDXFgaJpZM4KKchK.

#1475 @mflatt It's been quite more than a "few" days and the website still doesn't use HSTS or redirect to HTTPS.

The latest commit implements `**` and `{foo,bar,{baz,qux}}` etc. & addresses most of @elibarzilay 's comments (thanks again Eli & Jay & Gustavo).

Things that we might still want to change:
- I added keyword arguments, but kept the parameter (as the keywords' default, also without the `**`)
- globs are still path strings -- because I think it's a convenient interface & couldn't think of a "less dangerous" option.
- I don't understand point `7` about `glob->list`. I think `glob` is doing what `glob->list` would do.

Docs here: http://www.ccs.neu.edu/home/types/racket-doc/file/glob.html

I say merge!

Why is the build failing?

2 technical issues:
- Is it possible to use `rackunit` in the `file` collection or in `racket-test/tests/file` ? The CI failed when I tried `(require rackunit)`.
- [L40](https://github.com/racket/racket/pull/1464/files#diff-751266cc6e8f06cdc77958951f21cd0eR40) in the doc has a broken cross reference to "flat contract", but I don't know how to fix it.

Probably, you want also to add the line: `#define MZ_USE_JIT_PPC`.

Did you try to run DrRacket? Everything works fine?.

If possible, can you run the tests and to copy/paste the output?:

```
$ racket -e '(eval-jit-enabled)'
$ raco pkg install --auto -u racket-test-core
$ cd ~/.racket/$(racket -e '(display (version))')/pkgs/racket-test-core/tests/racket/
$ racket -f quiet.rktl
```

We finally tracked a problem down to Sierra's new path randomization, which would specifically affect new installations and not existing installations.

We've updated the ".dmg" for the distribution so that it's signed (in addition to signing the executables in the distribution), and that should fix the problem for installation on Sierra.

Compiling it with `#define MZ_USE_JIT_PPC` gives me the error

```
./../src/jit.c: In function 'scheme_generate':
./../src/jit.c2473: error: 'JIT_LOCAL4' undeclared (first use of this function)
```

Without jit enabled the build works. Installing packages works but it complains about not being able to install some documentation. 

The output of `racket -f quiet.rktl` is:

```
Section(basic)


TIMEOUT -- ABORTING!
```

I see the interest in being able to search for languages.
If you search for, say `H:eopl`, you get the full list of exports from eopl, whereas if you search fo `H:eop`, you only get the language. Is that intentional?
The `H:` prefix is unfortunate, but `L:` is already taken...

You should be able to use `rackunit` from `racket-test/tests/file`, but not from inside the `file` collection proper.
To fix the cross-reference, use the top-level of the reference as the `doc`, instead of the specific section on contracts.

The stack trace you're seeing is the result of the runtime's best effort at reconstructing a stack trace from optimized code.
If you want better stack traces, you can run your programs using `racket -l errortrace -t my-program.rkt` or by enabling "debugging and profiling" in DrRacket. Errortrace adds annotations to the compiled code that make it possible to have better stack traces, but at the cost of performance.

Build racket with `--disable-places --disable-futures`.

Probably you want "debugging" not "debugging and profiling" (that setting is the default in DrRacket).

Should I disable places and futures by default for the powerpc architecture?

FWIW, those at least used to work on PPC on Mac OS. I last used that combination ~5 years ago, though, and I think we got rid of those build machines some time ago, so it may have bit-rotten.

So I'll just disable them in my build script not in the racket configuration file?

@alehed yes, both are not supported on powerpc. With both disabled in the configure script, you can build the interpreter with JIT.

@stamourv look #1239.

Ah, looks like I was out of date then. :)

I've pushed a fix for this here: https://github.com/racket/htdp/commit/d6d90adcff65c926c7a9215375e9bd575e0bebac

but you probably should use 

```
(require test-engine/racket-tests)
```

instead of the `require` line you've got there. That's really intended to be used only from inside DrRacket, if I understand correctly.

Yes that's intentional. It's the same fall-through behavior as `L:` ... if there's an exact match, show all results from the module, if not just show module names that partially match.

The reason I think it should be like `L:` and not like `M:` is so `H:` by itself doesn't just list "all identifiers whose language partially matches the empty string". Instead you get a list of language names.

Thanks, FYI, I _was_ using this inside of DrRacket (actually, my _students_
were). We already switched to racket-tests as a workaround, but it will
nice to have this fixed for next year---you definitely diagnosed the
problem and fixed it, right?

-CR

On Mon, Oct 3, 2016 at 8:54 PM, Robby Findler notifications@github.com
wrote:

> I've pushed a fix for this here: racket/htdp@d6d90ad
> https://github.com/racket/htdp/commit/d6d90adcff65c926c7a9215375e9bd575e0bebac
> 
> but you probably should use
> 
> (require test-engine/racket-tests)
> 
> instead of the require line you've got there. That's really intended to
> be used only from inside DrRacket, if I understand correctly.
> 
> —
> You are receiving this because you authored the thread.
> Reply to this email directly, view it on GitHub
> https://github.com/racket/racket/issues/1480#issuecomment-251268563, or mute
> the thread
> https://github.com/notifications/unsubscribe-auth/ACsqECwDJBaYAalJYE6yVjlMqUO3W5x2ks5qwaPegaJpZM4KNGTw
> .

## 

Dr. Charles Rich, Professor, Computer Science Department
http://www.cs.wpi.edu
Interactive Media and Game Development Program
http://www.wpi.edu/academics/imgd/
Robotics Engineering Program http://www.wpi.edu/academics/robotics/
Worcester Polytechnic Institute, Fuller Laboratories B25b
100 Institute Road, Worcester, MA 01609-2280

Email: rich@wpi.edu   Phone: 508-831-5945   Fax: 508-831-5776
Home: http://www.cs.wpi.edu/~rich

Appears to work without issue @charlesrich 

```
(require test-engine/racket-tests)
(check-expect (+ 2 2) 5)
(test)
```

```
Ran 1 check.
0 checks passed.
    Actual value differs from the expected value.
    Actual value: 4
  Expected value: 5

 At line 2 column 0
```

Sorry, my typo.  It is test-engine/racket-gui that blows up.

racket-tests was the workaround.

Sorry for the confusion.

I think the bug has already been fixed.

-CR

On Mon, Oct 3, 2016 at 9:27 PM, jcmdln notifications@github.com wrote:

> Appears to work without issue @charlesrich
> https://github.com/charlesrich
> 
> (require test-engine/racket-tests)
> (check-expect (+ 2 2) 5)
> (test)
> 
> Ran 1 check.
> 0 checks passed.
>     Actual value differs from the expected value.
>     Actual value: 4
>   Expected value: 5
> 
>  At line 2 column 0
> 
> —
> You are receiving this because you were mentioned.
> Reply to this email directly, view it on GitHub
> https://github.com/racket/racket/issues/1480#issuecomment-251272872, or mute
> the thread
> https://github.com/notifications/unsubscribe-auth/ACsqECNFi0gDpuH9TfAe7-YRQ09Xr6HQks5qwauGgaJpZM4KNGTw
> .

## 

Dr. Charles Rich, Professor, Computer Science Department
http://www.cs.wpi.edu
Interactive Media and Game Development Program
http://www.wpi.edu/academics/imgd/
Robotics Engineering Program http://www.wpi.edu/academics/robotics/
Worcester Polytechnic Institute, Fuller Laboratories B25b
100 Institute Road, Worcester, MA 01609-2280

Email: rich@wpi.edu   Phone: 508-831-5945   Fax: 508-831-5776
Home: http://www.cs.wpi.edu/~rich

I get the same intermittent error.  I don't think it has anything to do with the code being stepped.  It first started appearing when I changed the width of the macro stepper window.

racket-tests isn't the work around. It is the library you should have been
using from the start! (I think the other isn't documented.)

The other is a component of DrRacket's implementation, not meant to be used
by a program written inside DrRacket.

I beg to differ:  racket-gui is in the v6.6 documentation at

http://docs.racket-lang.org/test-engine/#%28mod-path._test-engine%2Fracket-gui%29

See end of page.

-CR

On Mon, Oct 3, 2016 at 9:46 PM, Robby Findler notifications@github.com
wrote:

> racket-tests isn't the work around. It is the library you should have been
> using from the start! (I think the other isn't documented.)
> 
> The other is a component of DrRacket's implementation, not meant to be used
> by a program written inside DrRacket.
> 
> —
> You are receiving this because you were mentioned.
> Reply to this email directly, view it on GitHub
> https://github.com/racket/racket/issues/1480#issuecomment-251275101, or mute
> the thread
> https://github.com/notifications/unsubscribe-auth/ACsqEOGngQwisHARdzdDduHcvtvASNpPks5qwa_wgaJpZM4KNGTw
> .

## 

Dr. Charles Rich, Professor, Computer Science Department
http://www.cs.wpi.edu
Interactive Media and Game Development Program
http://www.wpi.edu/academics/imgd/
Robotics Engineering Program http://www.wpi.edu/academics/robotics/
Worcester Polytechnic Institute, Fuller Laboratories B25b
100 Institute Road, Worcester, MA 01609-2280

Email: rich@wpi.edu   Phone: 508-831-5945   Fax: 508-831-5776
Home: http://www.cs.wpi.edu/~rich

P.S. Plus we have been using racket-gui for years in our course at WPI.

-CR

On Mon, Oct 3, 2016 at 9:50 PM, Charles Rich rich@wpi.edu wrote:

> I beg to differ:  racket-gui is in the v6.6 documentation at
> 
> http://docs.racket-lang.org/test-engine/#%28mod-path._
> test-engine%2Fracket-gui%29
> 
> See end of page.
> 
> -CR
> 
> On Mon, Oct 3, 2016 at 9:46 PM, Robby Findler notifications@github.com
> wrote:
> 
> > racket-tests isn't the work around. It is the library you should have been
> > using from the start! (I think the other isn't documented.)
> > 
> > The other is a component of DrRacket's implementation, not meant to be
> > used
> > by a program written inside DrRacket.
> > 
> > —
> > You are receiving this because you were mentioned.
> > Reply to this email directly, view it on GitHub
> > https://github.com/racket/racket/issues/1480#issuecomment-251275101,
> > or mute the thread
> > https://github.com/notifications/unsubscribe-auth/ACsqEOGngQwisHARdzdDduHcvtvASNpPks5qwa_wgaJpZM4KNGTw
> > .
> 
> ## 
> 
> Dr. Charles Rich, Professor, Computer Science Department
> http://www.cs.wpi.edu
> Interactive Media and Game Development Program
> http://www.wpi.edu/academics/imgd/
> Robotics Engineering Program http://www.wpi.edu/academics/robotics/
> Worcester Polytechnic Institute, Fuller Laboratories B25b
> 100 Institute Road, Worcester, MA 01609-2280
> 
> Email: rich@wpi.edu   Phone: 508-831-5945   Fax: 508-831-5776
> Home: http://www.cs.wpi.edu/~rich

## 

Dr. Charles Rich, Professor, Computer Science Department
http://www.cs.wpi.edu
Interactive Media and Game Development Program
http://www.wpi.edu/academics/imgd/
Robotics Engineering Program http://www.wpi.edu/academics/robotics/
Worcester Polytechnic Institute, Fuller Laboratories B25b
100 Institute Road, Worcester, MA 01609-2280

Email: rich@wpi.edu   Phone: 508-831-5945   Fax: 508-831-5776
Home: http://www.cs.wpi.edu/~rich

Okay, thanks for letting me know.

You're welcome :-).

Btw, since you seem so responsive, any progress on Issue #1408, which
appears to be a graphics bug in the macro stepper?  I believe there is
another issue posted on the same bug, but I couldn't find it again.   This
one has also been a problem for my class.

Thanks, -Chuck

On Mon, Oct 3, 2016 at 10:04 PM, Robby Findler notifications@github.com
wrote:

> Okay, thanks for letting me know.
> 
> —
> You are receiving this because you were mentioned.
> Reply to this email directly, view it on GitHub
> https://github.com/racket/racket/issues/1480#issuecomment-251277220, or mute
> the thread
> https://github.com/notifications/unsubscribe-auth/ACsqECow4e3OPR6dA1guD_31IU6JDXxfks5qwbQigaJpZM4KNGTw
> .

## 

Dr. Charles Rich, Professor, Computer Science Department
http://www.cs.wpi.edu
Interactive Media and Game Development Program
http://www.wpi.edu/academics/imgd/
Robotics Engineering Program http://www.wpi.edu/academics/robotics/
Worcester Polytechnic Institute, Fuller Laboratories B25b
100 Institute Road, Worcester, MA 01609-2280

Email: rich@wpi.edu   Phone: 508-831-5945   Fax: 508-831-5776
Home: http://www.cs.wpi.edu/~rich

Sorry, maybe @rmculpepper can help.

Right, the empty string behavior makes sense, and is nice. It's the "string that matches a language" behavior that I was finding odd.
In any case, this looks like a useful feature, and the implementation looks reasonable.

I cloned racket, changed freebsd on ppc in the sconfig to contain:

```
#define SCHEME_PLATFORM_LIBRARY_SUBPATH "ppc-freebsd"
#define MZ_USE_JIT_PPC
```

And built it with `make`. I get the error: `http-client: connection ended early`. Any thoughts on this?
Note that by default both futures and places are disabled on ppc.
`make base` builds without errors.

I'll enumerate, as usual...
1. Re my earlier point 7: it looked to me like the only interface you provide is `in-glob`, but I can think of at least two additional useful things: a `glob->list` that returns the list (instead of going through an extra step to get it, in the many cases where a list is fitting); maybe some `glob->pred` that returns a predicate (or, if you're doing a similar hack to what I did: some `glob->regexp`).
2. I see now that I fell into the GH markdown trap -- in point 10 the thing that was unclear to me was whether things like `*/*/*` work: I'm sure that most people expect it to work, but there are cases where you can only have a `*` in the last element, so it would be good to mention that.
3. Re the `foo{x,y}bar` thing: this is a good thing in general, but note that there could be two ways to interpret it.  The more obvious one (IMO) is "paths whose name matches `foo` followed by `x` or `y` followed by `bar`".  But what shells do is subtly different: they do the brace expansion _before_ expanding globs.  For example, in a new directory do a `touch fooxbar` and then try `echo foo{x,y}bar*` -- it behaves differently in bash and in zsh, and in each one can behave differently based on some shell configuration.  IMO, the former interpretation is more reasonable when you deal with file globs (shells have a problem where they can't tell what's intended to be a glob and what not), and therefore at some point I had used a `foo(x|y)bar` syntax instead.
   
   In any case, I'm not criticizing what you did (I didn't even try it, so I really don't know) -- but it's something that should be mentioned explicitly in the docs either way.  From a brief readin, it looks to me like you're doing the shell thing, but because you just use it to match, you get the good behavior, and in that case describing it as first doing the `{}` thing might be misleading.
4. I see this in the docs:
   
   > If the glob ends with a path separator (`/` on `'unix` or `'macosx` systems, `\` on `'windows` then it only matches directories.
   
   This looks wrong because the convention is that `/` can also be used on Windows to separate directories, so I think that a suffix of `/` should mean the same across all platforms, and `\` works also if you're on windows.  This is especially true since you're keeping the paths-or-strings thing, which means that I would expect a path of `foo/` to match a `foo` directory when it's used as a glob on windows too.
5. Finally, having both a keyword and a parameter means that either it's complictaed (as in having the parameter have three values: include dots, don't include them, and unset; the first two overriding a keyword, and the last being the default), or it's simple and then the parameter can mess up otherwise-fine code.  IMO the complexity is not worth it, and the simple case is too fragile.

Building it with the ports system (minimal-racket) with the above sconfig and without places or futures I get an error in racket3m:

```
/usr/ports/lang/racket-minimal/work/racket-6.6/src/racket/.libs/racket3m: Undefined symbol "GC_variable_stack"
```

Thanks,
1. [`(glob ....)`](https://github.com/racket/racket/pull/1464/files#diff-751266cc6e8f06cdc77958951f21cd0eR61) builds the list of matching files. `(λ (x) (glob-match? g x))` [(doc)](https://github.com/racket/racket/pull/1464/files#diff-751266cc6e8f06cdc77958951f21cd0eR109) does what `(glob->pred g)` would do. There is a `glob->regexp` in the implementation, but I would rather just export `glob-match?` because `glob-match?`'s implementation is a little smarter than just calling `regexp-match?` on the whole pattern.
2. `*` and `**` can be anywhere in the pattern, there's 2 examples in the docs for this: [L75](https://github.com/racket/racket/pull/1464/files#diff-751266cc6e8f06cdc77958951f21cd0eR75) [L79](https://github.com/racket/racket/pull/1464/files#diff-751266cc6e8f06cdc77958951f21cd0eR80)
3. Brace expansion happens before any globs are expanded -- so `(glob "{foo,bar}*")` gives the same result as `(glob '("foo*" "bar*"))`. I tried to explain this in the docs with an [example](https://github.com/racket/racket/pull/1464/files#diff-751266cc6e8f06cdc77958951f21cd0eR92) and calling braces a [meta-wildcard](https://github.com/racket/racket/pull/1464/files#diff-751266cc6e8f06cdc77958951f21cd0eR50), but I'll add another line to make it clear.
4. Fixed, thanks
5. The parameter has 2 values, `#f` and anything else, and changes the default value of the keyword argument `#:capture-dotfiles?`. The use-case I have in mind is that someone writes a script with a few calls to glob functions, then realizes they wanted to match dotfiles. They can just set the parameter instead of modifying the call sites. (And if you do specify `#:capture-dotfiles?`, that call ignores the parameter.) Can you explain how it might be fragile?

About `{a,b}` vs. `{a|b}`, I think we should stick to `,` because it'll be familiar to (some) shell, [perl](http://perldoc.perl.org/functions/glob.html), and [php](http://php.net/manual/en/function.glob.php) programmers. But I do like the `|` --- anyone else have thoughts about switching?

1dd934c8cb78ba038235eab9659bc9c4c08c07df

1. Sounds good.
2. -"-
3. Given that the overall effect is to leave only strings that match paths, I'm saying that you could downplay the two stages.
4. -"-
5. Oh, I missed that the parameter sets the default value for the keyword.  That sounds perfectly fine then.
6. Yeah, I gave my `(|)` choice as an example, I don't really have an opinion on it, and preferring `{,}` has valid reasons...

@mflatt Can you help me with this?

I added the following test case

```
(begin
  (define-syntax (slv stx)
    (syntax-case stx ()
      [(_ t)
       #`'#,(object-name (syntax-local-value #'t))]))

  (define-syntax one (procedure-rename (λ (stx) #'1) 'one))
  (define-syntax two (procedure-rename (λ (stx) #'2) 'two))

  (define-syntax-parameter normal
    (make-rename-transformer #'one))
  (test #f eq? (slv normal) 'one)
  (test #t = normal 1)
  (syntax-parameterize ([normal (make-rename-transformer #'two)])
    (test #f eq? (slv normal) 'two)
    (test #t = normal 2))

  (define-rename-transformer-parameter rt
    (make-rename-transformer #'one))
  (test #t eq? (slv rt) 'one)
  (test #t = rt 1)
  (syntax-parameterize ([rt (make-rename-transformer #'two)])
    (test #t eq? (slv rt) 'two)
    (test #t = rt 2)))
```

to `~plt/pkgs/racket-test-core/tests/racket/stxparam.rktl`

but I can't make heads or tails of it. The `rt` binding definitely calling the dynamic `rename-transformer-target` function that uses `syntax-local-get-shadower` to make it so it binds to the inner-most `rt33` (or whatever) which is why `syntax-local-value` works, but I can't see why the expander doesn't see that when expanding `rt`.

I feel like if one works, the other should too, and I really can't tell the different between the two contexts looking at the `syntax-debug-info` of the two identifiers inside the implementations.

downloaded the dmg from the official website, double click on it, nothing happens after the "verifying" message

I think we should merge this once you put in a test.

I finally got a build working with JIT enabled (I didn't give it any JIT flags like msse, msse2 or mfpmath=sse). The output of eval-jit-enabled ist true. 
I have to say, my racket interpreter is pretty slow. When I execute the given test, the output is still the same as when I ran it the first time (see above).
BTW: I installed racket-minimal and I'm running freebsd without a window system so I don't know if DrRacket would work or not.

I was also mistaken about the default build. On PowerPC you specifically have to specifically disable places and futures, otherwise it doesn't work. 

@jeapostrophe What kind of test do you think would be most useful? It seems like it would be difficult to test the actual authentication mechanism without actually running a git server that requires authentication.

You could use pltgit. You could make a burner github account with an app-specific password. Clearly it would be good to have tests, right?

Yes, absolutely, but I don’t want core Racket tests to depend on some piece of _my_ configuration that only I control. If you can give me instructions on how to test this against some PLT-controlled service, though, I’d be happy to write the relevant tests.

I think the problem is that our pltgit only supports SSH keys :/

Can you make a little fake shim server that looks for a correctly formatted request appear?

Possibly, yes. It looks like [`git http-backend`](https://git-scm.com/docs/git-http-backend) implements the HTTP server as a CGI program, and it would be possible to wrap that with something that implements HTTP basic auth. Is it okay for a test to depend on `git` being on the system? And is it possible to use the web server in the tests, or would I have to implement it using only what’s in `base`?

On Wed, Oct 5, 2016 at 3:57 PM, Alexis King notifications@github.com
wrote:

> Possibly, yes. It looks like git http-backend
> https://git-scm.com/docs/git-http-backend implements the HTTP server as
> a CGI program, and it would be possible to wrap that with something that
> implements HTTP basic auth. Is it okay for a test to depend on git being
> on the system?
> 
> Yes
> 
> And is it possible to use the web server in the tests, or would I have to
> implement it using only what’s in base?
> 
> You can use the Web Server

Jay

## 

Jay McCarthy
Associate Professor
PLT @ CS @ UMass Lowell
http://jeapostrophe.github.io

```
       "Wherefore, be not weary in well-doing,
  for ye are laying the foundation of a great work.
```

And out of small things proceedeth that which is great."
                          - D&C 64:33

@jeapostrophe: I pushed a commit that adds a test using a proxy server, which is in `pkgs/racket-test/tests/pkg/git-http-proxy.rkt`. It still uses a predefined port, though, like the other services in `pkgs/racket-test/tests/pkg/util.rkt`. If you have a suggestion for a way to use an arbitrary port without a _lot_ of restructuring, I’d be open to it, but this seems to work alright for now.

The reason why I asked for the tests is because racket crashes on OpenBSD/macppc. I installed FreeBSD 10.2 and I see the same crash in the same test (`racket -f unsafe.rktl`). Something is broken in the powerpc JIT or GC code (the same test works fine without the JIT but other different tests fail).

That said, I think that the PR is correct and someone should commit the changes.

It looks great. We should merge.

1. It looks like this catches any `exn:fail:git` and retries with the next set of credentials, but that exception can be raised for other failures too?  So if there's some random error and I have three sets of credentials it'll re-try stuff four time --- and if some error happens after a minute's timeout I'll be waiting four minutes...
2. Credentials should allow forms other than username/password since there are other ways of authenticating that other people will want.
3. IMO, any piece of software that deals with passwords should be extra noisily verbose about storing passwords, even more if they're unencrypted.
4. Encrypting them _does_ have an advantage: pulling the password out is easy if you know what you're doing, but in most cases you're a hacker harvesting strings for passwords and you know nothing about racket.
5. Finally, something like this should really have some way to specify credentials to specific urls (or url templates/regexps/whatever).  There are systems that will happily blacklist your IP or username (if multiple credentials have the same username) when they see more than N authentication failures in a short period.  We had this issue with the PLT git server blacklisting people who had more than 3 identity files specified that would be tried for all hosts, resulting in being blacklisted before getting to the correct key.  (And I see companies that _do_ have such restrictions, BTW.)

@elibarzilay: Aside from maybe the encryption issue, it looks like all your comments could be addressed later without breaking backwards compatibility (and maybe the encryption issue too).
Given that @lexi-lambda would like this change to be included in the release (and branch day is tomorrow (which is not the last chance to merge, but I digress)), I'd be in favor of going forward with the merge now, and improving the feature later.

@stamourv: bullet point 1 seems likely to be a trivial fix and worth doing today?

Could be. I'd leave it up to @lexi-lambda. She's offering us a very nice contribution already. If she wants to do more work before merging, that's nice, but if not that's ok too.

Sure, of course!

> It looks like this catches any exn:fail:git and retries with the next set of credentials, but that exception can be raised for other failures too? So if there's some random error and I have three sets of credentials it'll re-try stuff four time --- and if some error happens after a minute's timeout I'll be waiting four minutes...

The tricky thing here is that git does not really specify authentication very closely—it clearly permits using basic auth, but it doesn’t describe what responses should be or what should happen when things go wrong. Since the smart HTTP protocol makes a number of requests, it’d probably require more thought to figure out how to more gracefully treat authentication failures (that is, it should look for status codes and headers, such as `WWW-Authenticate`, which the current code doesn’t do at all). For that reason, it wouldn’t be trivial, but it’s certainly doable.

> Credentials should allow forms other than username/password since there are other ways of authenticating that other people will want.

Probably, yeah, but I think those are outside the scope of this pull request, and nothing in these changes should preclude adding more authentication schemes later.

> IMO, any piece of software that deals with passwords should be extra noisily verbose about storing passwords, even more if they're unencrypted.

Yeah. I am uncomfortably aware that the way this code handles passwords is terrible, perhaps bordering on irresponsible. I am no security expert, though, and I’m not sure what the right thing to do is here. For GitHub, at least, you can use personal auth tokens as “passwords”, so you’re not storing your real password as plaintext, but that’s a totally GH-specific thing.

Is there any facility in the Racket core that could encrypt/decrypt the passwords? Also, separately, what do you consider “noisily verbose” in this particular context? I know the `raco pkg config` interface isn’t very good for this, and I’d like to improve it, but I really don’t have the time to overhaul that right now.

> Finally, something like this should really have some way to specify credentials to specific urls (or url templates/regexps/whatever). There are systems that will happily blacklist your IP or username (if multiple credentials have the same username) when they see more than N authentication failures in a short period. We had this issue with the PLT git server blacklisting people who had more than 3 identity files specified that would be tried for all hosts, resulting in being blacklisted before getting to the correct key.

If this becomes a problem for people, it sounds like a good idea to implement it. One thing I’d definitely _like_ to do, at the very least, is do some caching about which set of credentials succeeded for a particular package to be a little more intelligent when trying to clone the repository next time, but I definitely think that’s something that can be added later. In the meantime, given that this won’t impact people at all unless they explicitly opt-in to this feature, I’m not sure it’s worth the effort to do up front (and I _do_ think it would be a lot of effort, not because it’s technically complicated, but because the `raco pkg config` command-line interface is not very sophisticated, and providing a good UI for these kinds of options would require making it a lot more capable than it is now).

Hi Robbie, This bug is preventing my students from using the macro stepper
for their homework and projects.   Is it possible to give me some sort of
"patch file"---even it involves manually copying a binary file into a
folder somewhere, this would be a big help.

Thanks in advance,

-Chuck

On Mon, Oct 3, 2016 at 8:54 PM, Robby Findler notifications@github.com
wrote:

> I've pushed a fix for this here: racket/htdp@d6d90ad
> https://github.com/racket/htdp/commit/d6d90adcff65c926c7a9215375e9bd575e0bebac
> 
> but you probably should use
> 
> (require test-engine/racket-tests)
> 
> instead of the require line you've got there. That's really intended to
> be used only from inside DrRacket, if I understand correctly.
> 
> —
> You are receiving this because you authored the thread.
> Reply to this email directly, view it on GitHub
> https://github.com/racket/racket/issues/1480#issuecomment-251268563, or mute
> the thread
> https://github.com/notifications/unsubscribe-auth/ACsqECwDJBaYAalJYE6yVjlMqUO3W5x2ks5qwaPegaJpZM4KNGTw
> .

## 

Dr. Charles Rich, Professor, Computer Science Department
http://www.cs.wpi.edu
Interactive Media and Game Development Program
http://www.wpi.edu/academics/imgd/
Robotics Engineering Program http://www.wpi.edu/academics/robotics/
Worcester Polytechnic Institute, Fuller Laboratories B25b
100 Institute Road, Worcester, MA 01609-2280

Email: rich@wpi.edu   Phone: 508-831-5945   Fax: 508-831-5776
Home: http://www.cs.wpi.edu/~rich

I recommend you just change the require line. 

But if you really think it is worth the trouble and you think they are savvy enough to edit files in the Racket distribution, then can open DrRacket, choose the "Open Require Path..." menu item (File menu), type "test-engine/test-display", hit return, and then make the edit that you see in this diff (at the end):

https://github.com/racket/htdp/commit/d6d90adcff65c926c7a9215375e9bd575e0bebac

and then exit DrRacket and run "raco setup" from teh command-line (this works on windows too), wait for that to complete and then restart DrRacket.

> The tricky thing here is that git does not really specify authentication very closely—it clearly permits using basic auth, but it doesn’t describe what responses should be or what should happen when things go wrong. Since the smart HTTP protocol makes a number of requests, it’d probably require more thought to figure out how to more gracefully treat authentication failures (that is, it should look for status codes and headers, such as `WWW-Authenticate`, which the current code doesn’t do at all). For that reason, it wouldn’t be trivial, but it’s certainly doable.

I would assume that the authentication failures would be covered by standard HTTP response codes (maybe even done completely by the web server in some cases), and therefore would be easy to catch.

> > Credentials should allow forms other than username/password since there are other ways of authenticating that other people will want.
> 
> Probably, yeah, but I think those are outside the scope of this pull request, and nothing in these changes should preclude adding more authentication schemes later.

The only thing is that you're saving a list of username/passwords, so there's no real place to extend it.  What I meant in the above is that it should be wrapped by something that indicates the contents (eg cons a 'basic in front), and a simple check for that (check that 'basic is there), and that's enough to have different things in the future.

> Is there any facility in the Racket core that could encrypt/decrypt the passwords? Also, separately, what do you consider “noisily verbose” in this particular context? I know the `raco pkg config` interface isn’t very good for this, and I’d like to improve it, but I really don’t have the time to overhaul that right now.

There might be something in ssl, but the main thing is some visible warning, in the docs & command line, wherever possible.  If the cli interface doesn't make it possible to add printouts, then maybe the description could include "(UNENCRYPTED)", or something...

> If this becomes a problem for people, it sounds like a good idea to implement it. One thing I’d definitely _like_ to do, at the very least, is do some caching about which set of credentials succeeded for a particular package to be a little more intelligent when trying to clone the repository next time, but I definitely think that’s something that can be added later. In the meantime, given that this won’t impact people at all unless they explicitly opt-in to this feature, I’m not sure it’s worth the effort to do up front (and I _do_ think it would be a lot of effort, not because it’s technically complicated, but because the `raco pkg config` command-line interface is not very sophisticated, and providing a good UI for these kinds of options would require making it a lot more capable than it is now).

Same as above: just a small hook to make it possible.

Sorry please ignore my email.  Was thinking about _other_ (macro stepper)
bug

On Thursday, October 6, 2016, Robby Findler notifications@github.com
wrote:

> I recommend you just change the require line.
> 
> But if you really think it is worth the trouble and you think they are
> savvy enough to edit files in the Racket distribution, then can open
> DrRacket, choose the "Open Require Path..." menu item (File menu), type
> "test-engine/test-display", hit return, and then make the edit that you see
> in this diff (at the end):
> 
> racket/htdp@d6d90ad
> https://github.com/racket/htdp/commit/d6d90adcff65c926c7a9215375e9bd575e0bebac
> 
> and then exit DrRacket and run "raco setup" from teh command-line (this
> works on windows too), wait for that to complete and then restart DrRacket.
> 
> —
> You are receiving this because you were mentioned.
> Reply to this email directly, view it on GitHub
> https://github.com/racket/racket/issues/1480#issuecomment-252037158, or mute
> the thread
> https://github.com/notifications/unsubscribe-auth/ACsqEIWw-LNzpe3-vMDndMbGMYPEfDUZks5qxTQcgaJpZM4KNGTw
> .

## 

Sent from my iPhone...

Dr. Charles Rich, Professor, Computer Science Department
Interactive Media and Game Development Program
Robotics Engineering Program
Worcester Polytechnic Institute, Fuller Laboratories B25b
100 Institute Road, Worcester, MA 01609-2280

Email: rich@wpi.edu Phone: 508-831-5945 Fax: 508-831-5776
Home: http://www.cs.wpi.edu/~rich

@jeapostrophe I hope to have time to look at this tomorrow or this weekend.

Just squashed the commits. Let's merge in T-minus 2 days?

T-minus 2 days?
I'd recommend merging now; branch day is tomorrow.

👍  97c65102b3ca4aaacf0674fe691e3c0783224bc0

65a69417cc4d1bc1d5c8cfef2b3ab6bb830852d4

I’m going to merge this because, frankly, I’d like to have this functionality, and I don’t have the time to implement anything significantly better right now. Hopefully it shouldn’t be too hard to revisit this later if people need stronger guarantees or more features.

Thanks for contributing!

@lexi-lambda 

> It looks like this catches any exn:fail:git and retries with the next set of credentials, but that exception can be raised for other failures too? So if there's some random error and I have three sets of credentials it'll re-try stuff four time --- and if some error happens after a minute's timeout I'll be waiting four minutes...

The tricky thing here is that git does not really specify authentication very closely—it clearly permits using basic auth, but it doesn’t describe what responses should be or what should happen when things go wrong. Since the smart HTTP protocol makes a number of requests, it’d probably require more thought to figure out how to more gracefully treat authentication failures (that is, it should look for status codes and headers, such as `WWW-Authenticate`, which the current code doesn’t do at all). For that reason, it wouldn’t be trivial, but it’s certainly doable.

> Credentials should allow forms other than username/password since there are other ways of authenticating that other people will want.

Probably, yeah, but I think those are outside the scope of this pull request, and nothing in these changes should preclude adding more authentication schemes later.

> IMO, any piece of software that deals with passwords should be extra noisily verbose about storing passwords, even more if they're unencrypted.

Yeah. I am uncomfortably aware that the way this code handles passwords is terrible, perhaps bordering on irresponsible. I am no security expert, though, and I’m not sure what the right thing to do is here. For GitHub, at least, you can use personal auth tokens as “passwords”, so you’re not storing your real password as plaintext, but that’s a totally GH-specific thing.

Is there any facility in the Racket core that could encrypt/decrypt the passwords? Also, separately, what do you consider “noisily verbose” in this particular context? I know the `raco pkg config` interface isn’t very good for this, and I’d like to improve it, but I really don’t have the time to overhaul that right now.

> Finally, something like this should really have some way to specify credentials to specific urls (or url templates/regexps/whatever). There are systems that will happily blacklist your IP or username (if multiple credentials have the same username) when they see more than N authentication failures in a short period. We had this issue with the PLT git server blacklisting people who had more than 3 identity files specified that would be tried for all hosts, resulting in being blacklisted before getting to the correct key.

If this becomes a problem for people, it sounds like a good idea to implement it. One thing I’d definitely _like_ to do, at the very least, is do some caching about which set of credentials succeeded for a particular package to be a little more intelligent when trying to clone the repository next time, but I definitely think that’s something that can be added later. In the meantime, given that this won’t impact people at all unless they explicitly opt-in to this feature, I’m not sure it’s worth the effort to do up front (and I _do_ think it would be a lot of effort, not because it’s technically complicated, but because the `raco pkg config` command-line interface is not very sophisticated, and providing a good UI for these kinds of options would require making it a lot more capable than it is now).

@elibarzilay 

> The tricky thing here is that git does not really specify authentication very closely—it clearly permits using basic auth, but it doesn’t describe what responses should be or what should happen when things go wrong. Since the smart HTTP protocol makes a number of requests, it’d probably require more thought to figure out how to more gracefully treat authentication failures (that is, it should look for status codes and headers, such as `WWW-Authenticate`, which the current code doesn’t do at all). For that reason, it wouldn’t be trivial, but it’s certainly doable.

I would assume that the authentication failures would be covered by standard HTTP response codes (maybe even done completely by the web server in some cases), and therefore would be easy to catch.

> > Credentials should allow forms other than username/password since there are other ways of authenticating that other people will want.
> 
> Probably, yeah, but I think those are outside the scope of this pull request, and nothing in these changes should preclude adding more authentication schemes later.

The only thing is that you're saving a list of username/passwords, so there's no real place to extend it.  What I meant in the above is that it should be wrapped by something that indicates the contents (eg cons a 'basic in front), and a simple check for that (check that 'basic is there), and that's enough to have different things in the future.

> Is there any facility in the Racket core that could encrypt/decrypt the passwords? Also, separately, what do you consider “noisily verbose” in this particular context? I know the `raco pkg config` interface isn’t very good for this, and I’d like to improve it, but I really don’t have the time to overhaul that right now.

There might be something in ssl, but the main thing is some visible warning, in the docs & command line, wherever possible.  If the cli interface doesn't make it possible to add printouts, then maybe the description could include "(UNENCRYPTED)", or something...

> If this becomes a problem for people, it sounds like a good idea to implement it. One thing I’d definitely _like_ to do, at the very least, is do some caching about which set of credentials succeeded for a particular package to be a little more intelligent when trying to clone the repository next time, but I definitely think that’s something that can be added later. In the meantime, given that this won’t impact people at all unless they explicitly opt-in to this feature, I’m not sure it’s worth the effort to do up front (and I _do_ think it would be a lot of effort, not because it’s technically complicated, but because the `raco pkg config` command-line interface is not very sophisticated, and providing a good UI for these kinds of options would require making it a lot more capable than it is now).

Same as above: just a small hook to make it possible.

@lexi-lambda: if you pushed it as-is, then you _are_ making it unnecessarily hard to revisit for more features etc.  Just cons a symbol in the front, and you'll make it easy again.

This is not an imaginary problem, BTW.  The handin server still uses MD5 checksum -- it's pretty hard to update in a backward compatible way because there is no place for a type or version specification.  Another example of a similar problem: look at a linux password file (usually `/etc/shadow`) and you'll see passwords that start with things like `$n$` -- that's a hack since there was no other easy way to enhance the file format without breaking compatibility.

I pushed what I had at the suggestion of three other maintainers, not least in part because I simply do not have more time to dedicate to this right now. If you’d like to revert it, I will not complain, but unless someone else is willing to take this on, it seems unlikely it will get done at all.

There is an argument to be made that doing things right eventually is better than doing things wrong now, but I am willing to defer to the judgement of others here.

Yes, for me it also crashed on that test. 

Btw: Is it normal that a simple hello world in racket takes about 2s on an old computer (~700 according to geekbench)?

@lexi-lambda: I'm not going to revert it.  To make it clear, all I'm suggesting is that you cons up one symbol before the username/password list.  It's a tiny ~1min change that would go a long way to make it easy to extend in the future, since it'll be possible to make the current code deal with configurations that start with that symbol.

Try this: `echo '#lang racket/base\n(displayln "hello world")' > hello.rkt && raco make hello.rkt`.  Then run `racket hello.rkt`, it will avoid the slow cold start. BSDs on powerpc are usually slow, I don't know how Apple made OSX fast on these machines.

If you run `raco make -v hello.rkt` (adding the `-v` flag) and you see lots and lots of output, that means that probably you missed a step in the build process. (You would see all this output only the first time you run the command; but you know it was there if the command gets a lot faster the second time.)

@elibarzilay: If the change is this simple (which I can believe), please point me to the relevant parts of the code, and I'll make the changes.
Asking @lexi-lambda to do more work after she's already contributed a valuable improvement is not the right things to do here.

@stamourv, I'm talking about a very minimal change that will avoid an ugly hack when it's extended in the future.

Looking through the diff, it looks like only two files are relevant:
1. In `pkgs/racket-doc/pkg/scribblings/pkg.scrbl`:
   
   ```
    @item{@exec{git-checkout-credentials} --- ...
   ```
   
   Update and say that it starts with a format specification datum which is currently only `'basic`.
2. In `racket/collects/pkg/private/config.rkt`:
   
   ```
    (or (current-pkg-git-checkout-credentials)
        (read-pkg-cfg/def 'git-checkout-credentials)))
   ```
   
   Minimal: add a `cdr` around the whole thing.  Optional: throw an error if it's not 'basic.
   
   (It _looks_ like `current-pkg-git-checkout-credentials` is intended to fake a setup, but I'm not sure since I don't see it used anywhere in the diff.)
   
   In the definition of `get-default`:
   
   ```
        ['git-checkout-credentials '()]
   ```
   
   Change the value to `'(basic)`.
   
   In the definition of `pkg-config`:
   
   ```
          (update-pkg-cfg! 'git-checkout-credentials
                           (for/list ([val (in-list vals)])
   ```
   
   wrap a `(cons 'basic ...)` around the `for/list`
   
   A bit later in `pkg-config`:
   
   ```
               (for ([creds (in-list (read-pkg-cfg/def 'git-checkout-credentials))])
   ```
   
   Add a `cdr` around the result of `read-pkg-cfg/def`

@irrigator Do you mean that the ".dmg" itself doesn't open? Can you double-check the SHA1 hash of the ".dmg" file (possibly using `open ssl racket-6.6-x86_64-macosx.dmg`)?

Side note, if it matters: a number of my students have mounted the .dmg, dragged the DrRacket application out onto the desktop, then ejected or destroyed the disk. I've seen these students try to launch DrRacket, and seen it simply silently close again. I wonder if it would be possible to provide an alert in this case. Yes, I could probably do this myself.

If any developer is reading this, please reply, as I would like to know that this will be fixed before I teach a course with DrRacket again next fall.   This caused a lot of trouble for my students this year, but we lived with it---I am hoping it will eventually be fixed.   Thanks, -CR

Looking at the code, it seems like it is calling methods like `set-max-width` (and others) in an illegal way. In particular, it is calling them from threads that are not the eventspace main thread of the frame containing the editor (receiver object for the `set-max-width` method). The code seems to be going to some trouble to cope with this, so it may be relying on invariants I don't know about, tho. @rmculpepper may know more, as he is the author/maintainer of this code.

Also: this is the wrong repo. You may have more luck if you use the right one: https://github.com/racket/macro-debugger

Thanks, Robbie!

On Fri, Oct 7, 2016 at 12:51 PM, Robby Findler notifications@github.com
wrote:

> Looking at the code, it seems like it is calling methods like
> set-max-width (and others) in an illegal way. In particular, it is
> calling them from threads that are not the eventspace main thread of the
> frame containing the editor (receiver object for the set-max-width
> method). The code seems to be going to some trouble to cope with this, so
> it may be relying on invariants I don't know about, tho. @rmculpepper
> https://github.com/rmculpepper may know more, as he is the
> author/maintainer of this code.
> 
> Also: this is the wrong repo. You may have more luck if you use the right
> one: https://github.com/racket/macro-debugger
> 
> —
> You are receiving this because you commented.
> Reply to this email directly, view it on GitHub
> https://github.com/racket/racket/issues/1408#issuecomment-252303794, or mute
> the thread
> https://github.com/notifications/unsubscribe-auth/ACsqEJ56CiDtWe9b4DK36ZyuHv5XHmIOks5qxnijgaJpZM4JZwRC
> .

## 

Dr. Charles Rich, Professor, Computer Science Department
http://www.cs.wpi.edu
Interactive Media and Game Development Program
http://www.wpi.edu/academics/imgd/
Robotics Engineering Program http://www.wpi.edu/academics/robotics/
Worcester Polytechnic Institute, Fuller Laboratories B25b
100 Institute Road, Worcester, MA 01609-2280

Email: rich@wpi.edu   Phone: 508-831-5945   Fax: 508-831-5776
Home: http://www.cs.wpi.edu/~rich

Closing this issue now that @charlesrich moved it to the right repo. Thanks @charlesrich !

https://github.com/racket/macro-debugger/issues/17

Merged.

I've pushed the changes. Thanks @eli!

Phew, I'm glad I wasn't incompetent :)

@mflatt Might be that the download was corrupt. I downloaded it again and verified that the SHA1 is correct. Everything works fine.

It appears to be a general hygiene issue, not a syntax-parse issue, as demonstrated by the following program:

```
#lang racket
(require (for-syntax racket/match))
(begin-for-syntax
  (define-syntax-rule (my-struct . opts)
    (struct . opts))

  (my-struct A (x y))
  (struct B (x y)))

(define-syntax (foo stx)
  (match (A 1 2)
    [(A x y) #`(quote #,(list x y))]
    [(B x y) #`(quote #,(list x y))]))
```

which raises the error `match: syntax error in pattern in: (A x y)`. That is, the `syntax-local-value` call on `A` in the match pattern fails for some reason---presumably the same reason it fails when looking up the syntax class `cls1` in the original example.

Hm. Just to be sure: Is it something I'm missing, or is it intended to be that way? I have the feeling that both examples should work without the `remove-use-site-scope` trick.

Both programs work in Racket 6.1.

[syntax-local-identifier-as-binding](http://docs.racket-lang.org/reference/stxtrans.html#%28def._%28%28quote._~23~25kernel%29._syntax-local-identifier-as-binding%29%29) was added in v6.3, which is when the new macro expander from @mflatt was used. Maybe that's just a limitation / new way of working of the new expander.

Compiling reduces the two seconds to about one and a half.

On `raco make -v` the output shows nothing unexpected. On `raco make --vv` I get almost 300 lines of `checking: ...` but also that seems quite expected.

But to be honest, it's not such a big deal for me. As long as it works, I'm happy.

I don't have the details of the logging system paged in, but I remember there being a lot of subtlety there.

The solution you're suggesting seems to conflict the design goal of `with-intercepted-logging`, which is to catch log messages from the thunk passed to it only, and would break backwards compatibility, I believe.

It looks like your use case would be satisfied by adding a keyword argument to specify which logger to listen to. Would that satisfy the actual use case you have (presumably in some larger program)?

@bennn: If you want to give it a shot.

Just read the commit --yeah that's perfect.

I wanted a program like this to print "intercepted"

```
#lang racket/base
(require racket/logging)

(define-logger custom)

(with-intercepted-logging
  (λ (l) (displayln "intercepted"))
  (λ () (log-custom-warning "hello"))
  'warning)
```

@stamourv -- thanks!

Oh, good. I wasn't sure about the docs.
Is it ok if this doesn't go into the release?

Yeah that's fine, no rush.

What happened to this?

Merged, thanks!

As https://github.com/racket/racket/commit/9422d6660103494e6c79f9f3e1c8944de66c4901

Update: per @mflatt's suggestion, I poked around and it seems likely these errors/warnings occur when TR's testing framework type checks a `#lang typed/racket/gui` file in a place that is not the main process.

This is the file in question https://github.com/racket/typed-racket/blob/master/typed-racket-test/succeed/gui-lang.rkt

I ran the tests a couple times without this file present and with the file present -- that seemed to correlate with whether or not the error occurred.

That error message looks like it comes from here:
https://github.com/racket/racket/blob/master/racket/collects/syntax/parse/private/runtime.rkt#L54-L56

``` racket
(define-syntax-parameter fail-handler
  (lambda (stx)
    (wrong-syntax stx "internal error: fail-handler used out of context")))
```

So it's probably a `syntax/parse` bug and not a macroexpander bug.

I just updated this to make Travis build new packages on v6.7 by default. Ping @stamourv : should this be included in the release branch?

Hmm, that's an interesting one.
Yes, it would be nice to have this in the release. But, until the release actually happens, this change "breaks" raco pkg new, in that it will ask Travis to look for a version that doesn't exist (yet).
I guess I could merge it to the release branch, but only merge it to master after 6.7 is released?

In any case, any additions to the release at this point need consensus from the release managers. I'll bring it up.

@stamourv yes, it breaks the Travis build for packages created via `raco pkg new` until 6.7 is out. I thought 6.7 would be out soon enough that it wouldn't really matter (plus the Travis error is easy enough to spot), but your idea of merging on `release` first then on `master` when 6.7 is out sounds way better :) .

@jsmaniac: After consultation with release management, we'll go with merging to release, then merging to master once the release is out.

In general, though, hard-coding release numbers like that is a terrible idea (not blaming you).
A better solution would be to have `raco pkg new` write down the version it's using itself (if it's a release version), maybe defaulting to the latest (there's code for latest version checking somewhere) if it's not. Want to give it a shot?

@stamourv I'll think about it. I suppose something along these lines would work:

```
(require version/utils)
(string-join
 (for*/list ([major (in-range 6 (add1 (car (version->list (version)))))]
             [minor (in-range 0 (add1 (cadr (version->list (version)))))])
   (format "- RACKET_VERSION=~a.~a" major minor))
 "\n")
```

It will definitely require some testing (I'm not sure if `(version)` always returns `major.minor.x.y`, for starters), so I'll put that on my todo-list for later.

That general approach should work. A couple comments.
- Do we want to list all these versions? That doesn't seem to be a great use of Travis, no?
- This won't catch releases like 6.1.1, which was a regular (i.e., not a quick bug fix) release, AFAIR. We've basically moved to just using major.minor, but I expect that bug fix releases may still end up using the 3rd number. And we'd definitely want to test those.

Merged. Will look into getting it in the release.

Yeah, I thought the `6.1.1` and future bug-fix releases would still need to be hard-coded. I don't really see how this could be done otherwise: if there is a 6.7.1 and a 6.7.2 release, and we move on to 6.8, the 6.8 release does not contain any reference to the 6.7.1 and 6.7.2 releases.

In the end, the candidate versions are those present on http://mirror.racket-lang.org/installers/, but I don't really like the idea of fetching this within `raco pkg new` (I'd expect that command to work in the same way, regardless of the network connectivity).

As for whether to include all the versions by default, or a specific set + the latest / the last 3 / …, I'd rather leave the decision to people who are more knowledgeable about the specificities of each relase (i.e. I probably should ask on the dev mailing list).

Personally, I'd be fine with just having `raco`'s own version (or latest, if it's not a release) in the list.
`raco pkg new` is not the be-all end-all of good testing practices. It's there to give you a starting point, and show you what you can do. Having a Travis config at all is enough for that.

It’s certainly possible, but it seems odd to me that something would work fine in an ordinary module but fail in a submodule, which is what leads me to wonder if it’s a macroexpander or syntax parameter issue.

Thanks!

[Sorry for the very slow response!]

I think `equal?` should be marked as non-cm, and that should solve the problem with the `values` wrapper. (Probably I just didn't think hard enough about it before, other than observing that `equal?` can't be folding like `eq?` and `eqv?`.)

The rest looks ok to me. I slightly prefer the name `true-object?` (following `eof-object?`) instead of `strict-true?`, but I'm happy either way.

These changes are good as far as I can tell.

Maybe `latin-1-char?` instead of `small-char?`? Or `interned-char?`, which more directly expresses the relevant property, but grates slightly with `symbol-interned?` (which only works on symbols).

For what it’s worth, I recently got this same error while using DrRacket, though I’m not sure exactly what caused it. It’s definitely not specific to remix, though, since I don’t have remix installed.

Sorry – I missed this thread before. The current theory is that these errors are due to me not bumping the version number with commit 9011fe7d839a8908be239a60991d4d04a043bc84. That change creates a mismatch between existing ".zo" files and the validator, but forcing a rebuild of Racket (as if I had changed the version) resolves the mismatch.

I rebased al the commits, and renamed `strict-true?` to `true-object?`.

I also added two small tweaks. One is an extension of the reduction for the expanded version of `or` and the other is a similar modification for the expanded version of `and`. (I think it’s more natural to squash and merge them now, than waiting to add the later.)

I like `interned-char?`, specially because perhaps some day more chars will be interned. (I don't have any unicode block in mind now, but it doesn't seam to be an impossible idea.) 

But I agree that it sounds too similar to `symbol-interned?`. I'll wait a few days, and if no one propose a better name I'll merge this with `interned-char?`.

That all sounds good to me.

Ok!

(where forcing a rebuild can be accomplished with `raco setup -c ; raco
setup`)

I confirm that after this incantation, the error is still there.

On Tue, Oct 25, 2016 at 2:25 PM, Robby Findler notifications@github.com
wrote:

> (where forcing a rebuild can be accomplished with `raco setup -c ; raco
> setup`)
> 
> —
> You are receiving this because you authored the thread.
> Reply to this email directly, view it on GitHub
> https://github.com/racket/racket/issues/1494#issuecomment-256125852, or mute
> the thread
> https://github.com/notifications/unsubscribe-auth/AAOM-ggcRDgzLd9_mNjFba2qLA4fbiP9ks5q3kmggaJpZM4KcFA7
> .

## 

Jay McCarthy
Associate Professor
PLT @ CS @ UMass Lowell
http://jeapostrophe.github.io

```
       "Wherefore, be not weary in well-doing,
  for ye are laying the foundation of a great work.
```

And out of small things proceedeth that which is great."
                          - D&C 64:33

I am fairly certain that I got the error before updating to include that
commit (although I did update to include it before sending the report.) But
I will test shortly and force a rebuild.

On Mon, Oct 24, 2016 at 1:23 PM, Matthew Flatt notifications@github.com
wrote:

> Sorry – I missed this thread before. The current theory is that these
> errors are due to me not bumping the version number with commit 9011fe7
> https://github.com/racket/racket/commit/9011fe7d839a8908be239a60991d4d04a043bc84.
> That change creates a mismatch between existing ".zo" files and the
> validator, but forcing a rebuild of Racket (as if I had changed the
> version) resolves the mismatch.
> 
> —
> You are receiving this because you authored the thread.
> Reply to this email directly, view it on GitHub
> https://github.com/racket/racket/issues/1494#issuecomment-255806484, or mute
> the thread
> https://github.com/notifications/unsubscribe-auth/AAOM-tjRApBWovJyrFJ_TSuBBd0sDBaIks5q3Ol2gaJpZM4KcFA7
> .

## 

Jay McCarthy
Associate Professor
PLT @ CS @ UMass Lowell
http://jeapostrophe.github.io

```
       "Wherefore, be not weary in well-doing,
  for ye are laying the foundation of a great work.
```

And out of small things proceedeth that which is great."
                          - D&C 64:33

I've pushed the squashed version: https://github.com/racket/racket/commit/f159295e55b2e480eaba453dbd405cd7185137d5

It's possible that would work, although it might create other problems for splicing definitions. (I'm not sure.)

I'm less in favor of fixing `syntax-local-get-shadower` than getting rid of it. Like `syntax-local-introduce`, it was an experiment to support certain goals, but it has problems and we've worked out better constructs to support those goals. The rewritten expander (still pending performance improvements that I hope to get back to in December) provides new core constructs to get rid of the remaining uses of `syntax-local-get-shadower` in the main collections.

Can you say more about your interest in `syntax-local-get-shadower` and having it work with splicing forms?

@mflatt Thanks for the quick answer. The use case I see for `syntax-local-get-shadower` is as an alternative to `syntax-local-value` which works with `let`. In the code below, `foo` fails to access the "most nested" binding of `aaa`. Replacing `(syntax-local-introduce #'aaa)` with `(syntax-local-get-shadower (datum->syntax #f 'aaa))` gives the expected result.

``` racket
#lang racket
(define-syntax (foo stx)
  (syntax-local-introduce #'aaa))

(define aaa 1)
(let ([aaa 2])
  (foo))
;; => Prints 1
```

Do you have any documentation or notes on how `syntax-local-get-shadower` and `syntax-local-introduce` will be replaced in the new expander? I'm using `syntax-local-introduce` quite often when writing hygiene-bending macros, although I agree it's not necessarily the best tool there is for the job  (e.g. it sometimes needs to be combined with `syntax-local-identifier-as-binding`, which often yields a lot of head-scratching), so I'm interested in considering the new/future "best practises".

---

A bit of context which you might be interested in:

I'm working on an alternative expander (built at a high level upon the existing one, i.e. I'm not trying to re-implement the low-level machinery of scopes etc.) which allows anonymous macros, and also allows a macro call to expand to another macro identifier, which can itself grab the parameters of the surrounding form. I intended to test-drive this alternative expander as the mechanism for expanding types in my type-expander library.

With my (WIP) expander, the following code:

``` racket
((macro-a args₁ …) args₂ …)
```

can expand to (provided that `macro-a` returns `#'macro-b`):

``` racket
(macro-b args₂ …)
```

where `macro-b` gets passed the whole form (instead of being expanded as an identifier macro, as is done by the official expander), so the whole form gets expanded to:

``` racket
the-result
```

Some cases are a bit more involved, for example consider:

``` racket
(define a 123)
((let-syntax ([mymacro mymacro-definition])
   (let ([a 456])
     mymacro))
 argument)
```

which gets expanded as a first step to:

``` racket
(define a 123)
(mymacro argument)
```

If the `mymacro-definition` does `(syntax-local-get-shadower (datum->syntax #f 'a))`, it is not clear whether it should refer to the `a = 456` in the context where the `mymacro` name appears, or the `a = 123` in the context where the actual macro call `(mymacro argument)` is expanded.

In order to have some level of compatibility / similarity with the existing expander, I was in the process of defining two alternatives, `syntax-local-get-ref-shadower` and `syntax-local-get-call-shadower`, the first producing `a = 456` and the second producing `a = 123` in the above example. Both would give the same value as `syntax-local-get-shadower` when the macro is immediately invoked.

It's probably better for me to attempt some compatibility / similarity with the future expander, so I'm definitely interested in knowing what the new constructs are.

@mflatt IIUC by reading the source of your linklet branch, the new constructs related to the current expansion context are:
- the expand-context struct
- make-expand-context
- copy-root-expand-context
- current-expand-context
- get-current-expand-context
- current-expand-observe
- and the as-*-context functions

Are these supposed to be public, or am I looking at the wrong file?

Merged into master. Should I leave this PR open for when you add the improvements we discussed?

@jsmaniac Those are not public, but the environment in an expansion context is made accessible, in a way, through the new `syntax-local-expand-expression/extend-environment` and `syntax-local-environment-ref` functions (which I see that I haven't documented, yet).

The mappings in an environment are intentionally separated from bindings – so, they avoid the problems of `syntax-local-get-shadower` while providing the primitive sensitivity to expansion context that is needed to implement constructs such as syntax parameters.

I'm getting the idea that you don't actually want to use `syntax-local-get-shadower`, but instead feel obligated to figure out how to support it (or something similar) in your expander. If I understand correctly, then I'd just encourage you to just ignore `syntax-local-get-shadower`. 

> I'm getting the idea that you don't actually want to use syntax-local-get-shadower, but instead feel obligated to figure out how to support it (or something similar) in your expander. If I understand correctly, then I'd just encourage you to just ignore syntax-local-get-shadower.

That's roughly it :) , thanks for the suggestion (which I'll follow!).

I had found the source for `syntax-local-expand-expression/extend-environment` and `syntax-local-environment-ref`, and they do seem useful.

Feel free to close this as "wontfix".

This is the relevant code:
https://github.com/racket/racket/commit/456a72a36c37a474e47d1b1c72df37b8167886ac#diff-140cdb4821379213ccc46e0f6054bd7bR163

``` racket
(define missing (gensym 'missing))
(define (id-table-ref! who d id default identifier->symbol identifier=?)
  (define entry (id-table-ref who d id missing identifier->symbol identifier=?))
  (cond [(eq? entry missing)
         (id-table-set! who d id default identifier->symbol identifier=?)
         (if (procedure? default) (default) default)]
        [else entry]))
```

@AlexKnauth Thanks! I pushed a patch, will open a PR in a minute.

Does the relocate function get used when there's concurrent mutation?

@stamourv I'm closing this PR, and I opened a separate issue to choose which versions to include, as it's not quite clear for me what is the best automatic strategy.

Yes, relocate is an attempt to mimic how @rmculpepper handled what happened if the bucket in the underlying mutable hash table changes between iterations within that bucket.

ping

This all seems plausible, so I'm fine with merging to try it out.

Merged, thanks!

4 or 5 both sound fine to me. It would be nice to also have the latest release, but that does require network access. I guess `raco pkg new` could just try to get access to the release info, and if it fails, just swallow the exception and skip adding that version.

If you're going to include HEAD, you might want to make it exempt from failure in the Travis build matrix. I've found it a bit too unstable for external packages to tie themselves to in CI.

Oh, interesting. I've found HEAD pretty stable in general. Any recent issues you remember?

There are two issues that come to mind, the latter more troublesome than the former:
1. Some time ago when @AlexKnauth and I were working on the lens library, every once in a great while the build against HEAD would fail while everything else passed, typically due to some odd macro bug somewhere in the latest version of racket. Reporting the bug and waiting for a fix wouldn't take too long, but we didn't want our CI process dependent on this.
2. Attempting to download the source would fail relatively often due to network issues. Setting up a retry isn't too hard, but it's more complex than I'd like for a CI script and it drastically increases build times.

How about using the nightly builds instead of HEAD? Wouldn't help with 1, but would help with 2.

That would probably work much better. Avoiding doing a git pull and install would go a long way towards making the "recent Racket" build as reliable as the released Racket builds.

Doesn't it already use the nightly builds for that?

Yes, greghendershott's `travis-racket` script, which is used by the currently generated `.travis.yml` uses the nightly builds for what it calls `HEAD`.

The generated `.travis.yml` also contains the following lines to make failures on HEAD acceptable:

```
matrix:
  allow_failures:
#   - env: RACKET_VERSION=HEAD
```

It's currently commented-out, but I can un-comment that line.

@stamourv by the way, do you happen to know (roughly) where the release info is available online?

http://download.racket-lang.org/version.txt

First, you should keep the old implementation around so the new one can fall back to it. The implementation of `in-idtbl/proc` is wrong; it produces a list (a sequence that yields one value per step) rather than a sequence that yields two values per step. You might want to add tests of the following forms to the existing tests in `pkgs/racket-test-core/tests/racket/id-table-test.rkt`:

```
(sequence->length (in-free-id-table _)) = _
(for ([(k v) (in-free-id-table _)]) _) = (for ([(k v) (values (in-free-id-table _))]) _)
```

Second, avoid macros that expand into (big) macro definitions like `define-in-tbl`. I recommend defining a compile-time transformer-producing function first:

```
(begin-for-syntax
  ;; make-in-table-transformer : Indentifier -> Syntax -> Syntax/#f
  (define ((make-in-table-transformer pred?-id) stx)
    (syntax-case stx ()
      [[(key val) (_ table)]
       (with-syntax ([pred? pred?-id])
         #'___)]
      [_ #f])))
```

and then calling it inside of the `make-code` template:

```
(define (in-tbl* d)
  (in-id-table 'in-idtbl d identifier->symbol identifier=?))
(define-sequence-syntax in-tbl
  (lambda () #'in-tbl*)
  (make-in-table-transformer #'tbl?)) ;; might need other args too
```

Yes, redefining the existing functions like `idtbl-map` and `idtbl-for-each` to use `in-idtbl` sounds like a good idea. I would avoid adding new higher-order looping functions if the new `in-idbtl` sequence is fast enough to cover their use cases.

I believe I made all the suggested changes -- happy to tweak things further if needs be.

You'll have to talk to Google about linking to documents that aren't linked by our pages.

docs, pkg-build, pkgs, and pkgn all do not link to that page because pict3d fails to install in the under the time limit imposed by pkg-build (see here: http://pkg-build.racket-lang.org/server/built/fail/pict3d.txt )

Looks good to me. Thanks!

Commits are now squashed into 1. (I don't have push access to this repo - happy to tweak things further if needed)

I found two small bugs in the jit code, but they are easy to fix.

In particular 

```
(define (s-c? x) (small-char? x))

(s-c? #\a)        ;==> #f   (jit)
(small-char? #\a) ;==> #t   (no-jit)
```

They are not discovered by the tests because most of the tests run the not jitted code. Is it posible to force all the code to be jitted? (This is more a feature request than a real question.)

I tried to rebase all of this, but I'm geting segfault when I reenable cstartup.inc with the 1154 expected primitives . I'll try to fix whatever is broken and if in a few days I still have problems I'll ask for help. 

It seems like a problem that when a package starts having an error, the docs disappear and all links to them break.

Could you use this macro to jit things?

  (define-syntax-rule (jit-it e) ((lambda () e)))

Robby

Merged, thanks!

Unfortunately that stack trace is for a SEGV used in Racket's implementation. To see the actual error, you should do the following:

```
(gdb) handle SIGSEGV nostop noprint
(gdb) run
```

That linked issue has more details, though which suggest that the issues are:

(1) incorrect information in the SIGSEGV signal
(2) not supporting `poll()` on descriptors created by `epoll()`.

Here is the stacktrace with SIGSEGV not handled. 

(gdb) bt
#0  0x00007f5225716c37 in __GI_raise (sig=sig@entry=6)
    at ../nptl/sysdeps/unix/sysv/linux/raise.c:56
#1  0x00007f522571a028 in __GI_abort () at abort.c:89
#2  0x0000000000688a7e in fault_handler ()
#3  <signal handler called>
#4  0x000000000068410a in scheme_gmp_tls_unload ()
#5  0x0000000000650fb3 in ?? ()
#6  0x000000000068d5e8 in ?? ()
#7  0x00000000006942be in GC_malloc_one_tagged ()
#8  0x000000000043dc6f in scheme_malloc_fail_ok ()
#9  0x000000000067015a in scheme_make_vector ()
#10 0x00000000005ed73c in ?? ()
#11 0x00000000005eedac in ?? ()
#12 0x00000000005ed543 in ?? ()
#13 0x00000000005eee6e in ?? ()
#14 0x00000000005edcbd in ?? ()
#15 0x00000000005eede7 in ?? ()
#16 0x00000000005ed543 in ?? ()
#17 0x00000000005eee6e in ?? ()
#18 0x00000000005e5c21 in ?? ()
#19 0x00000000005ea3a0 in ?? ()
#20 0x00000000005eaa70 in ?? ()
#21 0x000000000047c575 in scheme_top_level_do_worker ()
#22 0x00000000005ea888 in scheme_internal_read ()
---Type <return> to continue, or q <return> to quit---
#23 0x00000000005c0697 in ?? ()
#24 0x0000000000486d39 in scheme_dynamic_wind ()
#25 0x00000000005c02ac in ?? ()
#26 0x00007f52241c1102 in ?? ()
#27 0x0000000000000004 in ?? ()
#28 0x00007fffc3058be8 in ?? ()
#29 0x0000000000000000 in ?? ()

Even if links breaking is desired behavior, it would be nice to show a better error page

I think that maybe what Jay is trying to say is that this isn't a problem
for the racket repo, but instead a problem for the pict3d package and
whatever repo it lives in.

That is, the pkg system provides a service of building packages and hosting
their docs, but if the pkg changes in a way that causes it not to work
anymore, then that needs to be taken up elsewhere, not here (of course, it
may be that something in racket changed that broke it, in which case we'll
end up here again, but with more information).

Is that it Jay?

Sure, and in this case the problem is either that pict3d takes too long to build (fault: pict3d and typed-racket) or that pkg-build's timeout is too low

Of course the pkg-build system can't always succeed in building things successfully that built in the past. However, the issues that @endobson and @jackfirth point out are about how we handle that failure -- currently, we get a broken link and an incomprehensible error message. 

Oddly I had to perform a reinstall of the operating system to resolve this. 

I’ll merge this in a minute.

The error was very silly. I was adding a new primitive `interned-char?`, but at the same time I was removing a duplicated version of `char-title-case?`, so the total count of primitives wasn’t changing. I forgot about `char-title-case?` and while rebasing I was trying to increase the total count of primitives, so I got an error.

I finally left the `syntax?` primitive classified  as `RLV_IS_RELEVANT` instead of `RLV_EQ_TESTEABLE`. This classification is a little overcautious an it disables the reduction `(equal? stx-x y) => (eq? stx-x y)`, where `stx-x` is a `syntax?`.  I think that it would be correct to enable this reduction, but `syntax?` is a very complex type and it’s a little weird that it doesn’t have some kind of custom criteria for `equal?`. 

A few comments:

0) this does happen in all of the languages, but perhaps it is easier to come across in the teaching languages. In general, DrRacket uses special, non-textual handling for any number that is exact and isn't an integer, I believe.

1) the current strategy for implementing number printing in DrRacket is such that most of these issues aren't really fixable (without trying a new strategy). Fixable ones include the selection strangeness and the color, I believe, but probably not the others. Of course, we could experiment with alternative strategies.

2) the implementation of this is in a different repo. Here's a link to the file that contains most of it: https://github.com/racket/gui/blob/master/gui-lib/framework/private/number-snip.rkt

heh, lol, who needs hygeen anyway... ^_^

Oh, wow

I think this can actually be solved by passing in a local-expand to the id used in struct. I'll give this a shot.

Oh wait, wrong way....never mind. :/

No, this should be solved by using the struct-info to get the correct accessors. (I thought that's what it already did; apparently not (no, it does, but what is doesn't do is use the struct-info to get the correct struct name))

It’s not possible to fix `struct-copy` to get the correct accessors (I would have done it myself if it were possible) because it specifically does not require the user to specify the whole struct field names. That is, it allows users to specify `x` instead of `point-x` or `point2d-x` in the original example. A naïve implementation could try to make guesses based on matching name suffixes, but it isn’t too hard to come up with pathological cases in the presence of struct subtyping.

The right fix for this is probably changing something much more fundamental about information exposed by `struct`, which is a lot trickier to do in a backwards-compatible way.

It would need to go through all the accessors, searching for one which has that field at the end? That's not ideal. Does the struct info have actual field names in it anywhere, separate from the accessors?

No, it does not. There’s not even an obvious way to add it, given that it’s possible to have duplicate field names in the presence of struct inheritance. This is totally legal:

``` racket
(struct foo (a))
(struct bar foo (a))
```

The `struct-copy` macro gets around this with the `#:parent` option, but that’s a little bit hacky.

Personally, I think the best fix for this would be to introduce a way to do struct copying at a low level rather than having it be a derived concept, which would avoid the slicing problem that `struct-copy` has. Improving the static type information provided by `struct` would be helpful, too, but it wouldn’t solve all of the issues with `struct-copy` and subtyping.

What @lexi-lambda said. `struct-copy` is hopeless and can't be fixed without major changes to how structs work.

I think you're probably seeing the issue discussed here:

 https://github.com/Microsoft/BashOnWindows/issues/900

It looks like the problem is considered a bug in BashOnWindows, but you may be able to work around problems by changing "sighand.c" around line 71 to check for SI_KERNEL (= 128) instead of SEGV_ACCERR. If that works, maybe you can also figure out suitable processor conditionals to enable a workaround for BashOnWindows.

Okay, I've fixed those two problems and I'm going to close this issue now, as I don't think that I'll make any attempts on a new strategy.

Feel free to reopen and/or discuss further if you'd like. Maybe something useful will come of it. I don't mean to end the conversation, just closing as I (currently) have no plans to do more with this.

Gentle ping on this, given that I think this change is relatively harmless. @mflatt, you’re probably the person most qualified to look at this, but I’m sure @jeapostrophe or @rmculpepper would be more than capable, too.

It looks good to me.

This isn't the right repo. DrRacket is elsewhere, but DrRacket uses a library, found here: https://github.com/racket/scribble/blob/master/scribble-lib/help/search.rkt

That library uses another one to open an web page via `open` on the mac (are you using a mac?) which opens the new tab by default, IIUC. So I'm not sure of the right place to configure this, but it may be that you can do it via your OS. That other library, however, is here:

  https://github.com/racket/net/blob/master/net-lib/net/sendurl.rkt

Probably you want to open an issue on that repo. Or maybe submit a pull request there?

@mflatt: Does this look reasonable to you?

Yes

Thanks!

Would it make sense to combine those into one `evil-racket-support` emacs package or something? Otherwise, it's kind of a scattering of stuff.

Perhaps.  I can see the appeal of keeping a short list.  But at the same time I'm generally not keen on emacs packages that just configure some other packages.  Personally I have some extra configuration for each of these packages, and any configuration in an `evil-racket-support` package would just be something I would be fighting.  I think it would be useful to have just a long list of editor plugins/configuration/etc that people find useful, but maybe the guide could just point to it.  Maybe somewhere in a wiki.

How about a general `evil-mode` bullet? Puts everything related to it in the same place, and easy to skip for people who don't use it.

Agreed.  How about this update?

LGTM

Could you move this issue to the [typed-racket](https://github.com/racket/typed-racket) repository?

Moved to https://github.com/racket/typed-racket/issues/456

Same for me (`armv7l`)

This link contains the patch with a fix: https://groups.google.com/forum/#!msg/racket-users/j7buyPoSwUE/fhTeHk8LAAAJ

The patch and recommendations from Juan Francisco Cantero Hurtado (a copy from the mentioned thread):

> Install also libffi and use "--enable-libffi". 

``` patch
diff --git a/racket/src/racket/sconfig.h b/racket/src/racket/sconfig.h
index ca5cce6..f80ef04 100644
--- a/racket/src/racket/sconfig.h
+++ b/racket/src/racket/sconfig.h
@@ -259,9 +259,6 @@
 #endif
 # if defined(__arm__)
 # define MZ_USE_JIT_ARM
-# ifndef __ANDROID__
-#  define MZ_USE_DWARF_LIBUNWIND
-# endif
 #endif

 #endif
```

> Steps, if still failed to work:
> - Remove the old git repo. 
> - Delete every file installed by racket within `~/.local`. 
> - `rm -rf "~/.racket/6.*"` 
> - `mkdir -p "~/.local/bin"` 
> - `export PATH="$PATH:~/.local/bin"`
> - `git clone --depth 1 --single-branch https://github.com/racket/racket.git racket-git`
> - `cd racket-git` 
> - copy the patch 
> - `patch -p1 -i racket-arm-unwind.patch` 
> - `cd racket/src` 
> - `./configure --enable-shared --prefix="~/.local" --enable-libffi` 
> - `make` 
> - `make install` 
> - `raco pkg install --auto main-distribution (or any other raco package)` 

But seems, `sconfig.h` was changed since those times, these lines are at line 264 nowadays

Looks fine. I imagine the constraint to a single clause was also related to the old coordinate system, and the constraint doesn't seem necessary now.

I think so. This change was was almost impossible with the old coordinate system and totaly trivial now.

LGTM

LGTM

Just got a new MacBook Pro 15" with Touchbar. DrRacket will not open. I've installed the latest version, 6.6, and 6.5 and no luck with any of them. I was getting an error message, but I am no longer getting one. It just silently closes.

Try opening DrRacket from the terminal:

   promt> open DrRacket.app

in the folder where Racket is installed.

/Jens Axel

2016-11-15 19:42 GMT+01:00 Matt Shank notifications@github.com:

> Just got a new MacBook Pro 15" with Touchbar. DrRacket will not open. I've
> installed the latest version, 6.6, and 6.5 and no luck with any of them. I
> was getting an error message, but I am no longer getting one. It just
> silently closes.
> 
> —
> You are receiving this because you are subscribed to this thread.
> Reply to this email directly, view it on GitHub
> https://github.com/racket/racket/issues/1470#issuecomment-260728592, or mute
> the thread
> https://github.com/notifications/unsubscribe-auth/AAcLxV3LHCxY0-Ydj0BHRZ74rZicVUfHks5q-f0dgaJpZM4KKVsX
> .

## 

## 

Jens Axel Søgaard

No luck. Same thing. It bounces once in my dock and then disappears. I've attached one of the crash reports.

[DrRacket_2016-11-15-140908_MaRShMBP.crash.txt](https://github.com/racket/racket/files/592883/DrRacket_2016-11-15-140908_MaRShMBP.crash.txt)

You might find some helpful output in the Console (which is an app in the
Utilities folder inside Applications).

That's the first place I checked, but I don't know how to interpret any of the crash reports in there, which is why I attached the one above. The crash report was the only output recorded in the console.

Running `bin/drracket` results in the following output:

```
$ /Applications/Racket\ v6.7/bin/drracket ; exit;
Segmentation fault: 11
logout
Saving session...
...copying shared history...
...saving history...truncating history files...
...completed.
Deleting expired sessions...none found.

[Process completed]
```

And I'm guessing these are the relevant lines from the crash reports:

```
Exception Type:        EXC_BAD_ACCESS (SIGSEGV)
Exception Codes:       KERN_INVALID_ADDRESS at 0x0000000000000008
Exception Note:        EXC_CORPSE_NOTIFY

Termination Signal:    Segmentation fault: 11
Termination Reason:    Namespace SIGNAL, Code 0xb
Terminating Process:   exc handler [0]
```

> On Nov 15, 2016, at 11:05 AM, Matt Shank notifications@github.com wrote:
> 
> No luck. Same thing. It bounces once in my dock and then disappears.

Before anything else: did you install DrRacket by dragging the folder to your Applications directory, or did you move the DrRacket app out of its enclosing folder? The second of these can mess things up.

Second: what if you run the binary directly? That is, navigate to the “bin” subdirectory of the Racket installation and then run

./drracket

?

John Clements

The results of running the binary directly are above your post. Segmentation fault. I installed DrRacket by dragging the folder, but I've also tried it a bunch of other ways to try and get it to work.

My highly uneducated guess is that it might be related to hardware differences on the new MacBook Pro model just released, since it appears that issues related to running it on macOS Sierra have been addressed in 6.7. I have one of the first 2016 MBPs released. Pre-ordered it as soon as it was announced and received it yesterday.

EDIT: Searching Google, I'm seeing a lot of similar error reports for many different applications that occurred after updates to macOS Sierra.

I installed the 32-bit version instead of 64-bit and it works!

Try installing the 32-bit version instead of the 64-bit. It worked for me.

Others that have observed this have noted that the 32 bit version doesn't crash. You might try that one until we can get a fixed version out.

(#1470)

I'm having the same crash launching DrRacket on Sierra w/touch bar MBP. Stack trace is exactly the same from lines 0–14. This was built from the current repo source. (PS If 32-bit is the workaround, is there a way to force 32-bit when building from source?)

There is a configure flag you can pass, namely `--disable-mac64`, I believe, but I know how to provide only when I build the binary myself directly and not from the top-level MAKE file. You might try setting the `CONFIGURE_ARGS_qq` environment variable and see if that works?

Oops, I meant @rfindler 

I tried 

```
export CONFIGURE_ARGS_qq="--disable-mac64"
```

and then rebuilding from source as usual. It did not work. Though I am not ruling out human error.

The 32-bit prebuild does work, however.

PS After rebuilding, the `code type` field in the error report still said `X86-64 (Native)`, which I take as a possible sign that it was not in fact compiled as 32-bit.

I no longer remember this code. But if you add a test and it passes, then sure.

(fixnum? (expt 2 40))

will return #t on a 64 bit build and #f on a 32 bit build.

And when you say "rebuilding", did it actually make a new binary? This
particular change is not explicitly tracked as a dependency.

It might work to go into the directory racket/src/build, do "rm -rf *" and
then do "../configure --disable-mac64" and then make and then make install.

OK, I can get to a REPL and verify that `(fixnum? (expt 2 40))` is `#f`. But how do I build the DrRacket binary from here? `raco pkg install drracket` is insufficient. (Sorry but I usually do a whole `make in-place` build, so I’ve never scrutinized things further)

> OK, I can get to a REPL and verify that (fixnum? (expt 2 40)) is #f. 

(After rebuilding Racket by following your suggestion)

If I go onto the `racket` REPL and do `(require drracket)`, then DrRacket launches normally. I’m still not sure how to generate the official standalone DrRacket app. But compiling in 32-bit mode as you suggest seems to work.

Just `drracket` on the command line should also open it. (If not, the `drracket` executable is in the same `bin/` folder as the `racket` executable).

(I don't know how to make the DrRacket.app though)

When I follow @rfindler’s instructions, I don’t end up with a `bin/drracket` exectuable. Only `bin/racket` and `bin/raco`. And then `raco pkg install drracket` makes it possible to do `(require drracket)`, but also does not build `bin/drracket`.

Now that you're run `configure` in the `src` directory, you can go back to the top and use `make` (or `make in-place`).

Thanks. I did try that (I ordinarily use `make in-place` from the top directory for my git builds). 

The result is `../../foreign/foreign.c:84:10: fatal error: 'ffi.h' file not found`

Ah, well, I'm not sure what might have gone wrong.

If you'd like to try from scratch, it should work to use `make CONFIGURE_ARGS_qq="--disable-mac64"` as described in "INSTALL.txt".

Meanwhile, it could be useful to know whether the crash in 64-bit mode happens during the body of "gui-lib/mred/private/wx/cocoa/queue.rkt". Does adding log-error to the end of that module show that it's reached?

Thanks. This worked: `make in-place CONFIGURE_ARGS_qq="--disable-mac64"`

> "gui-lib/mred/private/wx/cocoa/queue.rkt". Does adding log-error to the end of that module show that it's reached?

I will look into this tomorrow.

I rebuilt from source in 64-bit mode. I added a diagnostic `log-error` message to the bottom of the `queue.rkt` module. I ran `drracket` from the command line. I saw the diagnostic message, implying that the module had been reached. DrRacket still ended up crashing with the same error as above.

I have a theory about why the touch bar bothers DrRacket (or vice versa? The touch bar is, in general, a misfeature.) 

In DrRacket you can hold down the `ESC` key and hit other keys to issue successive commands. For instance, on the REPL, you can cycle through previous expressions by holding down `ESC` and pressing `p` repeatedly.

But with the touch bar, it seems that the `ESC` key does not emit a sustained "key down" message. So, to cycle through previous REPL expressions with the touch bar, I have to press `ESC`, hit `p`, lift and repress `ESC`, hit `p`, and so on. 

Whether this behavior is specific to DrRacket, I’m not sure — I’d have to think of another program that relies on a sustained `ESC` press in the same way.
Maybe something goes wrong in key-translate?

https://github.com/racket/gui/blob/master/gui-lib/mred/private/wx/cocoa/key-translate.rkt

The function key-translate is used to convert virtual keycodes into the
value
specified by the keyboard layout. I haven't tested key-translate with a
second keyboard
so if the touch bar appears as a second keyboard (does it?) maybe that's
causing
a problem.

Now from line 551 and forth there is a loop used to build a cache. One
experiment:
replace key-translate with a dummy function:

(define (key-translate virtual-key-code . more) "x")
and see if DrRacket can start. If it does not, then key-translate
is not to blame. If on the other hand it does, then try commenting out
the expression on line 552 that caches all key combinations
and see if DrRacket can start.

/Jens Axel

2016-11-20 21:08 GMT+01:00 Matthew Butterick notifications@github.com:

> I have a theory about why the touch bar bothers DrRacket (or vice versa?
> The touch bar is, in general, a misfeature and I will likely return this
> laptop, though mostly because the battery life is dismal.)
> 
> In DrRacket you can hold down the ESC key and hit other keys to issue
> successive commands. For instance, on the REPL, you can cycle through
> previous expressions by holding down ESC and pressing p repeatedly.
> 
> But with the touch bar, it seems that the ESC key does not emit a
> sustained "key down" message. So, to cycle through previous REPL
> expressions with the touch bar, I have to press ESC, hit p, lift and
> repress ESC, hit p, and so on.
> 
> Whether this behavior is specific to DrRacket, I’m not sure — I’d have to
> think of another program that relies on a sustained ESC press in the same
> way.
> 
> —
> You are receiving this because you are subscribed to this thread.
> Reply to this email directly, view it on GitHub
> https://github.com/racket/racket/issues/1520#issuecomment-261801907, or mute
> the thread
> https://github.com/notifications/unsubscribe-auth/AAcLxcMSnhTqwAm13BC9kvWJjIUc7yJ5ks5rAKjXgaJpZM4K1TEW
> .

## 

## 

Jens Axel Søgaard

It doesn't seem like a good idea to me, but then again, neither does the
original design (at lease ever since we got chaperones) for these
combinators. Maybe we should think about what a better design is instead
and promote that?

Meanwhile, I don't mind a keyword argument that causes this functionality
to kick in when asked for. Would that work for now?

That's certainly reasonable, and would be easy for TR to generate. I'd rather think harder about a better design, though, and generate that.

We could go with an always-lazy design, similar to how mutable vectors work. Unfortunately, I think this slows down some other programs (I've seen this on the `synth` benchmark from the same paper, which uses lots and lots of length-1 immutable vectors).

We could have a keyword argument for how many elements to check eagerly. Then TR and other users of the contract system could choose, but that seems like a choice that we as authors of the contract system could make more effectively.

Other suggestions we might want to think about? I'm happy to implement whatever we decide here.

I'm not sure the contract system is always the best place to make this
guess​. I think that, in general, the client knows more than the contract
system, so it does make sense for there to be a way to let the clients make
the decision.

I also feel like a few more keyword arguments are a good way to go here.

How about a keyword argument that says "copy only if larger than N
elements" where, if N is supplied as a nat, that is taken, but N can also
be supplied as a symbol that is something like "you make a guess, contract
system" and we write that that's currently 10, but we make up a micro
benchmark that we maybe reevaluate periodically to choose a different
number? (And document the benchmark too.) We could also allow +inf.0 as the
argument, which means to never copy? Maybe that will unify some of the
other behavior internally?

The pkg-build system does preserve documentation from a previous successful build when a new build fails.

However, when there's a new Racket release, I have been resetting the whole pkg build system, which doesn't preserve successful doc builds from one Racket release to the next Racket release.

I'm not sure how to fix this in an automated way. In the near term, probably the solution is to more quickly fix build problems after a release. (I think it's fair to blame the pkg-build run in this case, instead of the package.)
> replace key-translate with a dummy function:
> (define (key-translate virtual-key-code . more) "x")
> and see if DrRacket can start

Thank you for the suggestion. I tried it. DrRacket still did not start.
Added a test and merged.
I think these problems have gone away as the version number has since been incremented, but reopen if that's not right.
The rewritten macro expander doesn't raise an error for this program. Unless the bug is pressing, I'll file this under things to be fixed by replacing the expander in the near future.
Ok - worth a try.

/Jens Axel

2016-11-21 17:53 GMT+01:00 Matthew Butterick notifications@github.com:

> replace key-translate with a dummy function:
> (define (key-translate virtual-key-code . more) "x")
> and see if DrRacket can start
> 
> Thank you for the suggestion. I tried it. DrRacket still did not start.
> 
> —
> You are receiving this because you commented.
> Reply to this email directly, view it on GitHub
> https://github.com/racket/racket/issues/1520#issuecomment-261996893, or mute
> the thread
> https://github.com/notifications/unsubscribe-auth/AAcLxQFKUw8AO3XXpWpinGDnRcmpz2C-ks5rAcyRgaJpZM4K1TEW
> .

## 

## 

Jens Axel Søgaard

@rfindler I've now re-implemented this along the lines you suggested (but without the "contract system picks something" option so far).
LGTM

@mflatt @jeapostrophe: Should we apply this patch?
I think so.
PS. In `scrbl` files only, not `rkt` files.
Does it help to note I can generate a "Segmentation fault: 11" with a TouchBar mac and 64 bit Racket 6.7 without DrRacket?

$ racket
Welcome to Racket v6.7.
> (require racket/gui/base)
Segmentation fault: 11

The "Segmentation fault: 11" with a TouchBar mac and **32 bit** Racket 6.7 does not occur:

```$ racket
Welcome to Racket v6.7.
> (require racket/gui/base)
>
```
Hi - I don't recognize that error. Pasting into into a web search suggests an issue with mixing versions of GCC or linking tools. Can you say more about how your distribution (e.g., some version of Debian) and how you compiled or installed Racket to get "libracket3m.a"?
I traced the segfault back to [`gui/gui-lib/mred/private/wx/cocoa/init`](https://github.com/racket/gui/blob/5e433c8035e434b203d2a0a4b1d74e8dd6984a3f/gui-lib/mred/private/wx/cocoa/init.rkt), which in turn calls two functions in [`gui/gui-lib/mred/private/wx/cocoa/queue.rkt`](https://github.com/racket/gui/blob/5e433c8035e434b203d2a0a4b1d74e8dd6984a3f/gui-lib/mred/private/wx/cocoa/queue.rkt): `cocoa-start-event-pump` and `cocoa-install-event-wakeup`. 

I tried to eliminate the segfaults through commenting out parts of these functions. I didn't find anything that worked consistently. It seems to have something to do with the thread and sync routines, which IIUC reside in the Racket core. Thus I could trace no farther.

(In addition to whatever deeper sorcery is happening in this file, see, e.g., [warning](https://github.com/racket/gui/blob/5e433c8035e434b203d2a0a4b1d74e8dd6984a3f/gui-lib/mred/private/wx/cocoa/queue.rkt#L39) of "extreme hackery")

oh,thanks for the reply. I'm using Debian 8.6 and Racket was installed by apt-get. Now I have downloaded the source file then compiled it and that works. So actually I have solved the problem but forgot to close the issue, sorry :P
This is, in some sense, the same problem as with this program:

```
#lang racket
(define-syntax (m stx)
  (syntax-case stx ()
    [(_ e)
     (with-syntax ([(tmp) (generate-temporaries '(tmp))])
       #'(let ([tmp e]) tmp))]))

((m (λ (x) (zero? x))) 1 2)
```

What's happening is that the lambda expression is picking up the name from the binder that's hiding inside the macro definition. 

If there is a way to fix that macro (without removing the `let`), then I can fix the expansion of `->`.
I guess that probably the inferred name process needs to be extended so that it can be told that some `let` that got introduced "doesn't count" so it can look for an outer one (or use the source location of the procedure like it does when there are no `let`s).

I would imagine a property on the `let` or on the variable in the `let`? 

Does this seem to be on the right track?
I think this is already available, by using `(void)` as the `'inferred-name` property:

```
#lang racket
(define-syntax (m stx)
  (syntax-case stx ()
    [(_ e)
     (with-syntax ([(tmp) (generate-temporaries '(tmp))])
       #`(let ([tmp #,(syntax-property #'e 'inferred-name (void))]) tmp))]))

((m (λ (x) (zero? x))) 1 2)
```
I defer to @samth. This was my thought (of course the `λ` case would need to be stronger, but you get the idea):

```racket
#lang racket
(define-syntax (m stx)
  (syntax-case stx ()
    [(_ e)
     (with-syntax ([(tmp) (generate-temporaries '(tmp))]
                   [name (syntax-case #'e ()
                           [(λ . body) #`'#,(string->symbol
                                             (format "~a" (syntax->datum #'e)))]
                           [else #''e])])
       #'(let ([tmp (procedure-rename e name)]) tmp))]))

((m (λ (x) (zero? x))) 1 2)
```

BTW I came across this problem in an attempt to demonstrate how [wonderful and helpful](http://beautifulracket.com/explainer/contracts.html) the contract system is :wink:
PS While we're here, I've never understood the perma-caveat `(assuming the contract is correct)`. Is it possible for the contract system to have some different inference about the correctness of the contract (which would alter this caveat)? Or is it just a general warning that faulty contracts lead to faulty results? (If so, this seems true of all code, all the time, and thus unnecessary to mention)
No, that doesn't work. This program should produce `x` in the error message, not just `#<procedure>`

```
#lang racket
(define-syntax (m stx)
  (syntax-case stx ()
    [(_ e)
     (with-syntax ([(tmp) (generate-temporaries '(tmp))])
       #`(let ([tmp #,(syntax-property #'e 'inferred-name (void))])
           tmp))]))

((let ([x (m (λ (x) (zero? x)))]) x) 1 2)
```

and similarly, this program should print a lambda expression with a source location in it:


```
#lang racket
(define-syntax (m stx)
  (syntax-case stx ()
    [(_ e)
     (with-syntax ([(tmp) (generate-temporaries '(tmp))])
       #`(let ([tmp #,(syntax-property #'e 'inferred-name (void))])
           tmp))]))

((m (λ (x) (zero? x))) 1 2)
```

(This latter one is the closer equivalent to MB's original program.)
I agree that the first example isn't as good as it could be, but the second one works for me the way I think @mbutterick wanted:

```
[samth@huor:~ plt] cat /tmp/zzz.rkt 
#lang racket
(define-syntax (m stx)
  (syntax-case stx ()
    [(_ e)
     (with-syntax ([(tmp) (generate-temporaries '(tmp))])
       #`(let ([tmp #,(syntax-property #'e 'inferred-name (void))])
           tmp))]))

((m (λ (x) (zero? x))) 1 2)
[samth@huor:~ plt] r /tmp/zzz.rkt 
/tmp/zzz.rkt:9:4: arity mismatch;
 the expected number of arguments does not match the given number
  expected: 1
  given: 2
  arguments...:
   1
   2
  context...:
   /tmp/zzz.rkt: [running body]
```

Note that in DrRacket, I had to save the definitions window to get the source location.
@mbutterick: Re perma-caveat: I read it as the latter, as a reminder that when there's a mismatch between specification and implementation, it may be the specification that's wrong. You're right that this is true of all code, but a helpful reminder that specifications are code, too, can't hurt. :)
@rfindler The existing way to handle those examples is to use `syntax-local-name` or `syntax-local-infer-name` explicitly in the macro implementation.

Something more automatic from the macro expander seems tricky, if I understand, since the expander would have to inspect the body of the `let` and perform a kind of copy propagation before expanding the right-hand side (so that it sets up a name for reference via `syntax-local-name`, for example). Maybe it's related to the general problem of fusing the compiler, optimizer, and expander.
>  but the second one works for me the way I think @mbutterick wanted:

Not that “what I want” matters. But your error prints the function as

```/tmp/zzz.rkt:9:4: arity mismatch;```

This is more specific than `temp4`. But still different than my suggestion, which is to print`(λ (x) (zero? x))`. IMO this would be the behavior most closely analogous to what happens when you use a self-contained predicate like `zero?`.

@mbutterick Racket doesn't hold on to the source code at run time for functions, so printing that would be a much bigger change. The printer uses `object-name` on the function, which uses the source location if no name is available. `zero?` is the name of a function, not the source code you're using, in this example.
@mflatt: ah, okay. I should have thought of that other approach!

@samth, thanks! I'll push that fix.
I've found a bunch of places where the contract system does this wrong and fixed them, but if there are more that I'm missing that you come across, please let me know.
Even with repairs, I would like to consider this more before merging, because there must be other places (like ".txt" files) to make consistent.
I'll make these edits (duh, I forgot about the possibility of hard line breaks) and also comb through the `txt` files.
> because there must be other places (like ".txt" files) to make consistent.

I pushed an update for the main `INSTALL.txt` file. Otherwise AFAICT the references to "Mac OS X" in `txt` files are part of changelogs, history files, and other things that I assume should remain accurate to the time they were written, not the confusing times we live in today.
@mbutterick I think the problem likely boils down to Racket not using NSApplicationMain (which is related to making Racket's idea of threads and GUIs work out with Cocoa).

I tried disassembling NSApplicationMain in my 10.12.1 installation, but that didn't get me anywhere. In fact, I can't find the string "NSTouchBar" anywhere in "/System/Library/Frameworks".  Does grep find "NSTouchBar" in your "/System/Library/Frameworks/AppKit.framework/AppKit"?

Not directly — `AppKit` is a binary file, yes? — but if I do this:

```strings /System/Library/Frameworks/AppKit.framework/AppKit | grep "NSTouchBar"```

… [I get this.](https://gist.github.com/mbutterick/c1c25fea7fa637596566d5e12cf2796f) 
Another thought: Does commenting out the thread created at the end of "pool.rkt" have any effect?
AFAICT, no. Same segfault either way.
Looks ok to me.
This looks right to me. Note that you don't have to add tests in all those different places. :)
Failing case was allowing the match clause `[(hash-table) expr]` to fire when given `#hash((x . 3))`, when it should only match a key-value hash pattern with one key-value pair.
Ok, wasn't sure if it was worth checking the mzlib versions of match, but it wasn't much work to add those in.
I like this idea.

Should there be a function that finds all indices when an element is
present multiple times?

/Jens Axel


2016-12-07 11:10 GMT+01:00 Alexis King <notifications@github.com>:

> Whether or not it’s a good idea, like list-ref, people seem to want this
> a lot, as evidenced by the following Stack Overflow questions:
>
>    - How do I find the index of an element in a list in Racket?
>    <http://stackoverflow.com/q/15871042/465378>
>    - Find index of element in list in Scheme
>    <http://stackoverflow.com/q/29450734/465378>
>    - Scheme function that returns the index of the first location where
>    an element occurs in the list
>    <http://stackoverflow.com/q/29551711/465378>
>    - Is there a inverse of the function list-ref in scheme racket?
>    <http://stackoverflow.com/q/41013581/465378>
>
> There are likely more, but I’m not going to dig them all up. It seems like
> something that really ought to be in racket/list.
>
> Please bikeshed on the following two things:
>
>    -
>
>    *Names.* I went with index-of and index-where because that’s what I
>    called them in data/collection, but these are arbitrary. I also
>    considered find-index and findf-index to be more consistent with member
>    and memf/findf, but I’m not sure those are good names. Suggestions are
>    welcome.
>    -
>
>    *Argument order.* This one’s all over the map, and I went with the
>    member-style argument order, but maybe that’s a bad idea if the names
>    are different, anyway, since list-ref uses flipped argument order.
>    Consistency is good here, but we’re already inconsistent, so I’m not sure
>    what the right thing to do here is.
>
> Thank you. (Obviously, other comments are welcome, too.)
> ------------------------------
> You can view, comment on, or merge this pull request online at:
>
>   https://github.com/racket/racket/pull/1533
> Commit Summary
>
>    - Add index-of and index-where to racket/list
>
> File Changes
>
>    - *M* pkgs/racket-doc/scribblings/reference/pairs.scrbl
>    <https://github.com/racket/racket/pull/1533/files#diff-0> (21)
>    - *M* pkgs/racket-test-core/tests/racket/list.rktl
>    <https://github.com/racket/racket/pull/1533/files#diff-1> (14)
>    - *M* racket/collects/racket/list.rkt
>    <https://github.com/racket/racket/pull/1533/files#diff-2> (29)
>
> Patch Links:
>
>    - https://github.com/racket/racket/pull/1533.patch
>    - https://github.com/racket/racket/pull/1533.diff
>
> —
> You are receiving this because you are subscribed to this thread.
> Reply to this email directly, view it on GitHub
> <https://github.com/racket/racket/pull/1533>, or mute the thread
> <https://github.com/notifications/unsubscribe-auth/AAcLxZ-VlalROuK8q4sDXgijVbSZ_k6fks5rFoYcgaJpZM4LGaYn>
> .
>



-- 
-- 
Jens Axel Søgaard

I coudn't reproduce this in Windows or Travis. In case it was caused by my previous commit, I have a blind guess and possible fix of the problem.

I'm convinced that `head->num_clauses == 0` is removed elsewhere, but in case some of them are still there:

Do you see a buch of `00000` with this? https://github.com/gus-massa/racket/commit/05bee035e6dc985eefe841d8a087f925db59611f

Does this fix the problem? https://github.com/gus-massa/racket/commit/d7037504082debbd05728b24e63f0d0e2ee9f027

That would probably be nice to have, too, yes, and it would be easy to add. Do you have a suggestion for a name for such a function?
+1 to the names `index-of` & `index-where`, and the argument order from `member`
I think we've tried, with functions that came into our world post-Scheme,
to have the argument order be that the first argument is the ADT that this
function goes to and the subsequent arguments are not. So, if we were to
add member today, we'd probably have it take the list first and the element
second. In other words, since member is viewed as a "list-related"
function, the list argument should come first.

Of course, there are probably counterexamples to this claim, but this is
the pattern I've noticed.

Ok, I’ve updated this pull request to incorporate what’s been said so far:

- I added `indexes-of` and `indexes-where`, as per @soegaard’s suggestion.
- I’ve fixed the issue with the contracts in the documentation that @bennn pointed out.
- I’ve changed the argument order back to the way it is in `data/collection` to be consistent with @rfindler’s note.
I didn't double-check that you caught all of them; I trust your grep-fu.
LGTM, but may want to wait until next year to push.
Sorry: I just looked at the code. You should probably supply all of the arguments (not just the one that is wrong) to the error message printing code.
Ah, sure, I can change that. I just emulated the error-handling code from the other functions in `racket/list`, which pretty much all use the single-argument form of `raise-argument-error`. Would it be a good idea to change them all to supply all the arguments?
Yes.
What’s the proper error-handling strategy for functions with optional arguments? Should I convert those functions into `case-lambda` instead of using optional arguments to avoid including the optional arguments in the error messages if they aren’t supplied?
That sounds like too much work. I am not sure of the bet strategy but you
could supply only the ones up to the bad one (or all mandatory) since the
bad one was (presumably) actually supplied.

Thanks for looking into this!

On Sat, Dec 10, 2016 at 3:46 PM Alexis King <notifications@github.com>
wrote:

> What’s the proper error-handling strategy for functions with optional
> arguments? Should I convert those functions into case-lambda instead of
> using optional arguments to avoid including the optional arguments in the
> error messages if they aren’t supplied?
>
>
>
>
> —
> You are receiving this because you were mentioned.
>
>
> Reply to this email directly, view it on GitHub
> <https://github.com/racket/racket/pull/1533#issuecomment-266242264>, or mute
> the thread
> <https://github.com/notifications/unsubscribe-auth/AAYWsHs3RziXg9tAJexrn-7hz7Hr3djCks5rGx2egaJpZM4LGaYn>
> .
>


The bad constellation could be created by a proper value for one parameter 
that somehow doesn’t work with a default value for an optional argument. I
can’t imagine this to be the case for a library function that has survived for 
‘’yeah long’ but who knows. 



> On Dec 10, 2016, at 5:21 PM, Robby Findler <notifications@github.com> wrote:
> 
> That sounds like too much work. I am not sure of the bet strategy but you
> could supply only the ones up to the bad one (or all mandatory) since the
> bad one was (presumably) actually supplied.
> 
> Thanks for looking into this!
> 
> On Sat, Dec 10, 2016 at 3:46 PM Alexis King <notifications@github.com>
> wrote:
> 
> > What’s the proper error-handling strategy for functions with optional
> > arguments? Should I convert those functions into case-lambda instead of
> > using optional arguments to avoid including the optional arguments in the
> > error messages if they aren’t supplied?
> >
> >
> >
> >
> > —
> > You are receiving this because you were mentioned.
> >
> >
> > Reply to this email directly, view it on GitHub
> > <https://github.com/racket/racket/pull/1533#issuecomment-266242264>, or mute
> > the thread
> > <https://github.com/notifications/unsubscribe-auth/AAYWsHs3RziXg9tAJexrn-7hz7Hr3djCks5rGx2egaJpZM4LGaYn>
> > .
> >
> —
> You are receiving this because you are subscribed to this thread.
> Reply to this email directly, view it on GitHub <https://github.com/racket/racket/pull/1533#issuecomment-266244064>, or mute the thread <https://github.com/notifications/unsubscribe-auth/ABf5-56I91lJoEpkAO75NFsBxqWaPMQxks5rGyXdgaJpZM4LGaYn>.
> 


The simple cases where this could go wrong would be if someone provides the optional argument but provides an invalid mandatory argument, like this:

```racket
(index-of 'not-a-list 'a eq?)
```

The error will include `'not-a-list` and `'a`, but won’t list `eq?` in the “other arguments” list. If that’s an acceptable issue, then I’ll do what Robby suggests and just leave it off unless it’s guaranteed to have been supplied.
Oh, and one other thing: *none* of the error functions appear to handle keyword arguments, except perhaps `raise-arguments-error` indirectly. How should those be handled, both when they are “other” arguments and when they’re the actual invalid arguments?
Beware of trying to build with these commits. Something is wrong and the documentation step of the build starts using all of memory.
The space commit seems clearly like a good idea and I think it makes sense to document this explicitly as a limitation (in a tone that suggests that if someone wants to fix it with a more complex `make-sequence` protocol, that fix would be welcome).

The other one is hard for me to judge. Is the performance improvement by avoiding the reverse something that is well-understood, or is this something where making some plots might help clarify the choice?
The performance difference for building a list is the same as the following two programs in current Racket:
```
#lang racket

(define N 5000)
(define L 5000)

(collect-garbage)
(time
 (void
  (for/fold ([v 0]) ([i (in-range N)])
    (for/list ([j (in-range L)])
      j))))

(collect-garbage)
(time
 (void
  (for/fold ([v 0]) ([i (in-range N)])
    (let loop ([j 0])
      (if (= j L)
          null
          (cons j (loop (add1 j))))))))
```
At the moment, I don't find an `L` that makes the latter one slower. Back when we changed `map`, I thought that it wasn't always a win, but maybe things have changed.

Meanwhile, the bug in the revised `for/list` is that it doesn't handle 0 sequences (by stopping after 1 iteration). And I think I was confused about the difficulty of making `for/list` always avoid `reverse`; it now looks easy enough to generalize to all `for/list` forms, although I haven't yet done that.
I ran the program below on a few machines I have easy access to (a macbook air with 1.7 ghz core i7, mac pro 2.6 ghz intel xeon e5, and a red hat Intel(R) Xeon(R) CPU E31270 @ 3.40GHz) and none of them could find a value of `L` where the latter was slower. (I also tried without the jit on the air.)

```
#lang racket
(require compiler/find-exe)

(define me (let-syntax ([m (λ (stx) (with-syntax ([f (syntax-source stx)]) #''f))]) m))

(let/ec done
  (for ([ignored (in-range 10000)])
    (define sp (open-output-string))
    (parameterize ([current-output-port sp])
      (system* (find-exe) "-e" (~s `(require (submod (file ,(~a me)) timing)))))
    (unless (equal? "" (get-output-string sp))
      (display (get-output-string sp))
      (done (void)))
    (display ".")
    (flush-output))
  (printf "never slower\n"))

(module timing racket/base
  (define L (+ 1 (random 10000)))
  (define N (ceiling (/ (* 5000 5000) L)))

  (collect-garbage)
  (define-values (results1 cpu1 real1 gc1)
    (time-apply
     (λ ()
       (for/fold ([v 0]) ([i (in-range N)])
         (for/list ([j (in-range L)])
           j)))
     '()))

  (collect-garbage)
  (define-values (results2 cpu2 real2 gc2)
    (time-apply
     (λ ()
       (for/fold ([v 0]) ([i (in-range N)])
         (let loop ([j 0])
           (if (= j L)
               null
               (cons j (loop (add1 j)))))))
     '()))

  (when (< cpu1 cpu2)
    (printf "slower @ L = ~s\n" L)))
```
LGTM
Thanks! After looking at this a lot more, I've become convinced that the `for/list` change is a good idea. Partly, I'm more encouraged because I now have a general solution that ends up being just a little more code, instead of a solution that's a big chunk of duplicated code that only handles a subset of `for/list` forms.

Adjusting the sequence API to make `in-list` generally work also isn't that bad, although I don't have it right yet. (So far, I've found one optimizer bug. Space safety is hard.)
Am I right that because the code below prints out a list (and not `#f`) that the `#%kernel` version of `map` has to be adjusted too? (Probably you already realized this, and if so and decided not to bother then that's okay with me :)).

```
#lang racket
(let ()
  (define l1 (cons 2 '()))
  (define lb (make-weak-box l1))
  (define l2 (cons 1 l1))
  (set! l1 #f)
  (void
   (map (λ (i j k)
          (when (= i 2)
            (collect-garbage)
            (printf "~s\n" (weak-box-value lb))))
        l2 l2 l2)))

(let ()
  (define (my-map f l1 l2 l3)
    (cond
      [(null? l1) null]
      [else (let ([r1 (cdr l1)]
                  [r2 (cdr l2)]
                  [r3 (cdr l3)])
              (cons (f (car l1) (car l2) (car l2))
                    (my-map f r1 r2 r3)))]))

  (define l1 (cons 2 '()))
  (define lb (make-weak-box l1))
  (define l2 (cons 1 l1))
  (set! l1 #f)
  (void
   (my-map (λ (i j k)
             (when (= i 2)
               (collect-garbage)
               (printf "~s\n" (weak-box-value lb))))
           l2 l2 l2)))

```
This is a crashing bug in the expander. I'll push a repair soon. Meanwhile, I don't see an easy workaround, but I can look harder if you need one.
@mflatt I can wait for the repair, this is not an urgent change on my side :). Thanks!
I can confirm that this fix worked. Thanks.
Thanks for the report! I've been trying various distributions that I have conveniently available, and none of them have failed in this way, so I think it's a matter of trying the right distirbution and/or configuration. Can you tell me more about your OS and GTK+ 3 installation/version?
and for what it's worth, 6.7.0.4 64 bit working here too. Many thanks.
I am on the latest Debian Unstable with the default `gnome` installation and the `racket` package from the Debian repos. GTK+3 version is 3.22. I don't think there's anything weird with my setup, and the behavior has been stable through many system updates for a long time.
Yes, definitely a bug. Thank you for pointing it out! I should have a fix before too long.
FWIW, I am beginning to doubt that the behavior that you describe about contracts that depend on unsupplied arguments/results. I see also that, although this case worked before (and now works again), there are others that don't (and didn't before). I guess we're committed to this path now, tho.
(And I should say that the behavior you describe is also the behavior I intended!)
Oh, wait! No, I am confused. You explained it right, but I was thinking wrong. I'll update the docs.
Thanks for the quick fix! And also thank you for the documentation clarification. :)
I think I've tracked the problem down to a repair in GTK+3 3.22 that breaks a workaround in `racket/gui`, and I've pushed an intended repair to `racket/gui` as racket/gui@5e70534b43ad9161e14001238aea46b25c96676f
Oops. This looks like an earlier sketch for the docs for `impersonate-procedure*?` which I left there by mistake. Thanks for catching it!
Probably you don't want `(with-handlers [(values`, unless you're trying explicitly to handle all things that could be passed to `raise` except `#f`. I think you want to use `exn:fail?` as the predicate instead (because catching break exceptions and propagating them is strange and confusing).
I would argue against `exn:fail?`, and specifically for propagating breaks, because the use of a thread is unimportant here, and any failure or interruption should be signalled on the main thread.
It really doesn't matter, I suppose. We can see all the code that runs on this private thread and none of it raises anything other than `exn:fail?`.

I hope you squash the commits before pushing.
This looks fine to me, although it would be great to have a test in "pkgs/racket-test/tests/file".
Thanks @rfindler and @mflatt for the review comments. @mflatt, I have added a test case. On the assumption that all is OK, I'll merge this now.
@lexi-lambda After a first read (finally!), I don't get how `#%namespaced` differs from `local-require`. Can you say more about the difference, or maybe point me to a part of the description that I missed?
I don't know if I like this idea, but just as a poll: What if we changed "Mac OS X" to just "Mac OS" instead of the correct (for now!) "macOS"?

I know it shouldn't bother me, but because I'm so old, "macOS" hurts my eyes – especially at the beginning of a sentence. "Mac OS" has a perfectly clear meaning, it side-steps the issue of past versions, and it has the advantage of staying equally incorrect when when Apple changes the OS name yet again. "Mac OS" has the drawback of being wrong.
It’s not bothersome because you’re old. It’s bothersome because it’s objectively awful.

Your argument for “Mac OS” is persuasive. LGTM
@mflatt Sure. For `racket/base` specifically, the difference isn’t super relevant. However, for other `#lang`s, it might be.

The idea is that `#%namespaced` is much “lower level” than something like `local-require`. It’s the absolute minimum functionality required to add a way for meta-languages to ask for specific bindings without doing things like producing syntax from `read-syntax` with scopes. Using `local-require` for this would require meta-languages to make two assumptions:

  1. All `#lang`s that support language extensions provide `local-require` under the same name.
  2. All `#lang`s that support language extensions provide a block-scoping form under the same name (probably `let`).

These are much stronger requirements than asking all languages to reprovide `#%namespaced` from `racket/base`, which is conceptually much closer to reproviding similar hooks like `#%datum` or `#%top`. Additionally, `local-require` + `let` probably wouldn’t be a good replacement for `#%namespaced`, anyway, since that would make things like this fail to work:

```racket
#lang curly-fn racket/base
(require (only-in racket/base [let racket-let])
         (for-syntax syntax/parse))

; use a Clojure-like let
(define-syntax let
  (syntax-parser
    [(_ [(~seq x:id v:expr) ...] body:expr ...+)
     #'(racket-let ([x v] ...) body ...)]))

#{+ % 2} ; oops, now `let` has different semantics
```

Basically, it seems extremely likely that `let` will be rebound in different `#lang`s, so it wouldn’t make sense to use it as part of an implicit protocol all `#lang`s must support. The `#%namespaced` form makes the protocol as simple and explicit as possible.
+1
On Thu, Dec 22, 2016 at 2:45 PM Matthew Butterick <notifications@github.com>
wrote:

> It’s not bothersome because you’re old. It’s bothersome because it’s
> objectively awful.
>
>
> Your argument for “Mac OS” is persuasive.
>
>
>
>
> —
> You are receiving this because you are subscribed to this thread.
> Reply to this email directly, view it on GitHub
> <https://github.com/racket/racket/pull/1527#issuecomment-268886787>, or mute
> the thread
> <https://github.com/notifications/unsubscribe-auth/AAYWsGwuQimv3za0qYF-O8UakpqQJxAOks5rKuFMgaJpZM4K-Rif>
> .
>
>
>
>
>
>
>
>
>
>
>
>
>
>
>
>
>
>
>

Looks good to me

+1 for Matthew and +omega for Matthew. Max OS all the way (no typo :-) 

Thanks for the report!
Ok, let's try out "Mac OS"
My bad, I can reproduce the issue with an older version from 2016-12-15, so I guess it must be something else than the commit I pointed to.
Thanks!
I don't thinks it's related to (non-) Mac OS. I get a different error on Mac OS, but it looks like there's a general mismatch between the use of a sandbox and what the sandbox allows. I'll have to look more to find out when the mismatch started.
I can also reproduce this error using emacs + racket-mode with `C-c C-l`... that's apparently running this in the repl:

```
> ,run ("myfile.rkt") 2048 t profile nil
```
This program doesn't close the port it opened for `fn.java`, which is why you're not seeing the output.  I recommend you use `call-with-output-file`, e.g.:

```
#lang racket
(call-with-output-file "fn.java"
  (λ (port)
    (parameterize ([current-output-port port])
      (dynamic-require "MOU.scrbl" #f)))
  #:exists 'truncate)
```

To make DrRacket behave more like racket here, you could evaluate `(exit)` in the REPL. That'll close the ports and will probably cause the data that's pending to be flushed. (But better to close the port explicitly yourself, as above.)
You are right that, if you want a correct function, you need the parens. But my intention was to demonstrate the pitfall.

I see that I didn't explain that very well! I'll push a clarification (that closes the PR; if you think it can be improved, however, please do re-open).
Thanks for the report, but this appears to have been fixed since 6.7. Probably @stamourv 's commit: https://github.com/racket/errortrace/commit/f332fd9d4c75d57c40b78e60c9c05f8499a70cd1
I managed to narrow the issue a bit on my project. [This build works](https://travis-ci.org/jsmaniac/aful/jobs/188093842#L430), while [this build fails](https://travis-ci.org/jsmaniac/aful/jobs/188093969#L430). The [diff](https://github.com/jsmaniac/aful/compare/93660ec4b84e...95bdc806de65) shows that the only difference is that `(require (only-in scribble/base))` was added, i.e. the module is loaded but nothing in it is used.

I noticed one potential trouble-makers here: the module which contains `(require (only-in scribble/base))` is a reader module.
merged
Thanks!
Thanks! This is clearly a big improvement.

I didn't try building the document, but I don't think that using `defstruct*` instead of another binding's description will work right, since it will interrupt the enclosing descrpition. Also, it will make the declaration appear to be provided by the module, but it isn't.

FWIW, I'm not a fan of using a predicate like `path-string?` as a noun that stands for a value that satisfies the predicate, but that's minor.
Looks ready to merge to me — thanks!
haha thanks, I was just building a copy of the docs:
http://www.ccs.neu.edu/home/types/racket-doc/raco/command.html?q=asdf#%28tech._command._specification%29

Since "command specifications" is now a `deftech` [(link)](https://github.com/racket/racket/pull/1557/files#diff-40d6c8457967df7241159a8c9aa091a8R14), do you think it should be "raco command specifications" ?
I think "command specifications" is fine.
Ok, I take it back. There's a straightforward problem on non-Mac OSes, and I'll push a repair for that.

There's a second, unrelated issue when running from a Racket build as a Git checkout. In that setting,
```
#lang racket/base
(require racket/sandbox)

(define e (make-module-evaluator (string-append "#lang racket/base\n")))
(e '(require racket/sandbox))
(e '(make-module-evaluator (string-append "#lang racket/base\n")))
```
fails, because a sandbox doesn't include enough filesystem-access permissions to create a nested sandbox. The problem is specifically due to following relative links with up-directory indicators in a collection links file, such as "../../pkgs" to get to the "racket-doc" package. I have an idea how to fix that one, too.
LGTM. I'm impressed that you thought to preserve the `range` name and appreciate that you included a `history` note.
@lexi-lambda Thanks – that makes sense.

Sorry for delaying this so long, but I think we should wait at least until after the v6.8 branch before merging.

Then, I wonder how bad it would be to delay even a little longer:

Not only am I back to Racket work (my semester dominated by teaching is over, happily), but I expect to rewrite the Racket reader as my next task. It seems possible that a fresh look at the reader and reader–expander stack will suggest a more general solution, especially with bytecode-level changes as fair game. It would be nice to avoid `#%namespaced` if a more general replacement is in reach.

Then again, I don't know whether the reader implementation itself is a 1-week, 1-month, or longer task. It may be too much of a delay, considering that I don't even know whether we'll find a more general solution, and considering we have a useful intermediate solution.
Was the existing test suite sufficient?
Given that the only observable difference in behavior is the amount of time iteration takes, I wasn’t sure how to write a test that ensures the good behavior produced by this change. I *could* add a test to ensure the cases work properly, though…? I’d admittedly be a bit skeptical of the value of such a test, but I’ll add it if you like.
Oh, I was thinking of a test case like ((values range) 1 2) or something like that, where there is a new case to handle in the implementation than when `range` is defined as a normal function, but maybe the way that `define-sequence-syntax` works it doesn't matter. 
(indeed, I would say that if you think there isn't a need for a test like that, then I'm happy. I was just curious if you had considered that.)
That all makes sense to me. `#%namespaced` is a hack. It’s a hack that solves a problem, but it’s still a hack. If you think that there’s even a *possibility* that it can be done better, then I think it’s worth putting it off to try that first. I would only suggest going this route if it’s really unclear how to do it otherwise.
Thanks!
Sure, understood. I think this particular case doesn’t warrant the test, but I didn’t mean to be dismissive of the suggestion.
This is probably an issue with Typed Racket, not Racket (though I am willing to look into fixing it, since I broke it). I would imagine it would need to do the same thing with `in-range`, since `in-range` also expands into an internal procedure. @samth, do you know off the top of your head what needs to be done here?
@lexi-lambda Thanks for the fix!
Isn't the a special case of the fact that no object contract is a chaperone contract?
Why are no object contracts chaperone contracts? (again?)
I don't recall the details, but I think it was just hard implementation work that no one ever did. I don't think they've ever been chaperone contracts.

Correct. 

Based on my recollection, object contracts came before chaperones. Then Stevie walked into my office and said “we need two kinds of wrappers.” But he never went back to replace the object wrappers with chaperones. 




> On Jan 4, 2017, at 5:28 PM, Sam Tobin-Hochstadt <notifications@github.com> wrote:
> 
> I don't recall the details, but I think it was just hard implementation work that no one ever did. I don't think they've ever been chaperone contracts.
> 
> —
> You are receiving this because you are subscribed to this thread.
> Reply to this email directly, view it on GitHub, or mute the thread.
> 


On Wed, Jan 4, 2017 at 5:12 PM, Matthias Felleisen <notifications@github.com>
wrote:
> Based on my recollection, object contracts came before chaperones.
> Then Stevie walked into my office and said “we need two kinds of wrappers.”
> But he never went back to replace the object wrappers with chaperones.

It looks like objects don't have chaperones. Perhaps that's part of the
reason.

Oh, and now that I've reminded myself what's going on in the
implementation, it looks like we need `unsafe-chaperone-struct` too
(as the code is currently removing impersonators and putting new ones
on to avoid multiple redundant contract checking wrappers).

After thinking about this for a while, I don't see any problem with this plan.

I assume you understand that soft links will generally not unpack on Windows (since links are normally disabled by default at the OS level).
I would think that not unpacking on the platform that 95% (last I heard) of
our users use would be disqualifying?

Could you not create the link during some installation step, using a
platform-appropriate mechanism?

FWIW, I've now remembered even more and I think the right course of action is to get the `->` improvements pushed and then remove that hack in the `object/c` implementation and then revisit the chaperone issue here.
@rfindler, I think symbolic links are already allowed, even though they don't work on Windows. This is just about links with .. in the path.
@mflatt - Thanks, I'll prepare a patch proposal. I wasn't aware of the Windows limitation; that's useful information. I'll see if I can find somewhere sensible in the package-system documentation to put it in as a tip for package authors.

@rfindler - @samth is right. The change I am proposing removes a restriction on symbolic links in packages, but it has long been possible to have symbolic links in packages used in ways that don't fall foul of the restriction.
Foiled again by backwards compatibility. I stand by my suggestion that you
avoid them if you can.

I don't see any problem with the first commit, so merging that one is fine with me – although it would be nice to have a test case to expose the regression, if possible. (I couldn't' construct one right away, but I didn't try hard.)
I only could test this visually using decompile, and I think it’s possible to test it using something like

    (match m
       [(compilation-top max-let-depth binding-namess prefix code)
     ...])

But I wanted to test this with something like

    (lambda ()
      (define (f) ‘(123)) ; f not clonable
      (display (list f f)); f not single use
      (values (f))

In this example, `f` is correctly marked as single valued and mark preserving, so it the `values` in the last line could disappear. But the reduction for `values` uses `single_valued_noncm_expression` that doesn’t look at the flags of the `lambdas`. My idea is to extend  `single_valued_noncm_expression` later (next week?), I think that this reduction will enable to test easily more similar cases. 
 
Merged, thanks!
I haven't been able to provoke the error, even on Windows. Maybe I need to be using some of your changes?
I, Sam Tobin-Hochstadt, give permission to license my contributions to Racket under MIT/Apache 2. I've used the email addresses samth@ccs.neu.edu, samth@racket-lang.org, samth@cs.indiana.edu, samth@indiana.edu, sam@alumni.uchicago.edu, sam@uchicago.edu
I, Jay McCarthy, give permission to license my contributions to Racket under MIT/Apache 2. I've used the email addresses jay.mccarthy@gmail.com, jay@cs.brown.edu, jay@cs.byu.edu, jay@kenyamountain.com, jay@racket-lang.org, jay@plt-scheme.org
I, Stevie Strickland, give permission to license my contributions to Racket under MIT/Apache 2. I've used the email addresses sstrickl@ccs.neu.edu, sstrickl@racket-lang.org, sstrickl@plt-scheme.org. (I believe these are all the email addresses with which I've contributed to Racket, if others are found let me know and I'll give permissions for those commits as well.)
I, Spencer Florence, give permission to license my contributions to Racket under MIT/Apache 2. I've used the email addresses florence@ccs.neu.edu, spencer@florence.io
I, Nadeem Abdul Hamid, give permission to license my contributions to Racket under MIT/Apache 2. I've used the email addresses nadeem@acm.org, nhamid@berry.edu.
I, John Clements, give permission to license my contributions to Racket under MIT/Apache 2. I've used the email addresses clements@ccs.neu.edu, clements@cs.rice.edu, clements@brinckerhoff.org, clements@calpoly.edu, and clements@racket-lang.org. And possibly others.

I’m also attaching the previous paragraph as a text file, and as a signed text file using my publicly available Keybase key. Captain midnight decoder ring go!

John


BEGIN KEYBASE SALTPACK SIGNED MESSAGE. kXR7VktZdyH7rvq v5wcIkHbs9bdI7H Bd9QmdEF29oSjFi sRJad0Yvvwge0Pl wq7zbYMrpnlMrS3 l5gLBdk9SVddF12 ncXEWwfFlKXyW05 jkRNz5N0b5uCnow CoS3R3I5ZWqFkG8 Cz7qxBL75O7B9rr UF7SePCUlk95e9Q eV6L0k8jY0CXSL0 myusdk3bPAVUqE0 ZQJcIQMbCvYEroT PAgXV7gvBqhvmA6 bLjC2hRE6jlRnBE vhBiwdMrnPIuKzV vLNNLYEZJbjRH8Z s7r8XgGbucNolTy XFWO9inHk0WMR4W BOkpHDc5WGIXJjO KOGhHvNEgXujh7d h5ABQu8DDfc5tDR MZGjcqXg2KREbx4 jaaEhykvVPv3JJG ghkzMPBQrqRyRc3 wY7PQF5AlQDUBBo n9W5TDFIScgt3DG ruVSnZY9eHR82Mt cyLTzEwxv5Z0YdD haDMopmilyVKyC2 bUGBabbI7g3u8qK PESXmrkphz46K9x Jwj6d7kUeke1842 834XbtQAyu7dUqs uLDaAxPe2JAmgtp zAt0TRCEy89FVLW xKlIeOpcbApsC0k YgEIymtpO4os7B4 bRg7FLUmqbgvhmj aS2tfpUhPNawakB IChuGuTXYoXcYME 8hHj6m. END KEYBASE SALTPACK SIGNED MESSAGE.

I, John Clements, give permission to license my contributions to Racket under MIT/Apache 2. I've used the email addresses clements@ccs.neu.edu, clements@cs.rice.edu, clements@brinckerhoff.org, clements@calpoly.edu, and clements@racket-lang.org. And possibly others.

Ugh. I object to the term "permissive licence": a better term is "user-hostile licence". You can probably infer lots of other reckons from just that, so I'll leave it there. That said, this is a drop in the bucket as far as times being generally tough for end-users of software, and not a hill I'd choose to die on; therefore:

I, Tony Garnock-Jones, give permission to license my contributions to Racket under MIT/Apache 2. I've used or may have used the email addresses tonyg@ccs.neu.edu, tonygarnockjones@gmail.com and tonyg@leastfixedpoint.com. Like Stevie says, there may be others; let me know if I've missed any, and I'll give permission for those commits too.

---

What is the scope of the permission you are requesting? I assume, in the permission statement I make just above, that it is only meant to cover (portions of) the code in the main "racket" git repo (and its git history). Is anything further intended for inclusion? I'm probably happy to extend my statement accordingly if so, but please do let us all know specifically what the scope is to be.
@tonyg This is intended to cover all the code currently in the `racket` organization, or any other repository that's a dependency of the `main-distribution` Racket package. I'll clarify this in the issue.
I, Ben Greenman, give permission to license my contributions to Racket under MIT/Apache 2. I've used the email addresses benjaminlgreenman@gmail.com, types@ccs.neu.edu

MIT:
```
Copyright 2014–2017 Ben Greenman Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
```

Apache 2
```
Copyright 2014–2017 Ben Greenman Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License.  You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the License for the specific language governing permissions and limitations under the License.
```
I, Vincent St-Amour, give permission to license my contributions to Racket under MIT/Apache 2. I've used the email addresses stamourv@racket-lang.org stamourv@ccs.neu.edu
I, Matthias Felleisen, give permission to license my contributions to Racket under MIT/Apache 2. I've used the email addresses matthias@cs.rice.edu, matthias@rice.edu,, matthias@racket-lang.org, matthias@plt-scheme.org, matthias@ccs.neu.edu. 
I, Matthew Flatt, give permission to license my contributions to Racket under MIT/Apache 2. I've used the email addresses mflatt@racket-lang.org, mflatt@plt-scheme.org, mflatt@cs.utah.edu, matthew.flatt@gmail.com
I can reproduce this in Appveyor now. The secret was to redirect stdout to a file 

    > racket -f ..\pkgs\racket-test-core\tests\racket\optimize.rktl > hello.txt

I usually run the tests in that way, but I still can't belive it is important.

Test results: [appveyor/gus-massa/racket/1.0.644](https://ci.appveyor.com/project/gus-massa/racket/build/1.0.644#L2921)

New code to test get the error in Appveyor: [gus-massa/.../appveyor.yml](https://github.com/gus-massa/racket/commit/d074a1fc6f21ebc7999c2860313f88fae82f94b3) 
The following people have contributed on GitHub to some of the Racket repositories.

@alehed
@mafagafogigante
@jackfirth
@khinsen
@acarrico
@bluerider
@e45lee
@cordarei
@BartAdv
@hoelzro
@bon
@Metaxal
@jamessan
@davidtpierson
@kimmyg
@filonenko-mikhail
@jcwhittier
@arkadini
@RayRacine
@jaor
@shofetim
@4z3
@jacones
@ds26gte
@pnwamk
@btlachance
@miraleung
@projanen
@lyons
@LeiWangHoward
@david-vanderson
@lvilnis
@schuster
@cky
@frenchy64
@gcr
@offby1
@jsmaniac
@simmone
@mordae
@telephil
@jkominek
@philnguyen
@RenaissanceBug
@calvis
Also these people:


@dfeltey
@wilbowma
@sctb
@rhcarvalho
@dvanhorn
@SamB
@greghendershott
@juanfra684
@gmarceau
@mbutterick
@97jaz
@AlexKnauth
@lexi-lambda
@soegaard
@sbloch
@LeifAndersen
@Zoetermeer
@ntoronto
@paddymahoney
@dyoo
@jspiro
@maxsnew
@bdj
@stchang
@bfetscher
@ghcooper
@gus-massa
@kathryngray
@carl-eastlund
@clklein
@mikesperber
@kazzmir
@tewk 
@takikawa
@rmculpepper
@rfindler
@elibarzilay

I, Jon Zeppieri (@97jaz), give permission to license my contributions to Racket under MIT/Apache 2. I've used the email address zeppieri@gmail.com.
I, Jon Rafkind, give permission to license my contributions to Racket under MIT/Apache 2. I've used the email addresses jon@rafkind.com, rafkind@cs.utah.edu, rafkind@racket-lang.org
I, @gcr, give permission to license my contributions to Racket under MIT/Apache 2. I've used <gcr@sneakygcr.net>.
I, Jordan Schatz, give permission to license my contributions to Racket under MIT/Apache 2. I've used the email addresses jordan@noionlabs.com, shofetim@gmail.com & white.armor@gmail.com
I, Rob Hoelz (@hoelzro), give permission to license my contributions to Racket under MIT/Apache 2.  I've used rob AT hoelz.ro.
I, Jay Kominek, give permission to license my contributions to Racket under MIT/Apache 2. I've used the email address kominek@gmail.com
I, J.C. Whittier (@jcwhittier), give permission to license my contributions to Racket under MIT/Apache 2.
I, Jordan Johnson (@RenaissanceBug), give permission to license my contributions to Racket under MIT/Apache 2. I've used the email address accounts@fellowhuman.com.
I, Andrew M. Kent (@pnwamk), give permission to license my contributions to Racket under MIT/Apache 2. I may have used the following email addresses while contributing: pnwamk@gmail.com, andmkent@iu.edu, andmkent@indiana.edu, sgtamk@gmail.com, andmkent@racket-lang.org
I, Alexis King, give permission to license my contributions to Racket under MIT/Apache 2. I've used the email addresses lexi.lambda@gmail.com and jaking@cj.com.
I, WarGrey Ju(@wargrey), give permission to license my contributions to Racket under MIT/Apache 2. I've used the email address: juzhenliang@gmail.com.
I, Jose Antonio Ortega Ruiz (@jaor) give permission to license my contributions to Racket under MIT/Apache 2.  I've used the email address jao@gnu.org.
I, Alexander Knauth, give permission to license my contributions to Racket under MIT and Apache 2. I've used alexander at knauth dot org.
I, Jono Spiro, give permission to license my contributions to Racket under MIT/Apache 2. I've used the email addresses jonathan_spiro@brown.edu and github@lostinrecursion.net.
I, William J. Bowman, give permission to license my contributions to Racket under MIT/Apache 2. I've used the email addresses wjb@williamjbowman.com, wilbowma@ccs.neu.edu, and wilbowma@users.noreply.github.com.
I, Dorai Sitaram, give permission to license my contributions to Racket under MIT/Apache 2. I've used the email addresses dorai@cs.rice.edu, dorai@ccs.neu.edu, ds26gte@yahoo.com, ds26gte@gmail.com.
I, Gustavo E. Massaccesi, give permission to license my contributions to Racket under MIT/Apache 2. I've used the email address gustavo@oma.org.ar.
I, Javier Olaechea, give permission to license my contributions to Racket under MIT/Apache 2. I've used the email addresses pirata@gmail.com
I, Daniel Feltey, give permission to license my contributions to Racket under MIT/Apache 2. I've used the email addresses dfeltey@gmail.com, dfeltey@ccs.neu.edu, daniel.feltey@eecs.northwestern.edu
I, Jack Firth, give permission to license my contributions to Racket under MIT/Apache 2. I've used the email address jackhfirth@gmail.com.

----------

Are there any plans to add a [CLA](https://en.wikipedia.org/wiki/Contributor_License_Agreement) to the Racket project? If one was already present it would have made relicensing much simpler, and it would protect against any future copyright and IP disputes.
We don't plan to add a CLA to Racket. That would raise the barrier to contributing, and increase the bureaucracy that we have to manage. Hopefully this will be a one time thing, also.
I, Robby Findler (aka Robert Bruce Findler), give permission to license my contributions to Racket under MIT/Apache 2. I've used the email addresses robby@racket-lang.org, robby@plt-scheme.org, robby@northwestern.edu, robby@eecs.northwestern.edu, robby@cs.uchicago.edu, robby@ccs.neu.edu, robby@cs.rice.edu, and robby.findler@gmail.com.
@samth One can only hope :)
I, Phúc (Phil) Nguyễn, give permission to license my contributions to Racket under MIT/Apache 2. I've used the email addresses philnguyen0112@gmail.com, pnguyen@ccs.neu.edu, pcn@cs.umd.edu
I, Greg Hendershott, give permission to license my contributions to Racket under MIT/Apache 2. I've used the email address greghendershott@gmail.com.

---

https://youtu.be/vhKY9x9zz3Y
I, Roman Klochkov (@Kalimehtar), give permission to license my contributions to Racket under MIT/Apache 2. I've used the email address kalimehtar@mail.ru.
Thanks!
Thanks!
Thanks!
FWIW, I'm happy to have the contributions I've made to the various racket repos (basically anything on github.com/racket) licensed under the Apache v2 license or the MIT license (by MIT do you mean Expat or X11, as both have been called the mit license before).

IIRC the only email address I've used for Racket contributions is leif@leifandersen.net

Also, @jackfirth I am 100% opposed to having a CLA. I am 100% happy to license my contributions to the community and PLT Design Inc. But I want that to be under a standard free license, like the LGPL, Apache v2, BSD, MIT, etc. However, I absolutely do not want to license my code to them under a license that does not also apply to the rest of the community. (Basically, if PLT Design Inc. can relicense my contributions, I want every member of the community to also have that right.)
@LeifAndersen I'm not sure I understand that position, as CLAs are (typically) orthogonal to what license the project is released under. They do not affect users, commercial or otherwise, of Racket software in any way. Disclaimer: IANAL, nor do I play one on TV.
@LeifAndersen I believe, in the context of open-source licences, whatever opensource.org calls MIT licence is what is: https://opensource.org/licenses/MIT

---

As for my contributions, I'm happy to relicense my contributions under any free software licence PLT Design wishes to use now or in future. I've had contributions in Racket's repos under cky@cky.nz and cky944@gmail.com.
I, Alexander Hedges (@alehed), give permission to license my contributions to Racket under MIT/Apache 2. I've used the email address alehed@users.noreply.github.com.
I, Bartosz Przygoda (@BartAdv), give permission to license my contributions to Racket under MIT/Apache 2. I've used the email address bprzygoda@gmail.com
I, Laurent Orseau (@Metaxal), give permission to license my contributions
to Racket under MIT/Apache 2. I've used the email address
laurent.orseau@gmail.com

On 11 Jan 2017 6:51 am, "Bartosz" <notifications@github.com> wrote:

> I, Bartosz Przygoda (@BartAdv <https://github.com/BartAdv>), give
> permission to license my contributions to Racket under MIT/Apache 2. I've
> used the email address bprzygoda@gmail.com
>
> —
> You are receiving this because you were mentioned.
> Reply to this email directly, view it on GitHub
> <https://github.com/racket/racket/issues/1570#issuecomment-271792536>, or mute
> the thread
> <https://github.com/notifications/unsubscribe-auth/ABlNHNicAyZMWBP3MIjP9TUagiQXE6qDks5rRHwOgaJpZM4Lf72O>
> .
>

I, Arek Korbik, give permission to license my contributions to Racket under MIT/Apache 2. I've used the email address arkadini@gmail.com
I, Konrad Hinsen, give permission to license my contributions to Racket under MIT/Apache 2. I've used the email address konrad.hinsen@fastmail.net.
I, Tobias Grelsson, give permission to license my contributions to Racket under MIT/Apache 2. I've used the email address tgrelsson@gmail.com

I, Chen Xiao (@simmone <https://github.com/simmone>), give permission to
license my contributions to Racket under MIT/Apache 2. I've used the email
address chenxiao770117@gmail.com.

2017-01-11 9:13 GMT+08:00 Sam Tobin-Hochstadt <notifications@github.com>:

> The following people have contributed on GitHub to some of the Racket
> repositories.
>
> @rcobbe <https://github.com/rcobbe>
> @alehed <https://github.com/alehed>
> @mafagafogigante <https://github.com/mafagafogigante>
> @jackfirth <https://github.com/jackfirth>
> @khinsen <https://github.com/khinsen>
> @acarrico <https://github.com/acarrico>
> @bluerider <https://github.com/bluerider>
> @e45lee <https://github.com/e45lee>
> @cordarei <https://github.com/cordarei>
> @vraid <https://github.com/vraid>
> @PuercoPop <https://github.com/PuercoPop>
> @BartAdv <https://github.com/BartAdv>
> @hoelzro <https://github.com/hoelzro>
> @bon <https://github.com/bon>
> @Kalimehtar <https://github.com/Kalimehtar>
> @Metaxal <https://github.com/Metaxal>
> @jamessan <https://github.com/jamessan>
> @davidtpierson <https://github.com/davidtpierson>
> @kimmyg <https://github.com/kimmyg>
> @filonenko-mikhail <https://github.com/filonenko-mikhail>
> @jcwhittier <https://github.com/jcwhittier>
> @arkadini <https://github.com/arkadini>
> @RayRacine <https://github.com/RayRacine>
> @jaor <https://github.com/jaor>
> @shofetim <https://github.com/shofetim>
> @4z3 <https://github.com/4z3>
> @jacones <https://github.com/jacones>
> @ds26gte <https://github.com/ds26gte>
> @pnwamk <https://github.com/pnwamk>
> @btlachance <https://github.com/btlachance>
> @miraleung <https://github.com/miraleung>
> @projanen <https://github.com/projanen>
> @lyons <https://github.com/lyons>
> @LeiWangHoward <https://github.com/LeiWangHoward>
> @david-vanderson <https://github.com/david-vanderson>
> @lvilnis <https://github.com/lvilnis>
> @schuster <https://github.com/schuster>
> @cky <https://github.com/cky>
> @frenchy64 <https://github.com/frenchy64>
> @gcr <https://github.com/gcr>
> @offby1 <https://github.com/offby1>
> @jsmaniac <https://github.com/jsmaniac>
> @simmone <https://github.com/simmone>
> @mordae <https://github.com/mordae>
> @telephil <https://github.com/telephil>
> @shriram <https://github.com/shriram>
> @jkominek <https://github.com/jkominek>
> @philnguyen <https://github.com/philnguyen>
> @RenaissanceBug <https://github.com/RenaissanceBug>
> @calvis <https://github.com/calvis>
> @dfeltey
> @wilbowma
> @sctb
> @rhcarvalho
> @dvanhorn
> @SamB
> @greghendershott
> @juanfra684
> @gmarceau
> @mbutterick
> @97jaz
> @AlexKnauth
> @lexi-lambda
> @soegaard
> @sbloch
> @LeifAndersen
> @Zoetermeer
> @ntoronto
> @paddymahoney
> @dyoo
> @jspiro
> @maxsnew
> @bdj
> @stchang
> @bfetscher
> @ghcooper
> @gus-massa
> @kathryngray
> @carl-eastlund
> @clklein
> @mikesperber
> @kazzmir
> @tewk
> @takikawa
> @rmculpepper
> @rfindler
> @elibarzilay
>
> —
> You are receiving this because you were mentioned.
> Reply to this email directly, view it on GitHub
> <https://github.com/racket/racket/issues/1570#issuecomment-271749163>, or mute
> the thread
> <https://github.com/notifications/unsubscribe-auth/AAOT_hH77_YYwG3gNC5F4NCz5CjVt_qQks5rRCzPgaJpZM4Lf72O>
> .
>

Sent by email to Sam.
I, Juan Francisco Cantero Hurtado, give permission to license my contributions to Racket under MIT/Apache 2. I've used the email addresses iam@juanfra.info and juanfra@openbsd.org.
I, Leandro Facchinetti, give permission to license my contributions to Racket under MIT/Apache 2. I've used the email address me@leafac.com.
I, Gregory Cooper, give permission to license my contributions to Racket under MIT/Apache 2. I've used the email addresses gcooper@plt-scheme.org, ghcooper@gmail.com, and greg@cs.brown.edu.

I, Shriram Krishnamurthi, give permission to license my contributions to
Racket under MIT/Apache 2. I've used the email addresses
shriram@plt-scheme.org, shriram@racket-lang.org, sk@cs.brown.edu,
shriram@gmail.com, and shriram@cs.rice.edu.​

I, Richard Cobbe, give permission to license my contributions to Racket under MIT/Apache 2. I've used the email addresses cobbe@ccs.neu.edu, rcobbe@gmail.com, cobbe@cs.rice.edu, cobbe@owlnet.rice.edu, and cobbe@alumni.rice.edu (that I know of).
I, Guillaume Marceau, give permission to license my contributions to Racket
under MIT/Apache 2. I've used the email addresses gmarceau@cs.brown.edu,
gmarceau@cs.wpi.com, gmarceau@gmail.com

On Jan 11, 2017 8:09 AM, "rcobbe" <notifications@github.com> wrote:

I, Richard Cobbe, give permission to license my contributions to Racket
under MIT/Apache 2. I've used the email addresses cobbe@ccs.neu.edu,
rcobbe@gmail.com, cobbe@cs.rice.edu, cobbe@owlnet.rice.edu, and
cobbe@alumni.rice.edu (that I know of).

—
You are receiving this because you were mentioned.
Reply to this email directly, view it on GitHub
<https://github.com/racket/racket/issues/1570#issuecomment-271864312>, or mute
the thread
<https://github.com/notifications/unsubscribe-auth/AAybyg4G1JmOFAkkbs11rJz6gpEqI05Wks5rRNSTgaJpZM4Lf72O>
.

I, Tomislav Viljetić (@4z3), give permission to license my contributions to Racket under MIT/Apache 2. I've used the email address tv@also.
I am really happy to see this change taking place.

I, Bernardo Sulzbach, give permission to license my contributions to Racket under MIT/Apache 2. I've used the email address mafagafogigante@gmail.com.
It appears that when you redirect to a file in the Windows command line, then the file is opened in a way that doesn't work with SetFilePointer() to get the output position. So, `file-position*` actually reports just the number of bytes in the output buffer, which goes down when the buffer is flushed. But `transplant-output-port` assumes that the position always increments.

You can avoid the immediate problem by changing `(+ delta v)` to `(max 1 (+ delta v))` on line 108 of "racket/private/port.rkt". I'm working on a more complete repair.
I, Georges Dupéron (@jsmaniac), give permission to license my contributions to Racket under the licenses LGPL, MIT, Apache 2, and under the Public Domain (or CC0, which should provide similar rights, as some countries do not recognise dedications to the Public Domain), which implicitly allows any future licence change for my contributions.

Some of my contributions (past or future) may be derived from a small repository of code which I wrote while I was working at Cortus, S.A.S., in France, and I got their authorisation (by e-mail) for publishing these contributions in the Public Domain.

I have used the email addresses georges.duperon@gmail.com jahvascriptmaniac+github@gmail.com jahvascriptmaniac@gmail.com georges.duperon@cortus.com .
I've pushed a repair for the real problem, and I'll also push the change to `transplant-output-port` to avoid an internal error due to a oddly behaved port.
I, David Van Horn, give permission to license my contributions to Racket
under MIT/Apache 2. I've used the email addresses dvanhorn@cs.uvm.edu,
dvanhorn@cs.brandeis.edu, dvanhorn@ccs.neu.edu, and dvanhorn@cs.umd.edu.

On Tue, Jan 10, 2017 at 8:14 PM, Sam Tobin-Hochstadt <
notifications@github.com> wrote:

> Also these people:
>
> @dfeltey <https://github.com/dfeltey>
> @wilbowma <https://github.com/wilbowma>
> @sctb <https://github.com/sctb>
> @rhcarvalho <https://github.com/rhcarvalho>
> @dvanhorn <https://github.com/dvanhorn>
> @SamB <https://github.com/SamB>
> @greghendershott <https://github.com/greghendershott>
> @juanfra684 <https://github.com/juanfra684>
> @gmarceau <https://github.com/gmarceau>
> @mbutterick <https://github.com/mbutterick>
> @97jaz <https://github.com/97jaz>
> @AlexKnauth <https://github.com/AlexKnauth>
> @lexi-lambda <https://github.com/lexi-lambda>
> @soegaard <https://github.com/soegaard>
> @sbloch <https://github.com/sbloch>
> @LeifAndersen <https://github.com/LeifAndersen>
> @Zoetermeer <https://github.com/Zoetermeer>
> @ntoronto <https://github.com/ntoronto>
> @paddymahoney <https://github.com/paddymahoney>
> @dyoo <https://github.com/dyoo>
> @jspiro <https://github.com/jspiro>
> @maxsnew <https://github.com/maxsnew>
> @bdj <https://github.com/bdj>
> @stchang <https://github.com/stchang>
> @bfetscher <https://github.com/bfetscher>
> @ghcooper <https://github.com/ghcooper>
> @gus-massa <https://github.com/gus-massa>
> @kathryngray <https://github.com/kathryngray>
> @carl-eastlund <https://github.com/carl-eastlund>
> @clklein <https://github.com/clklein>
> @mikesperber <https://github.com/mikesperber>
> @kazzmir <https://github.com/kazzmir>
> @tewk <https://github.com/tewk>
> @takikawa <https://github.com/takikawa>
> @rmculpepper <https://github.com/rmculpepper>
> @rfindler <https://github.com/rfindler>
> @elibarzilay <https://github.com/elibarzilay>
>
> —
> You are receiving this because you were mentioned.
> Reply to this email directly, view it on GitHub
> <https://github.com/racket/racket/issues/1570#issuecomment-271749309>, or mute
> the thread
> <https://github.com/notifications/unsubscribe-auth/AAMiZekCCXImXgRnW3S41BmWI17yoJ0Qks5rRCz7gaJpZM4Lf72O>
> .
>

I hereby license my Racket contributions, past and future, to PLT Design Inc. under the [Apache License Version 2.0](https://opensource.org/licenses/Apache-2.0) and the [MIT License](https://opensource.org/licenses/MIT), as indicated below:

```
Copyright 2013–2017 Matthew Butterick

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
```

```
Copyright 2013–2017 Matthew Butterick

Permission is hereby granted, free of charge, to any person obtaining a copy 
of this software and associated documentation files (the "Software"), to deal 
in the Software without restriction, including without limitation the rights 
to use, copy, modify, merge, publish, distribute, sublicense, and/or 
sell copies of the Software, and to permit persons to whom the Software 
is furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in 
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, 
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE 
WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND 
NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT 
HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, 
WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, 
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER 
DEALINGS IN THE SOFTWARE.
```

Matthew Butterick (mb@mbtype.com)
Thanks for the report!

Is this with a release or with a snapshot or git checkout that includes 78bbcec9633110e9cb8027cfe0b828f4722392ed?
I, Anthony Carrico, give permission to license my contributions to Racket under MIT/Apache 2. I've used the email address acarrico@memebeam.org. 
@mbutterick someone came all lawyered up :D
Yes, it's git checkout, and 78bbcec is found.
Just to make sure, do you see the same error with `raco setup -j 1`?

I'm puzzled by the `given: ffi-obj` in the error message. Maybe something in the document configures printing, but does it really show up that way, without `#<...>`?
I, Scott Bell, give permission to license my contributions to Racket under MIT/Apache 2. I've used the email address scott@sctsm.com.
I, Stephen Chang, give permission to license my contributions to Racket under MIT/Apache 2. I've used the email addresses stchang@ccs.neu.edu, stchang@racket-lang.org, and stchang216@gmail.com
I, Eli Barzilay (@elibarzilay), give permission to license my contributions to Racket under MIT/Apache 2. I've used the email addresses eli@racket-lang.org, eli@plt-scheme.org, eli@barzilay.org.

I, James McCoy (@jamessan), give permission to license my contributions to Racket under MIT/Apache 2. I've used the email addresses vega.james@gmail.com.
I, Raymond Racine, give permission to license my contributions to Racket
under MIT/Apache 2. I've used the email addresses rracine@comcast.net,
ray.racine@gmail.com, ray@racine.cloud.

On Tue, Jan 10, 2017 at 8:13 PM, Sam Tobin-Hochstadt <
notifications@github.com> wrote:

> The following people have contributed on GitHub to some of the Racket
> repositories.
>
> @rcobbe <https://github.com/rcobbe>
> @alehed <https://github.com/alehed>
> @mafagafogigante <https://github.com/mafagafogigante>
> @jackfirth <https://github.com/jackfirth>
> @khinsen <https://github.com/khinsen>
> @acarrico <https://github.com/acarrico>
> @bluerider <https://github.com/bluerider>
> @e45lee <https://github.com/e45lee>
> @cordarei <https://github.com/cordarei>
> @vraid <https://github.com/vraid>
> @PuercoPop <https://github.com/PuercoPop>
> @BartAdv <https://github.com/BartAdv>
> @hoelzro <https://github.com/hoelzro>
> @bon <https://github.com/bon>
> @Kalimehtar <https://github.com/Kalimehtar>
> @Metaxal <https://github.com/Metaxal>
> @jamessan <https://github.com/jamessan>
> @davidtpierson <https://github.com/davidtpierson>
> @kimmyg <https://github.com/kimmyg>
> @filonenko-mikhail <https://github.com/filonenko-mikhail>
> @jcwhittier <https://github.com/jcwhittier>
> @arkadini <https://github.com/arkadini>
> @RayRacine <https://github.com/RayRacine>
> @jaor <https://github.com/jaor>
> @shofetim <https://github.com/shofetim>
> @4z3 <https://github.com/4z3>
> @jacones <https://github.com/jacones>
> @ds26gte <https://github.com/ds26gte>
> @pnwamk <https://github.com/pnwamk>
> @btlachance <https://github.com/btlachance>
> @miraleung <https://github.com/miraleung>
> @projanen <https://github.com/projanen>
> @lyons <https://github.com/lyons>
> @LeiWangHoward <https://github.com/LeiWangHoward>
> @david-vanderson <https://github.com/david-vanderson>
> @lvilnis <https://github.com/lvilnis>
> @schuster <https://github.com/schuster>
> @cky <https://github.com/cky>
> @frenchy64 <https://github.com/frenchy64>
> @gcr <https://github.com/gcr>
> @offby1 <https://github.com/offby1>
> @jsmaniac <https://github.com/jsmaniac>
> @simmone <https://github.com/simmone>
> @mordae <https://github.com/mordae>
> @telephil <https://github.com/telephil>
> @shriram <https://github.com/shriram>
> @jkominek <https://github.com/jkominek>
> @philnguyen <https://github.com/philnguyen>
> @RenaissanceBug <https://github.com/RenaissanceBug>
> @calvis <https://github.com/calvis>
> @dfeltey
> @wilbowma
> @sctb
> @rhcarvalho
> @dvanhorn
> @SamB
> @greghendershott
> @juanfra684
> @gmarceau
> @mbutterick
> @97jaz
> @AlexKnauth
> @lexi-lambda
> @soegaard
> @sbloch
> @LeifAndersen
> @Zoetermeer
> @ntoronto
> @paddymahoney
> @dyoo
> @jspiro
> @maxsnew
> @bdj
> @stchang
> @bfetscher
> @ghcooper
> @gus-massa
> @kathryngray
> @carl-eastlund
> @clklein
> @mikesperber
> @kazzmir
> @tewk
> @takikawa
> @rmculpepper
> @rfindler
> @elibarzilay
>
> —
> You are receiving this because you were mentioned.
> Reply to this email directly, view it on GitHub
> <https://github.com/racket/racket/issues/1570#issuecomment-271749163>, or mute
> the thread
> <https://github.com/notifications/unsubscribe-auth/AAAbJiZkyMnjlMSdPegrO5LX4vAPKB61ks5rRCzOgaJpZM4Lf72O>
> .
>

@cky Then we need to be precise here. Looking at the link in Sam's post I agree that its probably the Expat one that the OSI uses, but we should put that explicitly in the pros, rather than just the informal 'mit license', like everyone seems to be doing here.

Or alternatively, we could do what @mbutterick did an just put the deed right in the comment. (Good on you for doing that Matthew. :D )

Also, @jsmaniac fwiw, would it be possible to get the rights for the code under an actual license. Public Domain code is nice in theory, but is really problematic because various jurisdictions treat it very differently. And so its very good to have specifically what they mean by 'public domain' in writing. If your company likes putting it in the public domain, might I recommend CC0 (https://creativecommons.org/publicdomain/zero/1.0/), which has the stated goal of getting as close to that as legally possible, even in countries where putting something in the public domain is hard. You can read more about how it does that here: https://wiki.creativecommons.org/wiki/CC0 (or of course, just read the license itself...)


To save Sam trouble, lets move the discussion elsewhere.

Thanks,
Robby

(I should point out here that I am not a lawyer (and even if I was I'm not your lawyer), so all of this could certainly be wrong. I just want the best outcome for the racket project as possible, since I <3 it quite a lot. But if we're seriously concerned it would be prudent to get an actual lawyer.)  
@rfindler okay, where?
I, Max New, give permission to license my contributions to Racket under MIT/Apache 2. I've used the email address maxsnew@gmail.com
I, Jens Axel Søgaard, give permission to license my contributions to Racket under MIT/Apache 2. 
I, Philippe Mechaï (@telephil <https://github.com/telephil>), give
permission to license my contributions to Racket under MIT/Apache 2.

On Wed, Jan 11, 2017 at 2:13 AM, Sam Tobin-Hochstadt <
notifications@github.com> wrote:

> The following people have contributed on GitHub to some of the Racket
> repositories.
>
> @rcobbe <https://github.com/rcobbe>
> @alehed <https://github.com/alehed>
> @mafagafogigante <https://github.com/mafagafogigante>
> @jackfirth <https://github.com/jackfirth>
> @khinsen <https://github.com/khinsen>
> @acarrico <https://github.com/acarrico>
> @bluerider <https://github.com/bluerider>
> @e45lee <https://github.com/e45lee>
> @cordarei <https://github.com/cordarei>
> @vraid <https://github.com/vraid>
> @PuercoPop <https://github.com/PuercoPop>
> @BartAdv <https://github.com/BartAdv>
> @hoelzro <https://github.com/hoelzro>
> @bon <https://github.com/bon>
> @Kalimehtar <https://github.com/Kalimehtar>
> @Metaxal <https://github.com/Metaxal>
> @jamessan <https://github.com/jamessan>
> @davidtpierson <https://github.com/davidtpierson>
> @kimmyg <https://github.com/kimmyg>
> @filonenko-mikhail <https://github.com/filonenko-mikhail>
> @jcwhittier <https://github.com/jcwhittier>
> @arkadini <https://github.com/arkadini>
> @RayRacine <https://github.com/RayRacine>
> @jaor <https://github.com/jaor>
> @shofetim <https://github.com/shofetim>
> @4z3 <https://github.com/4z3>
> @jacones <https://github.com/jacones>
> @ds26gte <https://github.com/ds26gte>
> @pnwamk <https://github.com/pnwamk>
> @btlachance <https://github.com/btlachance>
> @miraleung <https://github.com/miraleung>
> @projanen <https://github.com/projanen>
> @lyons <https://github.com/lyons>
> @LeiWangHoward <https://github.com/LeiWangHoward>
> @david-vanderson <https://github.com/david-vanderson>
> @lvilnis <https://github.com/lvilnis>
> @schuster <https://github.com/schuster>
> @cky <https://github.com/cky>
> @frenchy64 <https://github.com/frenchy64>
> @gcr <https://github.com/gcr>
> @offby1 <https://github.com/offby1>
> @jsmaniac <https://github.com/jsmaniac>
> @simmone <https://github.com/simmone>
> @mordae <https://github.com/mordae>
> @telephil <https://github.com/telephil>
> @shriram <https://github.com/shriram>
> @jkominek <https://github.com/jkominek>
> @philnguyen <https://github.com/philnguyen>
> @RenaissanceBug <https://github.com/RenaissanceBug>
> @calvis <https://github.com/calvis>
> @dfeltey
> @wilbowma
> @sctb
> @rhcarvalho
> @dvanhorn
> @SamB
> @greghendershott
> @juanfra684
> @gmarceau
> @mbutterick
> @97jaz
> @AlexKnauth
> @lexi-lambda
> @soegaard
> @sbloch
> @LeifAndersen
> @Zoetermeer
> @ntoronto
> @paddymahoney
> @dyoo
> @jspiro
> @maxsnew
> @bdj
> @stchang
> @bfetscher
> @ghcooper
> @gus-massa
> @kathryngray
> @carl-eastlund
> @clklein
> @mikesperber
> @kazzmir
> @tewk
> @takikawa
> @rmculpepper
> @rfindler
> @elibarzilay
>
> —
> You are receiving this because you were mentioned.
> Reply to this email directly, view it on GitHub
> <https://github.com/racket/racket/issues/1570#issuecomment-271749163>, or mute
> the thread
> <https://github.com/notifications/unsubscribe-auth/AJx688txBevWKptMIy9Ich5UrUBnf91Hks5rRCzRgaJpZM4Lf72O>
> .
>

e2070b882d9065 fixes this.
Sorry my bad.
It's `#<ffi-lib>`, I removed `#<>` because markdown eats them.
The same to `#<ctype>` (sometimes it's displayed as `#<ctype:pointer>`.

In this morning, I never saw it with `-j 1`, without `-j`, it occurs or not at random.

Here is another off-topic question.
I see `(processor-count)` returns a constant 2 in Solaris, one year ago I modified the C source (and linked with `kstat`) to get the correct count, it built as expected, but even a simple future program crushed racket due to segfault. Do you have plan to solve it? For me, it's just curious since there are other ways to get the correct count and parallel programs can work as expected.

I, Jan Dvořák, give permission to license my contributions to Racket under MIT/Apache 2. I've used the email addresses jan.dvorak@singularita.net, jan.dvorak@techlib.cz and mordae@anilinux.org.
I, Brian Lachance, give permission to license my contributions to Racket under MIT/Apache 2. I've used the email address blachance@gmail.com
I, David Vanderson, give permission to license my contributions to Racket under MIT/Apache 2. I've used the email addresses david.vanderson@gmail.com
I, Luke Vilnis (@lvilnis), give permission to
license my contributions to Racket under MIT/Apache 2. I've used the email
address lvilnis@gmail.com <zeppieri@gmail.com>.

On Tue, Jan 10, 2017 at 8:13 PM, Sam Tobin-Hochstadt <
notifications@github.com> wrote:

> The following people have contributed on GitHub to some of the Racket
> repositories.
>
> @rcobbe <https://github.com/rcobbe>
> @alehed <https://github.com/alehed>
> @mafagafogigante <https://github.com/mafagafogigante>
> @jackfirth <https://github.com/jackfirth>
> @khinsen <https://github.com/khinsen>
> @acarrico <https://github.com/acarrico>
> @bluerider <https://github.com/bluerider>
> @e45lee <https://github.com/e45lee>
> @cordarei <https://github.com/cordarei>
> @vraid <https://github.com/vraid>
> @PuercoPop <https://github.com/PuercoPop>
> @BartAdv <https://github.com/BartAdv>
> @hoelzro <https://github.com/hoelzro>
> @bon <https://github.com/bon>
> @Kalimehtar <https://github.com/Kalimehtar>
> @Metaxal <https://github.com/Metaxal>
> @jamessan <https://github.com/jamessan>
> @davidtpierson <https://github.com/davidtpierson>
> @kimmyg <https://github.com/kimmyg>
> @filonenko-mikhail <https://github.com/filonenko-mikhail>
> @jcwhittier <https://github.com/jcwhittier>
> @arkadini <https://github.com/arkadini>
> @RayRacine <https://github.com/RayRacine>
> @jaor <https://github.com/jaor>
> @shofetim <https://github.com/shofetim>
> @4z3 <https://github.com/4z3>
> @jacones <https://github.com/jacones>
> @ds26gte <https://github.com/ds26gte>
> @pnwamk <https://github.com/pnwamk>
> @btlachance <https://github.com/btlachance>
> @miraleung <https://github.com/miraleung>
> @projanen <https://github.com/projanen>
> @lyons <https://github.com/lyons>
> @LeiWangHoward <https://github.com/LeiWangHoward>
> @david-vanderson <https://github.com/david-vanderson>
> @lvilnis <https://github.com/lvilnis>
> @schuster <https://github.com/schuster>
> @cky <https://github.com/cky>
> @frenchy64 <https://github.com/frenchy64>
> @gcr <https://github.com/gcr>
> @offby1 <https://github.com/offby1>
> @jsmaniac <https://github.com/jsmaniac>
> @simmone <https://github.com/simmone>
> @mordae <https://github.com/mordae>
> @telephil <https://github.com/telephil>
> @shriram <https://github.com/shriram>
> @jkominek <https://github.com/jkominek>
> @philnguyen <https://github.com/philnguyen>
> @RenaissanceBug <https://github.com/RenaissanceBug>
> @calvis <https://github.com/calvis>
> @dfeltey
> @wilbowma
> @sctb
> @rhcarvalho
> @dvanhorn
> @SamB
> @greghendershott
> @juanfra684
> @gmarceau
> @mbutterick
> @97jaz
> @AlexKnauth
> @lexi-lambda
> @soegaard
> @sbloch
> @LeifAndersen
> @Zoetermeer
> @ntoronto
> @paddymahoney
> @dyoo
> @jspiro
> @maxsnew
> @bdj
> @stchang
> @bfetscher
> @ghcooper
> @gus-massa
> @kathryngray
> @carl-eastlund
> @clklein
> @mikesperber
> @kazzmir
> @tewk
> @takikawa
> @rmculpepper
> @rfindler
> @elibarzilay
>
> —
> You are receiving this because you were mentioned.
> Reply to this email directly, view it on GitHub
> <https://github.com/racket/racket/issues/1570#issuecomment-271749163>, or mute
> the thread
> <https://github.com/notifications/unsubscribe-auth/AA8uckleTtdU5YbO91zGbdK0LN-ZW_PAks5rRCzPgaJpZM4Lf72O>
> .
>

@samth I don't know who Like Vilnis (above) is, but that's a link to my github page and that's my email address. Maybe this was just a poor cut and paste job?
Okay, I've found the right place to start.
The simplest solution is inheriting a `string-snip%` then return its instance in method `on-new-string-snip` of `text%`. 
(By the way, @lehitoskin, thank you for making the PR!)
Sure enough, the failing CI builds are from not having an `open-output-bytes` port in `o`.
I added an intermediate string port. Should be fine now.
I, Lehi Toskin, give permission to license my contributions to Racket under MIT/Apache 2. I've used the email addresses lehi.toskin@gmail.com and lehi@tosk.in
It appears the appveyor check failed because of a networking issue:
```
Section(foreign)
Section(cstruct)
Section(uni-norm)
ERROR: tcp-connect: connection failed
  address: www.unicode.org
  port number: 80
  step: 6
  system error: A connection attempt failed because the connected party did not properly respond after a period of time, or established connection failed because connected host has failed to respond.; errno=10060
Command exited with code 2
```
And I don't know quite why that one build failed in Travis. I looked around in the logs and it doesn't appear to be related to my code changes.
I, Steven Jaconette, give permission to license my contributions to Racket under MIT/Apache 2. I've used the email addresses jacones@u.northwestern.edu and stevenjaconette2007@u.northwestern.edu.
Maybe you can track who responded and who you are waiting for?

Also why don't you make the C code changes which you can at the earliest.
I, Danny Yoo, give permission to license my contributions to Racket under MIT/Apache 2. I've used the email addresses dyoo@hashcollision.org, dyoo@hkn.eecs.berkeley.edu, dyoo@cs.wpi.edu, danny.yoo@gmail.com.
@sirinath I'm tracking that externally to this issue. I'll send email to missing people in a little while.
I, Patrick Mahoney (@paddymahoney), give permission to license my contributions to Racket under MIT/Apache 2. I've used the email addresses paddy.mahoney@gmail.com
Thanks, works for me. I suppose any wording other than "chain of pairs" would be either be inaccurate or less user-friendly.
I don't think you need the "index reaches a non-pair" language at all. Would it make sense to replace it with something that expresses `"expected a (possibly improper) list with at least ~a pairs"`?
Okay, here's another try:
```
> (take 2 2)
; take: contract violation
;   expected: a chain of at least 2 pairs
;   given: 2
> (drop '(2) 2)
; drop: contract violation
;   expected: a list with at least 2 pairs
;   given: '(2)
```

(maybe should say "list .... elements" instead of "list .... pairs")
Posted one more update, based on feedback from alex

```
> (drop 2 2)
; drop: contract violation
;   expected: a (possibly improper) list with at least 2 pairs
;   given: 2
; [,bt for context]
> (take '(2) 2)
; take: contract violation
;   expected: a list with at least 2 elements
;   given: '(2)
; [,bt for context]
```
I, Neil Toronto, give permission to license my contributions to Racket
under MIT/Apache 2. I've used the email addresses neil.toronto@gmail.com
and ntoronto@racket-lang.org.

On Wed, Jan 18, 2017 at 4:39 PM, Patrick Mahoney <notifications@github.com>
wrote:

> I, Patrick Mahoney (@paddymahoney <https://github.com/paddymahoney>),
> give permission to license my contributions to Racket under MIT/Apache 2.
> I've used the email addresses paddy.mahoney@gmail.com
>
> —
> You are receiving this because you were mentioned.
> Reply to this email directly, view it on GitHub
> <https://github.com/racket/racket/issues/1570#issuecomment-273528115>, or mute
> the thread
> <https://github.com/notifications/unsubscribe-auth/AAd3jma4CvXWwu8wpHphxc1EgV-U2_2jks5rTkBKgaJpZM4Lf72O>
> .
>

These look good as far as I can tell
I, Mira Leung, give permission to license my contributions to Racket under
MIT/Apache 2. I've used the email address emailmiraleung@gmail.com.

On Fri, Jan 20, 2017 at 2:53 AM, Neil Toronto <notifications@github.com>
wrote:

> I, Neil Toronto, give permission to license my contributions to Racket
> under MIT/Apache 2. I've used the email addresses neil.toronto@gmail.com
> and ntoronto@racket-lang.org.
>
> On Wed, Jan 18, 2017 at 4:39 PM, Patrick Mahoney <notifications@github.com
> >
> wrote:
>
> > I, Patrick Mahoney (@paddymahoney <https://github.com/paddymahoney>),
> > give permission to license my contributions to Racket under MIT/Apache 2.
> > I've used the email addresses paddy.mahoney@gmail.com
> >
> > —
> > You are receiving this because you were mentioned.
> > Reply to this email directly, view it on GitHub
> > <https://github.com/racket/racket/issues/1570#issuecomment-273528115>,
> or mute
> > the thread
> > <https://github.com/notifications/unsubscribe-auth/
> AAd3jma4CvXWwu8wpHphxc1EgV-U2_2jks5rTkBKgaJpZM4Lf72O>
> > .
>
> >
>
> —
> You are receiving this because you were mentioned.
> Reply to this email directly, view it on GitHub
> <https://github.com/racket/racket/issues/1570#issuecomment-274044239>, or mute
> the thread
> <https://github.com/notifications/unsubscribe-auth/AFIo8fx2WvA9e_Nprz52f2Yqtl-ICaYOks5rUJI1gaJpZM4Lf72O>
> .
>

Actually, the `make-prefab-struct` is irrelevant, the problem arises only when using a `hash`:

```racket
#lang racket
(define-syntax (foo stx)
  (syntax-case stx ()
    [(_ name)
     #`(define-syntax name #,(hash 1 2))]))
(foo a)
```
Ono of the jobs failed on Travis due to what seems to be a transient networking error (the package catalog returning a 503 error code).

It seems that the tests for `stxparse` (`tests/stxparse/*.rkt`) are not run as part of the build. Are those supposed to run only on pkg-build, or should I add them to the Travis and AppVeyor build scripts?
@tonyg @jeapostrophe can you look at the pkg server issue?

@jsmaniac Running those tests sounds like a good idea to me.
@samth I added the tests to the Travis and AppVeyor build scripts.
I, Ryan Culpepper, give permission to license my contributions to Racket under MIT/Apache 2. I've used the email addresses ryanc@ccs.neu.edu, ryanc@plt-scheme.org, ryanc@racket-lang.org, and ryan@cs.utah.edu.
That's intentional; they are metafunctions, not metamacros. They receive the actual terms bound to the pattern variables (see the join example in the docs).

Should I take this as a feature request for template-expanders?
@rmculpepper Thanks for the review! I applied the changes you requested, I'll push in a minute. Should I squash or add a new commit?
@jsmaniac, whichever you prefer. It looks like github now has a "Rebase and merge" button, so multi-commit pull requests shouldn't be a problem.
@rmculpepper Done!

I tend to prefer making new commits, as last time I checked, GitHub used to hide away the reviews on commits which were removed by a force-push. Good to know that there is this "rebase and merge" feature :) .
I did recognize that behavior in the docs, but I was unsure why template metafunctions could not do both. I am ok with the behavior of what they receive, but I had expected that if a metafunction produced output that itself contained metafunctions (or `??` / `?@`), that result would be expanded.

Thinking on it a little bit more, though, I think I understand a bit better. The only thing this makes sense for is `?@`, since otherwise you could just use `template` to produce the resulting syntax. I just what I want is a “splicing metafunction” a la splicing syntax classes, though template expanders could probably generalize that.
When `raco pkg install --link` installs a package as in "user" scope, it needs to modify the  documentation to point back to the user's documentation space. For example, if a student goes to "cond-strict" documentation and tries to use the search box at the top left, I believe the search will point back to the documentation index of the user that set up that package.

So, that's kind of a corner, and there may be some other similar corner that I've forgotten. They reflect the intent that user-scope packages belong to a user.

Can you install the package for everyone as an installation-scope package (using `raco pkg install -i ...`)? That would require permission to modify the installation, but doing so lines up with the intent.

There are also intermediate layers of installation, where it's possible to have a notion of site installations that chain to a more global installation. I don't think that currently works in the direction for that you'd want, though.
Unfortunately, I'm just a little TA and don't have a permission to install a package systemwide. I will try to talk to those people with the permission, but if that doesn't work, I guess just ignoring the error is fine as well. Thank you!
The AppVeyor build failed with this error:

```
Section(foreign)
ERROR: =: contract violation
  expected: number?
  given: #<procedure:count>
  argument position: 1st
  other arguments...:
   0
```

The diff does not contain any mention of `count`, and it seems the error originates from `pkgs/racket-test-core/tests/racket/foreign-test.rktl`:

```
(t  78 'add1_int_int
      (_fun #:retry (again [count 0]) _int  -> (v : _int) -> 
            (if (= count 0)
                (again 76)
                (+ count v)))
      1)
  (t  95 'add1_int_int
      (_fun #:retry (again [count 0])
            (a) :: (a : _int = (+ a count))  -> (v : _int) -> 
            (if (= count 0)
                (again 92)
                v))
      2)
```

The implementation of `_fun` in `racket/collects/ffi/unsafe.rkt` and`racket/collects/ffi/unsafe/private/win32.rkt` does not use `syntax-parse` as far as I can tell, and I couldn't find the definition of the `(t …)` form.

I'm clueless as to how this PR relates to that error, and why it would fail only on Windows, any hints?
I manually re-ran the appveyor tests, and they passed.
Looks good, but you may want to add some explanation re why this particular way of doing it is preferable (i.e., your PR comment).
PR comment updated to describe the details of the issue
Sorry. I meant in the docs proper.
I'm not sure what we would add -- I think they docs are fine, the example was just wrong, and is now consistent with the rest of the docs in that area.

In the docs the declared specification for `for/fold/derived` is the following:

```racket
(for/fold/derived orig-datum
  ([accum-id init-expr] ...) (for-clause ...)
  body-or-break ... body)
```

Which is correct! I just fixed the _example_ following that specification in the docs to actually expand into that form that we already declared things should be. Previously the example was just wrong in a silly way (i.e. it didn't do what the docs said to do) that happened to work for some, but not all, of the ways a `for` loop can be used.

If you think the prose in the docs could be improved in a particular way I'm happy to make that change. But from where I sit the docs are fine, the example just broke its own rule.
Just noticed that v6.8 is out. I updated my local repository, but there's still no make targets called `in-place` or `unix-style`.
Okay, I was trying to compile from the wrong directory. As I was skimming the README and installation instructions, a friend told me for some reason that I was supposed to run `make` from the `racket/src` directory. Running from the root of the git repository fixes my issue.

Herp 😰 😅 
The second OSX job timed out just before finishing, could someone restart just that job? Thanks!
Here's my reasoning: the code in the docs was wrong, therefore it's not unbelievable that someone writing their own `for` form could make the same mistake (and end up with a `for` form that can't accept all the bells and whistles), and so explaining that mistake explicitly, and how to avoid it, may be a good idea.

If you think having an example that works fine is enough to avoid that, no problem. Just bringing it up.
I, Claire Alvis, give permission to license my contributions to Racket under MIT/Apache 2. I've used the email addresses claire.alvis@gmail.com, calvis@ccs.neu.edu, calvis@racket-lang.org
LGTM
I'd say this is a deficiency of `raco test --process`, because it ends up filling the initial namespace with `racket/base`, but the initial namespace should be empty.

Unfortunately, when you change the `test` module to `main` and run with `racket 12i.rkt`, then it also works. That's a little subtle: `racket 12i.rkt` first requires the overall module into the current namespace, which in this case provides `begin`, and then it requires the `main` submodule. So, again, things work out, but more or less accidentally.

Maybe another way to put it is that using `eval` without a specific namespace is asking for trouble, and various ways of running a module will unfortunately oblige with trouble.
I think the problem in DrRacket is that the output port spans phases, and it uses a `racket/pretty` at phase 0 relative to the program running in DrRacket, so it doesn't cooperate nicely with `racket/pretty` at phase 1. Probably something in `racket/pretty` is incorrectly assuming that it gets a compatible port via callbacks, and I'll investigate more.

The problem in Racket is a bug in `gen:custom-write` handling, and I'll push a repair for that soon.

Meanwhile, I think the way that `print` switches to quoted form is defined in "1.4 The Printer" in the Reference (where it talks about quoting depth). Does that not cover what you had in mind?
@mflatt Thanks for looking into this!

Concerning the docs, they explain what causes print to switch to the quoted form, but there seems to be no `parameter` to control that (i.e. prevent switching to quoted form when the contents are quotable). I had found out that in my particular case, printing to a temporary string and then printing that string prevented that behaviour, for some reason. In the end, though, I switched to using `mzlib/pconvert`.
I, Stephen Bloch, give permission to license my contributions to Racket under MIT/Apache 2.  I’ve used the email addresses sbloch@adelphi.edu <mailto:sbloch@adelphi.edu>, bloch@adelphi.edu <mailto:bloch@adelphi.edu>, sbloch1964@gmail.com <mailto:sbloch1964@gmail.com>, sbloch@google.com <mailto:sbloch@google.com> (and no doubt a bunch of others not relevant to Racket).

Stephen Bloch
sbloch1964@gmail.com <mailto:sbloch1964@gmail.com>

Some additional observations (given the module above):

- Accessing a field in a deserialized instance works as expected: 
  ```
  > (get-field v (deserialize (serialize inst)))
  '#hasheq()
  ```
- The bug only appears to affect classes that use automatic serialization. Given a class that implements `externalizable<?>`, things seem to work as expected:
  ```
  (define-serializable-class* explicit-foo% object% (foo<%>
                                                     externalizable<%>)
    (inspect #f)
    (init-field [v #hasheq()])
    (define/public (foo-method)
      'result)
    (define/public (externalize)
      v)
    (define/public (internalize x)
      (set! v x))
    (super-new))
  (define explicit-inst
    (new explicit-foo%))
  ```
  ```
  > explicit-inst
  (wrapper-object:explicit-foo% '#hasheq())
  > (deserialize (serialize explicit-inst))
  (wrapper-object:explicit-foo% '#hasheq())
  > (send (deserialize (serialize explicit-inst))
          foo-method)
  'result
  ```
- Unexpected behavior only occurs when calling a method that has a contract through its interface.
  ```
  (define bar<%>
    (interface ()
      [with-contract (->m any/c)]
      no-contract))
  (define-serializable-class* bar% object% (bar<%>)
    (inspect #f)
    (super-new)
    (define/public (not-in-interface)
      "Not in interface")
    (define/public (no-contract)
      "In interface, but no contract")
    (define/public (with-contract)
      "Has contract via interface"))
  (define deserialized-bar-instance
    (deserialize (serialize (new bar%))))
  ```
  ```
  > (send deserialized-bar-instance not-in-interface)
  "Not in interface"
  > (send deserialized-bar-instance no-contract)
  "In interface, but no contract"
  > (send deserialized-bar-instance with-contract)
   application: not a procedure;
   expected a procedure that can be applied to arguments
    given: '(#<procedure:with-contract method in bar%> ((#<chaperone-contract: (->m any/c)> (interface bar<%>) (class bar%) #f)))
    arguments...:
  ```
I think this is fixed in v6.8.
Problems related to v10.12.1 are fixed in v6.8.
I see that the Homebrew formula for Racket sets `bindir` to "/usr/local/bin", so that's why applications end up there. I've added a `guibindir` setting that overrides `bindir` for GUI applications (i.e., ".app"s on Mac OS) and could be set to "/Applications".

I'm not sure that's the right solution, but it might be a good idea, and I think a separate `guibindir` setting makes sense, anyway.
I, Blake Johnson (@bdj), give permission to license my contributions to Racket under MIT/Apache 2. I've used the email addresses bjohn3x@gmail.com and blake.johnson@byu.edu.
This issue was moved to racket/macro-debugger#20
@zenspider I think the relevant repo is racket/macro-debugger, and just moved the issue there, where it will hopefully get more attention: https://github.com/racket/macro-debugger/issues/20 .

I don't have the rights to close this issue here, can you take care of that?

Thanks.
The problem appears to be in DrRacket's syntax snips, not in quasisyntax etc. It also occurs in the following example:

    #'(add1 . (add1))

I would guess that the bug has to do with displaying identifiers in syntax pairs that are not syntax lists, but strangely it handles `#'(add1 . add1)` just fine.

BTW, if you use the macro stepper's syntax browser, you should see the correct information:

    (require macro-debugger/syntax-browser)
    (browse-syntaxes (list #'(add1 . (add1))))

@rmculpepper Indeed, the info is still here. I had a problem with an unbound identifier, and thought through debugging that this was the cause, but it's only a display issue. Thanks!
Just have been wondering what % progress is. Any estimate when it will be completed?
cc @PatrickMaier @magnusmorton
@rmculpepper 

The bad call to `datum->syntax` happens [*here*](https://github.com/racket/racket/blob/master/racket/collects/syntax/parse/private/runtime-report.rkt#L689-L693), and the bad value is `cx`, which is a list instead of a syntax object:

```racket
(define (stx+index->stx stx+index)
  (let*-values ([(stx) (car stx+index)]
                [(index) (cdr stx+index)]
                [(x cx) (stx-list-drop/cx stx stx index)])
    (datum->syntax cx x cx)))
```

According to the signature of `stx-list-drop/cx`, its second argument `stx` has to be a syntax object, but here it's not; it's `'(#<syntax 2> #<syntax wrong>)`.
The `ps->stx+index` function [*here*](https://github.com/racket/racket/blob/master/racket/collects/syntax/parse/private/runtime-report.rkt#L243-L276) has the signature `Progress -> (cons Syntax Nat)`. There are cases where it returns `(cons (interp ....) ....)`, so it seems that `interp` should return a syntax object. Is this correct?

However, in the `(cons (? exact-positive-integer? n) parent)` case of `interp`, it returns
```racket
(for/fold ([stx (interp parent)]) ([i (in-range n)])
  (stx-cdr stx))
```
Which often isn't a syntax object. 

Specifically, this causes `ps->stx+index` to return `'((#<syntax 2> #<syntax wrong>) . 1)`, which does not satisfy `(cons Syntax Nat)` from the signature.

What should this do? Should it be modified to always return a syntax object, or should the signature be changed to say it doesn't always return syntax, with everything else changed to not rely on it being syntax?
Here's a stacktrace:

```
☕  lldb `which racket`
(lldb) target create "/Users/robby/git/plt/racket/bin/racket"
Current executable set to '/Users/robby/git/plt/racket/bin/racket' (x86_64).
(lldb) settings set target.run-args tmp.rkt
(lldb) run
Process 44993 launched: '/Users/robby/git/plt/racket/bin/racket' (x86_64)
Seg fault (internal error) at 0x7fff5f3fff90
Process 44993 stopped
* thread #1: tid = 0x3f6b49, 0x00000001002dcae2 Racket`scheme_sfs_expr(expr=0x0000000100703410, info=0x0000000107509648, closure_self_pos=-1) + 34 at sfs.c:1365, queue = 'com.apple.main-thread', stop reason = EXC_BAD_ACCESS (code=2, address=0x7fff5f3fff90)
    frame #0: 0x00000001002dcae2 Racket`scheme_sfs_expr(expr=0x0000000100703410, info=0x0000000107509648, closure_self_pos=-1) + 34 at sfs.c:1365
   1362	
   1363	Scheme_Object *scheme_sfs_expr(Scheme_Object *expr, SFS_Info *info, int closure_self_pos)
   1364	/* closure_self_pos == -2 => immediately in sequence */
-> 1365	{
   1366	  Scheme_Type type = SCHEME_TYPE(expr);
   1367	  int seqn, stackpos, tp;
   1368	
(lldb) bt
warning: could not load any Objective-C class information. This will significantly reduce the quality of type information available.
* thread #1: tid = 0x3f6b49, 0x00000001002dcae2 Racket`scheme_sfs_expr(expr=0x0000000100703410, info=0x0000000107509648, closure_self_pos=-1) + 34 at sfs.c:1365, queue = 'com.apple.main-thread', stop reason = EXC_BAD_ACCESS (code=2, address=0x7fff5f3fff90)
  * frame #0: 0x00000001002dcae2 Racket`scheme_sfs_expr(expr=0x0000000100703410, info=0x0000000107509648, closure_self_pos=-1) + 34 at sfs.c:1365
    frame #1: 0x00000001002dd18a Racket`scheme_sfs_expr [inlined] sfs_application3(o=<unavailable>, info=<unavailable>) + 333 at sfs.c:340
    frame #2: 0x00000001002dd03d Racket`scheme_sfs_expr(expr=<unavailable>, info=<unavailable>, closure_self_pos=<unavailable>) + 1405 at sfs.c:1410
    frame #3: 0x00000001002dd36e Racket`scheme_sfs_expr [inlined] sfs_branch(o=<unavailable>, info=<unavailable>) + 208 at sfs.c:591
    frame #4: 0x00000001002dd29e Racket`scheme_sfs_expr(expr=<unavailable>, info=<unavailable>, closure_self_pos=<unavailable>) + 2014 at sfs.c:1419
    frame #5: 0x00000001002dcfa5 Racket`scheme_sfs_expr [inlined] sfs_application2(o=<unavailable>, info=<unavailable>) + 345 at sfs.c:319
    frame #6: 0x00000001002dce4c Racket`scheme_sfs_expr(expr=<unavailable>, info=<unavailable>, closure_self_pos=<unavailable>) + 908 at sfs.c:1407
    frame #7: 0x00000001002e0e09 Racket`sfs_one_branch(info=<unavailable>, ip=132993, vec=<unavailable>, delta=0, tbranch=<unavailable>) + 825 at sfs.c:518
    frame #8: 0x00000001002df09c Racket`scheme_sfs_expr [inlined] sfs_branch(o=<unavailable>, info=<unavailable>) + 69 at sfs.c:610
```
I independently started getting seg faults in what seems like a similar situation.

I dont know if it's the same as @wilbowma's bug but I think my seg faults are triggered when using preserved syntax properties with a non-serializable key:

```
$ racket
Welcome to Racket v6.7.0.4.
> (syntax-property #'+ (lambda (x) x) #'-)
#<syntax:1:19 +>
> (syntax-property #'+ (lambda (x) x) #'- #t)
SIGSEGV MAPERR si_code 1 fault on addr (nil)
Aborted
```

William, are you sure that you are using a symbol key? In my situation, I thought I was using a symbol but I made a typo and was actually using a function as the key.

I confirmed the seg fault in 6.8 as well.
I tried that program on an older version of Mac OS and different versions of Racket, and it failed on every version of Racket that I tried since 6.4 (when `'secure` was added).

I also tried the following program

    (ssl-connect "www.google.com" 443 (ssl-secure-client-context))

and it succeeded in Racket 6.3 and failed since 6.4.

Google just changed their certificate, I think, to use their new
certificate authority, so that might be the problem.

On Wed, Feb 1, 2017, 8:36 PM Ryan Culpepper <notifications@github.com>
wrote:

> I tried that program on an older version of Mac OS and different versions
> of Racket, and it failed on every version of Racket that I tried since 6.4
> (when 'secure was added).
>
> I also tried the following program
>
> (ssl-connect "www.google.com" 443 (ssl-secure-client-context))
>
> and it succeeded in Racket 6.3 and failed since 6.4.
>
> —
> You are receiving this because you are subscribed to this thread.
> Reply to this email directly, view it on GitHub
> <https://github.com/racket/racket/issues/1606#issuecomment-276774386>, or mute
> the thread
> <https://github.com/notifications/unsubscribe-auth/AAO789H-rEvoUb03Hba847RdV0bCgxoCks5rYOzNgaJpZM4L0PIN>
> .
>

Given that `ssl-default-verify-sources` just uses the default Mac OS keychain, why would my web browsers and `curl` all accept the certificate but Racket would not?
Looks good - thanks!
Testing now, but I'm getting the segfault with the following use of `syntax-property` with definitely I think for sure uses a symbol key, so I suspect this is a different issue:
```racket
       (local-expand #`(#%plain-lambda (n)                                                                                                                                                                         
                                       (let-syntax ([var (make-rename-transformer                                                                                                                                  
                                                          (syntax-property #'n 'type #'type #t))])                                                                                                                 
                                         (cps-obj& body #,(answer-type))))                                                                                                                                         
                     'expression                                                                                                                                                                                   
                     null)          
```
If I move `/Applications/Racket v6.8/lib/libssl-1.0.0.dylib` out of the way and restart racket (so it uses `/usr/lib/libssl.dylib` instead, I think), both examples succeed.

I found a stackoverflow page that suggests that openssl < 1.0.2 has problems with cross-signed certificates (which might be part of the transition plan for Google's CA, which Sam mentioned). Why does it work with the system libssl (0.9.8zg for me)? Maybe Google sends a different (compatible) certificate for non-SNI requests.

References:
- http://stackoverflow.com/questions/34646942/ssl3-get-server-certificate-certificate-verify-failed-on-python-when-requesting
- https://github.com/certifi/python-certifi/issues/26 (see the second message)
OOHhh maybe you're right. the `'type` is probably turning into `'(Type 0)`, because I've used the name `type` as a pattern variable.
@rmculpepper Thanks for investigating. Building v1.0.2k does solve the problem for me, so I'll update the relevant package.
@rmculpepper Should this be merged?
Yup, this solves it.
`raco pkg update racket-x86_64-macosx-2` should now fix the problem.
Well, that fixes the problem for the development build. I don't immediately know the right answer for v6.8.
Thanks to the three of you for your help and immediate fix. Given that @rmculpepper’s investigation indicates that the issue is not 6.8-specific, it seems like something that might have to wait for a 6.9 or 6.8.1 to get released? I’d be alright with calling this closed, even if the timing is a little unfortunate since 6.8 was just released.
Could we just update the pkg catalog for 6.8 so that people can fix it with
an update?

On Thu, Feb 2, 2017, 1:15 AM Alexis King <notifications@github.com> wrote:

> Thanks to the three of you for your help and immediate fix. Given that
> @rmculpepper <https://github.com/rmculpepper>’s investigation indicates
> that the issue is not 6.8-specific, it seems like something that might have
> to wait for a 6.9 or 6.8.1 to get released? I’d be alright with calling
> this closed, even if the timing is a little unfortunate since 6.8 was just
> released.
>
> —
> You are receiving this because you commented.
> Reply to this email directly, view it on GitHub
> <https://github.com/racket/racket/issues/1606#issuecomment-276836434>, or mute
> the thread
> <https://github.com/notifications/unsubscribe-auth/AAO78wWt_4urKrq6B2m4vGU8VpyMcfMxks5rYS4ogaJpZM4L0PIN>
> .
>

Another small thing: would it be possible to add version numbers to the libs packages so that I can depend on a version with the updated OpenSSL lib? I’d like to ensure my application doesn’t end up with an older version and blow up at runtime.
The full fix was more complicated, because a `'car` progress frame can also mean looking inside a vector or prefab struct. I included a condensed version of your test case and added more for vectors and structs.

Updating the package catalog is usually a problem, because changing ".zo" files means that other importing ".zo"s will try to rebuild. These packages don't supply any ".zo" files, though, so it seems possible on that front.

I think other things are likely to go wrong, such as someone trying to update a write-only installation and having that not fail before, since main-distribution packages have never changed for a release before. If the problem seems significant enough, we could experiment.

The problem doesn't seem to happen on Windows (which is the other platform where we provide a built OpenSSL), but I don't know why. If that's right, then we could at least limit the experiment to the Mac OS packages.
Perhaps the right experiment is not to update the 6.8 catalog, but to
improve our "out of cycle release based on a patch" process.

FWIW, we could do that with a bugfix 6.8.1 release.
That would also allow us to fix the TR issue fixed [here](https://github.com/racket/typed-racket/commit/6334dfb9398f6ad34ac64a4dbdfa4d118ebd871b).
@rmculpepper Thank you!
I have the same problem. MacBook Pro 2015 model with newest Sierra update. Tried to install DrRacket couple of minutes ago, by dragging the entire racket folder from the dmg to the Applications folder. When I try to open DrRacket, it bounces once, and closes quickly.

Tried `open DrRacket.app` and got this error message:

`LSOpenURLsWithRole() failed with error -10810 for the file /Applications/Racket v6.8/DrRacket.app.`
  
  
Try the 32-bit version. Worked for me.    
  
  

  
  
  
  

  
  
>   
> On Feb 2, 2017 at 6:23 PM,  <Eivind Lindbråten (mailto:notifications@github.com)>  wrote:
>   
>   
>   
>
> I have the same problem. MacBook Pro 2015 model with newest Sierra update. Tried to install DrRacket couple of minutes ago, by dragging the entire racket folder from the dmg to the Applications folder. When I try to open DrRacket, it bounces once, and closes quickly.
>
>   
>
> Tried  open DrRacket.app  and got this error message:
>
>   
>
> LSOpenURLsWithRole() failed with error -10810 for the file /Applications/Racket v6.8/DrRacket.app.
>
>   
>
> —
>  You are receiving this because you commented.
>  Reply to this email directly,   view it on GitHub (https://github.com/racket/racket/issues/1470#issuecomment-277116909), or   mute the thread (https://github.com/notifications/unsubscribe-auth/AECCyeHJm6mxO7fyTtX3dNxH59rlTC39ks5rYmVdgaJpZM4KKVsX).
>
>   
>   
>     
>     
>   
>   
  
  
 
@eivindml The `LSOpenURLsWithRole()` problem looks like the kind of thing that happened before the Racket distribution image was signed, but it's signed now, and I'm not seeing that on an up-to-date Sierra installation. I guess you don't have any unusual security settings?

One thing to try, to see whether this problem is related to the old one: Drag the "DrRacket" icon out of its folder – you'll like have to command-drag to move it, instead of creating an alias – and then move it back into the "Racket v6.8" folder. Does that change the error?
@shankm Does the 64-bit variant of Racket v6.8 still fail for you? We've fixed an issue that caused a startup crash on Touch Bar Macs.
It still fails on my Touch Bar Mac. I have resorted to using the 32 bit version.
Please ignore my previous comment. the latest snapshot that needed to be opened specially when it wasn't signed wasn't working it would just crash on launch, but the new 6.8 release launches fine. Sorry for the confusion.
@mflatt Hmm. After dragging DrRacket out of the folder, and back in again, it worked! Strange stuff.

I also got it to work yesterday by doing `Show package contents` and opening the DrRacket executable inside the Contents/MacOS folder. 
@eivindml Since the ".app"-moving magic worked, then it seems the issue is path randomization. Here's one explanation: https://weblog.rogueamoeba.com/2016/06/29/sierra-and-gatekeeper-path-randomization/

But I don't understand why the OS turns on path randomization for a folder that was extracted from a signed image or why I can't get that to happen on my machine. Definitely let us know if you have an idea about what might be different between our installations.
This change makes sense to me
I'll merge it after all the CI tests pass.

On Fri, Feb 3, 2017, 2:17 PM Matthew Flatt <notifications@github.com> wrote:

> This change makes sense to me
>
> —
> You are receiving this because you authored the thread.
> Reply to this email directly, view it on GitHub
> <https://github.com/racket/racket/pull/1609#issuecomment-277256689>, or mute
> the thread
> <https://github.com/notifications/unsubscribe-auth/AAO78yFawd4kqPACQheFR0iMtUv2IzNWks5rYzcCgaJpZM4L2V2o>
> .
>

I'm running Mac OS X 10.11.6 and running into the same problem with DrRacket 6.8.  Attempting to run `sudo open /Applications/Racket v6.8/bin/drracket` similarly results in

`LSOpenURLsWithRole() failed with error -10810 for the file /Applications/Racket v6.8/bin/drracket.`

This suggests to me (if I'm understanding correctly) that Sierra GPR is not the root cause of this issue.
I had a similar problem with building the Ubuntu PPA for 32-bit platforms.

You likely need to backport the following post-6.8 commit (https://github.com/racket/typed-racket/commit/6334dfb9398f6ad34ac64a4dbdfa4d118ebd871b) for Typed Racket to fix it. That's what I did for Ubuntu.
Update: the top-level exception handler works only sometimes, and I haven't figured out what criteria determine whether it works or not.
Just wondering if there are people with Open PRs who might not be in among contacted.
FWIW, if you actually use that `fc2` (e.g., call `display`) in the `begin0`, it holds on to the value.

What I suspect is going on is that that reference to `fc2` is considered "omittable" by the optimizer, and so is optimized away.

I think one could argue that this behavior is in line with the intended behavior of weak boxes, though.
I think that the semantics of references should be pinned down in such a
way that this program reveals a bug. (I can understand if it is too much
work to fix the optimizer, and so we pass on that part.)

If the reference had been before the weak-box-value call, then I agree with
you -- it is fine for the box to either contain the value or not.

I think that the current behavior is correct but surprising. It would be good to change the  [docs about weak box](https://docs.racket-lang.org/reference/weakbox.html) to make it more clear this possibility. (And probably the docs of weak hashes and ephemerons too.)

Weak box are a little too low level constructions and the abstractions may leak. It’s possible to detect  that a reference that is apparently alive has been collected using  current-memory-use or the order of the wills and executors.

Fixing this particular example is not too difficult (I think). It’s just enough to use a flag to keep the reference in the optimizer phase, and add the code to remove most of them later in the safe-for-space phase. 

It’s more complicated if you also want to change the case where you place the last `fc2` with `(if #f (display fc2) 7)` or `(if (box? (box 0)) (display fc2) 7)`. (This kind of code is more usual than expected after expansions and inlining.) The problem is that all the references in the discarded branch must be saved, without executing the code.

And with inlining, there are more interesting examples. 

    #lang racket
    
    (define (test z)
      (define fc1 (list (random) z))
      (define wb1 (make-weak-box fc1))
      (define fc2 (lambda () (void fc1) (displayln "*") z))
      (define wb2 (make-weak-box fc2))
      (collect-garbage)
      (collect-garbage)
      (collect-garbage)
      (list (weak-box-value wb1)
            (weak-box-value wb2)
            (fc2)
            (when #f (fc2))))
    
    (test 5)
  
The call `(fc2)` is inlined, so it disappears. But if you keep a reference to `fc2` then it will be necessary to keep a reference to `fc1` too. I’m worry that this change will keep to many things alive for too long. In particular, I worry that this will keep too much memory alive during recursions in loops, but I still couldn’t write a good example for this. 

Note that this isn't just a question of the core optimizer. For example, when you have
 `(define (f #:x [x 0]) ...)`
and
 `(f #:x 1)`
then the expansion of the call doesn't include a reference to `f`; instead, it refers directly to part of the implementation that takes optional-argument values and optional-argument flags to say whether the value was provided.

We could certainly design a language where keyword-argument applications are obliged to retain a reference to the general function, but I'm suggesting that there are likely many macros that would not be consistent with liveness defined in terms of identifier reference.

Naturally, I agree with @gus-massa that `make-weak-box` is a relatively low-level operation and intentionally underspecified (i.e., defined in terms of what the GC can prove, which is intentionally underspecified). I'd put it in the same category as `eq?`; it's not as bad as operations that we prefix with `unsafe-`, but maybe those operations deserve an `underspecified-` prefix. We'd rather throw out those operations than constrain the compiler and GC to make them fully specified, but we'd also rather have them for limited use than not have them at all.

I've occasionally run into the problem of keeping a value live when working with low-level features like weak boxes, and my solutions have involved implicit claims about what the GC would be able to prove. I think it would be useful to have some `observe` primitive that always returns `(void)` but where the GC is specifically not allowed to know whether `observe` uses any part of its argument (even though it doesn't).
(add1 @mflatt)
I'm happy to defer to @mflatt and @gus-massa on these points overall, but I think that the rules about when a variable reference can be eliminated can be made clear based on how safe-for-space works. In particular, if an optimizer can prove that `e1` always evaluates to `#t`, then it is safe to eliminate the `fc2` reference in this expression:

  `(if e1 e2 fc2)`

as the safe for space rules would never hold on to fc2. Or, put another way, a GC could have happened after the evaluation of the test position and before whatever weak boxes that `e2` might check.

But that reasoning does not work for the expression in the initial issue that Dan posted. In that case, the variable reference should be holding onto `fc2`.

I see what @mflatt means about this being an issue for macros too, and hadn't considered that before. I agree that makes the issue more sticky.

I think that one thing that distinguishes Racket from other languages out there is our grounding in PL theory, and so this is one place where I'd naturally lean towards preserving the semantics, since we know what a good semantics is. But I'll get off my soap box now ;)

> On Feb 7, 2017, at 11:22 AM, Matthew Flatt <notifications@github.com> wrote:
> 
>  we prefix with unsafe-, but maybe those operations deserve an underspecified- prefix.


+1
+10
+100
. . . 


Excellent. At least `git-checkout.rkt` could confirm that the connection is still live before trying to use it
Continuing @jeapostrophe's comment: A fresh connection could be noticeably slower for servers that support reusing the connection. Instead of using a fresh connection every time, probably the best approach is to check whether the connection is closed and then reopen it.

Maybe the `conn` should be wrapped with another layer that remembers the host and port, and then a wrapper on `http-conn-sendrecv!` would check whether the connection is still open and reopen as needed each time.
Thank you for the feedback. I feel like a wrapper around the `conn` is the best compromise between performance and correctness. But I think it wouldn’t belong in `git-checkout`, but as a separate widget in `http-client`. What’s your opinion?
I agree, `http-conn-open/reuse`?
Excellent, thanks! The last time I looked at this, I never figured out how to get all the right information in the error message under the right labels, but this seems to do it.
That works.  Thanks.  And my apologies for digging around in the wrong repository.
This is ok with me, but it doesn't seem all that convenient relative to defining a specific `http-conn-sendrecv!/reuse` in modules like `net/git-checkout`.

Another idea to consider, in case you didn't consider something like it already: an `#:auto-reconnect?` argument to `http-conn-open[!]` that would case the host and SSL to be saved in the connection (even after its gets closed) and make `http-conn-send!` and derived functions automatically connect when given a closed connection.
First, thank you for your feedback, @mflatt.

> This is ok with me, but it doesn't seem all that convenient relative to defining a specific `http-conn-sendrecv!/reuse` in modules like `net/git-checkout`.

Do you think that `net/git-checkout` would be the only user of `http-conn-sendrecv!/reuse`, so it would be better to have it as internal function in `net/git-checkout`, instead of public API in `net/http-client`?

> Another idea to consider, in case you didn't consider something like it already: an `#:auto-reconnect?` argument to `http-conn-open[!]` that would case the host and SSL to be saved in the connection (even after its gets closed) and make `http-conn-send!` and derived functions automatically connect when given a closed connection.

I considered this design, yes. As far as I understand, that was @jeapostrophe’s suggestion. I didn’t pursue it yet because it’s more invasive and it’s more difficult for me to anticipate all the consequences. But let me try it now:

- [x] Add fields to `http-conn` struct:
  - `auto-reconnect?`: Whether to automatically reconnect upon `http-conn-send!` and `http-conn-recv!`.
  - `auto-reconnect-host`: The `host` argument with which to call `http-conn-open!` upon automatic reconnection.
  - `auto-reconnect-ssl?`: The `ssl?` argument with which to call `http-conn-open!` upon automatic reconnection.
- [x] Add an optional argument `#:auto-reconnect?` argument to `http-conn-open[!]`. The default is `#f`, to preserve the current behavior. If `#t`, then populate the `http-conn` with the fields above.
- [x] Define `http-conn-liveable?` to mean `(or http-conn-live? http-conn-auto-reconnect?)`.
- [x] Change the contracts of `http-conn-send!`, `http-conn-recv!` and `http-conn-sendrecv!` to require a `http-conn-liveable?` instead of a `http-conn-live?`.
- [x] Define a function `http-conn-enliven!` which receives a `http-conn-liveable?` as argument and calls `http-conn-open!` if necessary.
- [x] Change `http-conn-send!` and `http-conn-recv!` to call `http-conn-enliven!`.

How does that sound?
Thanks for getting on this @leafac

I think you should put this code in `net/http-client`.

Your plan is good, but a few comments:
- You'll need the port too.
- I suggest making a function like `http-conn-enliven!` that takes a `http-conn-liveable?` and returns a `http-conn-live?` and have `send!`, `recv!`, and so on call that.
@jeapostrophe: Thank you for your feedback. I’ll work on my proposal and get some code for you to review soon.

I don’t think I’ll need to handle `port` in any special way. Because `http-conn-open!` [saves the `port`](https://github.com/racket/racket/blob/6632beeca98de0dda9b56121ee7ebed517a3a1ba/racket/collects/net/http-client.rkt#L94) in the `http-conn`, and no other function mutates it—[including `http-conn-close!`](https://github.com/racket/racket/blob/6632beeca98de0dda9b56121ee7ebed517a3a1ba/racket/collects/net/http-client.rkt#L102-L111). Of course, I could store a redundant field (say, `auto-reconnect-port`) just for clarity. What do you think is best?

Your point about `http-conn-enliven!` is well taken, I adapted the checklist in my previous comment accordingly.
You're right. I just meant that it will need to use the saved host/port/ssl?/etc, all the arguments to open!
@jeapostrophe, @mflatt: I implemented the approach we discussed, it’s on this pull request (the original proposal is still available on https://github.com/racket/racket/compare/master...leafac:fix-git-checkout-1 for comparison). Please let me know if you like it—after your approval I’ll move on to automated tests and documentation.

With this patch, the following snippet works:

```racket
#lang racket
(require net/http-client)

(define conn (http-conn))
(http-conn-open! conn "git.leafac.com" #:ssl? 'secure #:port 443 #:auto-reconnect? #t)
(http-conn-sendrecv! conn "/")
(http-conn-live? conn) ; => #f
(http-conn-sendrecv! conn "/") ; => Works :)
```

And, more importantly, the original issue no longer happens:

```
$ ./racket -l- net/git-checkout --https git.leafac.com pollen-component.git test
Contacting git.leafac.com
Getting refs [dumb protocol]
Server does not support `shallow`
Downloading loose objects
Extracting tree to test
Cleaning up
"8668ea3dc787b1a842baf65e8e10f60e6f5cbc8b"
```

-----

As always, thank you for your time reviewing my contributions.
Good work. I left some comments. Is it possible to add a test case with a synthetic server that closes things?
@jeapostrophe: Thanks a lot for reviewing my contribution.

I’m going to try to add a test with a synthetic server that closes things now that you confirmed my solution is sound.
Excellent
I wrote documentation and automated tests. This pull request is now ready for a more careful review.
Now we seem to get
```
    Gdk-Message: Unable to load arrow from the cursor theme
GdkCursor->C: argument is not non-null 'GdkCursor' pointer
  argument: #f
  context...:
   /usr/racket/collects/ffi/unsafe.rkt:1246:12
   /usr/racket/share/pkgs/gui-lib/mred/private/wx/gtk/cursor.rkt:61:2: set-standard method in cursor-driver%
   ...ivate/syntax.rkt:234:25
   ...ivate/syntax.rkt:24:6
   /usr/racket/collects/racket/private/class-internal.rkt:3553:0: continue-make-object
   /usr/racket/collects/racket/private/class-internal.rkt:3507:0: do-make-object
   /usr/racket/share/pkgs/gui-lib/mred/private/wxme/text.rkt: [running body]
   /usr/racket/share/pkgs/gui-lib/mred/private/mred.rkt: [traversing imports]
   /usr/racket/share/pkgs/gui-lib/mred/mred.rkt: [traversing imports]
   /usr/racket/share/pkgs/gui-lib/mred/main.rkt: [traversing imports]
   /usr/racket/share/pkgs/gui-lib/racket/gui/base.rkt: [traversing imports]
   /usr/racket/share/pkgs/drracket/drracket/drracket.rkt: [traversing imports]

```

Update:
The parameter `combine?` is not designed for this kind of problem, however, for some specific writing systems on some OSes, it happen to solve the problem (but likely comes along with other problems).

More specifically,
On Windows, choosing a right font **with** `combine?`, texts will be rendered correctly;
On OpenIndiana, all fonts work well (with few exceptions) **with** `combine?`;
For macOS, it's a headache, there are two fonts for Tibetan, native applications seem to have no such problem, but Racket is no luck. This is the reason I found `combine?` might be the good solution, it just solves the problem, but ... all upper parts of "words" are rendered one char ahead. Working with the fonts that copied from Windows **without** `combine?`, the chars are stacked correctly for most cases [Tibetan chars are ofter stacked vertically, if these chars are more than 3, they might be rendered in wrong vertical place, nonetheless, this is a fundamental issue]. 
I, Paul R. Ojanen, give permission to license my contributions to Racket under MIT/Apache 2. I've used the email addresses engineer@alum.mit.edu, paul@ojanen.com, ~~projanen@indiana.edu~~.
Excellent work. Thank you!
Thank you for your review and for merging my contribution.
I, Mark E. Lee, give permission to license my contributions to Racket under MIT/Apache 2. I've used the email addresses mark@markelee.com
Mid-2015 Macbook Pro, on MacOs 10.12.2, with 64-bit DrRacket installed. I can open DrRacket through the terminal with `/Applications/Racket\ v6.8/bin/drracket`. Attempting to open through Spotlight results in "The application “DrRacket.app” can’t be opened." Navigating to the executable in Finder and clicking it results in nothing. If I watch the Faults log in the Console while trying to open DrRacket through Spotlight or the Finder, these occur: 
``` 
error	10:31:11.355843 -0800	com.apple.quicklook.ThumbnailsAgent	getattrlist returned -1 Invalid argument
error	10:31:11.356083 -0800	com.apple.quicklook.ThumbnailsAgent	SQLite[1]: <private>
error	10:31:11.358561 -0800	geodMachServiceBridge	3.1 Asked to free space for a volume we don't control.
error	10:31:11.360008 -0800	com.apple.quicklook.ThumbnailsAgent	Sqlite request <private> failed on <private> with error [<private>]
```

Installing the 32-bit version doesn't change this behavior.
I had this problem last night on my mid-2012 Macbook Pro with 10.12.2 as well. I ended up moving the DrRacket app bundle into another folder, and then moved it back, and it worked.

I could not find any errors in the Console log that seemed pertinent.
@barbeque didn't work for me :(
Hi @jsmaniac – The bug-repair commit does include a test, although it more directly tests the problem primitives instead of going through `peeking-input-port`.  Did you see that test, but would also like to have one at the `peeking-input-port` level?
@mflatt Yes, I just thought it would be good to also test it through peeking-input-port. Feel free to reject the PR if you think the lower-level test is enough, of course :) !
Ok, thanks for the clarification!
I, David Pierson, give permission to license my previous contributions to Racket under MIT/Apache 2. I've used the email address dtp@mindstory.com
I had the same issue as you did. And after a series of hard debugging, I found I had an illegal cursor setting in dconf which caused this issue and it works now.
Thanks for the report!
cool thx for fixing :+1: 
Same for me. It doesn't work
Does the last comment mean that adding these breaks `rsound` and `video`?
Adding any new function to a Racket generally breaks any packages that have an define an identifier with the same name. The `rsound` and `video` packages are the only ones (on the package server) that use those identifiers, both for this exact purpose. And honestly, it only takes changing 3 lines of code to fix the packages to make them work both with versions of racket before and after those contracts are added.
In fact, its so easy I have fixed both of them, and going to submit a PR for `rsound` momentarily.
I mean, I wouldn't be opposed to putting them in a new library, like `racket/contract/numeric` or something like that. I just put them there so they would be at the same scope as >/c </c etc.
I don't think these belong in racket/contract.

@rfindler okay, why?
I don't think they have anything to do with racket/contract so
racket/contract/X doesn't seem right either.

They go in a number related library, to me.

I mean, predicates for other datastructures go in the library where those
other data structures go, right?

Robby


On Tue, Feb 28, 2017 at 5:48 PM Leif Andersen <notifications@github.com>
wrote:

> I mean, I wouldn't be opposed to putting them in a new library, like
> racket/contract/numeric or something like that. I just put them there so
> they would be at the same scope as >/c </c etc.
>
> —
> You are receiving this because you are subscribed to this thread.
> Reply to this email directly, view it on GitHub
> <https://github.com/racket/racket/pull/1623#issuecomment-283198748>, or mute
> the thread
> <https://github.com/notifications/unsubscribe-auth/AAYWsP0W-EGRWaEskI3ypcy1QhCD9ucJks5rhLI6gaJpZM4MPB14>
> .
>

@rfindler So, on the one hand I agree with you, it feels kind of odd to have them in `racket/contract`. On the other hand though, we have `</c`, `>/c`, `<=/c`, `>=/c`, `between/c`, etc. already in `racket/contract`, so it makes sense to have them there for consistency.
A math-related contracts library could reprovide those combinators, with the eventual goal of removing them from `racket/contract`.
I mean, we 'could' add them to `racket/base` somewhere, like their `exact-*` counterparts, and that would probably break no code. I just didn't do that because currently the `exact-*` counterparts are implemented in C.
@jackfirth In principle I agree. Although I'm usually weary of removing exports from libraries.
If you write a new list predicate, should it go in racket/contract? If you write a new function predicate that works with arities, does it go in racket/contract? If you write a new predicate on classes, does it go in racket/contract? No to all of those, in my opinion. The contract library has a few convenient combinators for primitive things like numbers, but that's different than putting in random predicates for every possible base value we might have in some other library. They can define the predicate themselves and those predicate will work fine with the racket/contract library. 

Think of it this way: if you were looking for functions related to numbers, why would you look in the contract library?
> a new list predicate

Depends on the predicate. We already have list/c and listof and list*of etc. So it might make sense to have others in there, such as list-assoc/c or something like that. So that analogy fails.

> new function predicate that works with arities

No, there are neither contracts combinations for functions nor flat contracts dealing with functions (that are documented) in racket/contract. So it would be silly to put a predicate there.

On the other hand,, the contract library already *does* have both contract combinators that handles numbers, as well as direct flat contracts for numbers, such as natural/c. So it is not surprising to have flat contracts for those cases as well. (Although maybe it would make sense to change the name to positive-integer/c instead, which the more I think about it, the more I think that is the correct choice here, so I'm going to make a commit changing those names).

> a new predicate on classes

No, of course not. Contracts for the class library are in `racket/class`, so from a design perspective, it would make sense to put predicates for classes there.  From an implementation perspective I think the class library relies on the contract one, so we couldn't do that even if we wanted to.

> Think of it this way: if you were looking for functions related to numbers, why would you look in the contract library?

I'm not looking for functions related to numbers, I'm looking for *contracts* related to numbers. I want this because I have several libraries that have contracts for all of the functions that require nonnegative integers, both exact and inexact. So much so that it makes sense to have them in a common library. And given that I'm not the only person who has run into this, and it seems to be a common contract pattern, it makes sense to put it in the contract library, as the contract library clearly handles number related contracts, both conbinators and flat contracts.
Okay. Switching the names to *-integer/c seems to fit a lot better now, both in terms of the rest of the `racket/contract` api, as @rfindler pointed out. Also, it does not break any of the projects which gets rid of the concern @samth had.
Thank you for your interest in racket and contributions to it. I remain unconvinced about this particular change, however, so I will close this PR now.

I will note that I find both your arguments for why it belongs unconvincing and I also find your arguments why it could not go elsewhere unconvincing. (I didn't talk about them much, because that's not what this PR is doing, however.)
So then, explain to me why natural-number/c belongs in racket/contract but positive-integer/c does not?
I wrote before you asked (I'm not sure why you didn't get it) that natural-number/c was a mistake. 
Ah, okay. Yes, that appears to have gotten lost...yay github and their crappy interface. :(

So, @rfindler , if your argument is that natural-number/c was a mistake and is really on there because of backwards compatibility, than I agree we should not add these contracts here, but somewhere else. (Probably in either base or math....but that's for a different PR.)

Anyway, thanks.
Thank you.

(I do wish we had a `natural?` or maybe even `nat?` predicate.)
> On the package server, both the rsound and video packages use these predicates. But only a one  line change is required to fix that.

The problem is, `rsound` imports `racket/math` and defines a function with the same name (and behavior) as one of the new functions in this PR.
Yup, exactly. The easiest fix is to just delete the functions and keep around the older version of rsound for older Racket version. Alternatively just don't require the identifiers from racket/math or "common.rkt"
Any chance I could get you interested enough to add `natural?` as an alias for `exact-nonnegative-integer?` 

Or do you think that's a bad idea?
I'd be 100% down for that. I'll add that when I get home tonight unless anyone wants to complain?
Should `positive-real?`, `negative-real?`, `nonpositive-real?`, and `nonnegative-real?` be added as well?
@AlexKnauth Meh. I'm not passionate one way or the other. Can you give me your motivation for adding them?
Maybe one way to make this decision is to audit the contracts that are
currently being used? I believe that (and/c real? positive?) is relatively
common in various functions in our libraries.

Robby

Maybe one way to make this decision is to audit the contracts that are currently being used? I believe that (and/c real? positive?) is relatively common in various functions in our libraries.
Do we need nonnegative? and nonpositive? as normal (non-contract)
predicates?

/Jens Axel


2017-03-02 4:03 GMT+01:00 Robby Findler <notifications@github.com>:

> Maybe one way to make this decision is to audit the contracts that are
> currently being used? I believe that (and/c real? positive?) is relatively
> common in various functions in our libraries.
>
> —
> You are receiving this because you are subscribed to this thread.
> Reply to this email directly, view it on GitHub
> <https://github.com/racket/racket/pull/1624#issuecomment-283542413>, or mute
> the thread
> <https://github.com/notifications/unsubscribe-auth/AAcLxTTzx8jT_35dGmsd_RCTovyK6mXqks5rhjGWgaJpZM4MQDW8>
> .
>



-- 
-- 
Jens Axel Søgaard

@rfindler Oh geez, I didn't realize `positive?` expected a real?. Then yes, I absolutely agree with @AlexKnauth's suggestion.
@soegaard, For me no, but I think rsound actually uses it for a few things. But basically for domains where 0 is valid.
Actually @AlexKnauth , the more I think about it, the more I wonder why something like: (</c 0) and friends don't work here for you? I mean, it's both more typing than `(</c 0)`. But I still don't feel strongly one way or the other.
So, @rfindler It looks like defining `natural?` causes issues with redex because its already defined in htdp/error. For example:

```
raco setup: error: during building docs for <pkgs>/redex-doc/redex/redex.scrbl
raco setup:   /Users/leif/rsrc/htdp/htdp-lib/2htdp/private/image-more.rkt:12:9: module: identifier already imported from: htdp/error
raco setup:     at: natural?
raco setup:     in: racket/math
raco setup:     location...:
raco setup:      /Users/leif/rsrc/htdp/htdp-lib/2htdp/private/image-more.rkt:12:9
raco setup:      /Users/leif/rsrc/htdp/htdp-lib/2htdp/private/image-more.rkt:11:9
raco setup:     context...:
raco setup:      standard-module-name-resolver
raco setup:      [repeats 1 more time]
raco setup:      /Users/leif/racket/racket/collects/racket/require-transform.rkt:266:2: expand-import
raco setup:      /Users/leif/racket/racket/collects/racket/private/reqprov.rkt:505:5
raco setup:      /Users/leif/racket/racket/collects/racket/require-transform.rkt:266:2: expand-import
raco setup:      /Users/leif/racket/racket/collects/racket/private/reqprov.rkt:266:21: try-next
raco setup:      /Users/leif/racket/racket/collects/racket/private/reqprov.rkt:348:21: try-next
raco setup:      /Users/leif/racket/racket/collects/racket/private/reqprov.rkt:243:2
raco setup:      /Users/leif/racket/racket/collects/syntax/wrap-modbeg.rkt:46:4
raco setup:      standard-module-name-resolver
raco setup:      /Users/leif/rsrc/redex/redex-doc/redex/scribblings/ref.scrbl: [traversing imports]
raco setup:      /Users/leif/rsrc/redex/redex-doc/redex/redex.scrbl: [traversing imports]
raco setup:      /Users/leif/racket/pkgs/racket-index/setup/scribble.rkt:901:0: load-doc/ensure-prefix
raco setup:      /Users/leif/racket/pkgs/racket-index/setup/scribble.rkt:1431:3
raco setup:      .../parallel-do.rkt:390:17
raco setup:      /Users/leif/racket/racket/collects/setup/../racket/private/more-scheme.rkt:261:28
raco setup:      ...
raco setup:
```
Change `htdp/error` to re-export `racket/math`s `natural?` predicate.
I'd be down for that, but then we have to allow inexact numbers too.

Because the current definition for `natural?` in htdp/error is:

```
(define (natural? w)
  (and (number? w) (integer? w) (>= w 0)))
```
I sent email, but that appears to be a bug. Eg:

```
#lang racket
(require htdp/matrix)
(make-matrix 2.0 1 '(1 2))
```

produces:

```
Welcome to DrRacket, version 6.8.0.2--2017-02-23(481dc9b0/d) [3m].
Language: racket, with debugging [custom]; memory limit: 256 MB.
. . make-vector: contract violation
  expected: exact-nonnegative-integer?
  given: 2.0
  argument position: 1st
  other arguments...:
> 
```
This doesn't seem to break `htdp/itunes`, tho.

It also makes the docs in `beginner-funs.rkt` wrong, too, since list-ref needs an exact.
Interesting. Well we should ask @mfelleisen what his intention is there. But on the surface that does seem inconsistent to me. :/
Oh, I just saw your email. Okay, thanks.
 
@rfindler This is a bug in htdp/error. Please fix. 


> On Mar 2, 2017, at 5:23 PM, Robby Findler <notifications@github.com> wrote:
> 
> I sent email, but that appears to be a bug. Eg:
> 
> #lang racket
> (require htdp/matrix)
> (make-matrix 2.0 1 '(1 2))
> produces:
> 
> Welcome to DrRacket, version 6.8.0.2--2017-02-23(481dc9b0/d) [3m].
> Language: racket, with debugging [custom]; memory limit: 256 MB.
> . . make-vector: contract violation
>   expected: exact-nonnegative-integer?
>   given: 2.0
>   argument position: 1st
>   other arguments...:
> > 
> —
> You are receiving this because you are subscribed to this thread.
> Reply to this email directly, view it on GitHub <https://github.com/racket/racket/pull/1624#issuecomment-283815476>, or mute the thread <https://github.com/notifications/unsubscribe-auth/ABf5-zcyhc1RBJ95QMJgB4k2yQJ-S6BTks5rh09ygaJpZM4MQDW8>.
> 


Cool, works for me. Thanks.
Okay, I have a PR to the htdp repo now too:

https://github.com/racket/htdp/pull/29

I will merge both of these when I get the ok.
Alright, since MF merged the other PR, I'm going to merge this one.
I think this needs a `@history` note and a version increment, so that `htdp-lib` can depend on the correct version.
Same problem here. Racket works, but the GUI won't open. I tried

```bash
$ cd /Applications/Racket v6.8/bin
$ ./drracket
```

but that exits with error code 1 and the following output:

```
add-protocol: NULL protocol
  context...:
   /Applications/Racket v6.8/collects/ffi/unsafe/objc.rkt:699:0: add-protocol
   /Users/hunan/Library/Racket/6.8/pkgs/gui-lib/mred/private/wx/cocoa/queue.rkt: [running body]
   /Users/hunan/Library/Racket/6.8/pkgs/gui-lib/mred/private/wx/cocoa/init.rkt: [traversing imports]
   /Users/hunan/Library/Racket/6.8/pkgs/gui-lib/mred/private/wx/cocoa/platform.rkt: [traversing imports]
   /Users/hunan/Library/Racket/6.8/pkgs/gui-lib/mred/private/wx/platform.rkt: [running body]
   /Users/hunan/Library/Racket/6.8/pkgs/gui-lib/mred/private/kernel.rkt: [traversing imports]
   /Users/hunan/Library/Racket/6.8/pkgs/gui-lib/mred/private/mred.rkt: [traversing imports]
   /Users/hunan/Library/Racket/6.8/pkgs/gui-lib/mred/mred.rkt: [traversing imports]
   /Users/hunan/Library/Racket/6.8/pkgs/gui-lib/mred/main.rkt: [traversing imports]
   /Users/hunan/Library/Racket/6.8/pkgs/gui-lib/racket/gui/base.rkt: [traversing imports]
   /Users/hunan/Library/Racket/6.8/pkgs/drracket/drracket/drracket.rkt: [traversing imports]
```

If it wasn't for the parenthesis highlighting, I'd probably not care about this.
EDIT 2: error messages changed again, the ones here are not representative.

EDIT: updated the picture ~~& error messages~~ based on Robby's comment.

Here's a sample error message:
```
> (random -1 (expt 2 40))
; random: contract violation
;   expected: (integer-in 0 4294967086)
;   given: 1099511627776
```

Here's another error message:
```
> (random 1 "three")
; random: contract violation
;   expected: (or/c exact-integer? pseudo-random-generator?)
;   given: "three"
```

Here's a picture of the docs:
![screen shot 2017-03-03 at 22 16 18](https://cloud.githubusercontent.com/assets/1731829/23575659/9fd9710a-005e-11e7-994c-af604c44c0aa.png)


Just refer to the variable: (<=/c (- bignumber min)) is Max's contract.

I would not refer to the variables like that in the error tho. "Fist and
second argument" is better there.

Robby

On Fri, Mar 3, 2017 at 7:52 PM Benjamin Greenman <notifications@github.com>
wrote:

> Here's a sample error message:
>
> > (random -1 (expt 2 40))
> ; random: (- max min) difference is not an (integer-in 1 4294967087)
> ;   min: -1
> ;   max: 1099511627776
> ; [,bt for context]
>
> Here's another error message:
>
> > (random 1 "three")
> ; random: contract violation
> ;   expected: (or/c exact-integer? pseudo-random-generator?)
> ;   given: "three"
>
> Here's a picture of the docs:
> [image: screen shot 2017-03-03 at 20 47 07]
> <https://cloud.githubusercontent.com/assets/1731829/23574929/e1b1d1e6-0052-11e7-9707-5779ad1c8731.png>
>
> I wasn't sure what to do about the contract. I want the requirement on (-
> max min) to be in contract (rather than just the text) but didn't want to
> make an ->i contract.
>
> —
> You are receiving this because you are subscribed to this thread.
> Reply to this email directly, view it on GitHub
> <https://github.com/racket/racket/pull/1626#issuecomment-284117121>, or mute
> the thread
> <https://github.com/notifications/unsubscribe-auth/AAYWsAdPBYCKdNdFzdXOiBrO1-gj80W7ks5riMO_gaJpZM4MS7kT>
> .
>

[openssl.txt](https://github.com/racket/racket/files/818697/openssl.txt)

This patch, along with installing libssl1.1, seems to fix the problem for me.

I agree that a less hardcoded approach would be nice; normally on Debian these kinds of questions are resolved at link time, but of course that doesn't work for dlopened libraries. 
Using dlopen isn't such a hard obstacle:
If you did run a ./configure script or equivalent, say while building a Racket .deb package (in Debian/Ubuntu PPAs), you could probably run pkgconfig and/or readlink to figure out the right version of dependencies. Part of the trick is that while building packages you can more reasonably depend on development packages.
The harder part is to figure out how to deal with non-.deb-based installs.

Meanwhile, Racket Debian packages could have a soft dependency on libssl-dev (probably recommends and not suggests). That *is* still a hack, but a more robust one on most fronts (except disk usage). And maybe dev. packages on a server increase security risks?
And after I figure out the right version, then what? racket still needs to be patched to load it.
I'm not very happy about the idea of recommending libssl-dev; this means when there's an SONAME bump, a new version will be brought in that hasn't been tested with racket. We already say that the bump to 1.1 required patching racket (not just the library loading, but changing the API used).
You're right, I ignored API changes as I wasn't aware of them. Those certainly need be handled by hand, as for other clients. I was just answering to:
> I agree that a less hardcoded approach would be nice; normally on Debian these kinds of questions are resolved at link time, but of course that doesn't work for dlopened libraries.

And there you didn't refer to API changes, did you?

IIUC, that means C code links against `-lssl` with `libssl-dev` installed, producing a binary linking against `libssl.so.N`. My idea was to emulate the same result by learning `N` and patching Racket code à-la configure. Say, for version `$SSL_VERSION`, have in the `.deb` package build script something like:

```
sed -i "s/@@SSL_LIBRARY_VERSION@@/$SSL_VERSION/" .../$PathToRacket/collects/openssl/libversion.rkt
```

That's equivalent to what's done usually at link time, and avoids the hardcoded version table: https://github.com/racket/racket/blob/1cbd75436b3a10090e7ff9094e64caef4876305f/racket/collects/openssl/libcrypto.rkt#L12-L53.

Again, nothing saves you with API updates such as the one for 1.1 (found it in b0c55b73945d8dab52f8ff86df69dd6cbb0147b4). But that's no argument for the status quo.

> I'm not very happy about the idea of recommending libssl-dev; this means when there's an SONAME bump, a new version will be brought in that hasn't been tested with racket.

I agree that would be a consequence. It's not obvious to me that's worse.

By that argument, maybe Racket should stop ever loading `libssl.so`. But I'm proposing to change the default. What's the danger though? This depends on OpenSSL compatibility policies:
- If used symbols are removed, failing when loading the library seems no different. If symbols are loaded lazily, code might fail later which would be more annoying.
- If used symbols change behavior arbitrarily, the worst case is that previously correct API usage misbehaves (detectable by testing) or becomes vulnerable (not detectable by testing). That would be actually bad, and (EDIT) _would_ warrant never loading `libssl.so`.
LGTM. Robby, you click the button, is that right?
"Paolo G. Giarrusso" <notifications@github.com> writes:

>
>> I'm not very happy about the idea of recommending libssl-dev; this means when there's an SONAME bump, a new version will be brought in that hasn't been tested with racket.
>
> I agree that would be a consequence. It's not obvious to me that's worse.
>
> By that argument, maybe Racket should stop ever loading `libssl.so`.

From my point of view as a distro packager, loading libssl.so is indeed
a bad idea.




Two requests:

- please call `raise-arguments-error` with all supplied arguments when any of them are wrong.

- please squash the commits.

@bennn can you push? If so, please go ahead after that.
@mflatt @gus-massa would it be ok to replace calls to `enforce-random-int-range` with calls to the new function with the offset? (By passing 0 as the second argument, or changing `enforce-random-int-range/offset` to make the second argument optional.) I'm worried because inlining.

Also I just noticed this PR doesn't check `exact-integer?` enough, fixing now.
Nevermind about inlining, the function's only called once so I'm just going to make the change (call `enforce.../offset` instead)

~~@robby~~ yep I'll use `raise-arguments-error`. ~~Will plan to push late tonight, unless anything else comes up.~~
EDIT: nevermind about pushing tonight, I want to wait until tomorrow night at least
@rfindler do you also want the `rand-gen` argument in the error message? Or is the idea: "show all values involved in the check that led to the error message"
Show all argument supplied to the function that was actually called (in the error message) is the right generalization. That is, if I call `(random 0)` I should see one value and if I call `(random 0 (current-pseudo-random-generator))` I should see two.

Of course, sometimes this is too much of a pain to be worth it. In that case, call `raise-argument-error`.
Made all the error messages use `raise-arguments-error` _except_ when given 2 arguments and the second is neither an `exact-integer?` or a PRNG. Because in that case, I didn't know what name to give the arguments.

Here's some example error messages. Suggestions?
```
> (define rng (current-pseudo-random-generator))

> (random "1")
; random: contract violation
;   expected: (or/c (integer-in 1 4294967087) pseudo-random-generator?)
;   given: "1"

> (random -1)
; random: contract violation
;   expected: (or/c (integer-in 1 4294967087) pseudo-random-generator?)
;   given: -1

> (random (add1 4294967087))
; random: contract violation
;   expected: (or/c (integer-in 1 4294967087) pseudo-random-generator?)
;   given: 4294967088

> (random "1" 2)
; random: first argument is not exact-integer?
;   min: "1"
;   max: 2

> (random "1" "2")
; random: contract violation
;   expected: exact-integer?
;   given: "1"

> (random 1 "2")
; random: contract violation
;   expected: (or/c exact-integer? pseudo-random-generator?)
;   given: "2"

> (random -1 "2")
; random: contract violation
;   expected: (or/c exact-integer? pseudo-random-generator?)
;   given: "2"

> (random 2 1)
; random: second argument is not greater than first argument
;   min: 2
;   max: 1

> (random -1 -2)
; random: second argument is not greater than first argument
;   min: -1
;   max: -2

> (random 0 (add1 4294967087))
; random: difference between first and second arguments is greater than
;   4294967087
;   min: 0
;   max: 4294967088

> (random "1" rng)
; random: first argument must be (integer-in 1 4294967087)
;   k: "1"
;   rand-gen: #<pseudo-random-generator>

> (random -1 rng)
; random: first argument must be (integer-in 1 4294967087)
;   k: -1
;   rand-gen: #<pseudo-random-generator>

> (random (add1 4294967087) rng)
; random: first argument must be (integer-in 1 4294967087)
;   k: 4294967088
;   rand-gen: #<pseudo-random-generator>

> (random "1" 2 rng)
; random: first argument is not exact-integer?
;   min: "1"
;   max: 2
;   rand-gen: #<pseudo-random-generator>

> (random "1" "2" rng)
; random: first argument is not exact-integer?
;   min: "1"
;   max: "2"
;   rand-gen: #<pseudo-random-generator>

> (random 1 "2" rng)
; random: second argument is not exact-integer?
;   min: 1
;   max: "2"
;   rand-gen: #<pseudo-random-generator>

> (random -1 "2" rng)
; random: second argument is not exact-integer?
;   min: -1
;   max: "2"
;   rand-gen: #<pseudo-random-generator>

> (random (add1 4294967087) "2" rng)
; random: second argument is not exact-integer?
;   min: 4294967088
;   max: "2"
;   rand-gen: #<pseudo-random-generator>

> (random 2 1 rng)
; random: second argument is not greater than first argument
;   min: 2
;   max: 1
;   rand-gen: #<pseudo-random-generator>

> (random -1 -2 rng)
; random: second argument is not greater than first argument
;   min: -1
;   max: -2
;   rand-gen: #<pseudo-random-generator>

> (random 0 (add1 4294967087) rng)
; random: difference between first and second arguments is greater than
;   4294967087
;   min: 0
;   max: 4294967088
;   rand-gen: #<pseudo-random-generator>
```

(cc @rfindler @jbclements @danprager )
This is looking good.

Strictly speaking, is the maximum range constant a property of the particular random-number generator employed?
Yep, see section 1.1 here: https://www.iro.umontreal.ca/~lecuyer/myftp/papers/streams00.pdf
Thanks. I see now that the class of rng's is fixed (L’Ecuyer), so the constant is ok.

[I was imagining that it might be possible to plug in other rng algorithms.]
Thanks

Sent from my iPhone

> On 27 Feb 2017, at 12:54, Liu Yuhui <notifications@github.com> wrote:
> 
> I had the same issue as you did. And after a series of hard debugging, I found I had an illegal cursor setting in dconf which caused this issue and it works now.
> 
> —
> You are receiving this because you commented.
> Reply to this email directly, view it on GitHub, or mute the thread.
> 

@bennn I feel stupid; I wrote `raise-arguments-error` but what I meant was `raise-argument-error` where you use the second alternative (with `bad-pos` and all of the arguments supplied). 

What you've done is certainly better! But in the case you found problematic, you could just take the `bad-pos` approach.
Ok, I updated some errors* to use `bad-pos`. (I didn't realize that version of `raise-argument-error` existed!)
"LGTM"

(* Some errors = the errors where it was awkward to name arguments)

```
(random "1" "1")
;; ==> 
;; random: contract violation
;;   expected: exact-integer?
;;   given: "1"
;;   argument position: 1st
;;   other arguments...:
;;    "1"
```

Here's a few more examples in the toplevel:
```
> (random "1" 1)
; random: contract violation
;   expected: exact-integer?
;   given: "1"
;   argument position: 1st

> (random 1 "1")
; random: contract violation
;   expected: (or/c exact-integer? pseudo-random-generator?)
;   given: "1"
;   argument position: 2nd

> (random 3 2)
; random: contract violation
;   expected: (>/c 3)
;   given: 2
;   argument position: 2nd

> (random 3 2 (current-pseudo-random-generator))
; random: contract violation
;   expected: (>/c 3)
;   given: 2
;   argument position: 2nd

> (random 1 2 "rng")
; random: contract violation
;   expected: pseudo-random-generator?
;   given: "rng"
;   argument position: 3rd
```
ping @hashimmm  @AlexKnauth , okay if I merge this tonight?
This looks much clearer
Are you passing all the arguments? I would have expected them to all show up in the error message, not just the first one.
Yes, I'm passing all the arguments in every error message. But they don't all appear when I run examples in the toplevel.

Example: `(random "1" "1")` (error raised on [L135](https://github.com/racket/racket/pull/1626/files#diff-13eaec578e818e85ad4749dc69a4dd57R135) of `pre-base.rkt`)
in the toplevel:
```
; random: contract violation
;   expected: exact-integer?
;   given: "1"
;   argument position: 1st
```

when I save to a file and run `racket file.rkt`
```
random: contract violation
  expected: exact-integer?
  given: "1"
  argument position: 1st
  other arguments...:
   "1"
  context...:
   /Users/ben/code/racket/fork/racket/collects/racket/private/pre-base.rkt:104:12: random
   /Users/ben/code/racket/plan-b/model/file.rkt: [running body]
```
Disable your repl customizations and see if they come back. This sounds
like a bug or a poor design decision (imo).

Robby

On Mon, Mar 6, 2017 at 2:18 PM Benjamin Greenman <notifications@github.com>
wrote:

> Yes, I'm passing all the arguments in every error message. But they don't
> all appear when I run examples in the toplevel.
>
> Example: (random "1" "1") (error raised on L135
> <https://github.com/racket/racket/pull/1626/files#diff-13eaec578e818e85ad4749dc69a4dd57R135>
> of pre-base.rkt)
> in the toplevel:
>
> ; random: contract violation
> ;   expected: exact-integer?
> ;   given: "1"
> ;   argument position: 1st
>
> when I save to a file and run racket file.rkt
>
> random: contract violation
>   expected: exact-integer?
>   given: "1"
>   argument position: 1st
>   other arguments...:
>    "1"
>   context...:
>    /Users/ben/code/racket/fork/racket/collects/racket/private/pre-base.rkt:104:12: random
>    /Users/ben/code/racket/plan-b/model/file.rkt: [running body]
>
> —
> You are receiving this because you were mentioned.
>
>
> Reply to this email directly, view it on GitHub
> <https://github.com/racket/racket/pull/1626#issuecomment-284519108>, or mute
> the thread
> <https://github.com/notifications/unsubscribe-auth/AAYWsBOo8zR048J0v2NtfIa9ry2RCyyeks5rjGoCgaJpZM4MS7kT>
> .
>

With xrepl (now on by default in REPL mode), you have to use `,bt` to see any message field that end "...". The output only says "[,bt for context]", though.
(Guess I shouldn't have deleted those `[,bt for context]` lines from my examples)
I guess the casual user will not realize that more information is available to them. And we almost certainly won't get that very useful information in our bug reports.

Can we do something slightly differently? Maybe could we have the lines with the ellipses show up and say ",bt for more information, including the elided parts of the message" or something like that?
Do you think I should change uses of `raise-argument-error` to be `raise-arguments-error .... "first-arg" x "second-arg" y)` etc.? I would rather keep the current messages.

fwiw, DrRacket also doesn't show the context. I need to click the red "triple X" to see what the "other arguments" are.
On Mon, Mar 6, 2017 at 5:22 PM, Benjamin Greenman <notifications@github.com>
wrote:

> Do you think I should change uses of raise-argument-error to be raise-arguments-error
> .... "first-arg" x "second-arg" y) etc.? I would rather keep the current
> messages.
>

I like what you currently have and think you've done a great service and it
is time to stop belaboring this! Please push away.


> fwiw, DrRacket also doesn't show the context. I need to click the red
> "triple X" to see what the "other arguments" are.
>
>
Believe it or not, I knew that. :)

Robby

#1582 
Excellent idea. Would you like to submit a PR?
When I get time :) I have to go through some internal bureaucracy for PRs to ensure I own the copyright instead of my employer. Makes it difficult to find the time for simple one-off changes like this.
Wow.
Would you be ok with someone submitting a PR for this on your behalf?
Can you move this issue to the r5rs repo?
https://github.com/racket/r5rs

It is what it is. Go right ahead!
The patch in f52464b makes a slightly different change to `check-unpack-path` to the one proposed above, but has the benefit of not being wrong :-)

Could I get a review from one or two of those on the thread, please? Thanks!
@tonyg small request. Please change the if to a cold and flatten out the let. 
@mfelleisen The final proposed implementation of `check-unpack-path` is quite different to the sketch above:

```racket
(define (check-unpack-path who filename
                           #:allow-up? [allow-up? #f]
                           #:relative-dir [relative-dir "."])
  (when (absolute-path? filename)
    (error who "won't extract a file with an absolute path\n  path: ~e" filename))
  (unless allow-up?
    (for ([e (in-list (explode-path (simplify-path (build-path relative-dir filename) #f)))])
      (when (eq? e 'up)
        (error who "won't extract a file with an up-directory element\n  path: ~e" filename)))))
```

In addition to this change, patch f52464b includes a change to `extract-tree` and its caller to track `relative-dir`, plus an updated test.
cc #1622 

previews:
![screen shot 2017-03-11 at 13 35 24](https://cloud.githubusercontent.com/assets/1731829/23825854/f7f0f28a-065f-11e7-96f1-bd79e8b8c1d3.png)
![screen shot 2017-03-11 at 13 35 44](https://cloud.githubusercontent.com/assets/1731829/23825853/f7ea1974-065f-11e7-84a5-3cbc575edeba.png)

I think we usually put the "see also"s into the description, not in the
sidebars.

Robby


On Sat, Mar 11, 2017 at 12:38 PM, Benjamin Greenman <
notifications@github.com> wrote:

> cc #1622 <https://github.com/racket/racket/issues/1622>
>
> previews:
> [image: screen shot 2017-03-11 at 13 35 24]
> <https://cloud.githubusercontent.com/assets/1731829/23825854/f7f0f28a-065f-11e7-96f1-bd79e8b8c1d3.png>
> [image: screen shot 2017-03-11 at 13 35 44]
> <https://cloud.githubusercontent.com/assets/1731829/23825853/f7ea1974-065f-11e7-84a5-3cbc575edeba.png>
>
> —
> You are receiving this because you are subscribed to this thread.
> Reply to this email directly, view it on GitHub
> <https://github.com/racket/racket/pull/1632#issuecomment-285890636>, or mute
> the thread
> <https://github.com/notifications/unsubscribe-auth/AAYWsN3FToSVz4h1d0hceD-O6ANlfhCFks5rkuobgaJpZM4MaSm9>
> .
>

New commit, new previews:

![screen shot 2017-03-11 at 14 00 28](https://cloud.githubusercontent.com/assets/1731829/23826038/0b996e4a-0663-11e7-98f2-f63ea1d50f52.png)
![screen shot 2017-03-11 at 14 04 16](https://cloud.githubusercontent.com/assets/1731829/23826039/0b99b378-0663-11e7-980a-cc8f6bddaf04.png)

One more, in standard "see also" style.

![screen shot 2017-03-11 at 14 10 16](https://cloud.githubusercontent.com/assets/1731829/23826145/fa0c44a8-0663-11e7-95b1-6d478b55469a.png)
![screen shot 2017-03-11 at 14 10 27](https://cloud.githubusercontent.com/assets/1731829/23826146/fa0cabf0-0663-11e7-9421-e5c71438ca83.png)

@rfindler ping, do you like the most recent revision?
Yes

On Sun, Mar 12, 2017 at 9:21 PM Benjamin Greenman <notifications@github.com>
wrote:

> @rfindler <https://github.com/rfindler> ping, do you like the most recent
> revision?
>
> —
> You are receiving this because you were mentioned.
>
>
> Reply to this email directly, view it on GitHub
> <https://github.com/racket/racket/pull/1632#issuecomment-286000598>, or mute
> the thread
> <https://github.com/notifications/unsubscribe-auth/AAYWsMh4RqrcmE1ANRRKaAJvBJLtjWClks5rlKgqgaJpZM4MaSm9>
> .
>

https://github.com/racket/racket/commit/10aaff692b55877952ece746b1fb2c05ef9c97dd
I think these might be nicer as optional keyword arguments to the existing functions. What do you think?
Yeah, that makes sense too. I'll update.
Switched to optional keyword arguments (rebase)
Looks good. Can you squash?
Squashed.
Looks good once CI finishes.
The error in Travis for the one test doesn't really make sense to me, either: https://travis-ci.org/racket/racket/jobs/191791547#L1648-L1671
All the Travis jobs have terminated with "The job exceeded the maximum time limit for jobs, and has been terminated."
Ah, that's because of the web server test issue, but this is ok anyway.
It looks like Alpine uses musl, which doesn't provide getcontext(). I can add a configuration test to avoid using libunwind if getcontext() isn't present. I don't think there's a way to disable the use of libunwind through a command-line flag, but commenting out `# define MZ_USE_DWARF_LIBUNWIND` in "sconfig.h" allows the build to proceed.

It doesn't get much farther, though, because Racket doesn't run with the JIT enabled, possibly due to restrictions on executable pages. Disabling the JIT proceeds further, but then runs into another problem – likely related to the implementation for floating-point predicates like `isinf()`.

So, there's not a simple fix here, and we'll need to investigate more to make repairs.
I've run into this before for the same reason: attempting to build a minimal Alpine-Linux-based Docker image for Racket. Would it be worth having an issue open exclusively for getting Racket to compile with musl?
Just a note that a new Racketeer was confused by this issue today.
@mflatt I appreciate the closer look and detailed report.

@jackfirth I think you are asking the Racket member community about making an explicit "Racket-with-musl" issue. I'm not a member contributor, just a Racket newb, but I think an explicit issue makes a lot of sense. (And if that is done then this issue could be closed with a reference to that new "Racket-with-musl" issue.)

I do think it would be useful to have Racket available on Alpine, and that musl support would be worth doing.

The reference -> guide pointers are at the top, but guide -> reference pointers are normally at the bottom. That choice was on purpose, but it's not clearly the right choice.
@JeNeSuisPasDave: The path from newb to contributor is shorter than you think. :)
Some of the Travis builds are failing because they're having trouble connecting to `www.unicode.org`.
This looks like a fine change to me (and just needs docs and tests to merge).
LGTM

(Edit) On second thought, this might not be a good change, because it means "x.tar" will become "x_tar.gz" instead of "x.tar.gz".
Merged after adding a repair for `raco` without arguments. Thanks!
This only modifies undocumented internal macros, so what would I do for docs?

I'll add some tests.
> what would I do for docs?

Perhaps a better question would be, there's a few examples now that use forms from `private/generic-methods`. Would some of those forms be worth moving to `racket/generic` and documenting them?
I agree with @stchang. I didn't catch that a private module is being used, so maybe it's ok to just have tests for now, but it sounds like something needs to be made public and documented.
I don't think this is the right repair, because docs rendered to user use space should point to the installation's license and acknowledgements.

Something is wrong with the installers (both release and snapshots) where full paths end up in "license/index.html" and "acknowledgements/index.html". I'm looking into that problem.
Closed by 8da0be8031ce4abff8867b83f375aafaaa88cd54 (and I meant to write this issue's number in the commit message).

Thanks for the report!
Should it be made public in a separate pull request?
Yes, a separate PR sounds good
So should this one be merged?
Yes
Right. (I should have said that in a comment.)

What about adding an optional byte string argument to `path-add-extension` to  replace `_`?
That addition sounds ok to me.
- changed `path-add-extension`to accept an optional 3rd argument
- `gzip` uses the 3rd argument, so zipping `x.tar` gives `x.tar.gz`
- added `@history` annotations for both changes

Docs building now, will post screenshots when they're finished
Is `6.8.0.2` the right version to cite?

![screen shot 2017-03-25 at 20 31 58](https://cloud.githubusercontent.com/assets/1731829/24327232/d3ed3264-1199-11e7-8859-e198fdde9581.png)
![screen shot 2017-03-25 at 20 34 11](https://cloud.githubusercontent.com/assets/1731829/24327233/d3f78d04-1199-11e7-9f1c-1664cfcc3988.png)

This looks ready to push to me.
Thanks for looking it over; merged via https://github.com/racket/racket/commit/2cbd44d64d815faeb939421cf448fbe2ae7635d0 and https://github.com/racket/racket/commit/30aa951db886dd4e6ac4d1630a0d2e42d035085b
It looks like you may have a minimal Racket installation. If so, try installing the `cext-lib` package with

 `raco pkg install cext-lib`

(maybe with `-i` before `cext-lib`), and then `raco ctool` should work.

I'll update the docs to mention that the "cext-lib" package provides `raco ctool`.
I built my racket installation from source.  `./configure && make && make install` and all that jazz. 
If you started with the Git repo checkout, be sure to see "INSTALL.txt" at the top level.
I tried interrupting the profiling of a simple infinite loop (in errortrace profiling mode), and I do get profiling info printed out.

Do you still see the problem, and if so, could you share a program that exhibits it?
I'd rather not. That's an internal interface, and we may want to change it.
Sounds to me like you already lost that capability. :(

Really? The require path includes ‘private’ and that means ‘sorry, you can get hurt at any point in time’


Well, I know that is what it is supposed to mean, but when an important app gets broken by change, it seems to me, we don't want to make that change. 

And to be clear, no one here is suggesting any need or plan to make any change, right?
Right. No plan to change anything. Just trying to keep options open for the future.
I think that the best way, in this situation, to make a good future for Racket is to look at what those libraries really need from their use of the private library's code, think about how to provide it in a future-friendly way and then ask them to change their implementations.

I find it hard to believe they would have used the private code lightly (although it is possible) and one way to interpret the use of "private" is a require for a pull request to provide that functionality (or something like it) publicly. 
For Typed Rosette in particular, the thing that it needed was a way to specify the scope of the method implementations with a separate identifier from the gen:interface identifier used to look up the property and method names.

This functionality could be provided in a more public way, so that a syntax like
```racket
(struct name [field ...]
  #:methods gen:interface #:method-scope here
  [method-def ...])
```
Could be used instead of the private macros.

However this seemed like such an uncommon need that it might not be worth it to add another case to the public `struct` syntax just for this.

@rfindler Another way to interpret ‘private’ then is to say it means nothing. If so, I consider this a serious gap in our language. We can’t say anything that remains truly private, so Racket lacks a lot of expressive power. 
@AlexKnauth: You're describing an implementation. What's the use case?
@mfelleisen If what you're saying is that we need a linguistic mechanism to play the role of the convention that `private` in a path in a require currently plays then yesterday I would have completely and enthusiastically agreed with you. But today, I start to realize that this flexibility we have in the current system has its own value, namely that it lets someone implement something in Rosette without having to bother the implementors of the generics system to get them to change something.

So maybe what I think we want is a linguistic mechanism that allows this kind of thing but that also makes it easier or somehow encourages us to find ways to accommodate these uses in a way that's public and that the authors of the library (the generics in this case) are comfortable with.

Not sure such a thing is possible, tho!
@stamourv Re: For Typed Rosette in particular:

The only use case (for that particular syntax) is for macros to expand to it without being denied by the default scoping rules. That's why it feels weird to add this to the main `struct` syntax.
A different use case I can think of for having access to `generic-property` and `generic-method-table`: since `interface*` can associate arbitrary structure-type properties with a class-based object, this would allow classes to implement generic interfaces, which they can't do currently except via defaults.

On the private issue, as a user, I definitely understand "private" to mean that no guarantees are made, but the times when I will actually require someone else's private module are I think what @rfindler describes: when I can almost make use of some library, but need some small additional piece of functionality that isn't exposed. Personally I would make a pull request rather than rely on this in a finished product (or fork the library if needed).
re "finished": I'm not sure we really want to make decision decisions in the language around the concept of finished software. Software is never finished.
@LiberalArtist But that would be better suited for a public interface added to `racket/class`. The `racket/class` module would require the private module, but the user shouldn't have to use `generic-property` or `generic-method-table`.
@AlexKnauth: I also don't like the idea of adding a method-scope argument to the struct form. Exposing generics' internal interfaces (as you originally suggested) would be less bad, IMO, but still not ideal.

Could you get what you want by changing how the generics library uses scopes internally?
I could change it to use the scope of the struct name instead of the interface name... But I don't know whether we can do that without breaking other things. The way generics uses scope, it has to be *exactly* right, not just the largest-subset relationship. Anything other than an exact match will result in either failing to implement the method or raising an ambiguous binding error.
Here's a slightly smaller example:

```
#lang racket

(module sig racket
  (provide true^)
  (define-signature true^
    ((contracted
      [true/c  true/c]))))

(module unit racket
  (require (submod ".." sig))
  (define-unit true@
    (import)
    (export true^)
    (define true/c #t)))
```
I did see it again the other day, but I haven't yet found a way to shrink it down to a reasonable example that exhibits the error (the current program is on the order of 10k LOC).

I'll spend a little more time on that and see if I can find a better example.
P.S. I still see the issue in Racket 6.8.
If you could share the 10kloc program, I can try to have a look.
Me too. MBP mid-2015, using 6.8. Neither 64- or 32-bit will launch, and none of the tips above have worked for me. 😭 
@vishvish Not that this is a solution to the problem, but I reverted back to using 6.7 until this is resolved. Might want to try that if the older version satisfies your needs. In my case, I use a very limited set of functionalities, so it did.
FWIW, I agree that this is confusing, but I'd argue that this should raise a duplicate binding error.
Unfortunately, I can't think of any fix that wouldn't break backwards compatibility.
Does this look right @rfindler?
What are you trying to achieve? Is there some program that behaves badly?

Robby

On Thu, Apr 6, 2017 at 10:42 PM Sam Tobin-Hochstadt <
notifications@github.com> wrote:

> Does this look right @rfindler <https://github.com/rfindler>?
>
> —
> You are receiving this because you were mentioned.
>
>
> Reply to this email directly, view it on GitHub
> <https://github.com/racket/racket/pull/1660#issuecomment-292312257>, or mute
> the thread
> <https://github.com/notifications/unsubscribe-auth/AAYWsB-R38fXvIeepXCxjMw2Oi_4Yqkwks5rtU4hgaJpZM4M15E->
> .
>

This program:

```racket
#lang racket
(define/contract ((f x) y) any/c (+ x y))
((f 1) 2 3)
```

now names the second procedure correctly, producing this error message:

```
/tmp/b.rkt:3:0: arity mismatch;
 the expected number of arguments does not match the given number
  expected: 1
  given: 2
  arguments...:
```

Old error message:
```
.../norm-define.rkt:53:83: arity mismatch;
 the expected number of arguments does not match the given number
  expected: 1
  given: 2
  arguments...:
```
Unfortunately, I haven't been able to add something to the contract test suite to effectively test this, perhaps because the good behavior only happens when the function is defined in a saved file.
I would not have been surprised by a duplicate binding error, either.

I also can't think of a backwards-compatible way to fix this, though I wish I could. If programs are relying on the current scoping, I guess at a minimum it should be documented.
Maybe something like this?

```
(parameterize ([current-namespace (make-base-namespace)])
  (namespace-require 'racket/base)
  (namespace-require 'racket/contract)
  (eval (datum->syntax #f
                       '(define/contract ((f x) y) any/c (+ x y))
                       (vector "x.rkt" 1 0 1 0)))
  (printf "~s\n" (eval '(object-name (f 1))))
  (eval (datum->syntax #f '(define ((g x) y) y) (vector "x.rkt" 1 0 1 0)))
  (printf "~s\n" (eval #`(object-name (g 1)))))
```

Thanks, I added that as a test in `test/racket/contract/define-contract`.
Maybe the last two lines of the test case aren't needed?

Otherwise, looks good to push to me.

Thanks!
ping @stamourv, I think this and #1657 should be in Racket v6.9
I will get there. Chill.

On Sat, Apr 8, 2017 at 3:06 PM Ben Greenman <notifications@github.com>
wrote:

> ping @stamourv <https://github.com/stamourv>, I think this and #1657
> <https://github.com/racket/racket/pull/1657> should be in Racket v6.9
>
> —
> You are receiving this because your review was requested.
>
>
> Reply to this email directly, view it on GitHub
> <https://github.com/racket/racket/pull/1658#issuecomment-292742358>, or mute
> the thread
> <https://github.com/notifications/unsubscribe-auth/AAYWsF9Xg60EwVgt71H77XJ8pjt_jnkMks5rt-i6gaJpZM4MxCNv>
> .
>

The missing party is not necessarily negative.
I think a better thing to do here is to add the `#:generate` argument to the function and remove the `#:exercise` argument from the docs. Otherwise, this looks great to me.

Thanks!
removed `#:exercise`, added a `@history` note
https://github.com/racket/racket/commit/3bb131ecb230a8670465c9af8de89c8283e41005
Should be fixed in the next nightly build, and on Racket 6.9. Thanks for the report!

https://github.com/racket/racket/commit/3bb131ecb230a8670465c9af8de89c8283e41005
Just to confirm, are you requesting that this commit go into 6.9?
Yes,

but Robby emailed me that the `@history` may be misleading (as the keyword was only removed from the docs, not the function). So that commit may require a follow-up.
Ok. Let me know which commits to cherry-pick when you're ready.
@stamourv the commits are:
- 3bb131ecb230a8670465c9af8de89c8283e41005
- 50f67cf6e48c4e9fdfa9ce09117b4dde13cf4da1
thank you!
Done. Thanks!
I made a branch here that exhibits the behavior: https://github.com/schuster/aps-conformance-checker

In the root directory of that project, run `raco profile --total --use-errortrace examples/raft.rkt`. When I let that run for 30 seconds or so then halt with Ctrl-C, I get this at the end of my output:

```
profiled thunk error: user break
Profiling results
-----------------
  Total cpu time observed: 30701ms (out of 30982ms)
  Number of samples taken: 516 (once every 59ms)

====================================
                        Caller
Idx  Total    Self    Name+srcLocal%
     ms(pct)  ms(pct)   Callee
====================================
```

You may want to run `raco make examples/raft.rkt` before profiling just to avoid the initial start-up time.
Do you have a "~/.racketrc" file?

I see that `plt-r5rs` was originally meant to load "~/.pltr5rs" instead, but the way it was implemented became broken when ".mzschemerc" was renamed to ".racketrc" (many years ago).
@mflatt Ah, yes I do. I have following piece of code in it: `(define nil null)`. That makes things easier for me when I'm working with Racket plus other Lisps, since I get used to typing `nil`. I'll have to comment that out for `plt-r5rs`. Thanks a lot for the help and the info.
Welp, looking this over it occurs to me that it is building wrapper functions instead of using chaperones, so probably that should get edited too. I'll take a look into it.
Apparently some of those issues have been fixed. Might be worth testing again, and seeing if it works or if the current problems can be worked around.
Hi @Vishesh-Gupta — Did you mean to provide a file that we should try running?

[Kenken.pdf](https://github.com/racket/racket/files/917718/Kenken.pdf)

Whenever I use the following text in .rkt format the system crashes.
Can you upload this file not as a pdf?
What format of file do you want I can't upload it in .rkt here?
If you can paste the text of the file into a comment here, that would be perfect.
```racket
;; The first three lines of this file were inserted by DrRacket. They record metadata
;; about the language level of this file in a form that our tools can easily process.
#reader(lib "htdp-intermediate-lambda-reader.ss" "lang")((modname kenken-start) (read-case-sensitive #t) (teachpacks ()) (htdp-settings #(#t constructor repeating-decimal #f #t none #f () #f)))
(require "kenken-draw.rkt")


(define-struct puzzle (size board constraints))
;; A Puzzle is a (make-puzzle 
;;                Nat 
;;                (listof (listof (anyof Sym Nat Guess)))
;;                (listof (list Sym Nat (anyof '+ '- '* '/ '=))))
;; requires: See Assignment Specifications

(define-struct guess (symbol number))
;; A Guess is a (make-guess Sym Nat)
;; requires: See Assignment Specifications

;; Some useful constants
;; from assignment specification
(define puzzle1
  (make-puzzle 
   4
   (list
    (list 'a 'b 'b 'c)
    (list 'a 'd 'e 'e)
    (list 'f 'd 'g 'g)
    (list 'f 'h 'i 'i))
   (list
    (list 'a 6 '*)
    (list 'b 3 '-)
    (list 'c 3 '=)
    (list 'd 5 '+)
    (list 'e 3 '-)
    (list 'f 3 '-)
    (list 'g 2 '/)
    (list 'h 4 '=)
    (list 'i 1 '-))))

;; a partial solution to puzzle1
(define puzzle1partial
  (make-puzzle 
   4
   (list
    (list 'a 'b 'b 'c)
    (list 'a 2 1 4)
    (list 'f 3 'g 'g)
    (list 'f 'h 'i 'i))
   (list
    (list 'a 6 '*)
    (list 'b 3 '-)
    (list 'c 3 '=)
    (list 'f 3 '-)
    (list 'g 2 '/)
    (list 'h 4 '=)
    (list 'i 1 '-))))

;; a partial solution to puzzle1 with a cage partially filled in
(define puzzle1partial2
  (make-puzzle 
   4
   (list
    (list (make-guess 'a 2) 'b 'b 'c)
    (list 'a 2 1 4)
    (list 'f 3 'g 'g)
    (list 'f 'h 'i 'i))
   (list
    (list 'a 6 '*)
    (list 'b 3 '-)
    (list 'c 3 '=)
    (list 'f 3 '-)
    (list 'g 2 '/)
    (list 'h 4 '=)
    (list 'i 1 '-))))

;; a partial solution to puzzle1 with a cage partially filled in
;; but not yet verified 
(define puzzle1partial3
  (make-puzzle 
   4
   (list
    (list (make-guess 'a 2) 'b 'b 'c)
    (list (make-guess 'a 3) 2 1 4)
    (list 'f 3 'g 'g)
    (list 'f 'h 'i 'i))
   (list
    (list 'a 6 '*)
    (list 'b 3 '-)
    (list 'c 3 '=)
    (list 'f 3 '-)
    (list 'g 2 '/)
    (list 'h 4 '=)
    (list 'i 1 '-))))

;; The solution to puzzle 1
(define puzzle1soln
  (make-puzzle
   4
   '((2 1 4 3)
     (3 2 1 4)
     (4 3 2 1)
     (1 4 3 2))
   empty))

;; wikipedia KenKen example
(define puzzle2
  (make-puzzle
   6
   '((a b b c d d)
     (a e e c f d)
     (h h i i f d)
     (h h j k l l)
     (m m j k k g)
     (o o o p p g))
   '((a 11 +)
     (b 2 /)
     (c 20 *)
     (d 6 *)
     (e 3 -)
     (f 3 /)
     (g 9 +)
     (h 240 *)
     (i 6 *)
     (j 6 *)
     (k 7 +)
     (l 30 *)
     (m 6 *)
     (o 8 +)
     (p 2 /))))

;; The solution to puzzle 2
(define puzzle2soln
  (make-puzzle
   6
   '((5 6 3 4 1 2)
     (6 1 4 5 2 3)
     (4 5 2 3 6 1)
     (3 4 1 2 5 6)
     (2 3 6 1 4 5)
     (1 2 5 6 3 4))
   empty))

;; Tiny board
(define puzzle3
  (make-puzzle 
   2 
   '((a b) 
     (c b)) 
   '((b 3 +) 
     (c 2 =)
     (a 1 =))))

(define puzzle3partial
  (make-puzzle
   2 
   (list
    (list 'a (make-guess 'b 1))
    (list 'c (make-guess 'b 2)))
   '((b 3 +) 
     (c 2 =)
     (a 1 =))))  

;; a big board:  will take a *long* time without trying the bonus
(define puzzle4
  (make-puzzle
   9
   '((a a b c d e e f f)
     (g h b c d i j k l)
     (g h m m i i j k l)
     (n o m p p q q r s)
     (n o t u p v v r s)
     (n w t u x x y z z)
     (A w B C C C y D D)
     (A B B E E F G H I)
     (J J K K F F G H I))
   '((a 2 /)
     (b 11 +)
     (c 1 -)
     (d 7 *)
     (e 4 -)
     (f 9 +)
     (g 1 -)
     (h 4 /)
     (i 108 *)
     (j 13 +)
     (k 2 -)
     (l 5 -)
     (m 84 *)
     (n 24 *)
     (o 40 *)
     (p 18 *)
     (q 2 /)
     (r 2 -)
     (s 13 +)
     (t 10 +)
     (u 13 +)
     (v 2 -)
     (w 63 *)
     (x 1 -)
     (y 3 /)
     (z 2 /)
     (A 7 +)
     (B 13 +)
     (C 336 *)
     (D 1 -)
     (E 15 +)
     (F 12 *)
     (G 9 +)
     (H 5 -)
     (I 18 *)
     (J 3 /)
     (K 40 *))))

;;==============================================================================
;; Part (a)

;; (find-blank puz) produces the position of the first blank
;; space in puz, or false if no cells are blank.  If the first constraint has
;; only guesses on the board, find-blank produces 'guess.  
;; find-blank: Puzzle -> (anyof Posn false 'guess)
;; Examples:
(check-expect (find-blank puzzle1) (make-posn 0 0))

(define (find-blank puz)
  (local
    [(define (find-blank/accumalator size board constraints posn/acc guess/bool)
       (cond
         [(empty? constraints) false]
         [(empty? board)
          (cond
            [guess/bool 'guess]
            [else (find-blank/accumalator size 
                                          (puzzle-board puz)
                                          (rest constraints)
                                          (make-posn 0 0)
                                          false)])]
         [(empty? (first board))
          (find-blank/accumalator size
                                  (rest board)
                                  constraints 
                                  (make-posn 0
                                             (add1 (posn-y posn/acc)))
                                  guess/bool)]
         [(and (guess? (first (first board)))
               (symbol=? (first (first constraints))
                         (guess-symbol (first (first board)))))
          (find-blank/accumalator size
                                  (cons (rest (first board))
                                        (rest board))
                                  constraints
                                  (make-posn (add1 (posn-x posn/acc))
                                             (posn-y posn/acc))
                                  true)]
         [(equal? (first (first constraints)) (first (first board)))
          posn/acc]
         [else (find-blank/accumalator size
                                       (cons (rest (first board))
                                             (rest board))
                                       constraints
                                       (make-posn (add1 (posn-x posn/acc))
                                                  (posn-y posn/acc))
                                       guess/bool)]))]
    (find-blank/accumalator (puzzle-size puz)
                            (puzzle-board puz)
                            (puzzle-constraints puz)
                            (make-posn 0 0)
                            false)))

;; Tests:
(check-expect (find-blank puzzle1soln) false)
(check-expect (find-blank puzzle1partial2) (make-posn 0 1))

;;==============================================================================
;; Part (b)

;; (used-in-row puz pos) produces a list of numbers used in the same 
;; row as (x,y) position, pos, in the given puz.  
;; used-in-row: Puzzle Posn -> (listof Nat)
;; Examples:
(check-expect (used-in-row puzzle1 (make-posn 1 1)) empty)

(define (used-in-row puz pos)
  (quicksort (map (lambda (x) (cond
                                [(guess? x) (guess-number x)]
                                [else x])) (filter (lambda (x)
                                                     (or (guess? x) (number? x)))
                                                   (list-ref (puzzle-board puz)
                                                             (posn-y pos)))) <))

;; Tests:
(check-expect (used-in-row puzzle1partial (make-posn 2 2)) (list 3))
(check-expect (used-in-row puzzle1partial2 (make-posn 0 1)) (list 1 2 4))

;; (used-in-column puz pos) produces a list of numbers used in the same
;; column as (x,y) position, pos, in the given puz.  
;; used-in-column: Puzzle Posn -> (listof Nat)
;; Examples:
(check-expect (used-in-column puzzle1 (make-posn 1 1)) empty)
(check-expect (used-in-column puzzle1partial (make-posn 2 2)) (list 1))
(check-expect (used-in-column puzzle1partial2 (make-posn 0 1)) (list 2))

(define (used-in-column puz pos)
  (local [(define new-puz (make-puzzle (puzzle-size puz)
                                       (apply map list (puzzle-board puz))
                                       (puzzle-constraints puz)))]
    (quicksort (map (lambda (x) (cond
                                  [(guess? x) (guess-number x)]
                                  [else x])) (filter (lambda (x)
                                                       (or (guess? x)
                                                           (number? x)))
                                                     (list-ref (puzzle-board new-puz)
                                                               (posn-x pos)))) <)))

;; Tests:

;;==============================================================================
;; Part (c)

;;This function may be useful as a helper for available-vals

;; (allvals n) produces a list of values from 1 to n
;; allvals: Nat -> (listof Nat)
;; Examples:
(check-expect (allvals 0) empty)
(check-expect (allvals 1) (list 1))

(define (allvals n) (build-list n (lambda (x) (add1 x))))

;; Tests:
(check-expect (allvals 3) (list 1 2 3))

;; (available-vals puz pos) produces a list of valid entries for the (x,y)  
;; position, pos, of the consumed puzzle, puz.  
;; available-vals: Puzzle Posn -> (listof Nat)
;; Examples:
(check-expect (available-vals puzzle1 (make-posn 2 3)) '(1 2 3 4))

(define (available-vals puz pos)
  (local [(define used-row (used-in-row puz pos))
          (define used-col (used-in-column puz pos))]
    (filter (lambda (x) (not (member? x used-row)))
            (filter (lambda (x) (not (member? x used-col))) (allvals (puzzle-size puz))))))

;; Tests:
(check-expect (available-vals puzzle1partial (make-posn 2 2)) '(2 4))
(check-expect (available-vals puzzle1partial2 (make-posn 0 1)) '(3))


;;==============================================================================
;; Part (d)

;; (place-guess brd pos val) fills in the (x,y) position, pos, of the board, brd, 
;; with the a guess with value, val
;; place-guess: (listof (listof (anyof Sym Nat Guess))) Posn Nat 
;;              -> (listof (listof (anyof Sym Nat Guess)))
;; Examples:
(check-expect (place-guess (puzzle-board puzzle1) (make-posn 3 2) 5)
              (list
               (list 'a 'b 'b 'c)
               (list 'a 'd 'e 'e)
               (list 'f 'd 'g (make-guess 'g 5))
               (list 'f 'h 'i 'i)))

(define (place-guess brd pos val)
  (local
    [(define (check-col col x val)
       (cond
         [(= 0 x)
          (cons (make-guess (first col) val) (rest col))]
         [else (cons (first col) 
                     (check-col (rest col) (sub1 x) val))]))]
    (cond
      [(= 0 (posn-y pos))
       (cons (check-col (first brd) (posn-x pos) val)
             (rest brd))]
      [else 
       (cons (first brd)
             (place-guess (rest brd)
                          (make-posn (posn-x pos) (sub1 (posn-y pos)))
                          val))])))

;; Tests:

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;DO NOT CHANGE THIS FUNCTION;;;;;;;;;;;;;;;;;;;;;;;

;; (fill-in-guess puz pos val) fills in the (x,y) position, pos, of puz's board
;; with a guess wtih value, val
;; fill-in-guess: Puzzle Posn Nat -> Puzzle
;; Examples:
(check-expect (fill-in-guess puzzle1 (make-posn 3 2) 5)
              (make-puzzle
               4
               (list
                (list 'a 'b 'b 'c)
                (list 'a 'd 'e 'e)
                (list 'f 'd 'g (make-guess 'g 5))
                (list 'f 'h 'i 'i))
               (puzzle-constraints puzzle1)))

(define (fill-in-guess puz pos val)
  (make-puzzle (puzzle-size puz) 
               (place-guess (puzzle-board puz) pos val) 
               (puzzle-constraints puz)))

;; Tests:
(check-expect (fill-in-guess puzzle3 (make-posn 0 0) 1)
              (make-puzzle
               2
               (list (list (make-guess 'a 1) 'b)
                     (list 'c 'b))
               '((b 3 +) 
                 (c 2 =)
                 (a 1 =))))

;;==============================================================================
;; Part (e)

;; (guess-valid? puz) determines if the guesses in puz satisfy their constraint
;; guess-valid?: Puzzle -> Bool
;; Examples:

(define (guess-valid? puz)
  (local
    [(define sym (first (first (puzzle-constraints puz))))
     (define op (third (first (puzzle-constraints puz))))
     (define cage-result (second (first (puzzle-constraints puz))))
     (define vlst (map guess-number 
                       (filter (lambda (x)
                                 (and (guess? x)
                                      (symbol=? sym
                                                (guess-symbol x))))
                               (foldr append empty (puzzle-board puz)))))]
    (cond
      [(symbol=? '+ op)
       (= cage-result (foldr + 0 vlst))]
      [(symbol=? '- op)
       (= cage-result (abs (- (first vlst) (second vlst))))]
      [(symbol=? '* op)
       (= cage-result (foldr * 1 vlst))]
      [(symbol=? '/ op)
       (or (= cage-result (/ (first vlst) (second vlst)))
           (= cage-result (/ (second vlst) (first vlst))))]
      [(symbol=? '= op)
       (= cage-result (first vlst))])))

;; Tests:
(check-expect (guess-valid? puzzle3partial) true)

;;==============================================================================
;; Part (f)

;; (apply-guess puz) converts all guesses in puz into their corresponding numbers
;; and removes the first contraint from puz's list of contraints
;; apply-guess:  Puzzle -> Puzzle
;; Examples:

(define (apply-guess puz)
  (local [(define apply-guess/helper (foldr (lambda (w x) (cons (foldr (lambda (y z) (cond
                                                                                       [(guess? y) (cons (guess-number y) z)]
                                                                                       [else (cons y z)]))
                                                                       empty
                                                                       w) x)) empty (puzzle-board puz)))]
    (make-puzzle (puzzle-size puz)
                 apply-guess/helper
                 (rest (puzzle-constraints puz)))))

;; Tests:
(check-expect (apply-guess puzzle3partial)
              (make-puzzle
               2 
               (list
                (list 'a 1)
                (list 'c 2))
               '((c 2 =)
                 (a 1 =))))  

;;==============================================================================
;; Part (g)

;; (neighbours puz) produces a list of next puzzles after puz in
;; the implicit graph
;; neighbours: Puzzle -> (listof Puzzle)
;; Examples:
(check-expect (neighbours puzzle3)
              (list 
               (make-puzzle 
                2 
                (list 
                 (list 'a (make-guess 'b 1)) 
                 (list 'c 'b)) 
                '((b 3 +) 
                  (c 2 =)
                  (a 1 =)))
               (make-puzzle 
                2 
                (list 
                 (list 'a (make-guess 'b 2)) 
                 (list 'c 'b)) 
                '((b 3 +) 
                  (c 2 =)
                  (a 1 =)))))

(define (neighbours puz)
  (cond
    [(false? (find-blank puz)) empty]
    [(and (equal? 'guess (find-blank puz))
          (guess-valid? puz)) (list (apply-guess puz))]
    [(and (equal? 'guess (find-blank puz))
          (not (guess-valid? puz))) empty]
    [else (map (lambda (val)
                 (make-puzzle (puzzle-size puz)
                              (place-guess (puzzle-board puz)
                                           (find-blank puz)
                                           val)
                              (puzzle-constraints puz)))
               (available-vals puz (find-blank puz)))]))

;; Tests:
(check-expect (neighbours puzzle2soln) empty)
(check-expect (neighbours puzzle3partial)
              (list 
               (make-puzzle
                2 
                (list
                 (list 'a 1)
                 (list 'c 2))
                '((c 2 =)
                  (a 1 =)))))  


;; This is just the find-route function from Module 12, slides
;; 31-37.  (Read a bit ahead if you want the deatils.) The explicit
;; graph G has been removed, and the termination condition (the desired
;; destination) is when the puzzle is complete (that is, find-blank
;; returns false).

;; (solve-kenken orig draw-option) finds the solution to a KenKen puzzle,
;; orig, or returns false if there is no solution.  A visual representiation
;; of the solution may be draw depending on the value of draw-option
;; solve-kenken: Puzzle Sym -> (anyof Puzzle false)
;; requires:  draw-option is one of 'off, 'norm, 'slow, 'fast
;; Examples:
(check-expect (solve-kenken puzzle1 'off) puzzle1soln)

(define (solve-kenken orig draw-option)
  (local
    [(define setup (puzzle-setup orig draw-option))
     (define (solve-kenken-helper to-visit visited)
       (cond
         [(empty? to-visit) false]
         [else (local
                 [(define draw (draw-board (first to-visit) draw-option))]
                 (cond
                   [(boolean? (find-blank (first to-visit))) (first to-visit)]
                   [(member (first to-visit) visited)
                    (solve-kenken-helper (rest to-visit) visited)]
                   [else
                    (local [(define nbrs (neighbours (first to-visit)))
                            (define new (filter (lambda (x) (not (member x visited))) nbrs))
                            (define new-to-visit (append new (rest to-visit)))
                            (define new-visited (cons (first to-visit) visited))]
                      (solve-kenken-helper new-to-visit new-visited))]))]))]
    (solve-kenken-helper (list orig) empty)))

;; Tests:
(check-expect (solve-kenken puzzle3partial 'off) false)
;; The time special form shows you the number of milliseconds spent
;; evaluating the given expression.  The first number (cpu time) is
;; the important one.
(check-expect (time (solve-kenken puzzle2 'norm)) puzzle2soln)
```
Thanks!
Your welcome. Also is it possible to know from your team about the reason why it was crashing as I really enjoy using racket and currently use it for studying in university.
It looks like this needs another file called `kenken-draw.rkt`. Can you provide that as well?
Sure.

```racket
(module a10 scheme
  (require racket/gui/base)
  (require racket/draw)
  
  (define (get-size puzz)
    (vector-ref (struct->vector puzz) 1))
  
  (define (get-board puzz)
    (vector-ref (struct->vector puzz) 2))
  
  (define (get-constraints puzz)
    (vector-ref (struct->vector puzz) 3))
  
  (define (get-guess-symbol gue)
    (vector-ref (struct->vector gue) 1))
  
  (define (get-guess-number gue)
    (vector-ref (struct->vector gue) 2))
  
  (define font-exp (make-object font% 5 'default))
  
  (define font-val (make-object font% 40 'default))
  
  (define square-size 50)
  
  (define blank-board false)
  
  (define blank-constraints false) 
  
  (define (first-occur ch lst)
    (cond
      [(empty? lst) false]
      [(symbol=? ch (first lst)) 0]
      [else (add1 (first-occur ch (rest lst)))]))
  
  (define (flatten list)
    (cond
      [(empty? list) empty]
      [else (append (first list) (flatten (rest list)))]))
  
  (define (get-grid-x sec grid)
    (remainder (first-occur sec (flatten grid))
               (length grid)))
  
  (define (get-grid-y sec grid)
    (quotient (first-occur sec (flatten grid))
              (length grid)))
  
  (define (gen-exp func total)
    (cond
      [(symbol=? '* func) (string-append (number->string total) "x")]
      [(symbol=? '= func) (number->string total)]
      [else (string-append (number->string total)
                           (symbol->string func))]))
  
  (define (invert-grid grid)
    (cond
      [(empty? (first grid)) empty]
      [else (cons (foldr (lambda (x y) (cons (first x) y)) empty grid)
                  (invert-grid (map rest grid)))]))
  
  
  (define board-frame (new frame% [label "Solve-KenKen"]
                           [width (* 8 square-size)]
                           [height (+ 22 (* 8 square-size))]
                           [x 50]
                           [y 50]))
  
  (define board-canvas (new canvas% [parent board-frame]))
  
  (define board-dc (send board-canvas get-dc))
  
  (define (resize-frame new-size)
    (begin (show-board false)
           (set! board-frame (new frame% [label "Solve-KenKen"]
                                  [width (* 2 new-size square-size)]
                                  [height (+ 22 (* 2 new-size square-size))]
                                  [x 50]
                                  [y 50]))
           (set! board-canvas (new canvas% [parent board-frame]))
           (set! board-dc (send board-canvas get-dc))
           (send board-dc set-scale 2 2)
           (show-board true)))
  
  (define (puzzle-setup puzz draw-option)
    (cond 
      [(not (symbol=? draw-option 'off))
       (begin
         ;create the best aproximation of an empty board
         (set! blank-board (map (lambda (x) (map (lambda (y)
                                                   (cond 
                                                     [(struct? y) (get-guess-symbol y)]
                                                     [(number? y) 'empty]
                                                     [else y])) x))
                                (get-board puzz)))
         (set! blank-constraints (get-constraints puzz))
         (resize-frame (get-size puzz)))]))
  
  
  (define (show-board bool)
    (send board-frame show bool))
  
  (define (draw-board puzz draw-option)
    (cond
      [(not (symbol=? draw-option 'off))
       (local
         [(define (draw puzz)
            (begin
              (send board-dc clear)
              (send board-dc set-pen "black" 6 'solid)
              (local
                ;draw the separating lines for a single row
                [(define (draw-row-vert row x-coord y-coord)
                   (cond
                     [(empty? (rest row)) (begin
                                            (send board-dc set-pen "black" 3 'solid)
                                            (send board-dc draw-line x-coord y-coord x-coord (+ square-size y-coord)))]
                     [(symbol=? (first row) (first (rest row))) (begin 
                                                                  (send board-dc set-pen "grey" 0.2 'solid)
                                                                  (send board-dc draw-line x-coord y-coord x-coord (+ square-size y-coord))
                                                                  (draw-row-vert (rest row) (+ square-size x-coord) y-coord))]
                     [else (begin
                             (send board-dc set-pen "black" 2 'solid)
                             (send board-dc draw-line x-coord y-coord x-coord (+ square-size y-coord))
                             (draw-row-vert (rest row) (+ square-size x-coord) y-coord))]))
                 
                 ;draw separating lines for each row
                 (define (draw-grid-vert grid y-coord)
                   (cond
                     [(empty? grid) (begin
                                      (send board-dc set-pen "black" 3 'solid)
                                      (send board-dc draw-line 0 (* (get-size puzz) square-size)
                                            (* (get-size puzz) square-size) (* (get-size puzz) square-size)))]
                     [else (begin
                             (draw-row-vert (first grid) square-size y-coord)
                             (draw-grid-vert (rest grid) (+ square-size y-coord)))]))]
                
                (draw-grid-vert blank-board 0))
              
              (local
                [;switch the rows and columns so that columns can be easilly worked with
                 (define invert-puzzle (invert-grid blank-board))
                 ;draw separating lines for a column
                 (define (draw-col-horz row x-coord y-coord)
                   (cond
                     [(empty? (rest row)) (begin
                                            (send board-dc set-pen "black" 3 'solid)
                                            (send board-dc draw-line x-coord y-coord (+ square-size x-coord)  y-coord))]
                     [(symbol=? (first row) (first (rest row))) (begin 
                                                                  (send board-dc set-pen "grey" 0.2 'solid)
                                                                  (send board-dc draw-line x-coord y-coord (+ square-size x-coord) y-coord)
                                                                  (draw-col-horz (rest row) x-coord (+ square-size y-coord)))]
                     [else (begin
                             (send board-dc set-pen "black" 2 'solid)
                             (send board-dc draw-line x-coord y-coord (+ square-size x-coord) y-coord)
                             (draw-col-horz (rest row) x-coord (+ square-size y-coord)))]))
                 
                 ;draw separating lines for each column
                 (define (draw-grid-horz grid x-coord)
                   (cond
                     [(empty? grid)]
                     [else (begin
                             (draw-col-horz (first grid)  x-coord square-size)
                             (draw-grid-horz (rest grid) (+ square-size x-coord)))]))]
                
                (draw-grid-horz invert-puzzle 0))
              
              (send board-dc set-font font-exp)
              
              ;fill in the expressions in the top left of squares
              (map (lambda (reg) 
                     (send board-dc draw-text (gen-exp (third reg) (second reg)) 
                           (+ 2 (* square-size (get-grid-x (first reg) blank-board)))
                           (+ 2 (* square-size (get-grid-y (first reg) blank-board))))) blank-constraints)
              
              (send board-dc set-font font-val)
              
              ;fill in a row with Numeric values
              (define (fill-grid-row row x-coord y-coord board-dc)
                (cond
                  [(empty? row)]
                  [(number? (first row)) (begin
                                           (send board-dc draw-text (number->string (first row)) x-coord y-coord)
                                           (fill-grid-row (rest row) (+ square-size x-coord) y-coord board-dc))]
                  [(struct? (first row)) (begin
                                           (send board-dc draw-text (number->string (get-guess-number (first row))) x-coord y-coord)
                                           (fill-grid-row (rest row) (+ square-size x-coord) y-coord board-dc))]
                  [else (fill-grid-row (rest row) (+ square-size x-coord) y-coord board-dc)]))
              
              ;fill in all Numeric values
              (define (fill-grid grid y-coord)
                (cond
                  [(empty? grid)]
                  [else (begin (fill-grid-row (first grid) 8 y-coord (send board-canvas get-dc))
                               (fill-grid (rest grid) (+ square-size y-coord)))]))
              
              ;add in a delay to make each step readable
              (fill-grid (get-board puzz) 0)
              (cond 
                [(symbol=? 'slow draw-option) (sleep 0.5)]
                [(symbol=? 'fast draw-option) (sleep 0.025)]
                [else (sleep 0.1)])
              true))]
         (draw puzz))]))
  
  (provide  draw-board puzzle-setup))
```

Also this code for kenken-draw is written by my university professor and the gui for this code is only working in MacOS as she said. Could you kindly look into that too?
The issue seems to be somewhere in the drawing -- running the unmodified program locks up DrRacket on my Linux machine (and produces artifacts in the window that pops up). But changing the drawing mode in the final test to `'off` makes the whole thing run successfully.
That also is correct but it is perfectly working on a MAC system (my friends). I have tried it myself with the same file. As soon as I shift it to a windows computer, the system crashes and when I run kenken-draw.rkt the grey draw gui window pops up and does nothing in windows.
Changing the `sleep`s in "kenken-draw.rkt" to `sleep/yield` allows the output to show up for me on Windows and Linux. A plain `sleep` doesn't give the GUI a chance to refresh the screen. (The screen is refreshed, anyway, on Mac OS due to the way screen activity is handled there.)

Even without `sleep/yield`, the program should not lock up DrRacket, and I'm not seeing that. @samth, are you saying that you can't click the "Break"/"Kill" button in DrRacket to terminate the program?

@Vishesh-Gupta, can you say more about what you're seeing as a crash? Does DrRacket exit, or is it just that the window where you want to see drawing fails to draw or react to any mouse clicks (since it's not handling events)?
The base shouldn't be 1, and I think you want an error from `log` in that case, instead of an error from `/`. A base of `0` happens to provoke an errr from `log`, but you may want a more direct check.

@mflatt, The crash is my OS stops with a stop error. It only happens with this file and with some other files. It did not happen till I update the version to v6.8 for racket and after I updated it and the crash started to happen. Happens even now when I downgraded to v6.7 which I was previously using. Also in some cases, it has happened on other .rkt files too.

Also the thing you mentioned for ```sleep/yield``` should I try that?
Ah, good catch. I will add error checking for that. Thanks.
I've pushed your commit and some follow on edits. If something should be done differently, then I'm happy to discuss more (and so please feel free to re-open).
I am able to repro the issue on a MacBook Pro running macOS Sierra version 10.12.4 
I have downloaded DrRacket 6.8 DMG and mounted the image and copied the Racket folder to `/Applications`. Then I double clicked on the `DrRacket.app` folder and nothing happened. Using spotlight I get an alert dialog that says *The application "DrRacket.app" can't be opened*. Then I tried to open it from the command line and I get this error:

    $  open DrRacket.app
    LSOpenURLsWithRole() failed with error -10810 for the file /Applications/Racket v6.8/DrRacket.app.

So ... not much information about what is going on under the covers.

So I decided to put a trace on the app by using the following command:

    $ sudo dtruss -a -f -n DrRacket 2> drracket_dtruss.txt

The trace output is attached and it captures the execution of the `open DrRacket.app` command above.  I hope it is helpful.

[drracket_dtruss.txt](https://github.com/racket/racket/files/918594/drracket_dtruss.txt)

UPDATE 01: I created a gist of the DTruss output here https://gist.github.com/gorauskas/f370679d6caf614684fd3f80bc5cdb67 in case the security conscious do not want to download random files from the Internet. 
I had the same issue with running DrRacket from provided .dmg. However, homebrew cask works.
Here the link to the homebrew formula, it doesn't seem to do anything special:

https://github.com/caskroom/homebrew-cask/blob/master/Casks/racket.rb
FWIW for testing `fllogb` from `math/flonum` can be used.

[http://docs.racket-lang.org/math/flonum.html?q=log#%28def._%28%28lib._math%2Fflonum..rkt%29._fllogb%29%29](fllogb in math/flonum)
@Vishesh-Gupta Yes, use `sleep/yield` in place of `sleep` to make the drawing part work. It's possible that change will also solve crashes related to a too-full event queue, although I still don't really understand what you're seeing there.
It looks to me like the `c` argument is the contract. In other words, there is only one, not contracts?
@soegaard Interesting. Although that function only works with flonums, while the `log` function only works for fixnums.

Either way, thanks. For the life of me I couldn't find an arbitrary log base function in all of our stdlib.

Does anyone else have any thoughts?
Woops, I mean, the `log` function (in `racket/base`), _also_ works on fixnums.
FWIW, this line looks possibly relevant:
```write(0x2, "standard-module-name-resolver: collection not found\n  for module path: (lib \"drracket/drracket.rkt\")\n  collection: \"drracket\"\n  in collection directories:\n   /Users/jonasg211/Library/Racket/6.8/collects\b\0", 0xCA)```
I think so, if I understand the question correctly.
This looks good overall to me.
@stamourv The path `~/Library/Racket/6.8/collects/` does not exist on my machine.  The file `drracket.rkt` only exists in `/Applications/Racket v6.8/share/pkgs/drracket/drracket/drracket.rkt` on my machine.  I wonder why it is looking in `~/Library`?
Okay, @mflatt and @soegaard , I think its ready to merge. The tests are failing, but that seems to be because they are currently failing in `master` as well. Thoughts?
@LeifAndersen @mflatt

Perhaps recommend using `fllogb` in case where accuracy is important?

https://github.com/racket/math/blob/master/math-lib/math/private/flonum/flonum-log.rkt#L138

Somehow it feels odd to have "almost" duplicated functionality. Should log
use the same algorithm as fllogb ?

Btw `max-dividing-power` provides similar functionality for bignums.


2017-04-14 3:45 GMT+02:00 Leif Andersen <notifications@github.com>:

> Okay, @mflatt <https://github.com/mflatt> and @soegaard
> <https://github.com/soegaard> , I think its ready to merge. The tests are
> failing, but that seems to be because they are currently failing in master
> as well. Thoughts?
>
> —
> You are receiving this because you were mentioned.
> Reply to this email directly, view it on GitHub
> <https://github.com/racket/racket/pull/1667#issuecomment-294064977>, or mute
> the thread
> <https://github.com/notifications/unsubscribe-auth/AAcLxf8dZnd_RDljukudCzub8W3ngFypks5rvs-3gaJpZM4M8DrV>
> .
>



-- 
-- 
Jens Axel Søgaard

I think we'd be happy to have that feature added. I don't have an opinion on separate shift/reduce and reduce/reduce expects.

Yes, https://github.com/racket/parser-tools/issues is a better place for the issue, but it doesn't matter that much. A pull request will only work over there, of course.
@soegaard @mflatt 

> Perhaps recommend using `fllogb` in case where accuracy is important?

Good call. I'll update the docs to reflect that tonight.

> Somehow it feels odd to have "almost" duplicated functionality. Should log use the same algorithm as fllogb ? 

I don't care one way or another. To me, it makes sense to have `(log a b)` defined as `(/ (log a) (log b))`, but has the potential to be computed faster. But if we want to use the same algorithm as `fllogb`, I guess that's fine too. It just seems odd to me to have:
`(log x)` and `(log x (exp 1))` return slightly different values because they are using a different algorithm. (The existing `log` algorithm in the first case and the `fllogb` algorithm in the second case.)

Thoughts?

One other thing, does anyone have a preference of whether this gets put into 6.9, or should wait until 6.10? I'm okay either way, but if we want 6.9 I should merge this tonight.
Since it seems like everyone is okay I'm going to go ahead and merge this.
I don't mind either way about adding a mention of the handin server. This ought to get merged for 6.9 though.
I don't think the implementation should disallow 0: it's a backward-incompatible change, it isn't general (hence the documentation note about inexact arithmetic), and the existing behavior is both well-defined and potentially useful (in the same way that infinite streams are useful).

A documentation note to warn about 0 or small numbers seems good, though.
Good points.
I'll remove the changes to the implementation, then adapt the doc changes.
Thanks for the feedback!
Pushed a revised version.
Running into this same issue. How can I help/get started?
Happening to both my computers too. Both are Win10 creator update!
I think it should be possible to teach `scheme_do_open_output_file()` an additional `#:perm #o600` or `#:permissions #o600` keyword.  I volunteer to do the work if there is consensus.

It's something of an open question how (or if) it should work on Windows.  As a data point, libuv (the I/O library that node.js uses) creates the file with FILE_ATTRIBUTE_READONLY unless any writable bits are set.

As a workaround, you could temporarily change the umask when creating the file:
```racket
(require ffi/unsafe)

(define umask (get-ffi-obj "umask" (ffi-lib "libc") (_fun _int -> _int)))

(define-syntax with-umask
  (syntax-rules ()
    ((_ mode body ...)
     (let ((saved (umask mode)))
       (dynamic-wind void
                     (lambda () body ...)
                     (lambda () (umask saved)))))))

;;; Note: umask is subtractive: (666 & ~077) = 600
(define port
  (with-umask #o077
    (open-output-file "file.txt")))
```
EDIT: That's not safe in multi-threaded programs though; the umask is a process-wide setting.
Adding that to `open-output-file` sounds like a good idea, but I might represent it as a list of symbols on the Racket side.
Merged, thanks! And will merge to 6.9.
Discussion of the handin server can be added later.
"We need to reboot the system now" is clearly a bug in the OS, but it's possible that DrRacket is doing something wrong to provoke the OS crash. Unfortunately, installing Windows 10 Creators Update on my development virtual machine has not been enough to let me experience the crash myself.

Is there any action in particular that causes the crash? Do you have to move the mouse, type on the keyboard, or use a scrolling gesture? Or does the OS crash without any further input? Does running plain "Racket.exe" crash? If not, how about "lib/GRacket.exe"? (I realize that asking you to crash your machine to check these details is asking a lot!)
I'll make a video and post it within the hour.
Video of when computer had been used for hours without any issues, but as soon as I open DrRacket, this happens.
https://goo.gl/photos/WgV9677ehWZrgrUV6

And here's the video of newly restarted computer and then opening DrRacket. Notice that I don't write anything the second time and same thing happens.
https://goo.gl/photos/ERFf4vvsMwstSq9f9

The build I'm on is 15063.138. I see there's an update for Windows. I'll update you guys if the bug is still there after I update.

Hope that helps.

EDIT: I realise now that DrRacket on the PC I filmed on is 6.7. I just installed 6.8 and have the same issues. 
@samth What should it look like?
@bnoordhuis something like `(open-output-file "file.txt" #:permissions '(read write))`.

Alternatively, `#:permissions 'read-write` or `#:permissions 'read`. Maybe @mflatt has thoughts on what would be most consistent with other APIs.
For `file-or-directory-permissions`, I went with a numerical argument. I'm still not sure that it was the right choice, but it was straightforward and about as general as it could be.
In that case, let's stick with the numeric argument for consistency.
Looking at `file-or-directory-permissions` more, it by default uses the list-of-symbols approach, but also the number approach. Which is a bit confusing, so I'm not sure what the consistent choice would be.
Oh weird. I also noticed that in the first language you were using r5rs, but in the second one you didn't have a language set.
Maybe the preferences file was corrupt (and this discarded).


On Fri, Apr 21, 2017 at 11:39 AM Leif Andersen <notifications@github.com>
wrote:

> Oh weird. I also noticed that in the first language you were using r5rs,
> but in the second one you didn't have a language set.
>
> —
> You are receiving this because you are subscribed to this thread.
> Reply to this email directly, view it on GitHub
> <https://github.com/racket/racket/issues/1671#issuecomment-296241360>, or mute
> the thread
> <https://github.com/notifications/unsubscribe-auth/AAYWsIO30NbcZS5GsJiM6uw7LrgM1aRVks5ryNvGgaJpZM4NCA4Z>
> .
>

Ya, that makes sense. What I was more thinking of was this makes it less likely that background macro expansion somehow killed it. (Although I could be totally wrong about that.)
@Wanghattan Thanks!

I have been able to crash the OS on my VM by using Remote Desktop from a machine (my phone) that is capable of generating touchpad events. I suspect it has something to do with events generated that way.
FWIW, I've compressed the example a bit:

```
#lang racket/base

(module benchmark-info racket/base
  (require racket/contract)
  (provide (contract-out [->benchmark-info any/c]))

  (define ->benchmark-info #f))
(require 'benchmark-info)

(define *sample-rate* (make-parameter #f))

(define (num-configurations->sample-size nc rate)
  (+ nc))

(define (make-lambda cfg)
  (map values cfg))

(define (generate-samples bm-name)
  (void (->benchmark-info bm-name))
  (define random-configuration (make-lambda '()))
  (define sample-size
    (num-configurations->sample-size (*sample-rate*) (*sample-rate*)))
  (for ([i 0])
    (for ([s (in-list sample-size)])
      (void (random-configuration)))))
```
FWIW, I made it smaller still:

```
#lang racket/base

(module benchmark-info racket/base
  (require racket/contract)
  (provide (contract-out [->benchmark-info any/c]))
  (define ->benchmark-info #f))
(require 'benchmark-info)

(define *sample-rate* (make-parameter))
(define (num-configurations->sample-size)
  (void *sample-rate*))
(define (make-lambda cfg)
  (map values cfg))
(define (generate-samples)
  (define random-configuration (make-lambda #f))
  (define sample-size
    (num-configurations->sample-size))
  (for ([i 0])
    (for ([s (in-list sample-size)])
      (->benchmark-info random-configuration))))
```
And...one more time...

```
#lang racket/base

(module benchmark-info racket/base
  (require racket/contract)
  (provide (contract-out [->benchmark-info any/c]))
  (define ->benchmark-info #f))
(require 'benchmark-info)

(define *sample-rate* (void))
(define (num-configurations->sample-size)
  *sample-rate*)
(define make-lambda map)
(define (generate-samples)
  (define random-configuration (make-lambda ))
  (define sample-size
    (num-configurations->sample-size))
  (for ([i 0])
    (for ([s (in-list sample-size)])
      (->benchmark-info random-configuration))))
```
Thanks! At this point, I'm pretty sure the repair is to simply remove an incorrect assertion, but I'll put a little more effort into getting a direct test case – so this smaller example is a helpful starting point.
Okay then. In that case I have one more (slightly) smaller example if that helps.

```
#lang racket/base

(module benchmark-info racket/base
  (require racket/contract)
  (provide (contract-out [+ any/c])))
(require 'benchmark-info)

(define *sample-rate* (void))
(define (num-configurations->sample-size)
  *sample-rate*)
(define (generate-samples)
  (define random-configuration (map))
  (define sample-size
    (num-configurations->sample-size))
  (for ([i 0])
    (for ([s (in-list sample-size)])
      (+ random-configuration))))
```
Thanks, but I'm down to
```
#lang racket/base

(define unknown #f)
(set! unknown unknown)

(define (generate-samples)
  (define random-configuration (unknown))
  (for ([i 0])
    (for ([s (in-list 'obviously-not-a-list)])
      (unknown random-configuration))))
```

Fixed in a71d87c5a9913cd20399e92536959d5b4de3fb3d
I was just about to propose a function vector-immutable! to turn a mutable vector into an immutable one. I would like to use that instead of placeholders. This PR seems to be exactly about that. What is the status here?
`file-or-directory-permissions` accepts a number but not symbols when setting the permissions.<sup>1</sup> Barring objections I'll go with that approach.

<sup>1</sup> Reading permissions is configurable with the `'bits` argument.
No conclusions, but an update: The crash for me consistently happens when I use Remote Desktop on my phone to click in an editor area. (Key and mouse-move events do not trigger the crash.) It doesn't happen with just GRacket. It doesn't happen if I change the GUI library to prevent dequeuing GUI events. The crash does still happen if I allow the GUI library to dequeue events, even if the events are not translated or dispatched.
I've discovered that disabling the Check Syntax tool avoids the crash in my setup.

@Wanghattan or others who see crashes: Does disabling the Check Syntax tool prevent the crash? Normally, you'd disable the tool through the "Tools" panel of the preferences dialog. If you can't get DrRacket to run long enough for that, try editing the file "{Home}/AppData/Roaming/Racket/racket-prefs.rktd" to have

```
(
 (plt:framework-pref:drracket:tools-configuration ((((lib "drracket") "syncheck.rkt") skip)))
)
```
––––––––––––––––––––––––––––––––

On my machine, the crash persists even if I reduce the Check Syntax tool to the implementation below. So, it seems the problem has something to do with extra levels of panel nesting. Removing either `get-definitions/interactions-panel-parent` or `make-root-area-container` makes the crash go away.

Happily, all indications so far suggest a simple workaround. @robby – it looks like `make-root-area-container` isn't needed at all in the current implementation. Is that right? Can we just remove it? That seems to be enough to avoid the crash with my setup.

```
#lang racket/base

(require racket/gui/base
	 racket/unit
         racket/class
         drracket/tool)
(provide tool@)

(define tool@ 
  (unit 
    (import drracket:tool^)
    (export drracket:tool-exports^)
    
    (define (phase1) (void))
    (define (phase2) (void))

    (define unit-frame-mixin
      (mixin (drracket:unit:frame<%>) ()
        
        (define/override (get-definitions/interactions-panel-parent)
          (define report-error-parent-panel
            (make-object vertical-panel%
                         (super get-definitions/interactions-panel-parent)))
          (define res (make-object vertical-panel% report-error-parent-panel))
          res)

        (define/override (make-root-area-container % parent)
          (let* ([s-root (super make-root-area-container
                                vertical-panel%
                                parent)]
                 [r-root (make-object % s-root)])
            r-root))
    
        (super-new)))
    
    (drracket:get/extend:extend-unit-frame unit-frame-mixin #f)))
```
You're absolutely right that that code was useless. I've removed it.
Disabling Check Syntax tool did not help. 

I have to correct my self from the previous post;
"Notice that I don't write anything the second time and same thing happens." 
Seems like I actually did write something.

I've now run DrRacket for about ten minutes, without crashing, but also without writing anything. Seems like as soon as I write something in, it crashes. 

If you guys need any testing I can help out. 
Seems like it's not crashing on The Interactions Window (REPL). Crashing only when I write in the upper textbox. 
Skipping syntax check as @mflatt suggested avoids the crash for me.
Skipping the syntax check also works for me.

The easiest way I've found to reproduce is simply clicking back and forth between the definitions window and the interactive window a few times.
That's what @gus-massa's `unsafe-vector*->immutable-vector!` pull request (https://github.com/racket/racket/pull/1237) is about. It would make libraries like this cheaper by getting rid of unnecessary allocations.

I'm not sure what the status is. I don't know whether it would be best to make separate functions (this pull request) or to add optional keyword arguments to the existing ones (https://github.com/racket/racket/pull/1341). There are different problems for both.
Well, I can still crash the OS by using "Touch" input mode in the Remote Desktop app, as opposed to "Mouse" input mode. Between that and @Wanghattan's experience, it seems the current workaround isn't enough.
Here's a program that blue-screens as soon as I move my regular mouse (no Remote Desktop needed) into the window.

I had tried this yesterday, but I only went up to 16. A depth of 32 appears to be the minimum value that triggers the blue screen.

```
#lang racket/base
(require racket/class
	 racket/gui)

(define f (new frame%
	       [label "Test"]
	       [width 600]
	       [height 400]))

(define p
  (for/fold ([p f]) ([i (in-range 32)])
     (new vertical-panel% [parent p])))

(void
 (new editor-canvas%
      [parent p]
      [editor (new text%)]))

(send f show #t)
```
I'm sitll not convinced if `unsafe-vector*->immutable-vector!` is a good idea or not. I prefer this ugly long name, so it's clear that it's a weird operation with strict conditions. It will return the same vector magicaly marked as immutable, but it also may return a new inmmutable vector, or perhaps a cached version???. My proposal was to just set the immutable flag, becaause it's easier and faster.

The problem of using `vector->immutable-vector!` is that it may break some code, like this:

    #lang racket
    
    (define (my-v-immutable? v)
      (eq? (vector-ref v 0) 'immutable))
    
    (define (my-v->immutable! v)
      (vector-set! v 0 'immutable))
    
    (define (my-v-set! v n val)
      (when (my-v-immutable? v)
        (error "nasty error :( :( :( :( :( :( :("))
      (vector-set! v n val))
    
    ;---
    
    (define (something v)
      (sleep (random))
      (when (my-v-immutable? vec)
        (error "nice error :)"))
      (sleep (random))
      (my-v-set! vec 1 7))
    
    (define vec (vector 'mutable 1))
    
    (void (thread (lambda ()
                    (sleep (random))
                    (sleep (random))
                    (my-v->immutable! vec))))
    
    (something vec)
    (vector-ref vec 1)

the function `something` looks good. It has a nice error in case someone use an immutable vector, but if you run this a few time you will get a race condition that makes the program raise the nasty error.

My other concer was that `vector->immutable-vector!` may confuse a future version of the bytecode optimizer. I think the current version ignores immutability of vectors, so there are currently no problems with something like this.

Anyway, the plan is to change the current VM of Racket and use the VM of Chez Scheme. See https://groups.google.com/forum/#!msg/racket-dev/2BV3ElyfF8Y/4RSd3XbECAAJ

So I guess that adding weird new procedures is on hold.
`unsafe-vector*->immutable-vector` would be useful in several places that I know of, including in the contract library, where the same operation is performed by copying. So adding this odd procedure in the near term seems like a useful idea to me.
@samth I would like to have it to create immutable cyclic datastructures. but why not a nicer name like vector->immutable-vector! what is unsafe about it? I dont think it matters for the underlying vm or wont matter with chez, or does it?

What are the preconditions that make existing code fail in weird ways? 



@minad The reason that it's unsafe is that code can currently rely on vectors not to change to be immutable, and so the new function would break the assumptions of current code. The precondition of the function would presumably be that no one else has a reference to the vector, which the function would not check. Generally, `unsafe` means that the procedure has unchecked preconditions.
@mfelleisen I'm not sure what you're asking. The bad thing that could happen is just what @gus-massa describes.

I understand that. But can we formulate a general pre-condition when these bad things can’t happen? 



> On Apr 24, 2017, at 8:25 AM, Sam Tobin-Hochstadt <notifications@github.com> wrote:
> 
> @mfelleisen I'm not sure what you're asking. The bad thing that could happen is just what @gus-massa describes.
> 
> —
> You are receiving this because you were mentioned.
> Reply to this email directly, view it on GitHub, or mute the thread.
> 



p.s. I guess the pre-condition is “no other thread assumes that this vector is immutable and the upstream flowgraph doesn’t either.”  W/o a Rust like type system, we may not be able to get there. 




> On Apr 24, 2017, at 8:25 AM, Sam Tobin-Hochstadt <notifications@github.com> wrote:
> 
> @mfelleisen I'm not sure what you're asking. The bad thing that could happen is just what @gus-massa describes.
> 
> —
> You are receiving this because you were mentioned.
> Reply to this email directly, view it on GitHub, or mute the thread.
> 


I think the precondition is "no one else has a reference to the vector". Which we can't check, and so it's an `unsafe` function.


[[ Now that’s a non-sequitor. We can’t check unsafe-vector-ref either but in Andrew’s refinement type system we can. ]] 



> On Apr 24, 2017, at 9:59 AM, Sam Tobin-Hochstadt <notifications@github.com> wrote:
> 
> I think the precondition is "no one else has a reference to the vector". Which we can't check, and so it's an unsafe function.
> 
> —
> You are receiving this because you were mentioned.
> Reply to this email directly, view it on GitHub, or mute the thread.
> 


I think the definition of `unsafe` in Racket is "could violate system invariants if used without following preconditions, where those preconditions are not enforced".

There is 

 — not enforced but enforceable in principle 
 — not enforceable, period 

I thin the two are distinct and this one is of the second kind and thus more worrisome than then first. 


> On Apr 24, 2017, at 10:17 AM, Sam Tobin-Hochstadt <notifications@github.com> wrote:
> 
> I think the definition of unsafe in Racket is "could violate system invariants if used without following preconditions, where those preconditions are not enforced".
> 
> —
> You are receiving this because you were mentioned.
> Reply to this email directly, view it on GitHub, or mute the thread.
> 


Just as @pnwamk's additions to TR can enforce the contract on `unsafe-vector-ref` (or just a dynamic check), an affine type system or a more expensive dynamic check (such a reference counts) could enforce that precondition.  Similar hard-to-enforce preconditions: the FFI requires lots of things of C code in order to be safe, `unsafe-chaperone-procedure` omits very-hard-to-verify dynamic check, etc.

See above. 


> On Apr 24, 2017, at 10:26 AM, Sam Tobin-Hochstadt <notifications@github.com> wrote:
> 
> Just as @pnwamk's additions to TR can enforce the contract on unsafe-vector-ref (or just a dynamic check), an affine type system or a more expensive dynamic check (such a reference counts) could enforce that precondition. Similar hard-to-enforce preconditions: the FFI requires lots of things of C code in order to be safe, unsafe-chaperone-procedure omits very-hard-to-verify dynamic check, etc.
> 
> —
> You are receiving this because you were mentioned.
> Reply to this email directly, view it on GitHub, or mute the thread.
> 


I prefer a stricter condition. “There are no other references to this vector anywhere, and I promise to not use this reference again”. 

My idea was to use this in straightforward cases, where the result of a primitive is guaranteed to be a fresh vector (or string) so it’s obvious that there are no other references anywhere, for example to transform 

    (vector->immutable-vector (list->vector a-long-list))

to

    (unsafe-vector*->immutable-vector! (list->vector a-long-list))

I think it’s ok to extend the uses cases to something like 

    (define (make-long-vector n a b c)
      (unsafe-vector*->immutable-vector! 
        (let ([v (make-vector n b)])
          (vector-set! v 0 a)
          (vector-set! v (-n 1) c)
          v)))

because it is applied to the only reference to the vector that is alive.

And by extension to equivalent code like 

    (define (make-long-vector n a b c)
      (let ([v (make-vector n b)])
        (vector-set! v 0 a)
        (vector-set! v (-n 1) c)
        (unsafe-vector*->immutable-vector! v)))

but now is not so obvious what “alive” means. Probably something like: `v` is never used in the continuation.

But I wouldn’t like something like

    (define (make-long-vector n a b c)
      (let ([v (make-vector n b)])
        (vector-set! v 0 a)
        (vector-set! v (-n 1) c)
        (unsafe-vector*->immutable-vector! v)
        v))

I don’t know too much about rust(!!!). but IIRC in rust after you use a reference as an argument you lose the ownership and you can't use it again. Also, I think you can enforce that all the borrowed references are released and you have the only and true reference. 

And for more complex flows, if they can implement reference counting as a library I guess they can extend it to check that there is only one reference alive. I'm not sure if they have a garbage collector to breack cycles, because you have to be sure that all the temporal reference have been collected.


Your uses are good. (I could extend the set! calculus and prove them syntactically correct.) But I like to think of unsafe-foobar! as something that comes with pre-conditions that we can check or validate somehow in general and in a reasonably efficient manner. This one appears to impose a large run-time cost and/or a thoroughly complicated/new type system. 






> On Apr 24, 2017, at 11:58 AM, gus-massa <notifications@github.com> wrote:
> 
> I prefer a stricter condition. “There are no other references to this vector anywhere, and I promise to not use this reference again”.
> 
> My idea was to use this in straightforward cases, where the result of a primitive is guaranteed to be a fresh vector (or string) so it’s obvious that there are no other references anywhere, for example to transform
> 
> (vector->immutable-vector (list->vector a-long-list))
> 
> to
> 
> (unsafe-vector*->immutable-vector! (list->vector a-long-list))
> 
> I think it’s ok to extend the uses cases to something like
> 
> (define (make-long-vector n a b c)
>   (unsafe-vector*->immutable-vector! 
>     (let ([v (make-vector n b)])
>       (vector-set! v 0 a)
>       (vector-set! v (-n 1) c)
>       v)))
> 
> because it is applied to the only reference to the vector that is alive.
> 
> And by extension to equivalent code like
> 
> (define (make-long-vector n a b c)
>   (let ([v (make-vector n b)])
>     (vector-set! v 0 a)
>     (vector-set! v (-n 1) c)
>     (unsafe-vector*->immutable-vector! v)))
> 
> but now is not so obvious what “alive” means. Probably something like: v is never used in the continuation.
> 
> But I wouldn’t like something like
> 
> (define (make-long-vector n a b c)
>   (let ([v (make-vector n b)])
>     (vector-set! v 0 a)
>     (vector-set! v (-n 1) c)
>     (unsafe-vector*->immutable-vector! v)
>     v))
> 
> I don’t know too much about rust(!!!). but IIRC in rust after you use a reference as an argument you lose the ownership and you can't use it again. Also, I think you can enforce that all the borrowed references are released and you have the only and true reference.
> 
> And for more complex flows, if they can implement reference counting as a library I guess they can extend it to check that there is only one reference alive. I'm not sure if they have a garbage collector to breack cycles, because you have to be sure that all the temporal reference have been collected.
> 
> —
> You are receiving this because you were mentioned.
> Reply to this email directly, view it on GitHub, or mute the thread.
> 


Thanks!

I don't think a second blame object deftech is needed.

Robby

Oh, stupid me. I misread the diff. Sorry.
What contracts do you plan to use `unsafe-chaperone-vector` for?
Space-efficient vector contracts.
I understand how chaperone-vector* helps there, but how does that use the
unsafe version?

On Wed, Apr 26, 2017, 5:24 PM Vincent St-Amour <notifications@github.com>
wrote:

> Space-efficient vector contracts.
>
> —
> You are receiving this because you commented.
>
>
> Reply to this email directly, view it on GitHub
> <https://github.com/racket/racket/pull/1675#issuecomment-297545437>, or mute
> the thread
> <https://github.com/notifications/unsubscribe-auth/AAO7844sgoyVsZqselfj-hvKOelhy_iaks5rz7X_gaJpZM4NJb8C>
> .
>

Its use is to allow "peeling back" an existing contract while preserving identity.
The idea is to use the existing contract machinery when a value gets its first contract, but if it gets a second, we switch to the (more expensive) space-efficient machinery and "replace" the original contract with a merged version of the two.
In that situation, the two arguments to unsafe-chaperone-vector are both
chaperones of the same underlying vector, right? Would it be worth
enforcing that with a dynamic check? Or maybe mentioning it in the docs.

On Wed, Apr 26, 2017, 5:30 PM Vincent St-Amour <notifications@github.com>
wrote:

> Its use is to allow "peeling back" an existing contract while preserving
> identity.
> The idea is to use the existing contract machinery when a value gets its
> first contract, but if it gets a second, we switch to the (more expensive)
> space-efficient machinery and "replace" the original contract with a merged
> version of the two.
>
> —
> You are receiving this because you commented.
> Reply to this email directly, view it on GitHub
> <https://github.com/racket/racket/pull/1675#issuecomment-297546805>, or mute
> the thread
> <https://github.com/notifications/unsubscribe-auth/AAO78_mKwl6Wx-OwkXicDLrgJ4a5hOx4ks5rz7dLgaJpZM4NJb8C>
> .
>

They are, in that particular case. But I see that more as a property of the particular use case, rather than of `unsafe-chaperone-vector` in general. It should, IMO, stick as closely as possible to `unsafe-chaperone-procedure`, which doesn't check the analogous property.
An update: Racket version 6.9 will ship with the workaround that we have, which reduces the OS crash for many of you. It's not a complete workaround; I think it just makes DrRacket less likely to trip over the bug.

The root problem appears an OS bug, and there appears to be no Racket bug involved. I've written a one-page C program that tends to blue-screen Windows 10 Creators Update (and not earlier version of Windows) independent of Racket. A member of the Windows group at Microsoft has been able to replicate the crash using that program. So, there's some hope that the OS will get fixed – but no promises.
I don't see any problems in the implementation just by looking. So, except maybe for the documentation issues, this seems ok to me.
I see how the set of implications is a better form of documentation overall, but I think some information has gotten lost.

The main lost information has to do with values that are not impersonators but contain impersonators. For example, a list can contain an impersonated value. The list itself is not an impersonator, but `impersonator-of?` for the list is not simply `equal?`.

Some information on hash tables hash also gotten lost – specifically the meaning of `impersonator-of?` in the case of a chaperoned immutable hash table that has been updated (to obtain a new hash table that is also an impersonator) via `hash-set`. It probably makes more sense to put that information in `chaperone-hash`, though.

The mention of `prop:imperonsator-of` is also gone with this patch, but as far as I can tell, it works to rely on `prop:impersonator-of` to define its contribution to the definition of "impersonates".
Thanks! We'll work those back in.
I think these changes address your comments.
Detangled the doc changes from #1666 and merged, with the requested changes.
Yes, I think this works.
Merged, thanks for the feedback!
Thanks, merging.
@mflatt , I believe I'm seeing the same error. On a Windows 10 laptop with Racket 6.8 and 6.9, I've had my system crash giving this error 
![image](https://cloud.githubusercontent.com/assets/9343364/25704515/56c9bfd0-309f-11e7-894f-cac00142d2ee.png).

I do not have this error on my Windows 10 desktop pc, which I've been using instead. I'm not sure exactly what's causing the error, as it seems to be any time I'm using DrRacket. My system is otherwise stable and I've tried the Microsoft troubleshooting (updates, drivers, clean boot). The signs point to some application interference with DrRacket and Windows (or Firefox, which is the only other consistent application).

I'd be glad to dig into some crash logs if I can find them and you can tell me what to look for.

@mookie-blaylocks Is your laptop running Windows 10 Creators Update? If so, see #1671 (but it isn't good news).
@mflatt Thanks for that! It does appear to be the same bug, as I can reproduce the problem with touchpad scrolling. Most other functions seem to work fine, and scrolling with a usb mouse is also fine. I also confirmed there is no problem with my Thinkpad on Linux, so the bug appears to be Windows specific, as suggested.
The `~or` has two meanings (which is unfortunate). It can mean it can mean "pick any number of each of these alternatives"  when directly under ellipses (nested `~or` clauses are inlined, and therefore also count as "directly under ellipses"), and it can otherwise mean "either a or b".

When you wrote `{~or a b} ...`, the former meaning is used, but when it gets wrapped with `{~describe "blah" {~or a b}} ...`, the latter meaning is used.

While `{~or {~optional a} {~optional b}} ...` means "any sequence of `a`s and `b`s, in no specific order, with at most one `a` and at most one `b`", the second version `{~describe "blah" {~or {~optional a} {~optional b}}} …` means "any sequence of `x`s or `y`s, in no specific order", where `x` means "either a or nothing", and `y` means "either b or nothing". In the second version, each element of the sequence can therefore be `a`, `b` or nothing (hence the error `an ellipsis-head pattern matched an empty sequence`), and there is no bound on the number of occurrences of `a` or `b`. The changes in https://github.com/racket/racket/issues/1359 therefore allowed a legitimate problem be detected in this case, because the meaning of the two clauses is rather different.

I see a few possible fixes:

1. Add a `#:name name-expr` parameter to `or^eh`, similarly to the `#:name name-expr` parameter of `~optional^eh`. Unfortunately, this would be ambiguous, as `#:name` and `name-expr` could be interpreted as alternatives among which `~or^eh` picks in parallel.
2. Change `~describe` so that it includes a `~describe^eh` version, which interprets a `~or` directly within as a `~or^eh` (i.e. the second meaning of `~or`). Unfortunately, it is quite possible that some programs rely on the fact that `~describe` prevents `~or` form being interpreted as an ellipsis-head. The common solution to force `~or` to have its first meaning is to write `{~and {~or alt1 alt2}} …`. I have an [`{~either . alternatives}`](http://docs.racket-lang.org/phc-toolkit/syntax-parse_helpers.html#%28form._%28%28submod._%28lib._phc-toolkit%2Fsyntax-parse..rkt%29._typed%29._~7eeither%29%29) pattern expander in my personal toolkit which expands to `{~and {~or . alternatives}}`. Hopefully nobody used `~describe` with this goal, but we can't know for sure, and that would be a rather insidious breaking change.
3. Deprecate `~or`, and introduce instead `~either` with the first meaning, and `~alts` (which needs a better name) with the second meaning. We could then make it so that `~deccribe` becomes `~describe^eh` when it directly contains a `~alts`, without it being a breaking change. This would also avoid a lot of headaches for newcomers and seasoned racketeers alike, as I frequently get myself bitten by `~or`'s heisen-behaviour, and it took me a couple of minutes to realise what was going on here.
4. Add a `#:describe` option to `define-splicing-syntax-class`, specifically for this use case.

As a final remark, I would say that having the whole list of options could be desirable anyway. I frequently grubmle because `syntax-parse` fails to produce useful error messages from complex patterns (and I'm guilty of laziness and not using `~describe` everwhere I should), so forcing it to be less specific in its error messages seems counter-productive :) . Unless the message is really huge, of course, but if it only lists keywords, it seems fine to me.
The documentation seems pretty clear to me that that's not what this message means. Perhaps you can suggest an edit to it?

@rfindler This isn’t about documentation but psychological context and conditioning. We tell people everywhere that blame information helps them discover the bug. When I blame party P via contract C, it is either P (or one of its server modules) or C that is wrong (or both). So I wouldn’t think of fixing P-opposite here. But as it turns out, that’s exactly what we want to fix when things go wrong with invariant-assertion. 

I fully understand that
 (1) the documentation says there is no boundary 
 (2) it also says that because you compile this construct into Racket machinery, you may end up seeing “blame messages” 
 (3) and that these blame messages always blame the surrounding context. 

If I were someone with an intuitive understanding of contracts (from Eiffel or Racket) I wouldn’t read that far. I’d read the name of the ’thing’, skip to the example, see the sentence above (which confirms that this is what I want) and be happily off. Indeed, as someone who knows Racket’s contract system :-) I read the paragraph, decided that it meant the expansion was what I had proposed to Prager and promptly forgot  about it (kind of). 

Does this clarify where I come from? I do not see this as a doc fix. The best I can think of right now is a name fix (invariant-assertion-do-not-read-blame-message). Sorry. 



> On May 6, 2017, at 11:14 PM, Robby Findler <notifications@github.com> wrote:
> 
> The documentation seems pretty clear to me that that's not what this message means. Perhaps you can suggest an edit to it?
> 
> —
> You are receiving this because you authored the thread.
> Reply to this email directly, view it on GitHub <https://github.com/racket/racket/issues/1681#issuecomment-299679568>, or mute the thread <https://github.com/notifications/unsubscribe-auth/ABf5-5pwHwoW2dtk43pF8G56HYhCjTc_ks5r3TcogaJpZM4NS7qX>.
> 


The issue clearly reads as if it were written by someone with a deep knowledge of the contract system (even without looking at the name), so I responded in kind. 

In particular, I don't think that a casual user would jump to the conclusion "blaming `anonymous-module` which suggests the surrounding region". There are concepts there that they won't have internalized yet.

Indeed, I think a casual user would interpret "blaming `anonymous-module`" as "something is wrong with my module", which is exactly what the error message says.

But I also don't understand what you mean when you write " So I wouldn’t think of fixing P-opposite here. But as it turns out, that’s exactly what we want to fix when things go wrong with invariant-assertion." The message is telling you to fix "P". There is no "P-opposite" that I see to fix here.

All that said, it may be easier for us not to talk past each of if you were to provide an edited version of the contract violation message that would have clarified for you. I'll suggest one to start:

```
unsafe-factorial: assertion violation
  expected: (and/c real? (not/c negative?))
  given: -5
  in: an and/c case of
      the 1st argument of
      (->
       (and/c
        integer?
        (and/c real? (not/c negative?)))
       (and/c
        integer?
        (and/c real? (not/c negative?))))
  assertion from: anonymous-module
  at: unsaved-editor:21.3
```


> On May 7, 2017, at 8:50 AM, Robby Findler <notifications@github.com> wrote:
> 
> The issue clearly reads as if it were written by someone with a deep knowledge of the contract system (even without looking at the name), so I responded in kind.
> 
> In particular, I don't think that a casual user would jump to the conclusion "blaming anonymous-module which suggests the surrounding region". There are concepts there that they won't have internalized yet.
> 
> Indeed, I think a casual user would interpret "blaming anonymous-module" as "something is wrong with my module", which is exactly what the error message says.
> 
> But I also don't understand what you mean when you write " So I wouldn’t think of fixing P-opposite here. But as it turns out, that’s exactly what we want to fix when things go wrong with invariant-assertion." The message is telling you to fix "P". There is no "P-opposite" that I see to fix here.
> 
> All that said, it may be easier for us not to talk past each of if you were to provide an edited version of the contract violation message that would have clarified for you. I'll suggest one to start:
> 
> 


I apologize for using language that implies I know what’s going on. I should have written it purely from the perspective of someone who (1) read posts on our mailing list (on boundaries and blame and such) and (2) reads ‘blaming . . . ‘ as what it means. 

Here is my suggested edit: 

> unsafe-factorial: assertion violation
>   expected: (and/c real? (not/c negative?))
>   given: -5
>   in: an and/c case of
>       the 1st argument of
>       (->
>        (and/c
>         integer?
>         (and/c real? (not/c negative?)))
>        (and/c
>         integer?
>         (and/c real? (not/c negative?))))
contract from: anonymous-module
  blaming: unsafe-factorial 
   (assuming the contract is correct)
  at: unsaved-editor:21.3

It is the internal function call that triggers the ‘unsafe-factorial’. 

Now I happen to know that the only way to get this with our contract machinery is by crossing a boundary. I also happen to know that this means ‘invariant-assertion’ has to place it outside of the definition of unsafe-factorial. But that’s not the impression that the function definition gives. 




I don't understand the paragraph "Now I happen ... function definition gives". Can you elaborate, please?

And maybe this is the same thing, but I'm also not seeing how, in the general case, to get the words that follow the "blaming:" in a way that would specialize to what you wrote. In this example, I could get them by asking what name is syntactically outside the `invariant-assertion` and `define` and other binding forms collaborate to supply that information (but I'm not sure if that is what you had mind for the contract system to get it).

I think the issue is "simply" that `d_namelen` does not exist, and Haiku's porting guide says to `#define` it to `d_reclen` (which we had done). But `d_reclen` gives the length of the whole C `struct`, not just the name length, so we need to subtract a few bytes.

```
#define d_namlen ((d_reclen) - sizeof(dirent_t))
```
fwiw this is unclear to me (just reading the new doc, and none of the context), maybe change to:

```
Independent of whether @var{strong} is zero, the value @var{o} is
initially weakly held, but becomes strongly held if the garbage collector
attempts to collect it.
```

but I'm not sure my edit is correct
If we replace `if` with `when` that sounds pretty close to my understanding. I'll make that change.
I don't think that there is an easy way. My best guess at a way would be if the runtime system opened up the stacktrace API that it uses so that macros could strategically place additional marks and then `define/contract` could place a mark at all call sites of the functions.

This doesn't seem like a very good idea to me, tho.
Hm, I had looked too quickly, the blame information points to the definition of the contracted function (line 2, column 18), not the call.

Feel free to close this as there is no easy fix.
I'm closing this for now (enabling debugging info is likely the best solution).

@rfindler What I am saying is that I understand how the contract system view forces you to assign blame to the module. (But I tested this on Shriram and Justin at SNAPL and they also see this as a failure of the function itself. FWIW, they are also studying psychological aspects of blame assignment.) 




> On May 7, 2017, at 1:35 PM, Robby Findler <notifications@github.com> wrote:
> 
> I don't understand the paragraph "Now I happen ... function definition gives". Can you elaborate, please?
> 
> And maybe this is the same thing, but I'm also not seeing how, in the general case, to get the words that follow the "blaming:" in a way that would specialize to what you wrote. In this example, I could get them by asking what name is syntactically outside the invariant-assertion and define and other binding forms collaborate to supply that information (but I'm not sure if that is what you had mind for the contract system to get it).
> 
> —
> You are receiving this because you authored the thread.
> Reply to this email directly, view it on GitHub <https://github.com/racket/racket/issues/1681#issuecomment-299732720>, or mute the thread <https://github.com/notifications/unsubscribe-auth/ABf5-7YaPn2bqv2V7WK4KnFNdA1DiuD9ks5r3ir9gaJpZM4NS7qX>.
> 


The contract system view does not force me to assign blame to the module. It is a choice I made in the design of invariant-assertion and one I'm happy to change.

My question about how to get the content of the line following the "blaming" seems to still stand, however?

Can you explain how to assign blame to the function with the contract system (w/o going to the lower level primitives)? 


> On May 11, 2017, at 4:07 AM, Robby Findler <notifications@github.com> wrote:
> 
> The contract system view does not force me to assign blame to the module. It is a choice I made in the design of invariant-assertion and one I'm happy to change.
> 
> My question about how to get the content of the line following the "blaming" seems to still stand, however?
> 
> —
> You are receiving this because you authored the thread.
> Reply to this email directly, view it on GitHub <https://github.com/racket/racket/issues/1681#issuecomment-300757467>, or mute the thread <https://github.com/notifications/unsubscribe-auth/ABf5-85CN7uaPoV2KRzVlfC_gYQPGfxcks5r4uwEgaJpZM4NS7qX>.
> 


No, I cannot explain how to assign blame to the function. I think that my inability to do that is what I have been saying all along here. 

I also don't see why my previous comment would lead you to write that question, so let me unpack my actual thinking a little bit?

1) I agree that it is natural to think that you should fix the function in this example

2) I have been saying for a long time that the "blaming" line (and blame in general) is trying to capture the idea "fix this code (or change the contract) to eliminate this error".

3) the current implementation of invariant assertion arbitrarily picks a module boundary and uses both parties the same. 

4) but this choice is clearly wrong because when an assertion fails, all we can say is "fix something in the program". We can't be more specific than that.

5) So I stand by my earlier suggestion and I still think we should just eliminate the blaming line because it has no useful information (it cannot say something more specific than "change your program" ala item 2)

> On May 11, 2017, at 7:35 AM, Robby Findler <notifications@github.com> wrote:
> 
> No, I cannot explain how to assign blame to the function. I think that my inability to do that is what I have been saying all along here.
> 
> 

Because I want to name the function. 


> I also don't see why my previous comment would lead you to write that question, so let me unpack my actual thinking a little bit?
> 
> I agree that it is natural to think that you should fix the function in this example
> 
> I have been saying for a long time that the "blaming" line (and blame in general) is trying to capture the idea "fix this code (or change the contract) to eliminate this error".
> 
> 

We have both been saying this, and I directed an entire dissertation on this. Christos’s work confirms all this. 

> 
> the current implementation of invariant assertion arbitrarily picks a module boundary and uses both parties the same.
> 
> 

I am going further. I suspect you cannot pick any “correct pair of names.” 

> 
> but this choice is clearly wrong because when an assertion fails, all we can say is "fix something in the program". We can't be more specific than that.
> 
> So I stand by my earlier suggestion and I still think we should just eliminate the blaming line because it has no useful information (it cannot say something more specific than "change your program" ala item 2)
> 
> 

Are you saying “in general” or “for this specific example”? 






> 
> —
> You are receiving this because you authored the thread.
> Reply to this email directly, view it on GitHub <https://github.com/racket/racket/issues/1681#issuecomment-300763119>, or mute the thread <https://github.com/notifications/unsubscribe-auth/ABf5-4FdDvXiOdTem4zGk4haoxVL-7U-ks5r4vJ5gaJpZM4NS7qX>.
> 


re "Are you saying ...": I am saying this in general for `invariant-assertion`. That is, I do not see that there are any natural boundaries to delimit blame assignment when using this construct. If that makes sense to you, then I think the only logical next step is to eliminate the "blaming" part of the error message. (It is essential to keep the source location of the assertion itself, of course.)

Put another way, I see `invariant-assertion` as a way to re-use the contract combinator library to do some useful checking in a context where you don't really have a natural boundary. You still want to know that, say, some expression always produces a function that does something good, but it is some internal part of your program and you just want the checking even though you don't have a boundary. (This is what I understood @dvanhorn 's argument when I first added this construct.)
I think removing the "blaming" line from this construct (invariant-assertion) is a good solution here. 
Just to make this clear. My remarks about "channels of communication" are not an objection but a timely observation. We have other holes like this one. We just need to be aware of them. 
This seems like a good idea, but I'm not sure about the name. What about
matches?

On Fri, May 12, 2017, 11:46 AM Leandro Facchinetti <notifications@github.com>
wrote:

> *FEATURE PROPOSAL*
>
> Add match? to racket/match. It is given a subject expression and a
> pattern, if the expression evaluates to a value that matches the pattern,
> then match? returns #t, otherwise it returns #f. Here’s a proposed
> implementation:
>
> #lang racket
> (require syntax/parse/define)
>
> (define-simple-macro (match? subject:expr pattern:expr)
>   (match subject
>     [pattern #t]
>     [_ #f]))
>
> (match? `(a b) `(,c ,d)) # => #t
>
> ------------------------------
>
> If you agree with this proposal, please let me know and I’ll send a pull
> request.
>
> Thanks.
>
> —
> You are receiving this because you are subscribed to this thread.
> Reply to this email directly, view it on GitHub
> <https://github.com/racket/racket/issues/1690>, or mute the thread
> <https://github.com/notifications/unsubscribe-auth/AAO78y51FGzkCcAtE7m1qAc2TFE6YEpIks5r5H7RgaJpZM4NZdcT>
> .
>

I thought `matches?` at first, too, but the `match?` name is actually more consistent with `regexp-match?` and `redex-match?`.
We need to consider [potential conflicts](https://docs.racket-lang.org/search/index.html?q=match%3F). Particularly interesting is that it seems [`match?` was a thing](https://docs.racket-lang.org/unstable/match.html?q=match%3F#(form._((lib._unstable%2Fmatch..rkt)._match~3f))) in the past.
Well, that wasn't any more of thing in the past than now, but it suggests we should use that name. But we do need to make sure there aren't conflicts.
@mflatt Should we merge this?
Yes, looks good.
Merged, thanks!
for me and my brother, right clicking something and selecting Jump to next bound occurrence causes the blue screen 100% of the time.
Based on what `racket` provides in terms of regexp predicates, and the availability of syntax-class combinators, I would suggest including only `rx`, `px`, `byte-rx` and `byte-px` (names aside).
I think the most common one to use would be something that match all forms of regular expressions (px/rx/byte/pbyte).
I could see Sam's suggestion being widely used as well. (Although, it makes me wonder if/why there isn't a px/rx/byte/pbyte predicate...)
It looks like you're also fixing a bug where `character` was the syntax class defined/provided, but the docs said `char` -- and you want to provide and doc both, now?

If so:

- That's great!

- I don't see where `char` is defined?

- A bit nit-picky: Because `char?` is the actual Racket predicate, I think `char` should stay in the main list, and `character` should be documented as the thing that's an alias (for `char`)?
How about I add the special power to attach syntax classes to existing bindings, and we call them `regexp`, `pregexp`, etc? (With this new power we can also rename `str` to `string` for the syntax class that recognizes literal strings, which has been a long-standing minor irritation to me.)

My inclination is to make this power available only to `syntax/parse/private/lib`, not as a user-level feature.

See also http://macrologist.blogspot.com/2013/06/define-vs-attach.html
@rmculpepper I like that idea.
Thanks!
@greghendershott `char` is defined as an alias of `character` a bit below my changes in the `lib.rkt` file, [line 60](https://github.com/jsmaniac/racket/blob/8bc9cef7a9d3c118438b5436af8ec020d363ea7a/racket/collects/syntax/parse/private/lib.rkt#L60) of the original. That section also contains the `nat` and `id` aliases. I agree that `char` is more intuitive, though.

@rmculpepper That sounds much better than re-inventing names — `str` always felt like a bit of a hack.
@wilbowma, @samth concerning the availability of a single px/rx/byte/pbyte predicate, I made a few quick tests and it seems that it is possible to match strings with byte-regexps (which implicitly convert the string, I suppose using utf-8?), and byte-strings with regexps. However, if either the string or the regexp is a `byte-`, then the resulting match object contains byte-strings.

The behaviour when mixing the types is therefore a bit iffy, and is likely to cause havoc further down the line. It will also be unlikely be unexpected by macro-writers, so after reconsidering it, it might be better to force macro-writers to be explicit when mixing different kinds of regexps (especially since the point of having a `:regexp` pattern will be to perform some operations with it at compile-time, so the macro-writer should likely know against which type of strings the (byte-)regexp will be used).
Hi,

I install and open v6.9 successfully. 

If you meet this error `LSOpenURLsWithRole() failed with error -10810 for the file /Applications/Racket v6.9/DrRacket.app.` you could have a try these steps:

1. delete all of your pervious installation - just remove the v6.9 directory into trash
2. change the option of `Security & Privacy -> Allow apps downloaded from` to be `App Store and identified developers`
3. reinstall  v6.9 - drop v6.9 directory into `/Applications`
4. `open DrRacket.app` 

good luck :)
I too was able to install and open 6.9 successfully. Didn't delete any of the older versions though. Just dropped 6.9 into `Applications` and it worked wonderfully.
Unfortunately it's not really possible to make "Report a bug" work in general because of GitHub's authentication model, but I have some plans/code to work on that that I need to finish up.
I still get the following error with 6.9:

    $ open DrRacket.app
    LSOpenURLsWithRole() failed with error -10810 for the file /Applications/Racket v6.9/DrRacket.app.
I have had the same experience and have opened [jaor/geiser Issue #212](https://github.com/jaor/geiser/issues/212) to report it.

Thank you.
I've added internal support for attaching syntax classes to existing bindings, and I've done so for `string` and `bytes`.

My current preference is to add only `regexp` to `syntax/parse/private/lib` (and thus `syntax/parse`) for now. It's not clear to me that making finer distinctions between regexp types *in patterns* (as opposed to in compile-time helper functions) will be useful. If you try it and think they're useful, we could create a `syntax/parse/lib/regexp` library for them.

On the one hand, it's kind of weird to have these functions be missing, while (1) their siblings exist and (2) their (less useful) inexact analogs exist. On the other, adding those may cause clashes, like adding `positive-integer?` and co did. It's not clear which is better.
Inexact integers just make me sad.
I have a PR ready to update the contract & documentation at https://github.com/jsmaniac/racket/tree/fix-1697-collapse-module-path-index-contract .

Are there any uses of `collapse-module-path-index` within the Racket library which need to be updated to take into account the `#false` case?
@rmculpepper What should that single `:regexp` pattern match, then? Both regular expressions and byte regexp? It would be semantically different then (as functions, `regexp?` vs `byte-regexp?`, and as a pattern, `:regexp` matching both).

I'm fine with not making the distinction between `pregexp?` and `regexp?`, especially since the `regexp?` predicate does not make the distinction either. Merging `regexp` and `byte-regexp` seems more iffy to me though. As I said earlier, `regexp-match` changes its return type from `string?` to `byte-string?` if matching a plain string against a `byte-regexp?`.

Here's an example where a macro might want part of its syntax to be a `regexp?`, and feeding a `byte-regexp?` instead ostensibly causes issues:

```racket
#lang racket
(require (for-syntax syntax/parse syntax/stx))
(define-syntax shorten-names
  (syntax-parser
    [(_ rx long-name:id ...)
     #:when (or (regexp? (syntax-e #'rx))
                (byte-regexp? (syntax-e #'rx))) ;; oops
     #:with (short-name ...)
     (stx-map (λ (n)
                (datum->syntax n
                               (string->symbol
                                (car
                                 (regexp-match (syntax-e #'rx)
                                               (symbol->string
                                                (syntax-e n)))))))
              #'(long-name ...))
     #'(begin
         (define-syntax short-name
           (make-rename-transformer #'long-name))
         ...)]))

(define foo 1)
(define → 2)
(shorten-names #px"^." foo →) ;; works fine

(define bar 3)
(define … 4)
(shorten-names #px#"^." foo →) ;; error:
;; string->symbol: contract violation
;;   expected: string?
;;   given: '(#"\342\206\222")
```
@rmculpepper I updated my patch based on your overloading of `string` as a syntax class. Before I push, one quick question:

Should `string`, `regexp` and `byte-regexp` be provided by `lib.rkt`?

The rationale being that they are documented as part of syntax/parse, so it should export them, especially since several other languages have their own binding for `string`, so you'd want the name clash to occur rather than a failure to recognise the `:string` as a syntax pattern). Or should I leave them out of the `provide` (the rationale being that the identifiers are already exported by `racket/base`, so there's no need to re-export them)?
Whoops, for some reason I thought `regexp?` recognized byte-regexps too, but it doesn't. You're right, let's add both `regexp` and `byte-regexp` to `syntax/parse/private/lib` and keep the meanings consistent with the corresponding predicates.

Regarding whether they should be exported: that's a good question, and I'm not sure which side of the trade-off is better for new modules. In this case, though, providing them would risk breaking compatibility, so I think we shouldn't.

Isn’t it weird that the `minimal-racket` formula installs Racket 6.8, but the logs mention version 6.5 as well?

(Isn’t it weird that the `minimal-racket` formula doesn’t install Racket 6.9?)
Yes, it is. It's like raco thinks that some packages belong to Racket 6.5 and tries to install them there. I don't know much about raco, so no idea how that can be.

EDIT: Homebrew lags behind sometimes. I supposed the maintainer hasn't updated the formula yet.
Sanity check: Does `racket --version` return 6.8?

Also, does `brew cask install racket` work as intended? Or do the versions get mixed up as well? (I know you don’t want to use the cask long-term, so after testing you can `brew cask zap racket`.)
Ya, this is very odd. When I do the same thing it tries to download the v6.8 binaries. I kind of wonder if you are running a different `raco` file (for a different version...)
> Sanity check: Does `racket --version` return 6.8?

Yes, it does.

> Also, does `brew cask install racket` work as intended?

Yes, it seems to work fine. I have switched to the cask so I can have a working installation for the time being.

> Ya, this is very odd. When I do the same thing it tries to download the v6.8 binaries. I kind of wonder if you are running a different `raco` file (for a different version...)

The odd thing is that some packages are installed for Racket 6.8 and others for Racket 6.5. I know that Homebrew renamed the formula from `racket` to `minimal-racket`, but `racket` as a formula still works. I might have something from before the rename left over, is there a way to wipe out any old aliases (or whatever the correct term is)?
> I might have something from before the rename left over, is there a way to wipe out any old aliases (or whatever the correct term is)?

Homebrew was supposed to do that on `brew update`, when it finds an installed package whose name changed. Maybe it messed up that process.

If you start with a fresh Homebrew installation—you can temporarily rename `/usr/local/Homebrew` so you don’t lose your current environment—does the version mismatch persist?
This is still an issue for me with Racket 6.9 and Windows 10 Creator's Update. Clicking in the definitions window triggers an UNEXPECTED_KERNEL_MODE_TRAP BSOD shortly after. 
We've changed how the help is opened, which should have fixed this.
If you'd like to try the fix, you can download a nightly build at: pre.racket-lang.org
Thank you but I don't think the nightly build is working. I tried both the 64 bit Ubuntu and Mac versions and they failed. Attached is the error after trying to open DrRacket on my Mac. Thank you for checking on this...

![screen shot 2017-05-21 at 8 26 22 pm](https://cloud.githubusercontent.com/assets/870698/26289318/ae8b8ac8-3e64-11e7-996b-4adab750df3b.png)

When you click on "Report" you should get another window with a huge amount of information. Can you copy and paste that here?
![screen shot 2017-05-21 at 9 05 15 pm](https://cloud.githubusercontent.com/assets/870698/26289946/ab826e8c-3e69-11e7-96ed-15a87409118f.png)

@rfindler @eatobin I initially had the same issue as well when I tried to open DrRacket from the nightly build, but the error disappeared after following the directions [found here.](https://groups.google.com/d/msg/racket-users/4Bl5OcU6DOI/HmkAWtCVAgAJ) I've run into this before; it seems to be an issue with Sierra's security policy, as noted in the link.

Also, it appears that the new build has fixed help functions all across the board. Thanks!

EDIT 1: By "all across the board", I mean that documentation functions now work in all the aforementioned places: Geiser, DrRacket, and invoking `help` from the REPL.

EDIT 2: FYI, I used [this build](https://plt.eecs.northwestern.edu/snapshots/current/installers/racket-test-6.9.0.4-x86_64-macosx.dmg) specifically.
Thank you @ylluminarious for the fix! Opened DrRacket and `(help and)` from the REPL works as expected. But I think the help documentation in DrRacket in Linux was called from a small icon in the upper right corner of the lower panel that isn't in the attached screen shot from the Mac version?

![screen shot 2017-05-21 at 9 35 49 pm](https://cloud.githubusercontent.com/assets/870698/26290687/ecda2000-3e6e-11e7-8551-af21fb1a942e.png)

@eatobin Sorry, I don't use DrRacket on Linux so I can't say.
Are you talking about the blue semicircle with the arrow?

Yes, that's it...
I think that might be something else wrong. I noticed a problem but haven't
had time to investigate.

On Sun, May 21, 2017 at 9:57 PM eatobin <notifications@github.com> wrote:

> Yes, that's it...
>
> —
> You are receiving this because you were mentioned.
>
>
> Reply to this email directly, view it on GitHub
> <https://github.com/racket/racket/issues/1685#issuecomment-302987749>, or mute
> the thread
> <https://github.com/notifications/unsubscribe-auth/AAYWsAgKmYJgpZRbSdTAYSdyp45T9beUks5r8PmlgaJpZM4NUfs->
> .
>

Okay. Just an FYI. Thanks...
@eatobin @rfindler Should I mark this ticket as closed then? It seems to me that the main issue here has been solved.
Sure!

On Mon, May 22, 2017 at 12:11 AM George D. Plymale II <
notifications@github.com> wrote:

> @eatobin <https://github.com/eatobin> @rfindler
> <https://github.com/rfindler> Should I mark this ticket as closed then?
> It seems to me that the main issue here has been solved.
>
> —
> You are receiving this because you were mentioned.
>
>
> Reply to this email directly, view it on GitHub
> <https://github.com/racket/racket/issues/1685#issuecomment-303000692>, or mute
> the thread
> <https://github.com/notifications/unsubscribe-auth/AAYWsChhBeSC44-9QixHmFV7sqjJK9Utks5r8RkBgaJpZM4NUfs->
> .
>

Is there another open issue where I could track the return of the missing
documentation icon in the Mac DrRacket?

Sent from my rotary phone.

On May 22, 2017 05:53, "Robby Findler" <notifications@github.com> wrote:

> Sure!
>
> On Mon, May 22, 2017 at 12:11 AM George D. Plymale II <
> notifications@github.com> wrote:
>
> > @eatobin <https://github.com/eatobin> @rfindler
> > <https://github.com/rfindler> Should I mark this ticket as closed then?
> > It seems to me that the main issue here has been solved.
> >
> > —
> > You are receiving this because you were mentioned.
> >
> >
> > Reply to this email directly, view it on GitHub
> > <https://github.com/racket/racket/issues/1685#issuecomment-303000692>,
> or mute
> > the thread
> > <https://github.com/notifications/unsubscribe-auth/AAYWsChhBeSC44-
> 9QixHmFV7sqjJK9Utks5r8RkBgaJpZM4NUfs->
> > .
> >
>
> —
> You are receiving this because you were mentioned.
> Reply to this email directly, view it on GitHub
> <https://github.com/racket/racket/issues/1685#issuecomment-303067097>, or mute
> the thread
> <https://github.com/notifications/unsubscribe-auth/AA1JKlO3aJ8XRC_Z54Mm896St3YZLZFjks5r8WlDgaJpZM4NUfs->
> .
>

bump
@samth ?
Oh, sorry. A non-linear pattern is one where the same variable is used multiple times, as in:

```
(match e
  [(list x x) "xs are equal"])
```

Those do not work correctly in general with `...` but can't be removed entirely for backwards compatibility reasons. I'll add documentation explaining what they are. 
Thanks, @samth 

Perhaps also add something to the log message so people who see that first know what to do?


FWIW, the issue you saw about opening DrRacket on Mac only applies to nightly builds, not to release builds. Not to say we shouldn't fix it, though. :)

As for the missing documentation icon, I don't think there's an issue for that yet. You're welcome to open one on the `scribble` repository (which is the likely culprit). Thanks for the report!
I'm just checking here if there's been any progress since it remains a significant problem (Racket 6.9 and Windows 10 Creator's Update).  It happens with basic usage of DrRacket and the pain is high.  Because it's a kernel issue the OS halts and no apps get a chance to save.  A large several GB file of the state of memory is saved in an attempt to help.
I have received a tracking number for the OS bug from Microsoft, but that's all I've heard so far.
`make-variable-like-transformer` is intended to cooperate with redefinitions of `#%app`, and in the simple examples I've tried, it does. I don't understand what you mean by the `#%expression` being at the wrong phase level. Do you have a small example that doesn't work the way you expect with the current definition of `make-variable-like-transformer`?
@rmculpepper  https://gist.github.com/iitalics/458fc2d765d3da57d2d96a6c8c930fde
This code is attempting to read syntax properties off of the function in an application. Then, we attach properties to a function and make it look like an identifier using make-variable-like-transformer. The issue arises when #%expression is introduced and obscures the desirable syntax properties. "Being at the wrong phase level" is evident by the fact that I can't get rid of the #%expression (and therefore expose the syntax properties) by simply writing my own implementation of it. The only solution I see is pattern matching on the expression to manually remove #%expression.

Is there any reason why #%expression is preferred over #%app? As I see it, #%expression just forces the #%app to be made anyways.
@iitalics Okay, it sounds like you would like to change the expansion to make the code slightly easier to analyze. I don't have a strong preference, if no one else is currently depending on the current expansion.

I like the `#%expression` expansion because it makes explicit that even in operator position the variable-like macro is treated just as an independent expression. It also prevents expansion from going through the used-as-operator path more than once, such as in the cases of `#%app` transformers that expand into implicit applications rather than explicit applications, such as

    (define-syntax-rule (my-app f a ...) (begin (do-something) (f a ...)))

On the other hand, there's no real harm if that happens.

The fact that your redefinition of `#%expression` doesn't affect the expansion of the variable-like macro has nothing to do with a "wrong phase level"; it's simple hygiene. The reference to `#%expression` refers to the binding in the context of the syntax template. In contrast, the transformer goes out of its way to get the binding of `#%app` from the use site, using `datum->syntax` to transfer it to the pair that represents the implicit application.

Nitpick: your gist example shouldn't be seeing the used-as-operator expansion anyway, since your `my-app` local-expands the operator as an independent expression.

>it's simple hygiene. The reference to #%expression refers to the binding in the context of the syntax template.

Well yes, but which syntax template? My impression is that its the template in `(cons #'(#%expression id) (cdr (syntax-e stx)))`, which means that #%expression is always the one imported from racket/base (due to `(require (for-template racket/base))`). I don't think this is very desirable for writing #lang's that aim to override many of racket/base's other imports.

>Nitpick: your gist example shouldn't be seeing the used-as-operator expansion anyway

I'm sorry, I'm not exactly sure what you meant by this. 

I think that only introducing #%app is easier to work with, and follows the documentation more closely without the level of indirection of #%expression. At the very least, #%expression should have a phase level that the user has some control over.
I don't know what is happening here, but I've found an extremely similar issue in GHC on macOS Sierra (https://ghc.haskell.org/trac/ghc/ticket/13730), which occurs when running OpenGL code in interpreted mode. It even has the same pattern of giving a warning in one version and an error message in the other!
@RyanGlScott unfortunately I haven't looked into this any more since filing this report (and the issue unfortunately still occurs on my machine when running Typed Racket's test suite w/ multiple parallel threads (i.e. places))
I can't seem to find any existing test cases for `id-set/c`. Do you see any?
Looks like we need some too. Unless I'm running things wrong, this produces blame and the docs say it shouldn't:

```
#lang racket/base
(require racket/contract
         syntax/id-set)
(contract (id-set/c integer?)
          (mutable-free-id-set)
          'pos 'neg)
```

Here's one way to add tests. This doesn't seem like quite the right place, but it isn't a terribly horrible place, either?

```
☕  git diff 
diff --git a/pkgs/racket-test/tests/racket/contract/syntax.rkt b/pkgs/racket-test/tests/racket/contract/syntax.rkt
index d2a625e..0d628a7 100644
--- a/pkgs/racket-test/tests/racket/contract/syntax.rkt
+++ b/pkgs/racket-test/tests/racket/contract/syntax.rkt
@@ -2,7 +2,8 @@
 
 (require "test-util.rkt")
 (parameterize ([current-contract-namespace
-                (make-basic-contract-namespace)])
+                (make-basic-contract-namespace
+                 'syntax/id-set)])
   
   (test/pos-blame
    'syntax/c1
@@ -20,4 +21,24 @@
   
   (test/no-error '(syntax/c (list/c #f)))
   (contract-error-test 'syntax/c-non-flat '(syntax/c (vector/c #f))
-                       (λ (x) (regexp-match? #rx"flat-contract[?]" (exn-message x)))))
+                       (λ (x) (regexp-match? #rx"flat-contract[?]" (exn-message x))))
+
+
+  (test/pos-blame
+   'id-set/c.1
+   '(contract (id-set/c integer?)
+              5
+              'pos 'neg))
+
+  (test/pos-blame
+   'id-set/c.2
+   '(contract (id-set/c integer?)
+              (mutable-free-id-set)
+              'pos 'neg))
+
+  (test/pos-blame
+   'id-set/c.3
+   '(contract (id-set/c integer?)
+              (mutable-free-id-set)
+              'pos 'neg))
+  )
```

this blue screem Happening in my lap top too.
i notice it happend when i scroll with two finger.
very strange!
There seems to already be tests here https://github.com/racket/racket/blob/master/pkgs/racket-test-core/tests/racket/id-set-test.rktl#L639

So I went ahead and merged
Just to report back, developers at Microsoft have diagnosed the problem as a stack-overflow bug, and they intend to fix the problem for a future release.
I wasn't getting email from drdr about failing tests. And the test case I wrote above suggests that either the implementation or the docs are wrong.

Can we fix those two things?
(I was wrong about the docs/implementation mismatch. I misread the docs.)
Update: the problem is gone, either the Homebrew formula got updated or it was because I removed the old name from `Homebrew/Library/Taps/homebrew/homebrew-core/formula_renames.json`.

However, I am getting another error:
```
raco setup: launcher: <gui-bin>/DrRacket.app
call-with-output-file: cannot open output file
  path: /usr/local/bin/DrRacket.app/Contents/PkgInfo
  system error: Permission denied; errno=13
  context...:
   /usr/local/Cellar/minimal-racket/6.9/share/racket/collects/compiler/embed.rkt:150:0: prepare-macosx-mred
   /usr/local/Cellar/minimal-racket/6.9/share/racket/collects/compiler/embed.rkt:1385:0: create-embedding-executable124
   /usr/local/Cellar/minimal-racket/6.9/share/racket/collects/compiler/../racket/contract/private/arrow-val-first.rkt:306:25
   /usr/local/Cellar/minimal-racket/6.9/share/racket/collects/setup/setup-core.rkt:1443:13: for-loop
   /usr/local/Cellar/minimal-racket/6.9/share/racket/collects/setup/setup-core.rkt:1420:8: make-launcher
   /usr/local/Cellar/minimal-racket/6.9/share/racket/collects/setup/setup-core.rkt:1532:8: for-loop
   /usr/local/Cellar/minimal-racket/6.9/share/racket/collects/setup/setup-core.rkt:172:50
   /usr/local/Cellar/minimal-racket/6.9/share/racket/collects/setup/setup-core.rkt:1417:4: for-loop
   /usr/local/Cellar/minimal-racket/6.9/share/racket/collects/setup/setup-core.rkt:71:0: setup-core
   /usr/local/Cellar/minimal-racket/6.9/share/racket/collects/setup/setup.rkt:65:3
   /usr/local/Cellar/minimal-racket/6.9/share/racket/collects/pkg/main.rkt:17:0: setup
   (submod /usr/local/Cellar/minimal-racket/6.9/share/racket/collects/pkg/main.rkt main): [running body]
   /usr/local/Cellar/minimal-racket/6.9/share/racket/collects/pkg/raco.rkt: [traversing imports]
   /usr/local/Cellar/minimal-racket/6.9/share/racket/collects/raco/raco.rkt: [running body]
   /usr/local/Cellar/minimal-racket/6.9/share/racket/collects/raco/main.rkt: [running body]
```
and
```
call-with-output-file: cannot open output file
  path: /usr/local/bin/Racket Documentation.app/Contents/PkgInfo
  system error: Permission denied; errno=13
  context...:
   /usr/local/Cellar/minimal-racket/6.9/share/racket/collects/compiler/embed.rkt:150:0: prepare-macosx-mred
   /usr/local/Cellar/minimal-racket/6.9/share/racket/collects/compiler/embed.rkt:1385:0: create-embedding-executable124
   /usr/local/Cellar/minimal-racket/6.9/share/racket/collects/compiler/../racket/contract/private/arrow-val-first.rkt:306:25
   /usr/local/Cellar/minimal-racket/6.9/share/racket/pkgs/racket-doc/help/installer.rkt:45:4: for-loop
   /usr/local/Cellar/minimal-racket/6.9/share/racket/pkgs/racket-doc/help/installer.rkt:22:2: for-loop
   /usr/local/Cellar/minimal-racket/6.9/share/racket/pkgs/racket-doc/help/installer.rkt:21:0: do-installer
   /usr/local/Cellar/minimal-racket/6.9/share/racket/pkgs/racket-doc/help/installer.rkt:12:0: installer
   /usr/local/Cellar/minimal-racket/6.9/share/racket/collects/setup/setup-core.rkt:863:6: for-loop
   /usr/local/Cellar/minimal-racket/6.9/share/racket/collects/setup/setup-core.rkt:856:2: do-install-part
   /usr/local/Cellar/minimal-racket/6.9/share/racket/collects/setup/setup-core.rkt:71:0: setup-core
   /usr/local/Cellar/minimal-racket/6.9/share/racket/collects/setup/setup.rkt:65:3
   /usr/local/Cellar/minimal-racket/6.9/share/racket/collects/pkg/main.rkt:17:0: setup
   (submod /usr/local/Cellar/minimal-racket/6.9/share/racket/collects/pkg/main.rkt main): [running body]
   /usr/local/Cellar/minimal-racket/6.9/share/racket/collects/pkg/raco.rkt: [traversing imports]
   /usr/local/Cellar/minimal-racket/6.9/share/racket/collects/raco/raco.rkt: [running body]
   /usr/local/Cellar/minimal-racket/6.9/share/racket/collects/raco/main.rkt: [running body]
```
I checked the file permissions and they are read-only for all three groups. Full output here: https://pastebin.com/wMnkPduB

Indeed, the Homebrew formula for `minimal-racket` [has been modified on 2017-05-20](https://github.com/Homebrew/homebrew-core/commit/6eaaf3851ea632c0a1e3ee5e68a24e4ae2e685df), to update it to Racket 6.9.

I think the part that is failing is not trying to **read** the files, but **write** to them, as part of the installation process. So read-only access is not enough. Can you try giving read+write access? You can try a setup similar to mine, `/usr/local` itself belongs to `root`, but all folders inside (`/usr/local/Cellar`, `/usr/local/bin`, and so forth) belong to my user. The command should be similar to `sudo chown <your-user>:admin -R /usr/local/*`.
All the directories belong to me already, and even the `DrRacket.app` directory has write permissions. It's only `PkgInfo`, the binary and the icon file that are read-only. Would it be possible that during the build process `DrRacket.app` copied `PkgInfo` with insufficient permissions?

> I think the part that is failing is not trying to **read** the files, but **write** to them, as part of the installation process. So read-only access is not enough.

Don't worry, I know my way around Unix :) I just don't know my way around Homebrew and Racket.
> Would it be possible that during the build process `DrRacket.app` copied `PkgInfo` with insufficient permissions?

What happens if you `chmod 644` the file in question and try the installation again?
I cannot run `raco pkg install --auto drracket`, `raco` complains that `drracket` is already installed. If I were to remove it I guess the same thing would happen again. Speaking of which, how do I remove all the packages? Running `raco pkg remove drracket` complains:

```
raco pkg remove: cannot remove packages that are dependencies of other packages
  dependencies:
   drracket (required by: (racket-doc))
``` 
A quick suggestion to people who are impacted by the bug. As a crude and temporary workaround, you can try installing Racket inside a virtual machine. It's obviously sub-optimal, but this should at least allow you to work with Racket without systematically crashing your computer.

1. Download VirtualBox
2. Download xubuntu https://xubuntu.org/getxubuntu/ (or any other Linux distribution, this one is lightweight enough).
3. Install xubuntu in a new virtual machine
4. Install Racket inside the xubuntu virtual machine
5. If you take the trouble to configure the "VirtualBox guest additions" on the Linux side you can drag-and-drop files in and out of the VM, otherwise simply send yourself the files you want to work with by e-mail, dropbox or any other file sharing service.

If you have trouble with any of the steps (e.g. due to linux-specific things which you are not used to), feel free to ask on [IRC](https://racket-lang.org/irc-chat.html), on the [Racket mailing list](https://groups.google.com/forum/#!forum/racket-users), by sending me an e-mail (georges dot duperon at-sign gmail dot com) or by replying to this issue.

Hope this helps (a bit, at least)
> I cannot run `raco pkg install --auto drracket`, `raco` complains that `drracket` is already installed.

`raco pkg install` first installs the package—finds it in the catalog, downloads it and so forth—then it calls `raco setup` to do things like compiling the code, installing the documentation, and so on. From the error messages from your listings a few comments above, and `raco` complaining that `drracket` is already installed, I assume the installation went fine, and setup failed.

So, please try `raco setup drracket` after `chmod 644` the problematic file and let’s see how that goes.

> Speaking of which, how do I remove all the packages?

I don’t know if there’s a way to do that, but I believe `raco pkg remove --force drracket` would be a way to start—this command removes the package regardless of dependencies. **Don’t try this**, though, as it might break the installation even further. Try the `raco setup` I mentioned above.
`raco setup drracket` appears to trash my old `/usr/local/bin/DrRacket.app/` and create a new one which has the same permission problems. The creation date of `/usr/local/bin/DrRacket.app/` after `raco setup drracket` is the current time and the file permissions of `/usr/local/bin/DrRacket.app/Contents/PkgInfo` are back to read-only.
The `PkgInfo` file and others are created as a copy of the ones in `Starter.app`, which is might be `/usr/local/Cellar/minimal-racket/6.9/lib/Starter.app`. Setting permissions there may avoid the error, although I'm not sure that's the right repair.
@mflatt That solved it. So does that mean the issue is in Racket itself? Should I file a new issue here on GitHub?

The other error I got was the same file `PkgInfo` but in `Racket Documentation.app`, which `raco install` should I run for that one?
> The other error I got was the same file `PkgInfo` but in `Racket Documentation.app`, which `raco install` should I run for that one?

I **think** that’d be `racket-doc`.
```
collection-path: collection not found
  collection: "racket-doc"
  in collection directories:
   /Users/hiphish/Library/Racket/6.9/collects
   /usr/local/Cellar/minimal-racket/6.9/share/racket/collects
   ... [108 additional linked and package directories]
```
`racket-doc` is listed as a dependency of `drracket`. Maybe it is not found because it was implicitly installed along `drracket` and not explicitly requested. I can live without it though.
"racket-doc" is a package, but it's not a collection. You could use either `raco setup --pkgs racket-doc` or `raco setup help`, since "help" is the collection (provided in part by "racket-doc") that installs "Racket Documentation.app".

The normal Racket distribution for Mac OS has a "Starter.app/Contents/PkgInfo" that is writable by the owner, so we could consider this an issue with the homebrew formula. But I think it's better for the executable creator to adjust file permissions as needed, so I'll make that change.
@mflatt Thank you, it works perfectly now. I hope this isn't too much off-topic, but assuming I would want to uninstall Racket one day, how should I uninstall the packages so that after `brew uninstall minimal-racket` there are no leftovers? Or is that impossible with Homebrew?

> But I think it's better for the executable creator to adjust file permissions as needed, so I'll make that change.

Thank you. Should this issue be closed then?
`raco pkg show` will show you explicitly-installed packages, and `raco pkg remove --auto <pkg> ...` will remove all of them (and dependencies) if you list them out as `<pkg> ...`. There's not currently shortcut for removing all installed packages, though.

On closing the issue: Sounds good. (I didn't make the commit above close, because I wasn't sure whether there are any other threads left here.)
> `raco pkg show` will show you explicitly-installed packages, and `raco pkg remove --auto <pkg> ...` will remove all of them (and dependencies) if you list them out as `<pkg> ...`. There's not currently shortcut for removing all installed packages, though.

That's good enough for me, I can list the packages by hand or if the list grows really large I can write a script that processes the output of `raco pkg show` into an appropriate list for `raco pkg remove`. Now that I think about it, if there was a sort of `--list` flag to `raco pkg show` that lists only the names one could remove all packages using a for-loop in the shell:
```sh
for pkg in `raco pkg show --list`
do
        raco pkg remove --auto "$pkg"
done

# or like this:
raco pkg remove --auto `raco pkg show --list`
```
I'm OK without it, I just think a list option would be more versatile than a "remove all packages" option which can only be used for one purpose.
DrRacket now has about 1/2 as many panels nested in its main window as it has in 6.9. My hope is that this change might make it less likely that DrRacket triggers the bug in Windows and thus is less likely to crash. If anyone wants to give this a try, the snapshot builds here have the change:

https://plt.eecs.northwestern.edu/snapshots/
I found out that this was caused by a stale `config.rktd` file. Is there a reason why `config.rktd` is preferred over `config.rktd.default`?
The file `/usr/local/Cellar/minimal-racket/6.9/lib/Starter.app` including the `PkgInfo` is written in  `racket/racket/src/mac/osx_appl.rkt`. This might be the place to fix this issue.
@mflatt or @elibarzilay (Or whoever maintains this package), thoughts?
LGTM
I tried snapshot 6.9.0.5 (Win x64) and installed Windows update KB4020102 first (Win10 Pro with Creators Update) - has been working fine for over 2 hours now, whereas v6.8/6.9 previously went down BSOD lane after a few seconds...we'll see if it stays that way. Fingers crossed. :)
uninstalling and reinstalling with homebrew solved the problem for me.
This looks like a fine addition to me - thanks!
+1
Turns out this is related to a MacOS bug, and also affects python (c.f. http://bugs.python.org/issue30392). The next version of MacOS should have a fix.

In the meantime, if you can't use nightly builds, or are still seeing issues with nightly builds, here's a workaround.

* In DrRacket, press Cmd+Shift+o. In the top text box, type `net/sendurl`, then press Enter. This will open the implementation of the `net/sendurl` library.
* Go to line 161 (if you are running Racket 6.9) or 164 (if you're running a nightly build).
* After that line, insert a new line with the following code: `(set! browser (or browser "Safari"))`. Feel free to replace `"Safari"` with the browser of your choice.
* Save the file and exit DrRacket
* In the terminal, run the `raco setup` command
* When you reopen DrRacket, F1 should now open the docs properly in Safari (or whichever browser you chose).

related: #1710
And relatedly, a `struct/derived` similar to `define-struct/derived` would be very useful, since `define-struct` is documented as being for backwards compatibility.
Calling `atexit()` is not always the right thing. Probably the code in `scheme_add_atexit_closer()` in "thread.c", which sometimes calls atexit() but sometimes does other things, should be moved into `scheme_atexit()` and called from `scheme_add_atexit_closer()`.
Good idea. I have moved the relevant code to scheme_atexit, thanks.
Would it be a good idea to also bump the version number, or do you think this is too minor for that?
If you need to depend on it from a package, then bump the version number. Otherwise, I'd just leave it.
Okay thanks. Finally, do you think its worth documenting on: http://docs.racket-lang.org/inside/Custodians.html?q=atexit#%28idx._%28gentag._582._%28lib._scribblings%2Finside%2Finside..scrbl%29%29%29

Otherwise I think its good to merge. (It doesn't seem like there are any tests for thread.c)
I think it's worth documenting, and I agree that it's otherwise ready to go.
Thanks for your feedback. Merged.
(I've also pushed the docs.)
Unless I'm misreading, I recommend inverting the return value: 1 (= true) for a successful wait, 0 (= false) f the semaphore isn't ready. That would be most consistent with `semaphore-try-wait?`.
This is fine with me.

I made it that way to match the pthread's sema_wait and Window's WaitForSingleObject semaphore call. (Both of which return 0 when the semaphore was decremented, and something non-zero otherwise.)
Anyway, Since none of the thread functions in mzrt are documented should I document them, or would we like to leave them undocumented?
Good point about 0 normally meaning success in C, so choose whichever variant you think is most consistent.

I should really make the `mzrt_...` functions properly public (which involves adding them to "schemef.h" et al.) and document them, but I don't think that needs to be your responsibility for this commit.
All right then. I will push the version that matches the mzrt_mutex_trylock function. (Which also matches the pthreads and windows api).

Thanks.
Preview:
![screen shot 2017-06-07 at 09 35 45](https://user-images.githubusercontent.com/1731829/26880868-d12af8a0-4b63-11e7-9656-3336ea829c6b.png)

Hello @rmculpepper I was wondering if you would be able to review this pull request and the other related PR at https://github.com/racket/db/pull/9

Thank you.
LGTM
Even if you comment out the `# define MZ_USE_DWARF_LIBUNWIND` you get another error down the line
```
Error [GCING] 234 in ./../src/bool.c: Function mz_long_double_eqv declared __xform_nongcing__, but includes a function call at __FLOAT_BITS.
Error [GCING] 270 in ./../src/bool.c: Function double_eqv declared __xform_nongcing__, but includes a function call at __FLOAT_BITS.
xform: Errors converting
make[4]: *** [Makefile:209: xsrc/bool.c] Error 1
```
I guess its missing the `__FLOAT_BITS` declaration 
I'm commenting here mainly so that I'll get notified about activity, and know what if anything to do in this regard for a few things:

- [ ] [Blog post with example using `--tidy`](http://www.greghendershott.com/2017/04/racket-makefiles.html)
- [ ] https://github.com/greghendershott/frog/blob/master/Makefile#L18
- [ ] https://github.com/greghendershott/rackjure/blob/master/Makefile#L23
- [ ] https://github.com/greghendershott/markdown/blob/master/Makefile#L23

It might turn out I should just delete the `--tidy` for compatibility with a range of Racket versions.
Update.
Good news: if you use an explicit call to `profile` in your program (as opposed to using `raco profile`) you can get profile info after interrupting the program.
Bad news: `raco profile --use-errortrace` is just broken, with or without interruption. I'm investigating.
Re explicit call to `profile`: You'll need `#:use-errortrace? #t`, and to run your program with `racket -l errortrace -t raft.rkt`.
Ok, fix pushed. Thanks for the report, and sorry for the wait!
Context: This came up on IRC yesterday when @zenspider cloned [Fear of Macros](https://github.com/greghendershott/fear-of-macros) and tried to `make html-single`.

I hadn't updated FoM and tried to `make html-single` in quite awhile -- possibly two or more years! I'm pretty sure it used to work, last I tried. But when I tried, yesterday, I got the same error @zenspider did.

I avoid the error if I parameterize `sandbox-memory-limit` to something bigger than the documented default `30`.  I took a WAG and found `100` works:

```diff
modified   index.rkt
@@ -12,12 +12,14 @@
           (for-label racket/syntax))
 @(define evaluator
    (parameterize ([sandbox-output 'string]
-                  [sandbox-error-output 'string])
+                  [sandbox-error-output 'string]
+                  [sandbox-memory-limit 100])
      (make-evaluator 'racket)))
 
 @(define typed/evaluator
    (parameterize ([sandbox-output 'string]
-                  [sandbox-error-output 'string])
+                  [sandbox-error-output 'string]
+                  [sandbox-memory-limit 100])
      (make-evaluator 'typed/racket)))
```

So now "it works".

It's interesting (to me) that the memory needed has apparently increased over one or more versions of Racket. On the face of it that's not shocking (to me). Maybe nothing actionable here. Unless maybe if the increase indicates some other issue that needs attention?

Or maybe just `sandbox-memory-limit` should default higher now?

Or maybe the `make-evaluator` docs need to mention this?

I don't know enough to say for sure which if any of these.

TL;DR: Later versions of Racket need more memory to do something. Either this matters, or it doesn't.

Great, thanks!
FWIW looks good to me. I think the use of `string-append` and the new code in the atomic block are fine.
See also: https://github.com/racket/drracket/issues/123
The PR was merged and this is already fixed in Racket 6.9.
Please see #1671. As noted at the end of the thread, the current snapshot build may work around the OS bug well enough for your machine.
By the way, I tried [building FoM using Travis CI against Racket versions from 5.3.5 through 6.8](https://travis-ci.org/greghendershott/fear-of-macros/builds/241736983). There _wasn't_ any simple pattern such as "the default 30 MB is inadequate only starting with vX.X".

---

Anyway, for Fear of Macros I think it is fine just to set `sandbox-memory-limit` to `#f`, and I'll push a commit to do that. (Although the FoM repo is what I use to build part of my site, not intended as a library for others to use, this will be good in case anyone uses it as an example.)
@tewk @takikawa @clklein @bfetscher @Zoetermeer @noelwelsh @matthewsj @deeglaze @chrdimo @tohammer @frenchy64 @offby1 @lyons @philippemeunier @tim-brown @SamB @sowens

You are the most prolific contributors who haven't yet agreed to the licensing change. I'd greatly appreciate it if you could either agree (following the form others have used here on this issue) or email me at samth@indiana.edu with either agreement or letting me know if there are problems.
I, Jacob Matthews, give permission to license my contributions to Racket under MIT/Apache 2. I've used the email addresses jacobm@gmail.com and jacobm@cs.uchicago.edu.
I, Asumu Takikawa, give permission to license my contributions to Racket under MIT/Apache 2. I've used the email addresses asumu@ccs.neu.edu, asumu@simplyrobot.org, and asumu@racket-lang.org
I, Noel Welsh, give permission to license my contributions to Racket under MIT/Apache 2. I've used the email addresses noelwelsh@gmail.com and noel@untyped.com
I, Christos Dimoulas, give permission to license my contributions to Racket under MIT/Apache 2. I've used the email addresses chrdimo@ccs.neu.edu, chrdimo@seas.harvard.edu and chrdimo@racket-lang.org
I, Dionna Glaze, give permission to license my contributions to Racket
under MIT/Apache 2. I've used the email addresses drdeeglaze@gmail.com and
ianj@ccs.neu.edu

On Jun 12, 2017 4:24 PM, "Noel Welsh" <notifications@github.com> wrote:

> I, Noel Welsh, give permission to license my contributions to Racket under
> MIT/Apache 2. I've used the email addresses noelwelsh@gmail.com and
> noel@untyped.com
>
> —
> You are receiving this because you were mentioned.
> Reply to this email directly, view it on GitHub
> <https://github.com/racket/racket/issues/1570#issuecomment-307962718>, or mute
> the thread
> <https://github.com/notifications/unsubscribe-auth/AAq-HIjDmSa0CoapJxOfHy7eZVD0C8BUks5sDciagaJpZM4Lf72O>
> .
>

Yes, thank you. The snapshot build worked for me.

On Sun, Jun 11, 2017 at 7:41 PM, Matthew Flatt <notifications@github.com>
wrote:

> Closed #1720 <https://github.com/racket/racket/issues/1720>.
>
> —
> You are receiving this because you authored the thread.
> Reply to this email directly, view it on GitHub
> <https://github.com/racket/racket/issues/1720#event-1118699295>, or mute
> the thread
> <https://github.com/notifications/unsubscribe-auth/AcAGATNcXDHy-HWUvj6OUpuq-ZDfkWDPks5sDIkegaJpZM4N2jPV>
> .
>

I, Kat Lyons, give permission to license my contributions to Racket under MIT/Apache 2. I've used the email addresses lyons@users.noreply.github.com and hello@katlyons.org
I, Ambrose Bonnaire-Sergeant, give permission to license my contributions to Racket under MIT/Apache 2. I've used the email addresses abonnairesergeant@gmail.com
I, Erik Silkensen, give permission to license my contributions to Racket under MIT/Apache 2. I've used the email addresses silkense@colorado.edu, ejs@ccs.neu.edu, and eriksilkensen@gmail.com
I, Reid Douglas '@arrdem' McKenzie, give permission to license my contributions to Racket under MIT/Apache 2. I've used the email addresses me@arrdem.com
I, Royall Spence, give permission to license my contributions to Racket under MIT/Apache 2. I've used the email address royall@royall.us
I, Andrew Gocke, give permission to license my contributions to Racket under MIT/Apache 2. I've used the email addresses agocke@gmail.com and andy@commentout.net
I, Geoff Hill, give permission to license my contributions to Racket under MIT/Apache 2. I've used the email address geoff@geoffhill.org
I, Martin DeMello, give permission to license my contributions to Racket under MIT/Apache 2. I've used the email addresses martindemello@gmail.com and mdemello@google.com
I, Stephen A. Goss, give permission to license my contributions to Racket under MIT/Apache 2. I've used the email address: steveth45@gmail.com
I, Milo Turner, give permission to license my contributions to Racket under MIT/Apache 2. I've used the email addresses iitalics@gmail.com and milo@ccis.neu.edu
I, Adam Wick, give permission to license my contributions to Racket under MIT/Apache 2. I've used the email addresses awick@cs.utah.edu and awick@uhsure.com.
I, Markus Bertheau, give permission to licensy my contributions to Racket under MIT/Apache 2. I've used the email address `mbertheau@gmail.com`.
I, Mark Lee, give permission to license my contributions to Racket under MIT/Apache 2. I've used the email address mark@markelee.com
I, Lindsey Kuper, give permission to license my contributions to Racket under MIT/Apache 2. I've used the email address lindsey@composition.al.
I, James Bornholt, give permission to license my contributions to Racket under MIT/Apache 2. I've used the email address bornholt@cs.washington.edu 
I, Philippe Meunier, give permission to license my contributions to Racket under MIT/Apache 2. I've used the email address meunier@ccs.neu.edu.
I, Justin Slepak, give permission to license my contributions to Racket under MIT/Apache 2. I've used the email address jrslepak@ccs.neu.edu
I, Andrei Mikhailov, give permission to license my contributions to Racket under MIT/Apache 2. I've used the email address amkhlv@gmail.com
I, Andrew Gwozdziewycz, give permission go license my contributions to Racket under MIT/Apache 2. I've (likely) used the email address apgwoz@gmail.com, web@apgwoz.com, or git@apgwoz.com for these contributions.
I, Gary Baumgartner, give permission to license my contributions to Racket under MIT/Apache 2. I've used the email address gfb@cs.toronto.edu .
@rpaulo @spdegabrielle @mromyers  @edwardearnest 

I don't have working email addresses for you so if you could comment here that would be greatly appreciated.
I, Will Farr, give permission to license my contributions to Racket under MIT/Apache 2. I may have used the email addresses farr@mit.edu, w-farr@northwestern.edu, or wmfarr@gmail.com.
I, Rui Paulo, give permission to license my contributions to Racket under MIT/Apache 2. I've used the email address rpaulo@me.com.

@ffatghub I don't have a working email addresse for you so if you could comment here that would be greatly appreciated.
I, Eric Hanchrow, give permission to license my contributions to Racket under MIT/Apache 2. I've used the email address eric.hanchrow@gmail.com.
@samth many of these people have websites and or real names on their profiles. Perhaps you can find their Social Networking accounts and react them through that? Also see if anybody knows them who are reachable who know them. Any way what % is finished? How many more people to respond?
Also some of the github people you are tagging might be the wrong user name. E.g. https://github.com/ffatghub?tab=overview&from=2006-12-01&to=2006-12-31&utf8=%E2%9C%93 does not seam to have any commits to racket. Perhaps this could be commits before moving into Github which share the same email address with Github in which case this might be a contributors.

Also note not all contributors appear in: https://github.com/racket/racket/graphs/contributors . You appear only if you use the same email address associated  your github account.
I, Chongkai Zhu, give permission to license my contributions to Racket under MIT/Apache 2. I've used the email addresses czhu@cs.utah.edu, chongkai@plt-scheme.org.
I, Tobias Hammer, give permission to license my contributions to Racket under MIT/Apache 2. I've used the email address tobias.hammer@dlr.de
Hi, hmm I am the wrong person. I never contributed to this project.
ciao
fra
I, Evgeny Odegov, give permission to license my contributions to Racket under MIT/Apache 2. I've used the email address evgeny-odegov@mail.ru
I, Jakub Piotr Cłapa, give permission to license my contributions to Racket under MIT/Apache 2. I've used the email address jpc@zenburn.net.
I, Burke Fetscher, give permission to license my contributions to Racket under MIT/Apache 2. I've used the email addresses bfetscher@gmail.com, burke.fetscher@eecs.northwestern.edu, bfetscher@racket-lang.org
@samth I think ffatghub has the foo@bar.baz e-mail address registered on GitHub, so commits made by other people who used this "dummy" address are attributed to ffatghub (when looking around, I saw this happen in another repository).
@sirinath We're making good progress, and I've emailed people as well as contacting them via github.
Who else have responded through email not already under this issue.
@sirinath Many people. I'll update everyone at an appropriate time on the progress.
How many more to respond?
I, Shu-Hung You, give permission to license my contributions to Racket under MIT/Apache 2. I've used the email addresses: shu-hung.you@eecs.northwestern.edu shhyou@u.northwestern.edu ( shuhung.you@eecs.northwestern.edu )
@abmclin, thanks for the pull request, and sorry for taking so long to get to it. I have two comments:

I think the sql strings should be trimmed only on the right; otherwise, if sqlite reported a syntax error with a location, the location would be off. (I don't know if it currently does, but I think the smallest change that achieves the goal would be best.)

Either string-trim should be called in the ffi functions before copy-buffer (rather than being called within copy-buffer), or copy-buffer should be renamed to something like trim-and-copy-buffer.

Otherwise, it looks good to me, including the atomic section.
That's an unusual error, and it looks like some file has been corrupted.

Can you say more about the version and OS that you're using and how you're running the program (e.g., inside DrRacket)?

If you ran in DrRacket, was a "compiled" directory created alongside your files, and if so, does moving that directory out of the way change the result?
Thanks for help.
When i restarted the computer, the error disappeared.I  remember that i ran the program in normal way.
So i can only provide the information about racket version(6.9) and OS (windows 10).
It is really a strange error,  and if similar errors appears next time, i will report how it happened.
Can you use `jsexpr?` for your validator?
No can do. I was checking to see if something was a 'terminal' JSON object, ie `(hasheqof symbol? string?)`.

I think it has more applications than just the json module anyway.
How about using the [`hash/c`](http://docs.racket-lang.org/reference/data-structure-contracts.html#%28def._%28%28lib._racket%2Fcontract%2Fprivate%2Fhash..rkt%29._hash%2Fc%29%29)  contract?

```
> (define (hasheqof k v) (and/c hash-eq? (hash/c k v #:flat? #t)))
> ((hasheqof symbol? string?) (hasheq 'a "a" 'b "b"))
#t
```
That's a better implementation, sure.

But the core problem is that the docs mention a contract that doesn't exist. Shouldn't it exist?
That, or the docs should be fixed.
Looks like the right repair to me. Don't lines 2257, 2389, and 3000 in "struct.c" need the same repair? (I looked for uses of `->redirects` and `SCHEME_VEC_SIZE`.)

Improving the old code by making/using a single point of control would be great.
Thanks for the PR! See also #1357. I think @samth didn't merge that one because he didn't finish the docs, so I appreciate that you've added docs here.

The `++args` approach used in #1357 is more in line with the way other Racket tools pass along command-line arguments. The `--` approach here seems more convenient, but it's not as composable, because there's no way to point `raco test` at a file whose name is `--` – which maybe doesn't seem like the sort of thing anyone would want to do with `raco test`, but that's more an explanation of why other tools use `++args`, and we'd like to make things as consistent as possible.

If you're not opposed to the `++args` approach, I wonder if you'd be willing to merge the PRs. If you really want `--`, we can discuss more.
P.S.  I think `++args` should have been `++arg`.
I don't have a strong opinion on the syntax, the `--` method was proposed by @jeapostrophe so I based my implementation on that. I'd be more than happy to to merge this request with #1357 if a consensus can be reached on the syntax. It seems like my implementation breaks some of the automated tests, so keeping the `--` syntax would require  more work than using `++arg`. 

The one possible issue I can see with `++arg` is: Would it allow the user to specify multiple command-line arguments to be forwarded easily? Or would it require one to type `++arg <arg>` once for each arg?
The current convention is that `++arg` would add only one argument at a time, which is why I suggest `++arg` instead of `++args`.

I can imagine a `++args` that adds multiple space-separated arguments at once. Space-separated arguments within a flag argument would be a new convention, as far as I can remember, but it doesn't conflict with any existing convention or composition possibilities as long as `++arg` also exists.
Thanks for the feedback @mflatt I think that ++arg and ++args are the right thing for Conor to do. Sorry for not noticing it before.
Thanks for the report!

The root problem here is Racket's implementation of continuations, where continuation capture or restore can take O(N) time for a continuation of size N. Each access of the generator is working in a longer continuation.

The short-term solution is probably to change the `for[*]/list` expansion back. The long-term solution is probably a better implementation of continuations.
I agree that setting `sandbox-memory-limit` to `#f` is the right choice here. 

Avoiding memory-use increase is a constant battle, which I think explains why there isn't a simple pattern for which version requires 30 MB. In fact, as I look at http://build-plot.racket-lang.org/, I see a spike at the left of the green and blue areas that seems to have appeared on June 2... so, we'll have another skirmish today or tomorrow.

Unfortunately, my short-term solution to the problem is to make it at least 3 times as difficult by having three different Racket variants in development.
`ffi-lib` tries the path that you provide without adding any suffix. For your case, can you just include the suffix in the `ffi-lib` path argument?
Oh, interesting. That's not what the docs say:

> path is a path without a version or suffix (i.e., without ".dll", ".so", or ".dylib"); and

Should I update them to say that the path _can_ potentially include the suffix?
That bit of documentation is after "Normally", and there are several constraints in that itemization that aren't always true, as detailed in the rest. The rest is long and complex, which is why there's a "Normally" to explain the typical use. Maybe you can see a rewrite to make the "Normally" aspect more clear.
Oh hey...I completely missed that. Thanks. :)
Thanks for the report!
The change is indeed due to racket/r5rs#2.

In the body of the module, `#%module-begin` is the shadowing import from `r5rs`. Formerly, `r5rs` exported the same `#%module-begin` as `racket/base`, so it worked to remove it in that first `provide`. Now, it's a different `#%module-begin`, so it's not a binding that can be removed from the set of imports from `racket/base` in the context of that `provide` form.
Fixed by f459dd9eb7889b1a0b8aaada1e4533951695cc2a, which adjusts the contract
That claim was true for the old macro system, but it isn't true anymore. I'll fix the docs.
The `--tidy` flag isn't specific to the named collections. So, if you want to tidy only in the user scope, `--tidy --avoid-main` should work.

When `raco pkg` subcommands call `raco setup`, they use `--tidy` in various situations, but they also add `--avoid-main` or `--no-user`, depending on whether the relevant packages were in user or installation scope.

You generally shouldn't use `--tidy` directly, because it only makes sense when you've just deleted something that probably should have been removed with a tool like `raco pkg remove`.
Do you think that's a sign that racket/r5rs#2 should be changed, or that this is just expected breakage?
I think this has to be expected breakage. Changing the binding of an export is never completely backward-compatible, but I don't think the issue can be addressed without the change.

The change also left a gap in the documentation links, which I expect to fix today. [Edit: I now see that @lexi-lambda fixed that yesterday – thanks!]
@rmculpepper Good point that trimming on the left would shift the string leftward and throw off locations. Right-only trimming seems to be the safest conservative approach. I'll make the changes.

I am leaning towards renaming `copy-buffer` to `trim-and-copy-buffer` approach.
@rmculpepper @bennn Suggested changes have been made, I also did a grep search of the Racket repository to be sure the `copy-buffer` procedure defined in sqlite3/ffi.rkt wasn't being used elsewhere which would be broken by renaming to `trim-and-copy-buffer`. So far it seems the rename is safe.
I'm having some issues getting `++args` to work correctly. It doesn't seem like `command-line` has any support for flags with variable arguments, and I don't think it's viable to hack in this functionality. The issue I'm seeing is that I don't think there's anything that immediately and obviously distinguishes between an argument to a flag and an argument to the test framework itself. 

For example, if the user types `raco test ++args foo bar -s mod file`, then it's obvious that `foo` and `bar` are arguments to `++args`, whereas `mod` is an argument to `-s` and `file` is the name of file/directory to test.

But consider if the user types `raco test ++args foo bar file`. It's much less obvious what the types of the arguments are. Are `foo` and `bar` both arguments to `++args`? Or are `bar` and `file` both file/directory arguments to test? I don't see any clear path forward in terms of getting these features to play nice with each other.
You're right that `raco test ++args foo bar file` can't work. A user would have to write `raco test ++args "foo bar" -s mod file` (in practically any shell) to make `foo` and `bar` a single argument of `++args`, and then `++args` must parse out the separate arguments itself.

What if a user wants to pass `hello world` and `something else` as two different arguments? I suggest that you don't try to handle that with `++args`, and the user would have to go with `++arg "hello world" ++arg "something else"`, instead.

In other words, `++args` will have its own little parsing sublanguage, which doesn't need to be as expressive as a shell.
I see, thank you!
I was almost certain I had pushed those documentations with the original commit, but I just happened to notice yesterday that it got lost somehow. My guess is I forgot to `raco update --link r5rs-doc`, so the changes were to my catalog-installed copy and never made it into git.
Okay `++args` should be ready for prime time now, unless anyone has any issue with the wording in the docs.
@mflatt The most recent commit tries to create a single point of control for distinguishing between the types of vector that can show up in the redirects of a chaperone, and then uses those predicates where they seemed to be checked throughout the runtime system. 
That looks like a great improvement to the code. Were you able to find test cases that provoke each of the three extra conditionals that you've now almost certainly repaired?
The problem is that the EH version of `~or` (that is, `~or` used immediately before ellipses) doesn't allow the same attribute to occur in multiple alternatives. The normal version of `~or` behaves as you expected:

    (syntax-parse #'(x y z)
      [((~and  ;; force S version of ~or
         (~or (~and (~literal x)
                    (~bind [test #'1]))
              (~and e (~bind [test #'2])))) ...)
       #'(test ...)])
    ;; => #<syntax:11:7 (1 2 2)>

The context-sensitive meaning of `~or` is one of the biggest mistakes in the design of `syntax-parse`.

I, Michael Myers, give permission to license my contributions to Racket under MIT/Apache 2.
I think this should be merged
This looks good to me, too, so I'll merge.

I'll probably adjust the doc wording "must be enclosed in quotation marks", because that assumes a particular kind of shell context, but the intent is clear enough, and I'll have to give the right words more thought.
Excellent
Obsoleted by @cfinegan's work in #1726. :)
We forgot about adding a `history` note to the docs, so I'll do that, too.
@tonyg Is your review comment addressed?
@lehitoskin can you rebase this, so that the CI runs again?
@mflatt The code on lines 2257 and 2389 seemed to be for refs and sets to the fields of a chaperoned struct, @stamourv and I tried to find an example of a prop-only vector chaperone getting to there, but it always seemed to be caught by a contract error earlier. We did come across a segfault using `unsafe-struct-ref` on a prop-only vector chaperone, but at that point there aren't really any guarantees anyway.

The `struct_info_chaperone` function on line 3000 seems to only be called from the `struct_info` function and only if the value was actually a struct, so we weren't able to provoke that one either.
Thanks for investigating! I'd say this is ready to merge.
I tried building with the PR commits locally merged, and I got lots of "database is locked" (SQLITE_BUSY) errors from raco setup. The fix is to let the outer `HANDLE` take care of any non-zero `prep-status` result, so that error reporting is handled uniformly but more importantly so that "busy" failures get properly identified and automatically retried. Sorry for missing that before. The code should look like this:

    (HANDLE fsym
     ;; Do not allow break/kill between prepare and
     ;; entry of stmt in table.
     (A (let-values ([(prep-status stmt tail?)
                      (sqlite3_prepare_v2 db sql)])
          (cond [(not (zero? prep-status))
                 (when stmt (sqlite3_finalize stmt))
                 (values prep-status #f)]
                [tail?
                 (when stmt (sqlite3_finalize stmt))
                 (error* fsym "multiple statements given"
                         '("given" value) sql)]
                [else
                 (when stmt (hash-set! stmt-table stmt #t))
                 (values prep-status stmt)]))))

@rmculpepper thank you for catching that.  I wish it had occurred to me to perform a fresh build with the changes.

I'll be sure to do that next time I make any changes in the Racket repository.
Perhaps more strangely - it appears to depend on which Racket binary I use. If I compile my own, and run it from the command-line, it works without errors. If I use an official DrRacket download, it does not.
Is it possible that you're compiling in 64-bit mode but downloading the 32-bit distribution, or vice versa?
That seems somewhat plausible. How can I check if the distribution is 32-bit? I don't see anything in the "About Dr Racket" window that seems relevant.
There's probably a simpler way, but I'd use `(system-library-subpath)`.
Both return `#<path:x86_64-macosx/3m>`; however, I did notice that my built copy is 6.9, and the installed copy is 6.8.
Thank you for the explanation. I misunderstood the meaning and purpose of `--tidy`. I'll stop using it.
@samth Okay. I hope I did this correctly...
I, Raymond Racine, give permission to license my contributions to Racket under MIT/Apache 2. I've used the email addresses ray.racine@gmail.com and ray@racine.cloud.
This issue has been resolved by the PR merge.
I, Scott Owens, give permission to license my contributions to Racket (PLT Scheme) under the MIT/Apache 2 license. I used the email addresses sowens@cs.utah.edu and Scott.Owens@cl.cam.ac.uk for these contributions.
@mflatt any thoughts on this PR?
Do we care that this keeps a copy of a potentially large file in memory, instead of always streaming to an output file? Probably we don't deal with any files big enough for this to matter, so I'm ok with ignoring that issue for now, but but the alternative would be a thread that performs the checksum concurrently.
That was my worry as well here. I think we probably want to avoid decompressing the whole thing in memory.
I'll merge and adjust the implementation to streaming
I think your understanding of the semantics is correct, but this has been the behavior for a very long time and seems hard to change compatibly.
Are you aware of any programs that rely on the literals list _not_ binding identifiers they match as pattern variables? (I'm not, but I've also not been around as long as you have.)
This program wouldn't work under the obvious way of implementing your suggestion:

```
(syntax-case #'(+ + +) (+)
   [(+ + +) 1] 
   [_ 2])
```

I've certainly written patterns that use elements of the literals list more than once.
AH, okay. Fair point. I guess its not clear which pattern to bind if you use a literal multiple times. Never mind then. I'll close this issue.
You could maybe add a variant on #:literals that did bind them?

Robby


On Mon, Jun 26, 2017 at 4:17 PM, Leif Andersen <notifications@github.com>
wrote:

> Closed #1733 <https://github.com/racket/racket/issues/1733>.
>
> —
> You are receiving this because you are subscribed to this thread.
> Reply to this email directly, view it on GitHub
> <https://github.com/racket/racket/issues/1733#event-1139449133>, or mute
> the thread
> <https://github.com/notifications/unsubscribe-auth/AAYWsMZgLv-rXnu2ZEFxPA3X0fG5IERhks5sIB_OgaJpZM4OFzh4>
> .
>

Possibly. Although it might make make more sense to do this with syntax classes though. Honestly, I'm fine either way.
Hi Markus, and sorry for the delay.
I can reproduce with Racket 6.9 (from download.racket-lang.org). I get an empty profile for your program on Dragonfly BSD. But, if I disable the JIT (using the `-j` flag), the profile is what we expect.
I also tried on FreeBSD, per your recommendation, and it works both with and without JIT.

The issue seems to be that the samples taken by the profiler have empty stack traces.
If you'd like to take a look, the relevant code is likely `scheme_native_stack_trace`, in `racket/src/racket/src/jitstack.c`, line 162. I don't directly see anything that would differ between FreeBSD and dragonfly, but the differences may come from definitions in `racket/src/racket/sconfig.h`.
`syntax-parse` lets you use literals like syntax classes, so you can write the following:

    (define-syntax (foo stx)
      (syntax-parse stx #:literals (add1)
        [(a:add1 x)
         (build-source-location #'a)]))

----

Here's another example of a problem caused by binding literals as pattern variables:

    (syntax-case stx (+)
      [(+ e ...)
       (andmap constant? (syntax->list #'(e ...)))
       #`(quote #,(apply + (constants->values #'(e ...))))])

That code would be illegal, because the pattern variable binding would shadow the `+` procedure.

> On Jun 27, 2017, at 9:50 AM, Syntacticlosure <notifications@github.com> wrote:
> 
> In some speical cases, match doesn't work properly, such as the code below :
> 
> (match `(1 2 3)
>   [`(,@(list (? number? x)) ...) x])
> 
> I expected it to return `(1 2 3), not an error.
> I don't know whether it is an bug or a feature, but I hope this problem could be solved.
> 
> —
> You are receiving this because you are subscribed to this thread.
> Reply to this email directly, view it on GitHub, or mute the thread.
> 


Think of match’s pattern language as a DSL that shares features with the surrounding language. Here is what you want: 

> (match `(1 2 3)
    [`(,(? number? x) ...) x])
'(1 2 3)


What you mentioned is an approach to correct the program, but sometimes my way may be useful.
Consider this example, I want to match numbers in pairs of two : 
```
(match `(1 2 3 4 5 6)
  [`(,@(list (? number? x) (? number? y)) ...) x])
```
It is just like the ~seq pattern in syntax-parse.
```
(syntax-parse #'(1 2 3 4 5 6)
  [((~seq x:number y:number) ...) #'(x ...)])
```
The code returns #'(1 3 5) correctly.
I am getting this also... I use a Surface Pro 4 i7 and I think it has something to do with Dr Racket compiling / running codes

Not quite. What I am saying is two things: 

1. the DSL of match is distinct from the one for syntax-parse and does not allow the pattern you wrote down. 

2. and yes, to get the original example to work, I gave you a replacement expression. 

As Gerry Sussman used to say “I hate pattern matching. All pattern languages are distinct and none does what I want in all situations.”  Well, it’s not quite a quote but that’s what he said when we Indianans requested considering of extend-syntax for the follow-up discussion of R3RS in the 80s. 






> On Jun 28, 2017, at 6:53 AM, Syntacticlosure <notifications@github.com> wrote:
> 
> What you mentioned is an approach to correct the program, but sometimes my way may be useful.
> Consider this example, I want to match numbers in pairs of two :
> 
> (match `(1 2 3 4 5 6)
>   [`(,@(list (? number? x) (? number? y)) ...) x])
> 
> It is just like the ~seq pattern in syntax-parse.
> ``
> (syntax-parse #'(1 2 3 4 5 6)
> [((~seq x:number y:number) ...) #'(x ...)])
> 
> The code returns #'(1 3 5) correctly.
> 
> —
> You are receiving this because you commented.
> Reply to this email directly, view it on GitHub, or mute the thread.
> 


LGTM - thanks!
@sluongng this is a bug in windows that DrRacket makes more likely to happen than other software does. Please see other comments above for some ideas on how to work around the problem.
I think this is probably some unfriendliness in `slideshow/base` where it sets some global parameters that break how DrRacket exits. The answer may just be "dont do that" but with a smaller example, a better answer may be forthcoming.
Fair. And I guess that makes sense since slideshow has the whole 'global slide deck' thing. Although it makes me wonder why this problem doesn't occur when your just writing a slideshow program in DrRacket.
DrRacket takes special pains to make sure that running a program in the definitions window doesn't break things. But when you install as a tool you are in the "trusted code base", and various invariants must be maintained.

As for slideshow, I expect that we'll probably want to either adjust slideshow/base or provide another library that exports everything the same, but doesn't update the state so it can be used as a tool (or other places that would probably also break).
Thank for help!
Thanks for the report! Commit 340b8789816f7e773507ab76f0d60829eb3368cb should repair this crash.
Is this a new problem? That is, does Racket 6.9 report a different error for `(tcp-connect "::1" 12325)`?

It looks like the test currently detects an absence of IPv6 by looking for an "Address family not supported by protocol" error message, which is not great, but would make sense if IPv6 is disabled for localhost but supported by getaddrinfo. The error you're getting suggests that numeric IPv6 addresses are not recognized by getaddrinfo.
I see a similar error with 6.9.

BTW, Racket only fails when `/etc/resolv.conf` includes the line `family inet4`.
I'll fix the test. Thanks for the tip on configuring to provoke the problem!
As an alternative, I think it would be reasonable to tie the TCP_NODELAY state to the port's buffer mode. That is, buffered (the default) ports would have TCP_NODELAY set to true, since the programmer is already taking control of when output is flushed. Unbuffered ports would set it to false.
I don't see more crashes or errors. Thanks for both fixes!.
Thanks for the report! The stack trace suggests that the OS disallows memory that is both writable and executable at the same time (as OpenBSD does). Is that right? If so, it's a limitation of Racket for now that it cannot work within that constraint.

Yes, that is correct - a new default for NetBSD 8.0.
(From the NetBSD mmap(2) manpage: "As a NetBSD extension, PROT_MPROTECT can be used to request additional
     permissions for later use with mprotect(2).  This is necessary for
     switching pages between writable and executable when PAX mprotect
     restrictions are in place.")

I don't know enough about Racket's internal structure to figure out how much that helps in figuring out a solution, though.
I filed an issue on racket/gui about this a while ago: https://github.com/racket/gui/issues/68

It's not immediately clear how to fix this because I think the scrolling supported by canvas is implemented at a pretty low level.
Thanks for that pointer, but I think `PROT_MPROTECT` is about switching to and from executable mode, but not about allowing writable and executable at the same time.

Does using `paxctl` with
```
paxctl +M path/to/racketcgc
```
allow `racketcgc` to run?
It does - well, you need +m rather than +M, but then it runs, yes. I'll add that as a local pkgsrc patch by way of workarond.
(I'm getting more errors further down the line, but at least there is progress - thanks!)
Huh.
```racket
(immutable? (syntax-e (quasisyntax #(1))))    ; expands to quote-syntax
(immutable? (syntax-e (quasisyntax #(#,1))))  ; expands to datum->syntax
```
Unfortunately, the semantics of the splicing/quasiquote behavior has never been documented to my knowledge, but I don't think this has ever worked in implementations of `match`.
@mflatt Does the new macro expander implementation make it possible to fix this?
Extending the new expander would certainly be easier than extending the old implementation. I'm not sure how difficult it would be, though, or whether it can be done without also changing tools like `raco make`.
I should add that this is using the Debian packages for Racket 6.9, but similar failures popped up in Travis for a project in 6.8 and HEAD.
This seems definitely like a bug to me. The new expander (as used in "racket7") appears to work correctly. Just to make sure, is this bug an obstacle for your work – which would mean that ignoring it for 6 months is a very bad option?
I have a workaround, which is to take some code that was in submodules and move it to the surrounding module, so it's not getting in my way immediately.

Thanks for the concern!
The trick is to use `wcm` to test whether the mark was set in the first frame.

```
#lang racket
(define-syntax wcm (syntax-rules () [(_wcm . more) (with-continuation-mark . more)]))

(define (call/icm key proc [default #f])
  (define marks (current-continuation-marks))
  (define vals  (continuation-mark-set->list marks key))
  (define val   (if (null? vals) default (car vals)))
  ; check whether val is from the first frame
  (define unique (list 'unique))
  (with-continuation-mark key unique
    (let ()
      (define new-marks (current-continuation-marks))
      (define new-vals  (continuation-mark-set->list new-marks key))
      ; The first value in new-vals is  unique.
      ; If the value after is val, then the mark wasn't immediate.
      (if (and (not (null? (cdr new-vals)))
               (eq? (cadr new-vals) val))
          (proc default)
          (proc val)))))

(define-syntax (test stx)
  (syntax-case stx ()
    [(_test expected expr)
     (syntax/loc stx
       (let ()
         (define res expr)
         (define ok? (equal? expected res))
         (unless ok?
           (displayln (list res expected '(call/icm . args))))))]))

; uncomment to test with Racket builtin primitives
; (define call/icm call-with-immediate-continuation-mark)

(define id (λ (v) v))
(test #f    (call/icm 'x id))
(test 10    (call/icm 'x id 10))
(test 12    (wcm 'x 12
                 (call/icm 'x id)))
(test '(#f) (wcm 'x 42
                 (list (call/icm 'x id))))
(test 12    (wcm 'x 12 
              (wcm 'y 13
                   (call/icm 'x id))))
(test 13    (wcm 'x 12 
              (wcm 'y 13
                (call/icm 'y id))))
(test 14    (wcm 'x 12 
              (wcm 'y 13
                (wcm 'x 14
                  (call/icm 'x id)))))

```

Thank you very much for your reply!

The solution you propose is similar to what my first attempt was in trying to define `call-with-immediate-continuation-mark` through `with-continuation-mark`, `current-continuation-marks`, and `continuation-mark-set->list`. (The only difference between your solution and my first attempt is that I compared the length of the continuation mark lists instead of using a unique value.)

However, both solutions are not correct because the continuation mark set (for the given key) for the continuation of the call to `proc` will have been modified. For example,

```scheme
(with-continuation-mark 'x 10
  (call-with-immediate-continuation-mark 'x
   (lambda (y)
    (call-with-immediate-continuation-mark 'x values))))
```
should evaluate to `10`, but would evaluate to the unique value in your solution.

The working solution with `continuation-mark-set->list*` I am having in my mind is

```scheme
(define (call-with-immediate-continuation-mark key proc)
  (with-continuation-mark %secret-key #f
    (let ((marks
           (continuation-mark-set->list* (current-continuation-marks)
                                         (list key %secret-key))))
      (proc (vector-ref (car marks) 0)))))
(define %secret-key (vector 'secret))
```

(For simplicity, this solution assumes that the default value is `#f`, but this is easy to fix.)

Marc

P.S.: As a side note, does Racket compare keys for continuation marks using `eq?`, `eqv?`, or `equal?`. I couldn't find it anywhere in the documentation.
You are right: we need to make sure the continuation of the call to `proc` isn't affected.
What if we simply restore the mark?

```
(define (call/icm key proc [default #f])
  (define marks (current-continuation-marks))
  (define vals  (continuation-mark-set->list marks key))
  (define val   (if (null? vals) default (car vals)))
  ; check whether val is from the first frame
  (define unique (list 'unique))
  (with-continuation-mark key unique
    (let ()
      (define new-marks (current-continuation-marks))
      (define new-vals  (continuation-mark-set->list new-marks key))
      ; The first value in new-vals is  unique.
      ; If the value after is val, then the mark wasn't immediate.
      (define immediate? (or (null? (cdr new-vals))
                             (not (eq? (cadr new-vals) val))))
      (with-continuation-mark key val
        (if immediate?
            (proc val)
            (proc default))))))

```

/Jens Axel

This won't work either. In case of a non-immediate continuation mark, this solution would leave an extra continuation mark on the stack when `proc` is invoked.

The expression

```scheme
(with-current-continuation-mark 'x 0
  (+ 1
   (with-current-continuation-mark 'x 1
    (+ 1 (call-with-immediate-continuation-mark 'x
            (lambda (y)
             (cadr (continuation-mark-set->list (current-continuation-marks) 'x))))))))
```

should evaluate to `2`, and not to `3`. (Note that I introduced the increments by `1` to avoid tail-calls and to generate frames.)

Marc

So we need a procedure that can remove a mark from an immediate frame.
I don't think there is a light-weight one. But it doesn't sound too hard to implement on a low level.

I attempted to make a version that used `call/cc` to capture the continuation before the test, and the then restore it after - but could not make it work.

FWIW here is the implementation of `call-with-immediate-continuation-mark` for the Chez Scheme backend:

[https://github.com/racket/racket7/blob/master/racket/src/cs/core/control.ss#L796](https://github.com/racket/racket7/blob/master/racket/src/cs/core/control.ss#L796)

Note that in Chez Scheme the expresison `(call/cc (lambda (k1) (call/cc (lambda (k2) (eq? k1 k2)))))` evaluates to true.

Wrt to the equality predicate used: I couldn't find it in the manual, but since

```
> (with-continuation-mark +0.0 'pos
    (with-continuation-mark -0.0 'neg
      (continuation-mark-set->list (current-continuation-marks) +0.0)))
'(pos)

```

it must mean that `eq?` is being used.
I think @mnieper's original report is right. Looking back at the operation that we replaced when adding `call-with-immediate-continuation-mark`, it's essentially @soegaard's solution, so that implementation would leave an extra mark behind if it wasn't present already (which was good enough for the use in implementing contracts at the time).

I also agree that `continuation-mark-set->list*` can solve the problem by using a private key, so that it doesn't matter if a mark using that key is left behind.
To clarify, this is a scratch build of the unix source release `racket-6.9-src.tgz`.
For your information: the issue I reported got my attention when I prepared a SRFI on continuation marks whose first draft was just put online: https://srfi.schemers.org/srfi-157/srfi-157.html. (Of course, I am always happy to receive comments helping to improve this SRFI. Without the pioneering work of Racket, it wouldn't have been possible.)

As for the issue itself, which I opened here, I'd suggest to change Racket's documentation so that `continuation-mark-set->list*` is mentioned (because a solution using only `continuation-mark-set->list` does not seem possible) so that this issue can be closed.

--

Marc

P.S.: I recently got interested in continuation marks while thinking of delayed evaluation in Scheme. R7RS has the primitives `delay`, `force`, and `delay-force`; there (rough) Racket equivalents are `delay`, `force`, and `lazy` (as in SRFI 45). By using `call-with-immediate-continuation-mark`, it is possible to get rid of `delay-force`/`lazy`. As Racket does have `call-with-immediate-continuation-mark` it would make sense to make `lazy` obsolete. The recipe is here: https://srfi-email.schemers.org/srfi-155/msg/6072673.
@mnieper - Thanks!

In case you haven't already seen it, you may be interested in the implementation of continuation marks within https://github.com/racket/racket7/blob/master/racket/src/cs/core/control.ss
That implementation is not portable, because it relies on `eq?` comparisons of continuations. (The delimited-control part also uses a few `#%$...` internal primitives of Chez Scheme.) It may be useful in discussions of implementation strategies, though.
Thanks for the note; I think we will merge this after Racket v6.10 is released
No reason not to merge now though.
Wouldn't a release manager need to cherry-pick it onto the branch?
(I know that's a tiny thing)

EDIT: well either way, the PR is up --- I just won't merge it myself until after :)
No, releases are cut from the `release` branch. You can just click "Merge" on your PR without affecting the release.
The word "except" does not appear?

But maybe this is easily misread so the change is a good idea regardless?

Robby

preview:
![screen shot 2017-07-18 at 23 36 33](https://user-images.githubusercontent.com/1731829/28349444-ee8450f4-6c10-11e7-838d-aabc8d271f86.png)

So why don't you work on a `dev` branch, and merge on `master`? Anyway thanks for the quick action.
LGTM

Previews:
![screen shot 2017-07-19 at 23 52 03](https://user-images.githubusercontent.com/1731829/28399627-490d9d7a-6cdc-11e7-9dd3-7995162bea18.png)
![screen shot 2017-07-19 at 23 52 10](https://user-images.githubusercontent.com/1731829/28399629-4efff78c-6cdc-11e7-9ec2-e041b2e67b5d.png)
![screen shot 2017-07-19 at 23 51 53](https://user-images.githubusercontent.com/1731829/28399634-559e6c68-6cdc-11e7-90ad-1c5f2f815219.png)


tested it out with a few values:

```
(integer->integer-bytes #x235E 2 #f)
(integer->integer-bytes #x22 1 #f)
(integer->integer-bytes #xFE 1 #f)
(integer->integer-bytes #x22 1 #t)
(integer->integer-bytes #x7E 1 #t)
(integer->integer-bytes (- #x7E) 1 #t)

(integer-bytes->integer (integer->integer-bytes #x235E 2 #f) #f)
(integer-bytes->integer (integer->integer-bytes 34 1 #f) #f)
(integer-bytes->integer (integer->integer-bytes #xFE 1 #f) #f)
(integer-bytes->integer (integer->integer-bytes #x22 1 #t) #t)
(integer-bytes->integer (integer->integer-bytes #x7E 1 #t) #t)
(integer-bytes->integer (integer->integer-bytes (- #x7E) 1 #t) #t)
```
I wanted to ask if the code is correct, when `sgned` is true it coerces to an unsigned short. 

```c
  case 2:
    {
      if (sgned) {
        unsigned short value = val;
        memcpy(str, &value, sizeof(unsigned short));
      } else {
        short value = val;
        memcpy(str, &value, sizeof(short));
      }
    }
    break;
```

scheme_bytes_to_integer does the opposite:

```c
  case 2:
    if (sgned) {
      short val;
      memcpy(&val, str, sizeof(short));
      return scheme_make_integer(val);
    } else {
      unsigned short val;
      memcpy(&val, str, sizeof(unsigned short));
      val >>= rshft;
      if (mask < 16) { val &= (((unsigned short)1 << mask) - 1); }
      return scheme_make_integer(val);
    }
    break;
```

I may be misunderstanding the code but I thought I'd ask!
Just merged @bennn's fix. Thanks for the report!
Has any progress been made on this? I just spent the last couple of days digging into trying decipher how unions worked, so this is disappointing. 
Maybe the docs on unions should be updated to notify users of the current state of the feature? 
I don't remember what happened here, but think it just fell through the cracks. I'll push a new approach to `_union` that I think will work more often.
This looks fine to me.
@rain-1 I think you're right that the test on `sgned` is backward for the action. The compiler likely generates the same code for both branches, but it doesn't have to.

I'll fold that repair and your tests cases into your commit to merge, and I'll add documentation.

Thanks!
Merged
There was no good reason. Thanks to @rain-1 for the patch to add the missing functionality.
Thanks!
Thanks!
I think the way to make the ".desktop" file non-executable is to remove the `(install-template file 'mzscheme "starter-sh" "starter-sh")` call, which is there specifically to make the ".desktop" file executable.

I'm unclear on whether the ".desktop" file should always be non-executable. From https://askubuntu.com/questions/419610/permission-of-a-desktop-file , I get the impression that the executable bit is needed when the ".desktop" file is in a user's directory. (That's probably the scenario I tried when I implemented ".desktop"-file support.) If that's right, then maybe the `(install-template ...))` call should be changed to `(when user? (install-template ....))`.
Removing the `install-template file` alone is not enough to make the `.desktop` file non-executable. I tried that first and it didn't work. I also had to mess with the permissions-copying code around line 159 of `launcher.rkt`. That succeeds in making the launcher non-executable, but I'm not sure if it has any negative side-effects.

As to whether or not the launchers _should_ be executable... I mean, what would happen if you executed one? =)

It looks like some file managers have implemented precautions to prevent you from e.g. downloading a `.desktop` file from the web and running it accidentally. Since `.desktop` files can launch arbitrary commands, I see the value in that. I'll ping the original reporter of the Gentoo bug (@jonasstein) to see if he knows more. If any modern desktop environments are still doing the same thing, we'll need to address that.
Hi, I asked on lists.freedesktop.org AFAIK there was the .desktop standard born. I could not find a clear answer yet. The executable .desktop came from KDE, but if I understand it correct it was not meant for system wide .desktop files. We can collect information on https://wiki.gentoo.org/wiki/.desktop_files 
If the file has no shebang it will be executed (most often) by bash. If you are lucky it just crashes or returns command not found.
Did you already have a ".desktop" file in place before removing the `install-template` call? If a file is already in place, it would keep its current permissions (while the content is rewritten), so that could explain it. Otherwise, I'm puzzled.

Unless I'm confused about the other changes you mean, those changes would mean that launcher scripts don't get execute permission.
@jaapb you also need to mark the executable "racket3m" with paxctl. 
Here's a way you could wrap it to safely enforce that condition:
```
(define (make-immutable-vector/pre-ref n [b])
  (let ([v (make-vector n b)])
    (case-lambda
     [() (if (immutable? v) v
           (unsafe-vector*->immutable-vector! v))]
     [(i x)(vector-set! v i x)])))

(define (make-long-vector n a b c)
  (define pre-v (make-immutable-vector/pre-ref n b))
  (pre-v 0 a)
  (pre-v (- n 1) c)
  (pre-v))
```

No references to the vector are obtainable while it's still mutable. The compiler should be able to in-line and eliminate the closure in most cases, and for performance critical cases where it can't, there's always the unsafe version.
@mflatt these were fresh installations -- our package manager installs everything to an empty temporary directory before moving them "live".

It looks like I misremembered exactly what I did, though. I wasn't able to _remove_ that `install-template` call, because I don't know racket, and I couldn't make it compile =)

What I was able to do instead was mark my copy of `starter-sh` non-executable at the very start, so the `install-template` line should not have made anything executable as a result.
This is probably just my inexperience with racket/ffi in general, and probably outside of the scope of this issue, but:

It seems like _union is meant to be used in conjunction with union-ref and union-set!. However, these two functions are private to the ffi package? See https://github.com/racket/racket/blob/4c5f66ff4a0ad2714f835a0f6551e4080b1f690a/racket/collects/ffi/unsafe.rkt#L1163

If these functions are protected, it seems unclear to me how one would go about unwrapping a union. For reference, I'm trying to figure out how best to represent SDL_PollEvent (https://wiki.libsdl.org/SDL_PollEvent), which takes an SDL_Event as a in-out param. 
`protected` does't mean "private". It means "protect against use by untrusted code".
Ok, sorry, this is probably not the place for this, but I'm not sure what I'm missing as to why the following snippet doesnt work. 
If I stay at the top level module and don't use `enter!`, everything works fine.
I've read over the doc for code inspectors, however I don't really understand how they tie into why this is prevented.
```
:~$ racket
Welcome to Racket v6.9.
> (module asdf racket)
> (enter! 'asdf)
'asdf> (require ffi/unsafe)
'asdf> _union
#<procedure:_union>
'asdf> union-ref
; ?: access disallowed by code inspector to protected variable from module:
;   "/opt/racket/collects/ffi/unsafe.rkt"
;   in: union-ref
; [,bt for context]
'asdf> ,bt
; ?: access disallowed by code inspector to protected variable from module: "/opt/racket/collects/ffi/unsafe.rkt"
;   in: union-ref
;   context...:
;    /opt/racket/share/pkgs/xrepl-lib/xrepl/xrepl.rkt:1448:0
;    /opt/racket/collects/racket/private/misc.rkt:88:7
'asdf> 
```
That doesn't look like the right behavior, and it's likely a problem in the macro expander related to `enter!`. (A newer implementation of the expander appears to not have this problem.)

I'll investigate more, but it looks like using `(require ffi/unsafe)` within the `asdf` module – before `enter!` – works around the problem. 
This didn't make it into 6.10, did it?
Correct. The change went in well after the branch date for v6.10 (which was July 7).
OK, thanks. I guess I can expect 6.11 in about another three months then.
Two questions:

- Did you have an `info.rkt` file in addition to the `main.rkt` file?
- Did you try to install this package in a Docker container by chance?
1.No
2.No
Since the error is about the file timestamp on "main.rkt" – a few hours in the future at the time of the error – can you say more about how you created the file, copied it from somewhere, and/or packed it in some way?
> I hope to complete the process for the Racket code in the next two
release cycles (six months).

@samth, it’s been six months. Can you update us on the progress of the license switch?
What you said made me realized that made me realized it might be the way I packed files that caused this problem.
So I  use the function which system provides instead of using winrar (a software) to build a `zip` file and it works.
Thanks for help.
[I'm not sure that this is the problem but] How much memory does your computer have? Can you check if it runs out of memory while building the docs? 

Building the docs uses a lot of memory. [IIRC, The builder has to remember all the internal links, or something.] 
@gus-massa 
After comparing the amount of memory allotted to the build environments of the passing vs. failing architectures, I think you might be correct.  I have no way to test this because the build system memory allotments are fixed, so I am closing the issue.  
Looks good

![screen shot 2017-08-03 at 22 33 56](https://user-images.githubusercontent.com/1731829/28951713-cdb53d7a-789a-11e7-9044-ee3c2178722f.png)

I would also be interested in a status update on this if it is possible.
Excellent. Well, the attached patch gets things into the install phase for me (racket is now happily raco setupping things). The detection is a bit crude, and could possibly be integrated with configure (on NetBSD, detecting whether memory protection is enabled is done through the security.pax.mprotect.enabled variable in sysctl(8)).
[patch.txt](https://github.com/racket/racket/files/1208988/patch.txt)

I think the docs are just wrong.
LGTM
I think the implementation is wrong, because the start page for "The Racket Reference" says the `racket` library includes `racket/logging`

http://docs.racket-lang.org/reference/index.html
Well, it certainly isn't re-exprted by racket/main.rkt. So one of them is wrong. Again, I am happy to fix them, I just need to know which way we want to go.
I think the docs should change, instead of the implementation.

> On Aug 8, 2017, at 12:26 PM, Leif Andersen <notifications@github.com> wrote:
> 
> Well, it certainly isn't re-exprted by racket/main.rkt. So one of them is wrong. Again, I am happy to fix them, I just need to know which way we want to go.
> 
> —
> You are receiving this because you are subscribed to this thread.
> Reply to this email directly, view it on GitHub, or mute the thread.
> 

A status update:

1. I've gotten permission from most people who have contributed to Racket, which is great. I'm confident we'll be able to complete the switch, barring unforseen changes.
2. Not everyone has responded yet, including some people who have made notable contributions. For some of these people, I'm still working on finding the best means of contacting them. 
I, William Gallard Hatch, give permission to license my contributions to Racket under the MIT/Apache 2 license.  I have used the email addresses william@hatch.uno and maybe willghatch@gmail.com for contributions.

Note that "contributions to Racket" here means contributions to any projects that are dependencies of the `main-distribution` package as of January 2017.  I specify just so that people in the future don't argue that I've also granted these licenses for other Racket libraries that I have made or will make when I don't necessarily intend for them to be a part of the core Racket distribution.


Sorry for the delay, as I let this drop from my radar after not getting around to it immediately after seeing the notification about it.  Though my contributions so far are extremely minor anyway.

I'm curious what the "other issues" of LGPLv3 are that are mentioned.
Thanks very much for the detailed investigation and report! I think you are completely correct, and I'll add your repair and a test.
Some people might be dead hence you might have to track down their estate also.
A different change could be making `reader` a `deftech` at the beginning of Section 1.3 and move the third paragraph of **1.3.18 Reading via an Extension** there.
I can confirm on Linux with DrRacket 6.10.
This looks like a good change. If my `refman` comment is correct (I didn't try it to make sure), that would be a little better, but I'm happy to merge either way.

I can easily believe that rearranging the docs could be even better, since I have trouble following the cross-references myself. 
With futures, IO causes blocking. There is more information here: http://docs.racket-lang.org/guide/parallelism.html
Oh wow. So I just retried this with 6.10 to see if it had magically been fixed in the interim, but it hasn't. So I tried a couple of things. It turns out running `./slideshow` from the `Racket v6.10/bin` directory works *fine*. But running it via the symlink farm I have terminates with `SIGSEGV`.

Here are reproduction instructions, assuming that `~/Racket v6.10/` exists and has the obvious content:

```sh
cd
mkdir qq
cd qq
ln -s ~/Racket\ v6.10/ c
ln -s c/bin/ b
./b/slideshow
```

And for me, it `SIGSEGV`s. This is OSX 10.12.6. Running `./c/bin/slideshow` works fine. (These instructions are a slight abstraction of the real setup I use.)

Er, never mind, I forgot to do `(require racket/serialize)`, closing.
LGTM
How about `struct-info`?

https://docs.racket-lang.org/reference/inspectors.html#%28def._%28%28quote._~23~25kernel%29._struct-info%29%29
@shhyou 
```racket
> (struct s (v))
> (struct-info (s 0))
#f
#t
> 
```
Right, but you need a more powerful inspector:

```
#lang racket/base

(struct s (v) #:inspector (make-inspector))
(struct-info (s 0))
;; #<struct-type:s>
;; #f
```

The page @shhyou linked to explains inspectors:
<https://docs.racket-lang.org/reference/inspectors.html>
@bennn How do I change a defined structure?
I'm not sure what you mean.

Do you want to get the struct type of a struct that's defined in another file & doesn't use `#:inspector` ? I'm not sure how to do that. If you could:

1. save `(current-inspector)`
2. set `(current-inspector (make-inspector))`
3. evaluate the struct definitions

then it'd be possible to use the saved inspector with `struct-type`. But I really don't know how to do step 3.
If you're using a `#:transparent` struct instead of an opaque one, you don't need a more powerful inspector:

```racket
> (struct s (v) #:transparent)
> (struct-info (s 0))
#<struct-type:s>
#f
```

If your struct isn't transparent, you probably shouldn't be reflecting over it with `struct-type` unless you're making something like a debugger or other program instrumentation tool. But if you are, using a more powerful inspector is a reasonable approach.
I'm implementing a DSL that needs to compare the two struct types.
@bennn 
```racket
> (current-inspector (make-inspector))
> (struct x (a))
> (x 0)
#<x>
> (struct-info (x 0))
#f
#t
> 
```
@zaoqi Here's how to do steps 1 and 4 in @bennn's suggestion:
```
> (define insp (current-inspector))
> (current-inspector (make-inspector))
> (struct x (a))
> (struct-info (x 0))
#f
#t
> (parameterize ([current-inspector insp])
     (struct-info (x 0)))
#<struct-type:x>
#f
```

@zaoqi Why not just use `#:transparent` for your structs?
Or perhaps provide your own `struct` to the user in the library
@shhyou Can I redifine `struct`?
Just put `recursive-contract` around the part that needs to be delayed:

```
#lang racket/base

(require racket/contract)

(define (sizedstream/c t)
  (or/c null?
       (cons/c t (recursive-contract (sizedstream/c t)))
       (promise/c (recursive-contract (sizedstream/c t)))))

(define/contract s1
  (sizedstream/c integer?)
  (cons 1 (cons 2 (cons 3 '()))))
```
@bennn 
https://github.com/zaoqi/zKanren/blob/master/stream.rkt
```racket
(define (promise+/c t)
  (or/c
   t
   (promise/c (recursive-contract (promise+/c t)))))
```
Something like this (simply shadows the `struct` binding from #lang)

```
; my-lib.rkt
#lang racket
(provide (rename-out [my-struct struct]))
(define-syntax my-struct
  (syntax-rules ()
    [(_ x ...) (struct x ... #:transparent)]))
```

```
#lang racket
(require "my-lib.rkt")
(struct x ())
(struct-info (x))
```

I think that a better example is probably a function one that accepts two contracts and returns a contract on lists that alternate those elements, one after the other. And then use it in a `#:rest` argument on an `->` contract.

This would require some English to motivate and explain, tho. 

You could start with an even-length list of integers and work your way up?
@shhyou 
```racket
(define (struct-type-eq? x y)
  (let-values ([(tx _x) (struct-info x)] [(ty _y) (struct-info y)])
    (equal? tx ty)))
```
Can I define it like this?
I've just stumbled upon the exact situation of a client refusing to deal with *GPL licenses. What's the chance that Racket 6.11 will be relicensed to MIT/Apache 2?
I like `even-length-list/c`, that seems simple & useful to me.

I'm thinking we should leave it at this:
- I don't want to add more English, because I don't want to distract from the main point of "how do I use `recursive-contract` at all?"
- I'd rather the contract isn't a function, because then it's really obvious when you've got it wrong. If you remove `recursive-contract` from this example then `define` raises an exception.
![screen shot 2017-08-28 at 11 51 24](https://user-images.githubusercontent.com/1731829/29781335-e3574b3c-8be6-11e7-9fa0-37905226ae0a.png)

Okay, that all makes sense. And I do think that something in the guide section on contracts is where to discuss adding a contract like `hash` has.
You can make this as a macro (and in fact I just did that on a project yesterday)

```racket
(define-simple-macro (singleton-struct id:id)
  (begin
    (struct the-struct () #:reflection-name 'id)
    (define id (the-struct))))
```

A `sugar-struct` package might be a good place to put this
When you are happy with it, please go ahead and push the commit. Thanks!
What are you trying to do?

What's the error message you're seeing?
I'm writing up a PR for this
@bennn 
```
> (promise+-fmap-flip (delay 0) (λ (x) (+ x 1)))
. . promise+-fmap-flip: broke its own contract
  two of the clauses in the or/c might both match: b and (promise/c (recursive-contract (or/c b (promise/c (recursive-contract (promise+/c t))))))
  produced: #<promise:unsaved-editor:15:6>
  in: the range of
      (->
       (or/c
        (and/c not-promise? a)
        (promise/c
         (recursive-contract (promise+/c t))))
       (-> a b)
       (or/c
        b
        (promise/c
         (recursive-contract (promise+/c t)))))
  contract from: (function promise+-fmap-flip)
  blaming: (function promise+-fmap-flip)
   (assuming the contract is correct)
  at: unsaved-editor:11.18
```
Ok, so the problem is that:

```
two of the clauses in the or/c might both match: b and (promise/c ....)
```

This is because `b` can match anything, including a promise.

I think you want `b` to be parametric over anything but a promise. But `racket/contract` can't express bounded parametric polymorphism.

Here's two ideas:
1. use a weaker contract; instead of `(spromise+/c a)` use `(spromise+/c any/c)` and explain the function's behavior with a comment
2. try the contracts in this library: https://github.com/thinkmoore/bounded
What is the problem?

(same for #1790 and #1789 , I'm not sure what the issue is)
@bennn https://docs.racket-lang.org/reference/hashtables.html:
Racket doesn't support immutable-weak-hash.
https://docs.racket-lang.org/reference/data-structure-contracts.html#%28def._%28%28lib._racket%2Fcontract%2Fprivate%2Fmisc..rkt%29._promise%2Fc%29%29
@bennn Racket doesn't support set/c and hash/c.
```racket
(set/c c) → contract?
--
c : contract?

(hash/c k v) → contract?
--
k : contract?
v : contract?
```
@bennn Racket doesn't support it.
It is supported. Please see the documentation on ephemerons. 
@rfindler What's ephemerons?
`racket/contract` provides a `hash/c` 
<https://docs.racket-lang.org/reference/data-structure-contracts.html#%28def._%28%28lib._racket%2Fcontract%2Fprivate%2Fhash..rkt%29._hash%2Fc%29%29>

`racket/set` provides a `set/c`
<https://docs.racket-lang.org/reference/sets.html?q=set%2Fc#%28def._%28%28lib._racket%2Fset..rkt%29._set%2Fc%29%29>
https://docs.racket-lang.org/reference/ephemerons.html?q=ephemeron#%28tech._ephemeron%29
@zaoqi I think you might be better served by using the [Racket users mailing list](https://groups.google.com/forum/#!forum/racket-users) for your questions. You're creating several github issues for things it seems you have done very little research on, or perhaps you just need a few pointers from someone more experienced (and the mailing list would be an excellent place to ask for guidance if you are confused and/or cannot find something).
Do you remember the exact command you ran? And what platform was that on?
FWIW, printing is fine at the command-line.
raco i think
@bennn `(spromise+/c any/c)`=`any/c`
@bennn `b` can be a promise.
@pnwamk I can't use *.google.com
test-engine is in the htdp repo.

On Thu, Aug 17, 2017 at 1:28 PM, Matthias Felleisen <
notifications@github.com> wrote:

> This program
>
> #lang racket
> (require (only-in pict rectangle colorize))
> (require test-engine/racket-tests)
> (check-expect (colorize (rectangle 4 4) "blue") (colorize (rectangle 4 4) "red"))
> (test)
>
> yields this error message:
>
> Ran 1 check.
> 0 checks passed.
> 	Actual value differs from the expected value.
> ..  :eulav lautcA  :eulav detcepxE
>
>  In /Users/matthias/svn/2HtDP/Images/bug-test.rkt at line 4 column 0
>
> Note the reversal of the word "actual value".
>
> Note 1: I have not been able to produce the error with a smaller example,
> not involving Pict.
> Note 2: Otherwise I would have guessed that it has something to do with
> test-engine.
>
> —
> You are receiving this because you are subscribed to this thread.
> Reply to this email directly, view it on GitHub
> <https://github.com/racket/racket/issues/1774>, or mute the thread
> <https://github.com/notifications/unsubscribe-auth/AAYWsFTgOyIY3vbcVM8tbpoV6-mw5xEyks5sZIZOgaJpZM4O6o6E>
> .
>

Oh, I see what Matthias means now. It is almost certainly a test-engine bug.

In general I think we should be ok with managing issues in general on this repo, since lots of people won't know which repo things belong in. Of course, @mfelleisen isn't most people ... :)

If you had read my submission, you would know that I know. 


> On Sep 2, 2017, at 8:55 AM, Sam Tobin-Hochstadt <notifications@github.com> wrote:
> 
> In general I think we should be ok with managing issues in general on this repo, since lots of people won't know which repo things belong in. Of course, @mfelleisen <https://github.com/mfelleisen> isn't most people ... :)
> 
> —
> You are receiving this because you were mentioned.
> Reply to this email directly, view it on GitHub <https://github.com/racket/racket/issues/1774#issuecomment-326745447>, or mute the thread <https://github.com/notifications/unsubscribe-auth/ABf5-3E_SKA6L2uixBv5gAr29MHepZPEks5seV5vgaJpZM4O6o6E>.
> 


Then maybe you don't want an `or/c` ?
?
Ah -- my apologies for the oversight.

In my humble opinion, that's definitely something the Racket community should look into (i.e. if users cannot reasonably access the mailing list, where is the next best place to post questions? or is there a workaround? etc) -- and maybe someone else has some suggestions.

Obviously @zaoqi isn't the only person affected by this. I would hope there is something that works well for everyone that isn't the repository's issue tracker as a general forum for Q&A (at least that's my two cents worth on the matter).
There's the Slack channel [racket.slack.com](http://racket.slack.com/), but you'll need to join via [racket-slack.herokuapp.com](https://racket-slack.herokuapp.com/) first. There's also the #racket IRC channel on freenode.net. @zaoqi, are either of those available to you? Either would likely get you quicker answers to your questions.
I'm not sure how a weak immutable hash could work. When a key is no longer reachable, it would have to be removed from the hash. But the hash is immutable, so removing it would violate the semantics of immutability.
You could wrap the contents of the promise in a single-field struct. That would let `or/c` tell the difference between a recursive promise and a normal value:

```racket
(struct done ([value #:mutable]) #:transparent)
(define (done/c t) (struct/c done t))
(define (done-map f d) (done (f (done-value d))))

(define (promise+/c t)
  (or/c
   (done/c t)
   (promise/c (recursive-contract (promise+/c t)))))

(define/contract (promise+-fmap-flip x f)
  (let ([a (new-∀/c 'a)] [b (new-∀/c 'b)])
    (-> (promise+/c a) (-> a b) (promise+/c b)))
  (if (promise? x)
      (delay (promise+-fmap-flip (force x) f))
      (done-map f x)))

;; evaluates to (done 1)
(force (promise+-fmap-flip (delay (done 0)) add1))
```

The struct is used as an immutable wrapper even though the `value` field is marked mutable. This is because [`struct/c`](http://docs.racket-lang.org/reference/data-structure-contracts.html?q=struct%2Fc#%28form._%28%28lib._racket%2Fcontract%2Fprivate%2Fstruct-dc..rkt%29._struct%2Fc%29%29) only allows [flat](http://docs.racket-lang.org/reference/contracts.html?q=struct%2Fc#%28tech._flat._contract%29) and [chaperone](http://docs.racket-lang.org/reference/contracts.html?q=struct%2Fc#%28tech._chaperone._contract%29) contracts on immutable fields, but [`new-∀/c`](http://docs.racket-lang.org/reference/parametric-contracts.html?q=new#%28def._%28%28lib._racket%2Fcontract%2Fparametric..rkt%29._new-~e2~88~80%2Fc%29%29) is an [impersonator](http://docs.racket-lang.org/reference/contracts.html?q=impersonator#%28tech._impersonator._contract%29) contract. Impersonator contracts can pretend to be arbitrarily different values when wrapping a value, which can violate the semantics of immutability.
Also, I think the [`lazy`](https://docs.racket-lang.org/reference/Delayed_Evaluation.html?q=lazy#%28form._%28%28lib._racket%2Fpromise..rkt%29._lazy%29%29) form does what you're trying to do. It allows you to return either a normal value or a promise, and the result promise automatically forces the inner promise (if present).
@jackfirth 
`promise+` is sized.
```racket
(define r (delay r))
```
The lazy form doesn't do what I'm trying to do.
https://github.com/jasonhemann/microKanren/blob/master/microKanren.scm
Thanks!
@mflatt Can you look through my implementation notes?
This also might be easier if the package catalog served both HTML and s-exp data for packages from the same URL using content negotiation. There wouldn't need to be any sort of URL templating enforced on the package catalog, it'd just have to respond differently based on the Accept header.
Here's the start of the referenced code: https://github.com/racket/scribble/blob/master/scribble-lib/help/search.rkt#L63
@jeapostrophe Looks generally good. I had forgotten about `current-pkg-catalog-file`, and it seems like a fine local catalog to use by default and update on demand; that's the same one used by the GUI package manager. As you and I discussed, I think we'll need a new configuration (as set by `raco pkg config` and reported via `setup/dirs`) to configure a target from links from package names.

@jackfirth If I understand what you mean, that's difficult or impossible with the current S3-backed setup.
@mflatt Yes, the current setup makes this difficult. An alternative setup using a pull-based model with AWS CloudFront instead of S3 would make it much easier, but I can open a separate issue for that. My point is that we already have a URL identifying where to get a package from, so adding a second URL and a URL template that catalogs are required to support adds unnecessary complexity and out of band information to the package catalog protocol.
As far as I can tell, the part that's going wrong is on the server side, although it's JavaScript sent back to the browser. The URL is parsed using string operations, and a "label" query is converted using `unescape` in JavaScript, which does not decode `+` into a space.

To avoid the immediate problem, I see advice like
https://stackoverflow.com/questions/12042592/decoding-url-parameters-with-javascript,
but surely that's not the right approach.

The deeper problem is that the JavaScript code shouldn't try to do its own parsing of a URL string. The obviously better choice is to use the `URL` class in JavaScript... but apparently `URL` is new and not always supported by browsers???

So, it seems like a stupid question, but: How do I correctly and portably parse a URL in JavaScript to extract a query value?
This suggests that you can use URL with high probability: http://caniuse.com/#feat=url
And if you want a backup solution for IE, here's a polyfill: https://github.com/webcomponents/URL
Part of the cause here is that the [HTTP URI scheme RFC](https://tools.ietf.org/html/rfc7230#section-2.7.1) does not standardize any format whatsoever for the query string; it can basically be any blob of characters. The `foo=1&bar=2` syntax is purely by convention of (nearly all) implementations. Many servers and clients have slightly different interpretations and formatting rules with no clear indication which set of rules is "correct".
@blerner I've updated docs.racket-lang.org. Does using "F1" in DrRacket now work?
Looks like it helps: F1 on `scene+line` yields the URL `http://docs.racket-lang.org/search/search-context.html?q=scene%2Bline&hq=O%3A%7B+L%3Alang%2Fhtdp-beginner+T%3Ateachpack+T%3Apicturing-programs+%7D&label=Beginning+Student` which then seems to work properly -- at least, on Linux, in Chromium and in Firefox.  I can't test on the lab machines right now, because I don't have access to changing their config myself, but it _should_ suffice...

Thanks!
Ah, it's not quite fixed.  The resulting page doesn't work in IE.  The relevant JS code is
```js
if (location.search.length > 0) {
  var u = new URL(location);
  var newsearch = "";
  for(var key of u.searchParams.keys()) { // <<<=== this line
    var val = u.searchParams.get(key);
    // an empty "hq=" can be used to clear the cookie
    if (key == "hq") {
      SetCookie("PLT_ContextQuery", val);
    } else if (key == "label") {
      SetCookie("PLT_ContextQueryLabel", val);
    } else {
      if (newsearch == "") newsearch = "?";
      newsearch = newsearch + "&" + key + "=" + encodeURIComponent(val);
    }
  }
  // localtion.replace => jump without leaving the current page in the history
  // (the new url uses "index.html" and the new search part)
  location.replace(location.href.replace(/\/[^\/?#]*[?][^#]*/,
                                         "/index.html" + newsearch));
} else {
  // no parameters found? just jump to the search page...
  location.href = "index.html";
}
```

I'm pretty sure IE doesn't support for-of loops.  You'd need to use the wordier for-in loop with a hasOwnProperty check...
Does this mean attributes are going to be available that lower-layer too? (And I could easily believe this is a confused question; apologies in advance if so.)
Attributes have always acted as syntax pattern variables. They should continue to behave the same. (Including support for promises, behavior on absent matches, etc.)

One new feature is that if `x` is bound as an attribute, an occurrence of `x.y` is an error until `x.y` is also bound as a pattern variable. (Because it was probably intended as an attribute reference rather than a literal.)

Did that answer your question?
Yes, I think so. Thanks!
If you are suggesting it is a misleading error message: I agree, it used to mislead me, and occasionally a student.
If you expected it to work: the problem is that `s` is used it before its definition. This works:
```
(define-syntax-rule (s (f x ...) e) 0)
(s (cons a d) (cons a d))
```

For reference in this discussion, the error for using a function before its definitions is:
```
s: undefined;
 cannot reference an identifier before its definition
```
which was generated by:
```
(s '(cons a d) '(cons a d))
(define (s x e) 0)
```


Merged, thanks.
Can you check something? I suspect that B IS removed but that you get an
error from `raco setup` ever after just because `A` is gone. (`raco pkg`
runs `raco setup` after every transaction.)

On Wed, Sep 20, 2017 at 5:20 PM, Leif Andersen <notifications@github.com>
wrote:

> If I have some package A, and another package B that depends on A.
>
> If I first delete the folder that contains the code for A, followed by
> running:
>
> raco pkg remove B
>
> The package will fail to be removed, and instead I will get an error like
> this:
>
> Removing B
> raco setup: directory: #<path:/home/leifandersen/A> does not exist for collection: "A"
>   context...:
>    /usr/racket-6.10.0.1/collects/setup/setup-core.rkt:327:2: collection-cc!20
>    /usr/racket-6.10.0.1/collects/setup/setup-core.rkt:476:8: for-loop
>    /usr/racket-6.10.0.1/collects/setup/setup-core.rkt:469:4: for-loop
>    /usr/racket-6.10.0.1/collects/setup/setup-core.rkt:71:0: setup-core
>    /usr/racket-6.10.0.1/collects/setup/setup.rkt:65:3
>    /usr/racket-6.10.0.1/collects/pkg/main.rkt:17:0: setup
>    (submod /usr/racket-6.10.0.1/collects/pkg/main.rkt main): [running body]
>    /usr/racket-6.10.0.1/collects/pkg/raco.rkt: [traversing imports]
>    /usr/racket-6.10.0.1/collects/raco/raco.rkt: [running body]
>    /usr/racket-6.10.0.1/collects/raco/main.rkt: [running body]
>
> —
> You are receiving this because you are subscribed to this thread.
> Reply to this email directly, view it on GitHub
> <https://github.com/racket/racket/issues/1808>, or mute the thread
> <https://github.com/notifications/unsubscribe-auth/AAOM-ulwndO3oWsRPLTByI6Cfzhhmdtiks5skYG7gaJpZM4Pefig>
> .
>



-- 
-=[     Jay McCarthy               http://jeapostrophe.github.io    ]=-
-=[ Associate Professor        PLT @ CS @ UMass Lowell     ]=-
-=[ Moses 1:33: And worlds without number have I created; ]=-

Hm. 

Nevermind?

I've gone back through the entire setup process, and I suspect there was user error involved. I have no errors on load/save.

I'm closing the ticket.
I checked, and yes.

- `raco pkg show B` says that `B` is removed
- `raco setup` errors every time I run it

Attached: the `A` and `B` folders I used.
[A-and-B.tar.gz](https://github.com/racket/racket/files/1322408/A-and-B.tar.gz)

Okay, but isn't the error that A has a problem in `raco setup`, not `B`? Just deleting A's directory out from underneath Racket is surely going to be a problem
@jeapostrophe Should `raco setup` / `raco pkg` be more graceful when handling a missing / deleted linked package with no packages that depend on it?
Should this have some tests?
Probably, and added to `pkgs/racket-test-core/tests/racket/cstruct.rktl`
Okay @samth tests added.
LGTM
(The failing tests are because unicode.org was down during the time travis was building. Once it goes back up the tests run as expected.)
LGTM
LGTM
