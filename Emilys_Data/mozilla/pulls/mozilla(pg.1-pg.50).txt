Does this make sense to you?

I'm thinking other things like logging preferences, hot reloading could go here

It seems silly to add gecko as a dependency just for some css, but we'll probably need it for something soon and our target audience has gecko... What do you think?

Hm, I posted here before but github lost my comment. Their service went down earlier today.

I don't think this config should one of the steps in the readme; I'd rather it be an optional footnote. So far we've gotten away with not needing any config, and it's one less step for someone to get up and running. What do you think of moving this to the bottom under a "Config" or "Advanced" section?

I'd say either make it optional (somehow conditionally pull in themes), or we should just copy themes into `ff-devtools-libs`. Those files are super easy to copy and don't require any changes, so will be easy to stay up-to-date. I don't love the idea of depending on gecko because I'd like to eventually send this around to people to feedback, and it would be great if they could just fire it up.

Made a minor style decision to load ff-devtools-lib modules before debugger.html modules. Feel free to push back

This is a copy pasta from debugger-controller. As a side-note it would be nice to consider adding local storage of preferences in `ff-devtools-libs` in the next milestone so that these preferences can be tested early on. I don't anticipate it too be hard.

Nah that's fine. I'd prefer to remove that newline and just have them all in one block though. I like that ordering.

When you select a tab, you're doing two things: attaching to the threadClient and loading sources. Chaining these actions in the click handler seemed a little dirty, but better than other alternatives. For example, I tried to dispatch the loadSources action from within the selectTab action, but it seemed bad for Tab actions to know about Sources actions.

These listeners used to be setup in `main.js`, which had access to the store and actions. 

It seemed like too much coupling for `thread-client` to have access to the store and actions, so I moved them here. Thoughts?

Is there a better way to see if a seemless-immutable object is empty?

It's so nice to see red in a bootstrap file like main.js. With that said, I tried to not lock us into a solution with too rigid an API.

The name `toolbox` is somewhat of a placeholder because that's a fairly well defined word. Do you think it works here?

I tried three different hacks for exporting `gThreadClient`, which would let us do something like:

``` js
const {gThreadClient} = require('../thread-client');

function loadSources() {
  gThreadClient.getSources();
}
```
1.  exporting a reference to the threadClient
   - `module.exports.gThreadClient = threadClient`  
   - webpack would get a reference to the module before the exports property had been set
2. exporting a stub that received threadClient properties
   - `Object.assign(gThreadClient, threadClient, threadClient.__proto__)`
   - webpack would get a reference to an object with all of the properties except the threadClient's prototype getters, which we could get if we did a slightly better deep clone than Object.assign
3. exporting a getter
   - `module.exports = {get gThreadClient () {return threadClient}}`
   - webpack would get a reference to threadClient before it was set.

Ultimately, I decided to leave `gThreadClient` a global for the time being. :)

`loadSources` is an action that means "get all the sources for the page". It definitely should not install listeners. There's no reason I can't call `loadSources` multiple times, and the current debugger does just that when switching sourcemaps on/off. I'd rather keep everything in `main.js` for now and next week we can clean up the protocol part.

I don't think it's too much coupling. For things outside the react/redux system, it's a simple pattern for them to "hook up" to it by directly dispatching actions on the store. It makes it very clear what "drives" the system. An initial action (not one dispatched from within an action creator) can _only_ be dispatched from two places: a UI event from a component, or a network event from some external source. I think it's nice to be able to see how the external source "binds" itself to the system: in this one file, all of the network events map to these actions.

The core issue is that actions can be called multiple times, so you don't want to have side effects in there that shouldn't happen multiple times.

You aren't doing anything async, so you should just return the action:

``` js
return {
  type: constants.ADD_TABS,
  value: tabs
}
```

The only reason you need to return a function that takes `dispatch` is if you need to dispatch something later, like `setTimeout(() => dispatch(...), 100)`

Yeah, it's generally not good to tie down actions like that, so I think this is fine. I don't think it's really that dirty: it's not uncommon to want to hook up a workflow like this, and that's why any async actions that use the promise middleware return promises when they are dispatched. It allows you to do stuff like this.

What do you think about this style? It removes some vertical noise.

``` js
 {  'className': 'tab',
    'data-actor-id': tab.actor,
    'onClick': onClickTab }
```

`Toolbox` might be too confusing. It implies a toolbar where you can select multiple tools. I'd prefer a different name, but I don't know what. `TabList`? 

seamless-immutable objects are normal JS objects. It just freezes them and augments them with a few more methods. But they are totally normal JS objects.

I think we should bite the bullet and switch everything to immutable.js though. I've had some troubles with seamless-immutable: https://gist.github.com/jlongster/028c83ed09d99c09983a#seamless-immutable

Yeah, sounds good. Let's talk next week about this.

Can you rename the file to "client.js" or something like that though? Because it creates the entire connection, not just the thread client. Eventually we will need the `DebuggerClient` for some things too, I think. You could name this `connection.js`, I dunno.

That works for me. 

nice

got it

This file is required in other places, so it doesn't need to be imported here.

I wonder if it'd be helpful to move some of the breakpoint source data collection to queries.js. So, instead of getting sources in the breakpoints component and formatting it with `URL`, you could get breakpoint props with a formatted pathname, which would be useful here and maybe other contexts as well.

@jlongster what do you think?

Breakpoints was refactored to be a react class because it needed to use connect, does that make sense? Also, should we be transitioning to es6 class syntax e.g. `class Breakpoints extends React.Component { }`

I'd still like to have this command here. It's nice to be able to copy and paste for people that want to do it quickly and not create a config file. It also exposed exactly what `start-firefox` does.

That's a very weird edge case. Is it worth having `start-firefox` if it only works some of the time?

Good point. I like that it's not magical. 

Let's kill it. I don't think it adds a lot of value. 

the style comments should be on the top of the file along with the license

@matt-oconnell did you delete the other import/url references in the file? If so, could you comment them out instead so it's clear what we need to move over to have the full functionality

@jlongster do we want to support the dark theme now? I am inclined to say now because this is just a prototype.

If we don't we can get rid of the selector scoping. If we do, I think we want to be consistent with the original [variables.css](https://dxr.mozilla.org/mozilla-central/source/devtools/client/themes/variables.css).

Thoughts?

Fixed in updated commit.

I don't love the class syntax, honestly. You lose auto-bound methods and I don't see much gain. We can still use the `foo() { ... }` syntax for declaring methods in objects, and we probably should start doing that. The only other syntax difference is `class` instead of `createClass`. I forget exactly but I think there were one or two other gotchas with ES6 classes.

(ES6 classes are also not optimized in SpiderMonkey yet, which is a big deal)

Yeah, that makes sense. Also, we have utility functions for parsing URLs. But I'm fine merging this and tweaking it later. I'll leave it up to you whether you want to merge this now or wait for this to be moved into `queries.js`.

Cool. That's why i asked. 

this allows more globals to be defined (document, window...)

this is because eslint doesn't know we're using a module system...

helps with a dispatch call on line 34, where dispatch is shadowing the outer define. We might want to disable shadowing globally for this reason.

was hungarian formatting

was tempted to add this to the list of globals in eslintrc, but figured, we'd be refactoring soon

for run_test

dropped this because it wasn't necessary.

dropping these in favor of consistent styles. might be a bit ugly, but that's okay

Yeah, I don't care too much about that rule. But if the devtools eslint forbids shadowing I guess we should keep it.

It'd be really nice to have an `.eslint` in all test directories that automatically define the globals so that we don't need this at the top of every test file.

This makes it so that we don't need "use strict"? How does the module system affect that?

We should probably keep "use strict"; at the top of all the files even if we could automatically do that in our build system, so that the code works the same way when we merge.

Sorry if I'm mis-interpreting, I'm not too familiar with eslint so it's a little hard to read all these tweaks.

happy to do that.

I'm not really sure what introductionType is doing, but this is what we were doing before, so i kept it

Related to issue #31. We can add a couple small utility functions that DRY up our code a lot. 

This is no longer necessary: [npm start](https://github.com/jlongster/debugger.html/blob/master/package.json#L4)

thanks, this was something that a lot of people needed yesterday

afterwards, maybe say. Quit and re-open firefox with the same command.

Please leave this line as it was. It's ok to check for general falsy-ness here.

Please leave the underscore. It's an internal function.

fixed.

fixed

You're not actually using a component. You're just using a function. You create a component with `React.createElement(Breakpoint)`. I would just rename `Breakpoint` as `renderBreakpoint` to make it clear that it's just a function.

`introductionType` comes from the JS engine and tell you what kind of source it is (eval, new Function, script tag, etc). Many scripts don't have a URL if they are eval'ed. You see this on any complex site; the list of sources includes things like `Function`, `eval`, etc. Eventually we will want to treat this differently.

sounds good

Why do we need `devtools.chrome.enabled` ? This is good to document, definitely

This and `componentWillReceiveProp` both need a lot of work. I'd say we mostly ignore this code for now until we focus on the editor. For some reason this code was giving me problems and it worked without it.

agreed. figured that was a placeholder at the time

it'd be nice to have better annotations at somepoint

nice. looks much nicer.

I just realized I think I messed up the structure here. `tab-url` shouldn't be inside of `tab-title`. Doh! You're structure before was pretty good but the main thing was moving the props down. Otherwise my JS formatter wants to bump the rest of the args over to line up with it...

Anyway, I'll make a new commit that fixes the structure

Just found this: https://www.npmjs.com/package/react-immutable-proptypes

is this still used in a couple places.

:+1: 

NOTE: this is just inside of the tests dir

found our first bug!

I'm not convinced we need these...

Heh, I hit something similar when I ran the first test under xpcshell. I thought I fixed this? Ah well, maybe not!

eslint fixes

should have killed earlier

it'd be nice to pull in a list of globals for mocha, node, ...

because for the time being the `test` and `test-browser` are dumb and can't recursively search for test files

`debugTab` used to be duplicated in `Tabs` and `Main`.

I'm really happy that in many places this PR cleaned up existing components. i.e. extracting actions from Breakpoints.

breakpoint gutters are now added as part of the `componentWillReceiveProps` lifecycle so that breakpoints are persisted as selected source changes. It is also more uni-directional ðŸ˜‰ 

this is definitely going to conflict with your breakpoint work, but hopefully it's very similar to what you have

Why are you copying unsolicitedEvents here? It looks like you are only using it to log the protocol, but this isn't the place to do it. If you set `require("devtools/shared/DevToolsUtils").dumpn.wantLogging = true` it should enable verbose logging which should log the protocol. If not, we just need to fix that in `ff-devtools-libs` because that's how it works in gecko-dev. (that setting is also flipped with a pref)

As said in my other comment, I'd prefer if you reverted the breakpoint-related changes in this file. I'm actively working on it already.

(edit: I see you added the debug line stuff, which is fine, that shouldn't conflict if it's just some extra functions and tweaks to the render method)

I don't think "breakOnNext" should be an array.

Is this stolen from our existing debugger? Just curious.

oh oops

yeah. but modified not to use `this`

cool

Can you remove the unsolicitedEvents here? I don't think we should add them here. Otherwise this PR is fine to merge

Are you sure you need a container? A previous commit made `.editor` have a width/height of 100% but it was removed for some reason. I think it was like this before:

```
.editor { flex: 1}

.CodeMirror { width: 100%; height: 100% }
```

You're supposed to give `.CodeMirror` a width/height if you want to tell CodeMirror what it should be. I think that should work and avoids a container element, but I could be wrong.

sadly that doesn't work due to a chrome flex box bug with height and width's with percentages.

damnit Chrome, so many bugs

This should probably be a query `getBreakpointBySourceLine(source, line+1)`

Could this also be two functions: `getBreakpoints` and `getBreakpointsByActor`?

In the case of the editor, I think you'll always want to call `getBreakpointsByActor` even if there isn't a selected actor. If there isn't a selected source, then the editor doesn't want any breakpoints. 

If you're updating the `makeLocationId` callsites, do you need to coerce here as well?

Also, I'm wondering why location is not immutable default. I ran into this in other places [as well](https://github.com/jlongster/debugger.html/blob/master/js/actions/breakpoints.js#L40)

It could be. I don't think every single data access needs to be a query though. If we expect to get an array of things, I think it's fine to operate on that array instead of having to go back through the queries. The queries mainly abstract out where that array comes from, so you can change around your app state.

You could even say that accessing the line from the location field of a breakpoint should be a query. But we can accept some amount of dependency on the state shape to make things more straight-forward.

So I'm not against it, but I'd rather wait and see if we need that in more than 1 place.

Yeah, that's a good call.

Makes sense. 

There is still some mismatch in a few places. This is what I was referencing in the first paragraph of this PR description. We should not need to coerce here; it was a stop-gap. There seemed to be one or two places where a non-immutable value would come through here but it wasn't straight-forward how.

I'll look at this more now and see if I can't do a more thorough conversion to immutable.

We need to decide which values are immutable or not. It's clear that if our state is immutable, components will receive immutable values and use them directly. But I think any parameters to actions or queries should be normal JS objects because you usually pass literals in (`action({ line: 5})`).

`[ninja]`s, there can be only one!  ðŸ¤• 
In general good, not sure about the Ninja part.  I like that its not `maintainers` which always sounds pretty lame.  Keep it fun!  Maybe lets keep asking around for more ideas.
The `default` here is necessary because we're using the es6 class in a non-es6 like world.  The switch to `import` and JSX would allow us to remove that.  There are also babel plugins to remove this as well but its only temporary.
But seriously I think you mean: `[ninja]:./docs/local-development.md#ninja` ðŸŽƒ 
The link probably needs the text `-runner` appended.
Might want to expand `OSS`
Weird that this was working before...
Why not `import { findDOMNode } from "react-dom";`?
Good question!  Essentially `nextProps` is the `propTypes` attribute of the class but I don't really want to write it out twice.  Here are the patterns I've seen in the wild when researching this.

Use the [flow-react-proptypes](https://github.com/brigand/babel-plugin-flow-react-proptypes) plugin.  This means you create a flow type for your prop types and don't define the `propTypes` in your react class; like this:

```js
type PropTypes = {
  breakpoint: Breakpoint,
  editor: any
};
```

And then babel would compile that type into a PropType for react.  This pattern doesn't settle well with me right now.  I wonder about our plans to move to es6 classes and how well this plugin works.  

Then of course other people just define both:

```js
type PropTypes = {
  breakpoint: Breakpoint,
  editor: any
};
const Breakpoint = React.createClass({
  propTypes: {
    breakpoint: PropTypes.object.isRequired,
    editor: PropTypes.object.isRequired
},
 shouldComponentUpdate(nextProps: PropTypes) {
 }
});
```

Which is a bit of overhead but would actually type the `propTypes` correctly.  Other than the overhead I don't think there is anything wrong with this pattern.  

My ideal pattern would be to type the `propTypes` inline.  So it would look something like this:

```js
const Breakpoint = React.createClass({
  propTypes: {
    breakpoint: PropTypes.object.isRequired: Breakpoint,
    editor: PropTypes.object.isRequired: any
},
 shouldComponentUpdate(nextProps: propTypes) {
 }
});
```

But so far in other components we haven't cracked this egg.
Much better! ðŸŽ‰ 
Markdown pro-tip! You can just define `[L10N]` at the bottom instead of creating the lowercase `[l10n]` alias and then here simply use `[L10N]` without anything else.
You could type this as a `number`
And then you wouldn't need to type the function return here.
Perhaps too far? ðŸ˜ 

It does ensure we're using the right link everywhere, previously this pointed to https://devtools-html.slack.com/messages/general/ instead of the heroku page https://devtools-html-slack.herokuapp.com/ and I think that's the right way to point people.

Which also reminds me that we should fork the heroku app into `devtools-html` so we can customize it as needed.
But I'm not sure why the diff doesn't handle those well.
We could call this something like: `--theme-selectable-background-hover` which should indicate that is a select-able object.
If we follow that pattern, this becomes something like `--theme-selectable-color-hover`
And this is something like: `--theme-selection-focused-background`
This is an interesting change!
ðŸ”¥ ðŸ‘ 
Is an enumeration possible here for align?
I think mode is a string in the opts type, right?
Oh strange, never mind then
Just asking, I didn't take a deeper look. String is a good start. 
Can you explain the difference here between `StartItems` and `EndItems`? they look so similar except for `button` vs `buttons` and I'm not sure why we have a `button` attribute.
Maybe this is what confuses me.  These are `StartItems` but there is a `buttons` attribute in the first one.
I think `any` is ok for now.  This is a good size change and we can dig into that later.
I'm not sure why this is. 
I don't know this stuff well, but could this be `margin-inline-start` instead?
I think this is extra unless you need headers
This means that we debounce for all requests happening within 100 of each other. However we'll never go more than 250 before running the `forceUpdate`.  So this becomes the combination of throttle and debounce, hopefully for the experience we want.
This line is a hair too long now! ðŸ˜± 
ðŸ‘ 
Why this change?
Any reason for `let` instead of `const` here?
I wasn't sure if we wanted add coverage to the default test script instead of a creating a new one.
I also added a `.` here which is what I believe is needed and was just missed from copy / pasta
I think the initial state for `hiddenTabs` is `null` so it might be best to return that here instead of undefined.  Not sure what's best.
I was trying this but then got console errors.
I don't understand.  What does this filter check for?  That `i` exists?
I think you should be able to do `pauseInfo.getIn(["why", "exception"])` here.  I'm pretty sure I did the `getIn().get()` pattern above for `message` and I think I made a mistake.
Oh that's interesting.  I wonder if this means we should only be importing the things we need from `immutable` in the future.  Thanks for pointing this out and looking it up. ðŸ¥‚ 
ðŸ¤¡ 
I think this is supposed to be under the `- image:` block
Here are the docs on [feature flags](https://github.com/devtools-html/debugger.html/blob/master/docs/feature-flags.md)
I've got
```
$ ./node_modules/.bin/prettier --version
1.3.1
```
Should probably leave this in
Should probably use **ET** instead of EST, right?

And the other one should be 12pm **PT**
done.

I personally don't like conflating more than one task in a single function.

For the regexp I'm not sure how loose you'd prefer but you might tighten it up to `/\blodash\b/`
I was thinking more to avoid false positives for things like `lodashify`, `slodash`, or `underscoreize` kind of names.
Ah, damnit. Guess I'm writing some tests as penance.
Yeah, the more I think about the reselect work, I'm of a mind to do things _the right way_ unless this editor perf issue is showing up in regular usage.

For `Editor`, adding reselect could enable us to memoize the `getExpression` function prop and then this complex `shouldComponentUpdate` wouldn't be needed at all.
_contravariance_?
What was the difficulty with `defaultProps`?
The only caveat here is that it's sometimes useful to be able to "cheat" in tests, like pass in a mock object that doesn't match the full type but does just what this particular unit test needs.
There are still a lot of `any`s, especially for callback functions and items stored in Immutable structures. Might be good to either review if they are trivially removable or, if there are real impediments, make a list of what they are.
_React components_?
Well the problem is we already have a selector `getSourceById` that takes the full state and an id. This function takes just the actual sources map and an id. For various kinds of callers, we need both.
I think this means that some related data can be set in a non-deterministic order based on how async actions happen to fire. (Especially true for things like parsing that happen in a separate web worker thread.) Flow makes us declare which things have to be present together and prove that all possible state transitions meet those rules.
Yeah, not sure what to do without finding a better name for either the top-level "sources state" or the nested "sources by id map".
Unfortunately, that distinction is made for a very particular reason. You can select a new sourceId but not have it yet be visible (if you're waiting for it the source to be fetched, for example). For this component to know when to run its editor commands, it needs to know when the source is actually displayed. Prior to this change, the highlight would run right away, and when the source arrived, it would be put in a new document and not get the highlight. This makes me think we need a way of telling side-effecting editor children something about the identity of the displayed document. 
This runs into the same thing with selected v visible, but yeah, I think it makes sense to not render if the visible document shouldn't have a highlight.
Unfortunately, I think we really need data about what source is shown in the editor. It's possible that the source text has loaded but we're at some state where the editor hasn't yet been updated to the new document. (Because that happens in lifecycle callbacks which may _happen_ to occur before or after this component renders with the new source data.)
Could `Array::find` work here as well, @jasonLaster ? We seem to have mixed use of lodash and native find across the code.
Hm, I posted here before but github lost my comment. Their service went down earlier today.

I don't think this config should one of the steps in the readme; I'd rather it be an optional footnote. So far we've gotten away with not needing any config, and it's one less step for someone to get up and running. What do you think of moving this to the bottom under a "Config" or "Advanced" section?

I'd say either make it optional (somehow conditionally pull in themes), or we should just copy themes into `ff-devtools-libs`. Those files are super easy to copy and don't require any changes, so will be easy to stay up-to-date. I don't love the idea of depending on gecko because I'd like to eventually send this around to people to feedback, and it would be great if they could just fire it up.

Nah that's fine. I'd prefer to remove that newline and just have them all in one block though. I like that ordering.

`loadSources` is an action that means "get all the sources for the page". It definitely should not install listeners. There's no reason I can't call `loadSources` multiple times, and the current debugger does just that when switching sourcemaps on/off. I'd rather keep everything in `main.js` for now and next week we can clean up the protocol part.

I don't think it's too much coupling. For things outside the react/redux system, it's a simple pattern for them to "hook up" to it by directly dispatching actions on the store. It makes it very clear what "drives" the system. An initial action (not one dispatched from within an action creator) can _only_ be dispatched from two places: a UI event from a component, or a network event from some external source. I think it's nice to be able to see how the external source "binds" itself to the system: in this one file, all of the network events map to these actions.

The core issue is that actions can be called multiple times, so you don't want to have side effects in there that shouldn't happen multiple times.

You aren't doing anything async, so you should just return the action:

``` js
return {
  type: constants.ADD_TABS,
  value: tabs
}
```

The only reason you need to return a function that takes `dispatch` is if you need to dispatch something later, like `setTimeout(() => dispatch(...), 100)`

Yeah, it's generally not good to tie down actions like that, so I think this is fine. I don't think it's really that dirty: it's not uncommon to want to hook up a workflow like this, and that's why any async actions that use the promise middleware return promises when they are dispatched. It allows you to do stuff like this.

What do you think about this style? It removes some vertical noise.

``` js
 {  'className': 'tab',
    'data-actor-id': tab.actor,
    'onClick': onClickTab }
```

`Toolbox` might be too confusing. It implies a toolbar where you can select multiple tools. I'd prefer a different name, but I don't know what. `TabList`? 

seamless-immutable objects are normal JS objects. It just freezes them and augments them with a few more methods. But they are totally normal JS objects.

I think we should bite the bullet and switch everything to immutable.js though. I've had some troubles with seamless-immutable: https://gist.github.com/jlongster/028c83ed09d99c09983a#seamless-immutable

Yeah, sounds good. Let's talk next week about this.

Can you rename the file to "client.js" or something like that though? Because it creates the entire connection, not just the thread client. Eventually we will need the `DebuggerClient` for some things too, I think. You could name this `connection.js`, I dunno.

I'd still like to have this command here. It's nice to be able to copy and paste for people that want to do it quickly and not create a config file. It also exposed exactly what `start-firefox` does.

That's a very weird edge case. Is it worth having `start-firefox` if it only works some of the time?

I don't love the class syntax, honestly. You lose auto-bound methods and I don't see much gain. We can still use the `foo() { ... }` syntax for declaring methods in objects, and we probably should start doing that. The only other syntax difference is `class` instead of `createClass`. I forget exactly but I think there were one or two other gotchas with ES6 classes.

(ES6 classes are also not optimized in SpiderMonkey yet, which is a big deal)

Yeah, that makes sense. Also, we have utility functions for parsing URLs. But I'm fine merging this and tweaking it later. I'll leave it up to you whether you want to merge this now or wait for this to be moved into `queries.js`.

Yeah, I don't care too much about that rule. But if the devtools eslint forbids shadowing I guess we should keep it.

It'd be really nice to have an `.eslint` in all test directories that automatically define the globals so that we don't need this at the top of every test file.

This makes it so that we don't need "use strict"? How does the module system affect that?

We should probably keep "use strict"; at the top of all the files even if we could automatically do that in our build system, so that the code works the same way when we merge.

Sorry if I'm mis-interpreting, I'm not too familiar with eslint so it's a little hard to read all these tweaks.

Please leave this line as it was. It's ok to check for general falsy-ness here.

Please leave the underscore. It's an internal function.

You're not actually using a component. You're just using a function. You create a component with `React.createElement(Breakpoint)`. I would just rename `Breakpoint` as `renderBreakpoint` to make it clear that it's just a function.

`introductionType` comes from the JS engine and tell you what kind of source it is (eval, new Function, script tag, etc). Many scripts don't have a URL if they are eval'ed. You see this on any complex site; the list of sources includes things like `Function`, `eval`, etc. Eventually we will want to treat this differently.

This and `componentWillReceiveProp` both need a lot of work. I'd say we mostly ignore this code for now until we focus on the editor. For some reason this code was giving me problems and it worked without it.

I just realized I think I messed up the structure here. `tab-url` shouldn't be inside of `tab-title`. Doh! You're structure before was pretty good but the main thing was moving the props down. Otherwise my JS formatter wants to bump the rest of the args over to line up with it...

Anyway, I'll make a new commit that fixes the structure

Just found this: https://www.npmjs.com/package/react-immutable-proptypes

Why do we need `devtools.chrome.enabled` ? This is good to document, definitely

Heh, I hit something similar when I ran the first test under xpcshell. I thought I fixed this? Ah well, maybe not!

It could be. I don't think every single data access needs to be a query though. If we expect to get an array of things, I think it's fine to operate on that array instead of having to go back through the queries. The queries mainly abstract out where that array comes from, so you can change around your app state.

You could even say that accessing the line from the location field of a breakpoint should be a query. But we can accept some amount of dependency on the state shape to make things more straight-forward.

So I'm not against it, but I'd rather wait and see if we need that in more than 1 place.

Yeah, that's a good call.

There is still some mismatch in a few places. This is what I was referencing in the first paragraph of this PR description. We should not need to coerce here; it was a stop-gap. There seemed to be one or two places where a non-immutable value would come through here but it wasn't straight-forward how.

I'll look at this more now and see if I can't do a more thorough conversion to immutable.

We need to decide which values are immutable or not. It's clear that if our state is immutable, components will receive immutable values and use them directly. But I think any parameters to actions or queries should be normal JS objects because you usually pass literals in (`action({ line: 5})`).

Why are you copying unsolicitedEvents here? It looks like you are only using it to log the protocol, but this isn't the place to do it. If you set `require("devtools/shared/DevToolsUtils").dumpn.wantLogging = true` it should enable verbose logging which should log the protocol. If not, we just need to fix that in `ff-devtools-libs` because that's how it works in gecko-dev. (that setting is also flipped with a pref)

As said in my other comment, I'd prefer if you reverted the breakpoint-related changes in this file. I'm actively working on it already.

(edit: I see you added the debug line stuff, which is fine, that shouldn't conflict if it's just some extra functions and tweaks to the render method)

I don't think "breakOnNext" should be an array.

Is this stolen from our existing debugger? Just curious.

Can you remove the unsolicitedEvents here? I don't think we should add them here. Otherwise this PR is fine to merge

Do you feel strongly about chai? I prefer https://www.npmjs.com/package/expect, but I don't want to slow this down.

I'd rather it be like it was before so you don't always have to add a new variable here whenever you need another action. You also don't have to worry about importing any actions/queries/etc. It's not that big of a deal to do `actions.newSource` instead of just `newSource`

Whatever feels right :)

Why not move `configureStore` into here and dynamically create a new store constructor each time and just close over the mock thread client?

Are you sure you need a container? A previous commit made `.editor` have a width/height of 100% but it was removed for some reason. I think it was like this before:

```
.editor { flex: 1}

.CodeMirror { width: 100%; height: 100% }
```

You're supposed to give `.CodeMirror` a width/height if you want to tell CodeMirror what it should be. I think that should work and avoids a container element, but I could be wrong.

damnit Chrome, so many bugs

This is a strange style. Can you move the last curly brace to a new line?

``` js
const {
  getSourceText, getPause, getBreakpointsForSource,
  getSelectedSource
} = require("../queries");
```

Yeah, that makes me really sad. Flexbox was supposed to allow us to avoid this kind of stuff. But I guess it works for now.

Honestly I can't really remember the real reason I switched a while ago. Maybe we should see what tofino is using; if we don't care too much it'd be nice to be on the same page for some stuff like this

I like this as documentation. It would be nice to make this as clear as possible though if it's going to be used as component docs. What if you made `renderBreakpoints` take the state instead, so none of these stories would to do the `configureStore` stuff? All it would do is pass the state.

Why'd you change this? Any specific reason for the storybook? I personally like the URL matching the filesystem, and we may add other directories later.

fwiw, if you use a query a lot in a test, you can still destructure it at the top (`const { getSourceText } = queries`). 

Why use `beforeEach` when you only have one test?

It seems like there should be one top-level describe and then several "its". The describe should be just take the string "sources" and then the `it` blocks are something like `it("fails to load", ...)`. At least I thought that's how mocha worked (`describe` specifies the thing you are testing, and `it` is the action).

I'd like to avoid mutating something that came in because it might be referenced elsewhere. What do you think of this?

```
let source = Object.assign({}, action.source, {
  filename: getFilenameFromUrl(newSource.url)
})
```

This also seems like something that the component could do when selecting this data, but I'm fine putting it here instead. I just realized that we're going to have to think through how we represent various things like sources and locations in a world where we will be talking to multiple servers (firefox/chrome/etc). They each will return different types of objects. Now sure how that will look yet, but we'll figure it. (For example, Chrome doesn't have an "actor" but has "scriptId")

The only downside to adding more "derived" properties in the state is that any of our mocks will have to also specify it. I know I said that you can "normalize" data here but to me this is more "derived data". But I don't really care that much, if you think it should be here that's fine!

I'm convinced now that that should live somewhere else and we should make a selector that extracts the filename from a source. The `URL` is undefined in node and none of this code should depend on the browser. 

If it's a selector and used from a component, I think it's ok to use `URL` and assume it's a browser environment. We don't test components in node, we'll run them in the browser, from what I understand

Nit: we've been discouraging this system in the devtools codebase. We prefer:

```
dom.li(
  { className: "scope", ... },
  ...
)
```

Generally it's easier to add more properties and looks better when there are more. Also some editors (like mine) want to align the arguments. Also, space after and before curly braces.

Yeah. I'm not sure what maintaining this is going to look like. It might be possible to automate generating these fixtures though: setup a devtools connection and automatically go to the right place and dump the protocol response to these files. It seems useful to have them, so let's just see how it feels over time.

I don't love how often we are "connecting" components, and I would prefer to pull state off from above and pass it down more often. This is somewhat subjective, but it's usually preferred to do it sparingly. I'm not clear where the balance is though, and once we implement these last set of features this is a good thing to think about across the project as a whole.

I will look at that tomorrow!

Haha :)

I agree, let's keep the component clean and free of hacks. It's unfortunate that we have to do this.... but thanks a bunch for fixing it! I was noticing this and was wondering what was going on.

If you move this code to `util/editor.js` we'll merge this.

Agreed, it's annoying. Not sure I follow, how do you add those globals? The top-level .eslintrc is just a JSON file. But do whatever works :)

I feel like the configs still belong at the top-level. We could make a top-level `configs` directory. We'll probably end up wanting to put some other stuff in there, like the `port` that the server runs on.

Yeah. `mapValues` might be something we use enough to have as a utility lib without pulling down all of lodash. If we end up being able to use webpack for real in the long-term, I'd be fine requiring specific lodash functions in.

a little annoying, yeah, but reflects the real state shape

I do because the Frames component still uses `connect` to get the action creator `selectSource`. That is confusing though.

I'm going to think some more about the pattern for "connecting" components. For now I might just make `Frames` pull the state off too because everything is doing that.

Ah good, I wasn't sure if you liked it the other way for clarity, but I think this works well!

yep, I think that's a great idea!

unfortunately the line is past the allowed length: 84 chars

I'm confused, for what exactly? And that name will conflict with the `navigate` function

nit: extra line here?

These files are all commented out, are they templates or going to be fleshed out later?

Why are you wrapping this with an accordion class? If these are to be as docs that's sort of confusing.

I'll remove it, I was only using it will heavily debugging. Calling `renderToolbox` within `then` makes the entire rendering happen within a promise, so any errors will be gobbled up. We show unhandled errors in devtools but only when the promise is garbage collected, so you have to wait a few seconds (or even longer in worst cases).

Anyway, I hate promises because they are like a virus. They spread everywhere.

I hate having to do 

```
let foo;
try { 
  foo = doSomething()
} catch(e) { ... }
```

But on the other hand it's worse to hide all errors in unrelated code like my code does. I think I added code there quickly without thinking about it. Wish JS had better error handling... (is it clear that there are things about JS I don't like? ðŸ˜› )

FWIW, I didn't do this prematurely; I was using inline-svg before but it clearly slowed down the tree because it does an AJAX request for every single SVG, even if it's the same one. The library does not support caching, so I implemented it myself but still hit another problem. I think when you expanded a node, the arrows would not be in the children for a split second and it would "flash" into appearance, bumping the text to the right.

Anyway, this was very straight-forward and immediately worked really well. We may want to look into a SVG->React conversion tool.

Very popular library for conditionally adding class names: https://www.npmjs.com/package/classnames

Instead of using string concat, give it an object and it'll apply only the class names which are truthy.

Yeah you're right, this code could be cleaned up. Will do.

All of this is just reordering the imports so they are grouped better.

Not sure I understand this; the `eval` happens right above this so the timer isn't installed before the `eval` finishes executing. But this is all magic to me.

Why do we depend on this?

We probably don't want to run tests directly against something pulled in from npm. It just seems too likely to change. I'd rather run tests against static files directly commited in our repos.

It's essentially a higher-order component. It's quite useful to do this sort of stuff in React, but how we use it definitely should be documented.

The Tree component that we use has no component state (well, right now I think it does track the window height but I want to remove that). It doesn't keep track of the current focused item, or which nodes are expanded. It's all up to the consumer to handle that. It's nice to do it that way for several reasons: it makes tests easier to write, and it allows the consumer to store that info somewhere else like redux if they want to.

But it puts a lot of burden on the user, especially if they are trying to learn how to use the tree. This is a common problem with components: who manages the state? A good technique is to offer two variants of the same component: one that doesn't manage the state, and one that does (here, we are calling it "managed").

So we're just wrapping the Tree widget (so we can't change the prop names, we are passing all of that into the Tree) and handling the necessary state for it to work.

In practice, React has more going on than just "props passed down, events go up". For ease of use it's local component state is really nice. Also, there's really no reason it has to be separated from Redux state. At some point React should allow the consumer to "mount" the internal state of any component somewhere else; you can read about it [in this React issue](https://github.com/facebook/react/issues/4595).

Anywhere, we're still figuring out the best patterns here and we'll definitely document them more.

I thought we decided to avoid this for now? I'd rather create a query string that specifies the target we should debug. It could take either a `chromePort` or `firefoxPort` option and depending on that it would connect to the specific target. It just feels easier to think about what I'm debugging, because I'm debugging a specific "tab" but is it a Firefox or a Chrome tab? We aren't building a toolbox/IDE right now, so I'd prefer to make it clear by using URL params to designate the debuggee.

Same as my comment above, I don't love this ambiguity because I'll find myself with the same page open in Firefox or Chrome (while testing) and it's not clear which browser I'm testing. I'd rather encode the target browser in the URL params.

Switching from `actor` to `id` is a good idea, we'll probably do that for all objects

`present` is a little ambiguous to me, it feels pretty close to `render` but this isn't actually presenting anything, it's just formatting. Not sure if there's a better word? If you want to keep it, that's fine!

Where did these files in the `chrome` folder come from? Might be worth documenting (unless they already are and I missed that)

I see another file has a "comes from" message, but it's just a relative path that doesn't link to anywhere. I haven't finished this PR yet, but it might be nice to have a `.md` in here describing exactly where to get these files.

Nit: space after equals

Can you file an issue to figure out a way to avoid both `delete` and `eval`? It does seem like something we should do sooner rather than later. 

I wonder if shadowing `String` would work?

```
const _String = String;
function String() { return _String.apply(this, arguments); }
String.prototype = Object.create(_String);
String.prototype.toTitleCase = ...
```

Not sure if that's totally correct or would even work...

This comes from the file `bootstrap.js` though, which is built by `public/js/clients/chrome/build-bootstrap.js`. Are you supposed to run that file manually to update `bootstrap.js`, and commit the changes?

My gut feeling is a little different. This is a build flag, and config files (to me) are runtime flags. The risk with moving this to a runtime flag is that somehow the wrong config is used to generate the bundle and when we automatically publish this into Firefox it doesn't work. `webpack.config.devtools.js` wants to unconditionally build a bundle for Firefox.

The other advantage is that it removes a step from the whole process of generating the Firefox bundle, so other people that do it just run `webpack --config webpack.config.devtools.js` and they get it. They don't need to muddle with config.

Another example: locally I'm developing something, then I want to test it in the Firefox devtools. I get the feature working and all I have to do is run that webpack command. I don't need to go into my config to switch the flag, generate it, and then switch it back. If I forget to switch it back I can't just run it locally.

Perhaps I like build-time flags more than config flags, because it seems simpler to coordinate local development.

Maybe there's a way to still specify this flag at build-time from webpack, but actually change the config json value? We could do this with things like `nconf` but I'm not sure the best way to set it here.

I was running into some weird problems and commented this out to make sure it wasn't that problem, but it wasn't related. I don't see any problem leaving this in here unconditionally, but we could put it behind a flag as well.

Yeah. The problem is that we've integrated the toolbox so we have to have a tab selected, so we just fake one. We don't actually use the tab from the store anywhere, so it's not a big deal. There might be a better way to do it; I'll think about it some more.

Yeah, this is fine for now.

You could make the panel get a reference to itself to close it, but you may be thinking that we want to close it from other places too which is why it's stored on the component, so that does make sense.

linter was complaining that `File` is a builtin type that we are overriding so I had to change these. Will probably pull them out later today too

I'm not completely sure about separating out the agents, but this made it so I could use it directly in `APIClient`. I suppose I could always call `getAgent("Debugger")` but this seemed like less work. I'm fine reverting this change though.

It's meant to be a clear indication that it's a global dynamic object, separating it out from local variables etc. When you see it anywhere in code you know where it comes from (it's not passed in, etc). Honestly, it comes from Scheme/Lisp where they have real dynamic variables all of them are called `current-*` but that convention has been carried over in other places as well.

But I'll remove the `current` prefix, it's not a big deal.

I agree, that would be great. Let's do that as a follow-up. I started feeling the same way as I was writing this.

If you look at the Firefox client I haven't actually translated id->actor anywhere yet, so it's still used for loading source text and probably other places. I will remove it today.

Yeah I don't have a good feeling about it. I think the most important thing is that we write code that is similar to other devtools code, and it doesn't matter where these modules live. We may want to merge `util` and `lib` somehow at some point.

It's confusing that you call `renderNotConnected` unconditionally; this feels like something that should be inside `renderToolbox`.

I just looked more at the code, and it took me a little bit to figure it out; `renderNotConnected` doesn't do anything if there are tabs. Personally I'd prefer to move that `isEmpty` check down here so that flow is more obvious and `renderNotConnected` only does 1 thing.

Nice, I like that this is closer to the connection code and there's not a top-level `setTimeout` any more.

Actually Jason, you were right, the new API automatically works because it just takes the `sourceId` in functions and already passes it as `actor`. I just pushed a small commit to remove this field.

Not sure what you mean; loading the frames is different than the sources. The main difference in here is at the bottom of `initPage` we call `client.getSources` instead of `actions.loadSources`. We were doing this before too; I just lumped in this event dispatcher stuff in here as well, but it just moved the previous event handlers up into here.

Ah. You are reviewing on your phone?! Don't feel like you need to, go enjoy the conference :) 

do you mind moving these collapse tests below the tests that were already in here? these seem like tests for the more advanced feature of collapsing and should be after the tests of the basic API

This code is a bit complex (inherently so), so I'm looking for any way to make it easier to follow. What do you think about making a `isCollapsed` function that runs his logic? You use it below as well. I don't care about abstracting out this logic as much as making this workflow easier to follow.

This makes sense, but I wonder if we should iterate over `parts.slice(0, parts.length - 1)`, meaning don't include the last part in this loop. It's already a little weird that overwrite the contents of the final node below. This way might a little clear, and we create the leaf node explicitly and add it (now that you have `getSortedIndex`, it shouldn't be much more verbose).

I may be missing a problem with that though, and it if takes too much time don't worry about it. We can massage this code over time.

Meant to say this: that would mean this could just be a `break` then.

Pretty slick how this works.

good point, there is. I will fix that in a follow-up PR (that I'm already working on)

Not a bad idea, but it's a little more confusing than Source or Location because in most places a breakpoint just _is_ a `Location`. The UI doesn't have any notion of a `breakpointId` like does a `sourceId`, because a `Location` is everything is needs to talk about breakpoints. At the protocol level we want an `id` and other things like `actualLocation`.

We could make a breakpoint type for the protocol though, with `id`, `location`, and `actualLocation` fields. It's clearly for the protocol, given that it has two location fields, which we can use to know if it's moved.

Unfortunately, we need to get the text if a breakpoint slides. We only know if it slides once the protocol request completes, at which point we need to query the editor again, but we have no way to do that. A function allows us to compute the new value if it slides.

EDIT: I will add a comment about this.

I don't feel strongly about it, but since we do it for the store too, it might be nice to have a function like `getDebugObjects` or something that you can destructure at the console (`const { store } = getDebugObjects()`) so that they are all grouped in one place. Or maybe that function sticks it on window itself, so you just call `injectDebugObjects()`. We can do this later.

Yeah, we could export a getter for `runtimeAgent` if you want to do this from somewhere else

Nice!

The technique here anchors the breakpoint to the beginning of the line, or the "right side" of the line number gutter. That way if there are 10,000,000 lines and the gutter expands really large, the breakpoint will be anchored to the right side and will travel with it. Unfortunately I need to do a little manual layout for that.

Did you mean to leave these console logs in?

True, I'll change it, but we'll probably want to rethink it again later because there are a few other methods for querying objects

Yeah, it's demo quality. We need to build the tree in a very different way so this will be totally re-worked when we have time to work on the object inspector again.

Gets all the variables in scope, filters out ones that are optimized out, and sorts them. 

That's fine with me

I'd rather avoid littering these around our code, as mentioned in the other places as well. I'm pretty sure you can get the CodeMirror instance from the DOM element that it sits in. That's a lot cleaner than this, so we should look into doing that instead.

I don't see it in the docs off-hand, but I'll look more. You can merge this but I'll file an issue to fix this.

`debounce` seems like the wrong abstraction though, at least for what `debounce` commonly means. Usually `debounce` means to run a function a certain amount of time after the debounced function is called, and if it is called again it resets the timer. We don't want that: we want to schedule a dispatch 10ms later, no matter what. It's more of a "throttle". Also, debounced functions don't usually depend on external state like this. This is an explicit function to queue a dispatch that can't be transparently debounced.

There probably is an abstraction here, maybe one that we could even tailor to actions specifically. I'd like to do that later though :)

I don't love this, but I'm not sure what else to do. Delaying things makes it hard to tests. One of the things I like about redux is it's so easy to think about the order in which things happen...

I really like the idea of implementing the throttling at the component level, because it's the sources component specifically that we want to avoid rerendering. That would solve this issue. More to think about...

Cool!

Yep, webpack just bundles this library and uses it instead. I explicit to `URL.parse` to be clear that we aren't using the native one. This is important because they have different semantics: the native URL will throw for invalid URLs like `/foo/bar.js` (it's a path, not a URL, URLs need the protocol). But this library will not throw, it will return `{ protocol: null, pathname: "/foo/bar.js" }`.

I don't like that the library is not compliant with browsers, but if we need this to work in node, we need to depend on it.

Nope, since the sources tree nothing uses those fields anymore.

I've come around to this idea, I like it.

Yeah, wherever we throttle it'll make it harder to test. But if we move to just testing the "dumb" component, and `connect` implemented throttling then we would bypass it easily. I'm not exactly sure of this yet. Dispatching "raw" actions isn't that bad. This test is mainly testing the reducer, so it's not a big deal.

Not sure what the right solution is, so we'll see.

The first sentence is not complete, if you drop the "while" it makes sense

Link to the README about running tests? (EDIT: well, you explain it below so it's ok)

You could link [here](https://wiki.mozilla.org/DevTools/CodingStandards#Code_style) and mention that we follow the greater devtools style guide

It's not that bug fixing isn't a priority, but fixing any bugs that relate to out-of-scope features. I would reword this to indicate something like that. Maybe even just saying "fixing all the bugs" instead of "bug fixing" sounds better.

I don't like having to guard against this every single time we require a CSS file. I'd rather just do this:

``` js
require.extensions['.css'] = function() {
  return {};
}
```

where the test runner initializes node. This will make requiring the CSS file a noop.

Yeah, might be nice to do it in this PR if it's a quick fix. If it's not for some reason, you can look into it later.

This feels like cheating :) I was thinking that stories use the raw "dumb" component and pass things in as documentation for what props the component uses. It would also allow us to develop the components in isolation.

However, I get that many of our debugger-specific components heavily rely on the pause data specifically so it's nice to just load that in. I'll try to use storybook more, as I don't have a strong opinion about this now.

I'll pull down the latest version and see if they changed the port. I bet they did.

I don't love the name `connectNode`. This isn't specific to node at all, it's just passing the websocket URL directly. It could be anything. People may use this API to build a different toolbox, or we might eventually have a websocket from Firefox to pass in. I'd rather it be something like `connectWebsocket`.

Neat. At this point, I wouldn't be surprised if we ended up using webpack for devtools generally so when that happens the JSON viewer can use that and we can avoid AMD completely.

I don't mind it at the top-level because it's a core part of the initialization process, but it makes sense as a util too.

I've never loved `reportException` anyway, and I'm not sure we even need it. Most errors like this (usually used at the end of a promise chain) could be automatically caught in the promise middleware if we want to do something special with them.

why not `state.merge({ selectedSource: action.source, tabs: addSourceToTabList(...) })` ? You can do it in the same `merge` rather than another `set`.

Same here

I think it looks better with the way that we indent the tree, but I would prefer sorting them alphabetically. As a user, it's confusing if I'm looking for a property and have to remember if it's an object or not.

What we should fix is how we display the tree so that they don't look so out of place. It's problematic anyway because it's unclear which items are children; for example, in the above screenshot, is `a: 2` a top-level item or a child of `pythagorean`? It lines up perfectly with the other top-level items, so it looks like it's top-level. But it's actually a child of `pythagorean`. The way to fix this is to indent all the children more and make them all line up (whether of not they have arrows). If you look at Firefox/Chrome, that's exactly what they do.

So I'd prefer to revert this change and I can work on styling them. If you're not working on this today/tomorrow (because of conference) I'll merge this in and do a follow-up. I'll work on scopes later this week.

Personally I like things either to be fully createClass components or not. We have eslint rules to force a specific ordering of how methods are declared in components so there is a consistent ordering of them (lifecycle methods first, render methods last, etc). If we pull them out we lose this, and it splits up the component. React will eventually support stateful function components, and we'll always use top-level functions then.

I don't actually see `index` used anywhere

Nit: no need for parens for single args (`item => ...`)

I didn't see the point of passing those things in, and when we move to v3 of react-hot-loader it'll make it easier (we can just call renderRoot again).

I thought of a few different ways to handle config, but couldn't come up with a great solution quickly that works both in client and server. In Node, we could simply check if the local config file exists and if not, don't load it in. But we can't do that in a browser.

EDIT: I didn't finish my thought... anyway, I brought back the try/catch solution to load in local config, because it does work. The only problem is the webpack emits a harmless warning, which is scary for new people setting up the project. This code creates a local config file if one exists, so the warning is not emitted with the typical first run workflow (`npm start`).

I don't love this ugly code, but it does really smooth out the first run experience.
We should talk through config soon because I think client config is very different from our server config. The client should ideally take preferences from the server, because in the Firefox toolbox we'll want to give the client preferences from the toolbox.

The indentation looks a little weird here. Preferably:

```
expect(getBreakpointLabel(breakpoints[1]))
  .to.equal("142 return undefined;");
```

Yes they are specific. We haven't made the scopes generic yet. It should be clearer how to do that now, but I'm not sure. We'll do it in the next few weeks probably.

I get what you mean, but it's actually pretty common to store things on element instances. It's a good way to keep track of things that aren't rendering state, and more complex situations (like this one) need it. react-redux has [many of them](https://github.com/reactjs/react-redux/blob/master/src/components/connect.js#L227) (maybe too many).

The only thing I'm unsure of is if I ever need to clear it out, but I can think of when to do that. I could do it in `componentWillUnmount` but that's pointless because that means the instance is going to be GCed anyway.

Will do. This part will be removed when we make the protocol more generic.

why these lines?

very nice. It might be a little more condensed to just say irc.mozilla.org channel #devtools? The port is the default port, so I don't think you really need to specify it.

Or: "we're all in Mozilla's IRC channel #devtools (link there) on irc.mozilla.org."

The README isn't just for open-source contributors though. And I think it's good to teach how things actually work. For me, the first thing I wanted to do was to tell `npm run firefox` to use a different version, but I had no idea how to do that. I think this info is pretty crucial for anyone who wants to more control, and it's feels weird putting it at the very bottom. It's not that scary and people can skip it.

Yeah I thought about that, I can do that.

Makes sense to make this an option. Wouldn't tabs normally open at the end rather than the beginning though? (if I'm reading what `position: 0` does correctly)

We might want a different icon. It's a little confusing to see 2 of those pretty close to each other. I think that icon is for settings specifically. If possible, use a placeholder for now.

nit: there's a mixture of styles here with the arguments. I thought we decided to bump down the second argument. But I could be convinced that this is too useful, as I've seen it elsewhere. Not a big deal for now, we can ignore this.

Why a separate file? CSS and JS files should be a 1:1 mapping. 

If you want to extract it, a separate dropdown component would simplify this component also.

Sounds good to me. I'm also fine if you want to pull in a few lodash methods eventually. I'd rather not depend on a huge amount of lodash, but some of its methods might be helpful. (I know I was more resistant before.) This is good for now.

I'd rather not keep adding globals here in main.js... would you be ok creating a new module somewhere that does all this injection? Could be something like `require("./utils/debug")(store)` and that module would only inject all this stuff if `process.env.NODE_ENV !== "production"` or something (or whatever debug mode flag).

Agreed (thought I was just meaning to extract the dropdown already in this component), but in that case I think we should just have the dropdown css in the source tabs css. I don't think we should have arbitrary CSS files; they exist as an implementation for a component, so it's weird to have standalone ones.

I was hoping to move all of this out of main.js and into the debug module. Something like `injectGlobals` that would be called here (you'd need to pass what you want to inject). 

Nice idea, I hadn't thought of it quite like that.

Looks fine to me, but I wouldn't work on this too much more right now. This is most unknown thing right now. Personally I'm not sure we will end up using cypress, but we need to look into other things before making that decision. As this is in such flux, I wouldn't encourage people to write these tests right now.

I think it's better this way because some protocols may not have the current state. we happen to have it in the current SourceClient, but I bet chrome just has these methods without the current state

remove this argument

I don't see actions being used anywhere? Is this just leftover? If so, please remove it

The current debugger has a nice progress bar. But yeah, this is fine for now

Nice. I'd very much prefer to pull in individual lodash methods though, so just require `lodash-template`. I don't see us using much of lodash, so it'd be great to only pull in the methods we need.

I prefer the other API with just `getConfig` and `setConfig`, with the latter returning the previous config. It's simpler and more functional (no need to worry about originalConfig in here).

Cool, didn't see this before I made my other comment!

It'd be great to have these inherit so that we don't duplicate the config across everything. A base config would work everywhere.

The only problem with this is that we aren't running a server in the devtools panel, so this won't work. We need raw HTML file for the panel.

Why not just `client`? The logging suffix is redundant now that it's in a logging section.

This suggestion makes sense to me.

I don't want to conflate the pane with production because dev/prod mode is something all libs use to turn on prod mode, and I'm sure there will be times where we want to do `NODE_ENV=production npm start` to try it in prod mode locally. 

Hm, I do see that using NODE_ENV in general is conflating it with the production meaning that libraries use. Because we load in the config below, and I can still just do `webpack --config webpack.config.devtools.js`, we can just use the config as the flag in `isFirefoxPanel` and never use NODE_ENV. That way NODE_ENV can be used normally: "production" turns on optimizations in libraries.

It might be nice to do turn on dev mode in the firefox panel build if we want to debug something there, but I'm ok forcing production here.

Thinking this through a little more (see my other comment) I'm not sure what the best solution is but it would be nice to be able to run in prod mode locally.

This kind of stuff, because it's very basic (and important) app state, might be nice to store in redux. But we can easily move it out later.

nit: devtools style is to forego the parenthesis when there's only one arg

shouldn't you send a 404 or 500 here?

Why do this here? We don't have a corresponding `firefox.debug` check in the firefox client, so it seems better to have it on the server.

This seems closely the same as `httpGet` in the server, I think there is an isomorphic-fetch package or something that works in browser and server and we could potentially reuse this function.

Nice

This seems like the right place to do this. I'm curious where you think we should store sourcemaps though. Technically, they are an important part of the UI, so they should be in redux, but that might make it hard to serialize... 

They never need to be set? The state should be pulled out into whatever toolbox thing we come up with. But this doesn't do any harm.

You could move this `spawn` up and do `yield networkRequest(...)`. It's probably good to add a catch handler here too and log the error (two common errors: soucemap fetching or parsing failed)

This will give you the source text. Just do `const { text } = yield dispatch(loadSourceText(...))`

We can't eagerly load in the source text for sources when they are introduced. This would create a huge amount of protocol traffic. It's already slow to transfer very large sources, and we don't want to do that at startup for every source.

The `SourceMapConsumer` should have a `sources` property which already lists the sources that the sourcemap represents. You should be able to dispatch new sources based on that, without needing any of the source contents until someone clicks on a source.

use lowercase, `text/javascript`

Oh! Hah I thought I had added a typo.

Nope, the syntax for types is only ES6 :/ But that's because CommonJS doesn't really have a way to do this. You'd have to special syntax for CommonJS, which starts getting weird because usually `require` is just an expression. So I get their design choice.

ES6 is the future anyway. Since we're using a build step, I wouldn't be surprised if we converted to ES6 modules at some point. But I don't think mixing the styles is too bad.

It definitely does. I just wanted to get this PR out. It's probably because I'm new to flow that this is verbose. We'll figure out the right balance over time, and I'll look at this again before merging.

Destructuring is supported, I just ran into an issue here and I can't remember what it was. I didn't spend much time on this part of the file, just had to get something working.

It statically gives the type system whatever type `breakpoints` is. This tells the system that what I'm returning has the exact structure of the `breakpoints` object, so it lets you do this dynamic `Object.assign` munging but still type it.

This is fine for now to get something started (sourcemaps are preffed off by default right?) but this will leak sourcemaps across navigations (and potentially load wrong sourcemaps if ids are the same across navigations of different sites).

I think it's going to be more trouble than it's worth to try and avoid storing them in the redux state. `loadSourceMap` should be an action creator that does this and checks the state to see if it exists. We gain the ability to faithfully snapshot what's really happening (and see all the sourcemap loading actions), and access the souremaps in tests. We'll have to recreate all of that if we don't store it in redux.

There may be times when we want to avoid keeping the sourcemaps in a state snapshot (because it potentially could be really big), but I think we need to be smarter about hydrating/dehydrating the state anyway.

There are problems with putting it in the state: we'll need to be smart about the hyrdating/dehydrating the `SourceMapConsumer` instance. But as I said above, I think we need a better way handle that anyway (see the transit library).

This is fine for now, not going to block merging this, but just wanted to discuss it.

We might want to go ahead and nix the generated/original terms, and come up with something better.

Why not create the `SourceMapConsumer` here? You don't want to recreate it every time you access it, as it parses the sourcemap. I'd change that before merging this in.

A UUID might be better so it doesn't depend on any state (not a blocker for now)

Nice, this is much better and is the way to do it

This lives in an actions file but isn't an action creator. Don't worry about it for now, but every function in here should return something that is dispatched. But we may want to have sourcemap loading actions, as mentioned in my other comment, so this would become an action creator. Anyway, not a problem right now.

The generated id is a sequential id, not a uuid. A uuid is guaranteed to never conflict, so if in a test we load a snapshot of the state and add a new sourcemapped source, that will still work, whereas here it will potentially conflict because `inc` will start from scratch.

It might be better to come up with a sourceId format that we can simply match here. That way we don't have to iterate all the consumers and all the sources in each of them every time you click on a source.

Are you sure this won't have any false positives? I feel like I've seen checks that are a lot more complicated than this.

Why can't the client in m-c use the standard WebSocket API?

I think that's kind of confusing to see stringified objects when debugging...  It would be just as useful to concat the generatedSourceId and originalSourceId fields into something like `id1-id2`. The rest of the stringified object is just clutter.

The id could simply like `generatedID/source-mapped-sourceID`. Another approach would be to add an `isOriginal` (or `isVirtual` or `isFake`) flag right onto the source object.

you can just do `return`. The thunk doesn't have to return anything.

`LOAD_SOURCE_MAP` might be a better description of this, analogous to `LOAD_SOURCE_TEXT`.

Nice, that looks very good

oh, really? Interesting, you can see in `selectSource` we just `return`, so not sure what was throwing that

I don't think we should uncomment this. You should probably check for this first, and if that doesn't exist, use `DevTools`. This lets people with the hook into the app with the redux browser addon.

I don't see where React is used?

I'm a little confused between the difference of `actualLocation` and `location` here. It looks like you pass in the before/after result of the `setBreakpoint` call, and `actualLocation` is only different if it slid the breakpoint. It doesn't have to do with sourcemapping.

Since many point of code will have to deal with sourcemapping, I think it's easier to do it like the current debugger server: have a function like `getOriginalLocation` that takes a location and always returns the original location. If the source is not sourcemapped, it'll just return the same location. If it is, it'll sourcemap it.

But it may be you are still working through this :) I don't quite understand this code because `location` and `actualLocation` are not different here.

EDIT: I see that you have `getGeneratedLocation`, which makes sense. Why no `getOriginalLocation`?

Can you prefix this with an underscore? All top-level methods in an action file should be action creators, and we use that convention to indicate "internal" methods in here.

EDIT: Although, you may want to move these out into utility files anyway...

I'm probably missing something here but why do we need to fetch the source at all if we just want to original source, and we already have that from the sourcemap?

Nice

Oh, here is `getOriginalLocation`. I feel like this and `getGeneratedLocation` should be in the same place.

This looks good though.

Might be worth looking into, I could be wrong too. From a high-level it seems like you should be able to serve the source for a given sourcemapped URL if you have a sourcemap. I have not thought this through though!

I see. I think the tension is with `actualLocation`. If we're sourcemapping, we know the server doesn't slide breakpoints so we can just use the original location. However, Chrome's server does slide even with sourcemaps. I think you should always use `actualLocation`, sourcemap that _back_ to an original location and pass it here as a single location.

This stuff is so confusing.... :p

Why not just `reduxDevtools: true`? Also camel-cased because we use that for all other options

You need to flag this off, because this is where all the perf problems are. Check if the `reduxDevtools` flag is enabled here and only instrument it if so.

I'd say that you should only export `DevTools` if it's enabled also, and the in the `App` render function just do `DevTools ? DevTools() : null` and avoid the `DevToolsPanel` function.

Thanks! It's a little shorter to do `if ((e.metaKey || e.ctrlKey) && e.key === "p") ...`, do you mind changing it to that?

nit: this alignment looks a little weird because the args are indented with the code, and we (devtools) usually do:

```
function foo(
  x, y, z
) {
```

Do we need to do this here? Any location coming from the UI should already be an original location, but if you want to do it for sanity, that's fine. Once we actually type locations we should be able to enforce that `location` is an original location and we shouldn't need to do this.

Perfect, this looks great

Yeah, I think it conflicts with the type name, and I would encourage this module to be used like `sources.State`. It should be used in tests 99% of the time where this specific reducer is being tested. But I may change, I'll think about it some more.

Our coworker gozala (uses flow in browser.html) may have come up with a solution. But yeah, for now I gotta stop spending time on it..

The contract for actions is that they always receive normal JS objects. This gives us some sanity about the API, because components can directly fire actions, and they should always know that that can simply pass literal objects like `{ sourceId: ... }`. So please move `toJS` back here, even if right now that action creator is only fired internally.

This is why actions always just receive normal JS objects :) We want to optimize for the common use case, and with actions you are always passing things in like this.

That's what I mean by "I would encourage this module to be used like sources.State". It's an API you shouldn't destructure, because if you do we should change it to `SourcesState` and `sourcesUpdate`, and by prefixing everything it's the same as `sources.*`.

It's probably better to whitelist the protocols where know there is a domain/host, at least as a temporary solution. Change it to:

``` js
} else if (urlObj.protocol === "http" || urlObj.protocol === "https") {
  return {
    path: urlObj.pathname,
    group: urlObj.host
  }
}

return {
  path: urlObj.path,
  group: urlObj.protocol + "//"
}
```

And what's the difference between `path` and `pathname` again?

I agree, I think this is too much of a dump of information. Most people (even advanced devs) won't care about most of this and will just use the defaults.

We just need to highlight a few that really matter: `hotReloading` and maybe `chrome.debug`. I really think we need a dedicated section to `hotReloading` to tell devs to turn it on because it makes the dev experience so much better. Or we could just turn it on by default in dev mode.

That's not a bad idea, I like it. I was trying to think of a way to encourage it without having it on the readme, and this makes sense.

That's fine with me. Does anyone use this to send a public URL to someone else? Usually you have to use a forwarding service anyway because you are behind a firewall/router.

Oh, your comment didn't exist when I commented. I see, makes sense

Any reason we need all these components now? We could just use `InlineSVG({ src: DomainIcon })` directly in the component that needs it. That would reduce the need to manage this file.

Haven't gone through all of this PR yet, but I will tomorrow. Thanks for pointing this out, because I think you already know that I think it should stay separate :)

This is a case where I want the data to be more denormalized, like a separate table in a db. A small nit that now the property is `sources.text.text`. My bigger complaint is that now the sources are not the canonical "protocol objects" as I call them: objects that are given to use from the client. The nice thing about that is that it's easy to back and forth. For example, in my WIP PR I snapshotted the source objects into this file: https://github.com/jlongster/debugger.html/blob/4b79f1f14ead1620fe01dbb549920d891d9f4246/public/js/test/fixtures/todoSources.json With those, I can pick them out and immediately send them into the `newSource` action. Changing the structure means I can't always go back and forth between actions and selectors.

I would like for the same constraint to be held to all protocol objects stored in the reducer, for example the `loadedObjects` field. It makes it easy to reconstruct state and work with the data in all of our testing infrastructure.

I'd like to hear more about your "pretty print explorations", or maybe I will see them when I look closer at this PR. We can write code to "convert" this state back into protocol objects when we need it, but I'd like to see what this actually made simpler.

Why drop this? We'll be inconsistent with the rest of devtools

Needed to tweak this also because the selected tab does not exist in the Firefox context, but I think the sourceMapURL should be resolved relative to the source. This should also be a smarter `join(source.url, source.sourceMapURL)`.

I can move this out of the PR, just wanted to show everything that we need to work on.

This function will now fire twice whenever the editor is rerendered (and thus the breakpoints). This could be solved by implementing `shouldComponentUpdate`:

``` js
shouldComponentUpdate(nextProps) {
  return this.props.editor !== nextProps.editor;
}
```

Now, it will only add the breakpoint if the editor changes (which will happen if it was `null` before).

We could probably pull these watch expressions into their own reducer, as the whole notion of "pause" state is too broad in my opinion. But that's something that can be done later.

We already have a bunch of messages and it's starting to feel like spam... do we need this message?

Nice!

You don't want to do this because it destroys the purpose of the key. The keys should stay consistent for each item with the renders, so that React can easily figure out which ones have simply moved. The above change makes React think items have been removed and need to be re-added.

The point of `item.path` is to always be unique. When is that not unique? That's a bug, and we should fix the path generation if there is a bug in there.

Can you throw an error if it's an unknown SVG? This PR is definitely a big improvement but we should make sure that typos/etc are easily caught:

``` js
if(!svg[name]) { throw new Error("Unknown SVG: " + name); }
```

Nice, didn't realize we didn't support navigation events for Chrome.

We don't actually want to do this, for Firefox at least. We keep breakpoints around, just like the server does. If you navigate back to a source, all the breakpoints should still exist. A key use case is refreshing: all the breakpoints should still exist, right? A refresh is a type of navigation.

Not sure if you're seeing some problem in Chrome, but I'm pretty sure this will break Firefox. (it'll pause on a top-level breakpoint after a refresh but the breakpoint won't exist in the UI)

> I think this is actually a question of using a selector that only queries for breakpoints at that domain or breakpoints that have a source in the store, which can be difficult.

Oh, that's a really good point, I forgot that the breakpoints list is going to show all of them. `getBreakpoints` should definitely only return breakpoints for the current page... I like the idea of checking if the source exists. Not sure if there's a more elegant way to handle this...

Why use `pick` here? `features[key]` should be fine. One thing I really don't like about lodash is it doesn't error on `null`, so `pick(null, ...)` just returns an empty object.

I don't want to do this here. If you pass a column of 0, it should send a column of 0. Firefox's behavior makes sense: if it's a real value then it should only set a breakpoint on that column.

You should move this logic up to source maps and decipher the column info there.

nit: to be consistent, the rest of devtools uses stars, not pluses

The ignore clause above should do this, yes. Try to figure out why that's not working. We shouldn't need this clause, just fix the `(NEW_SOURCE_IGNORED_URLS` patterns. 

Why are these changes in here?

Yeah, that's true. It became generic enough it probably could be. Usually test mock things themselves as needed. If we run into other things we want to mock we can think about it more, but I'll move it.

Hm, I want it to be a more complicated test case (multiple original sources). Also, are those examples things that you want people to run to try out the debugger? I don't think those should be our test cases; the former are things we will want to change over time, but the latter we can't ever change. My test case is never a runnable example, but just data to be consumed by tests.

Yeah, I use `afterEach` to terminate it. That's a good point that we could do this automatically though. We'll need to restart all of the workers, which I assume would be ok... I'll try it out!

nit: indentation is little weird here. Might be nice to indent it a little more to connect it with the first line?

We're getting away from embedding CSS in SVGs. That's why we go through great lengths to embed them right in HTML using the loader stuff. Can you move this CSS into the component's CSS that you are using it in? It makes it much easier to reuse SVGs.

(embedding allows you to use regular CSS on them)

Not sure if I love it being on by default. It adds more UI and the need to explain it anyway. Why not just have the explanation, since we'll need it anyway? The search bar is basically a modal and it feels weird to open the debugger by default with a modal.

For these kinds of changes we should loop in Helen also.

> I'd like the debugger test cases to all be hosted so that a user could go to them. Somewhat like mochitests examples as well.

That's the difference: these aren't integration tests like mochitests, they are unit tests. So it doesn't need runnable examples, it just needs some data. We have a bunch of really small data files like this in m-c too. I think it's worthwhile to have both because I can add any random file I need to without feeling like I need to tie it in somehow to the example's usage.

> I think there's a real benefit for contributors to be able to quickly load a test example and see how it works.

Yeah, I totally agree with more integration-y tests (as they need to be served anyway for those kinds of tests). Thinking about this more, maybe this is a better way of explaining it: what I need is just a bunch of source texts. Instead of saving fixtures, I'd like to have a folder with a bunch of sources (and some sourcemaps). It's just data that unit tests can use, and aren't grouped by various examples.

I will update this PR to reflect that, by renaming `sm-test-case` to something that is more just source texts. I could even make the thread client automatically load these as requested, so unit tests can freely load them.

> ```
> re: never changing
> ```
> 
> I don't see the examples changing too much, but if they do then I think it is okay to update the tests that are coupled.

Hopefully we'll have hundreds of unit tests so it really is a huge deal to change them. We've dealt with this on m-c and the unit tests data files are untouchable because you'd have to update almost every test. You can only add new test files, which is pretty easy anyway.

> One thing to keep in mind is that it's important to be able to run the unit tests in the browser for devtools debugging. So, please try and make sure that the new tests can run with npm run mocha-server. I'm now wishing karma worked :/

Yeah, currently it won't work in the browser because it loads sourcemaps from disk. I don't find much value in karma to be honest because all this code doesn't even deal with the UI so it should run the same in all browsers, and I don't use it for debugging... To get these working though, we just need to fix up the utility functions to load stuff over the network instead of from disk. It won't be hard to get it running again when we want to focus on it. I'd rather not spend more time on it now though.

It opens up UX questions: does that mean it auto-focuses on open? That means key shortcuts probably don't work, and the sources tree should probably be the thing we focus first. Beginners would probably be more confused sitting at a blank input rather than the sources tree. 

We had it like this before, but changed it to print the entire object because it got way too annoying to always expand the properties to inspect stuff. Usually you are scanning through many actions to see what happened, so we ended up having to manually expand every single one. For the type of debugging this allows, reading the action log is more important than interacting with it...

How do use action logging? Is there something about printing the object that you don't like?

The other thing is try/CI: printing the full object always made the logs from there useful, instead of things like `{ prop: [Object] }`

Yeah, I see where you are going with this. But I think there are some problems with this. If it's a source we should ignore, that doesn't mean it's a console evaluation, so the URL is a misnomer.

There are several types of sources, and some of them we should just flat out ignore. If you're writing tests and expect one of these sources to be in the store, that's a serious problem and we should figure out why it's not in the store instead of putting it in the store. Any sources in `NEW_SOURCE_IGNORED_URLS` should be ignored and never added to the store. Apparently a source with `introductionType` of `debugger eval` should be as well. That is code that the debugger frontend sends to the server to eval, and should never exist in the debugger itself.

What you're probably looking for is eval sources. These are introduced by `eval` in the debuggee and don't have a URL, unless they have been given one with the `//# sourceURL` pragma. If they don't have a URL, they should still exist in the store but the frontend should ignore them. So they are different than the above sources: the debuggee is concerned with them, but there is no good way to show non-URL sources easily.

The problem with `NEW_SOURCE_IGNORED_INTRODUCTION_TYPES` is you've conflated `debugger eval` and just `eval`. The former we should just ignore (never add to the store) and the latter we should add but the sources tree should ignore it if it doesn't have a URL. Your changes here would ignore valid eval-based sources that are given a URL with the `sourceURL` pragma, which currently should work fine.

This is how it works currently though. We ignore the right sources, and then the sources tree just ignores non-URL sources (https://github.com/devtools-html/debugger.html/blob/master/public/js/utils/sources-tree.js#L36). So dig into your tests and figure out what sources it's expected to exist, and go from there. That's where the real bug is.

The pause action is a problem, yeah. Maybe we can log both the action object and the stringified version of it, and cap the stringified version to 1000 chars or something. That way we would ensure that you can always scroll through actions at a certain rate, but have the ability to interactively dig into the action if you want.

> Ideally, this wouldn't be as much of a question because there would be a better redux action log :/

You can always install the redux devtools extension if you want a better log! :)

> I have a test for "break on next", where the debuggee pauses on a debugger eval...

Oh, I see. In the old debugger we do dynamically generate URLs for these kinds of things, just a dumb `SCRIPT#` name like `SCRIPT1`, with the number incrementing each time. I wouldn't say "console eval" because these scripts could be coming from any number of places. Chrome uses `VM#`.

I suppose we could add these to the store. Theoretically there's no reason a source needs to be in the store to display it: it could still load its source text and show it in a tab, and the `sources` state would still only have the sources in the tree. But it looks like our actions do go through the `sources` state to require it. This would mainly be an optimization.

I think I'd prefer to add `debugger eval code` and `debugger eval` sources to the store, assign them an arbitrary URL like `SOURCE#` or something, and not add another attribute. The source tree can only check the URL and work with sources that have one and it is not of the `SOURCE#` format.

The reason being I'd rather use the URL as the source for what "type" of source this is rather than adding more flags. Same goes for generated/original sources, you can detect an original source by just looked at the URL.

Some clarification: we need to generate URLs for these types of sources anyway (eval-ed, original) so we might as well encode that information in there.

Can you explain these changes more? We need to stay in sync with m-c, and this file comes from there. It might be best for you to make these changes there first and then copy the new file over.

Cool, so it's a bug on m-c too? Strange that we haven't hit it before... I don't see any reason Jaideep can't still contribute to m-c too after his internship :)

thrown should be an immutable object. It works for me, so I don't know what edge case you've found. It doesn't make any sense that it wouldn't be an immut object but `returned` and `this` would be... I'll check to make sure it is working for me, but I wonder what you hit.

This change does not work for me. I don't know what edge case you hit, but please look into it and figure out what happened.

This is what it looks like without `toJS`:

<img width="295" alt="screen shot 2016-08-12 at 11 16 24 am" src="https://cloud.githubusercontent.com/assets/17031/17627176/582f8432-607e-11e6-9d9e-3031c008b7b4.png">

If I call `toJS`, it shows me all the right fields:

<img width="305" alt="screen shot 2016-08-12 at 11 15 45 am" src="https://cloud.githubusercontent.com/assets/17031/17627193/5fd7aff2-607e-11e6-84e7-1e78c60c3c72.png">

These test cases look good. At some point we should have some test cases where the script is external, but I don't know.

Not sure what I'm supposed to look at there? :) Can you just reproduce it locally and debug it from there? 

Oh, I just realized something: you're tests are throwing strings. Make them throw `Error` objects instead and you'll see what happens. But that is a good edge case: strings aren't converted to immutable... so we need to only convert to JS if needed.

Nah I think inline scripts are actually better, they are more likely to be buggy. I like it.

You need to make sure it doesn't have a URL already. This still won't work with eval sources that are given a URL with the `sourceURL` pragma.

In fact, if we are unequivocally adding sources now, this could just be:

``` js
if (!source.url) { source.url = ... }
```

You only need to create a URL if it doesn't have one.

I'd still like to error here. This is a bug and we should suppress the error. Note that the current debugger acts this way too; we didn't implement proper add/remove ordering. The error doesn't break the UI; it just stops this redux dispatch cycle, but the state is still in tact and the UI keeps working.

I'd rather properly fix this. This is what the `waitUntil` middleware is for; because we don't have a good abstraction for these kinds of things, it allows you to wait on other actions in a primitive way. Here, if it's still loading, it should dispatch a `waitUntil` request can check when the bp isn't loading anymore, and then call `removeBreakpoint` again. I can do that, so remove this change and I'll implement a proper fix.

Yeah, I think the destructuring is fine. However, you could send off the requests in parallel:

`[PROMISE]: Promise.all(breakpoints.map(bp => dispatch(...)))`

Do we still need `removeAllBreakpoints`? I don't see it being used anywhere.

nit: usually in devtools code we put the last paren on a new line:

```
function foo(
  // lots of args...
) { 
}
```

or

```
function pauseOnExceptions(shouldPauseOnExceptions,
                           shouldIgnoreCaughtExceptions) {
  // ...
}
```

Agreed!

Personally I'd prefer to keep the items inline in here. I like breaking up complicated things but it's more useful to read what is going on with the accordion by just putting them here. Though I see it was like this before, so I guess I missed that change :) It's subjective.

You can just check `size` or I think immutable does have an `empty` predicate on collections

Is there a way we can wait for something to appear in the DOM instead of a setTimeout? This is going to introduce flakiness, for sure :)

The panel before was still pulling in the development config, so it was bundling in hot module reloading and such.

This check seems wrong. A "generated" source is considered any source that is the real source in the engine. This seems more like `hasSourcemap`.

Don't we want to hide it for sources that have sourcemaps _and_ original sources?

Once we add more tests it'll surely take longer than 5 seconds to run. But this is a good enough thing for now and this is easy to improve later :) I could have sworn selenium had a way to "wait" until an element appears on the page or something, but it's something we can talk about later.

Not sure I understand your question?

This is yet another case of the difference of build and run-time. In the firefox config we default NODE_ENV to be "production", but that doesn't happen at build-time. So we need to default to production at build-time too, but allow the user to override it.

We don't use pngs/svgs from m-c. We could patch all the URLs and copy the images over but I don't think it's worth it, as we are rewriting the basic components and using inline SVGs for everything.

But you're right in that I should probably just comment out the URLs instead of removing them, as that's better documentation for how we patched the file.

I don't think so; they are icons and should not be resized with the font. The command bar has a fixed height of 30px so the icons should fit inside of it exactly. I don't see the benefits of ems here. (in the future we probably want the ability to change the base font size, and the command bar should stay the same)

This is the magic that hooks into the local modules when in the panel. `devtoolsRequire` is the privileged require that will be available in the panel context. It will generate code like `var editor = devtoolsRequire("devtools/editor")`.

I will commit a patch to m-c that exposes the `devtoolsRequire` in the new debugger.

If it gets big enough, sure, but if it's only a few small utility functions I think inlining them is fine. But we'll see what this looks like after we cleanup all the sourceeditor/editor.js stuff.

I wish I had seen this before I spent a few minutes figuring that out, thanks!

I don't think you'd need this if you used `componentDidMount`, instead of `componentDidUpdate`. Typically you set up this kind of stuff when it mounts and then remove it when it unmounts.

What would be toggled?

Sorry, still confused... we don't have "wait on next expression"? We only have line-based stepping..

Why not just check `if(this.keyShortcuts) { ... }` ?

You're passing down a prop that is created in the parent's `componentDidMount`, so it makes sense to be null when it's rendering first.

There's might be a better way to do this, most likely using context to expose shortcuts across the whole app, or even just using a top-level object. Not sure.

I didn't notice this before, but shouldn't we be matching on ID instead of URL anyway? We switched the id format so we could easily match `/originalSource#` I thought. That way we can change the URL to whatever we want in the future (because it determines how it's display in the UI) and none of our detection code breaks.

Nice

`Creates a throttled function that only invokes func at most once per every wait milliseconds` That's exactly what this does, if it doesn't then it's a bug and I'll fix it :) It's the same as throttling with async channels, etc, which is what I'm familiar with.

I don't prefer early returns for small functions, but I know that's a stylistic choice. It's easier to see the full logic instead of having to see what returns at the top, but doing it for large/complex functions is fine... It's common in style guides to avoid early returning, but we should solidify these style rules at some point.

Yeah, I can do that

Oops, you're right, I didn't mean sourcemapped sources. This is for eval sources. But we can't change the ID of eval'ed sources, so this makes sense. Ignore my above comment.

Shouldn't need that; the way the data is shaped you can just do `.map(x => toPairs(x)[0]` like before. It's stupid, but it's because the object only ever going to have one key and one value.

I'd rather keep the logic of `excludeVariable` in here, it feels like over-abstracting. How come you check of `binding[1]` is truthy in the function?  You should just able tp filter out `binding[1].value.missingArguments || binding[1].value.optimizedOut;` which is pretty short.

It's stateful because we shouldn't keep transient objects like a tree structure in the redux state. It just is dynamically generated from the state.

Does it only fire twice when you are reloading when it's paused? `frame-update` should not fire if you are reloading a page when it's not paused.

Nit: `.set("pendingSelectedSourceURL", state.getIn(["selectedSource", "url"]))` I think that should work.

The sources seems like a weird place to put the URL. I don't have time to fully review this code but there are several problems with it, which I will mention in another comment below.

gitbook. I can't remember if it can do that. I agree that reference docs should be closer to the code it's documenting though. I also think that the action types file should just be the documentation for the actions, and we shouldn't replicate that info here.

Our higher-level docs could just link out to individual places where we keep reference docs, which would just be an .md file inside a folder like `reducers` or even just `action/types.js` itself.

But it doesn't really matter right now, we can land this if it helps for now even if we are going to change it a lot later.

It was leftover from previous codemirror work; we don't need to map it because we are mapping the `source-editor` file itself which includes codemirror. I noticed it here but I can separate it out if you want.

Yep. rsync went askew, I'll fix!

I looked into `frameUpdate` and we definitely don't want to use that: https://github.com/mozilla/gecko-dev/blob/master/devtools/server/actors/webbrowser.js#L785

It's fired when any frame in the page changes. We should just use the navigation events -- why are we listening to `frameUpdate` at all? I can't remember, but I think it had something to do with refreshing while paused. Above it sounds like you are seeing both events fire when paused, so we should be able to just use the navigation events.

I don't think we need the callback argument?

It's very hard to know. You don't know if a source is dynamically loaded in (which we should absolutely test) and if it happens a little bit later, then when is it "done"? The fact is sources can come in at any time so there is not such thing as "done". Better to embrace this and be explicit.

I can tell you this with a lot of experience with the old debugger that this is a good way to go. We've tried several things before (including having a "sources loaded" event) and it was _always_ a pain.

(Wanted to reply longer here and had to step out)

> I think it is good to keep the API similar to what the components call, that way we exercise the same behavior. We can't guarantee it's the same, but it's probably good to try.

Those actions are what they call :) But we can't guarantee that we are going to call the actions with exactly the same arguments, but I think that's ok. Our actions should be usable like this. They should just take simple arguments and work.

The fact that the `addBreakpoint` action requires that extra function is a bad thing (I know I implemented it). We need to fix that. But for the majority of the tests, it really doesn't matter that the text snippet isn't there. I'd like to write it this way, and just try improve the `addBreakpoint` so it has the text correctly without requiring this extra work. For now, we'll just make sure we add the line snippet when testing the breakpoint pane. It's a small detail that doesn't really matter, and it's just a bad API that we need to fix.

> The addBreakpoint command I setup assumes it's the selected source and passes along the getTextForLine param for that reason.

The selected source thing is a bigger question. I completely understand where you are coming from, but let me try to explain why I don't think we should do it.

We don't drive the UI by actually clicking on the DOM in every test for a reason. For any given test, they are really trying to make sure a specific workflow is correct (and ignore all the other details). Redux actions are a super nice way to do this, even if it's not literally the same workflow that the UI goes through. As long as we make sure adding a breakpoint on the current selected source works, it shouldn't matter if adding a breakpoint is on the selected source or not in other tests. If we really wanted to test the UI as the user uses it every time, we'd be clicking DOM elements.

I actually really like the idea of being able to set breakpoints on other sources than the selected one, and I want to do that some day. Something like a "command bar" that lets you say `break <url> <line>`. That would be awesome. There's no reason we should tie together a simple action like that with changing out the entire editor, loading source texts, etc.

In the old debugger, there are many tests that set breakpoints in several sources, and then continue through and make sure all of them are hit. These tests are a lot simpler if you can just set a breakpoint on any source. It makes it easier to test complex scenarios like "set a breakpoint on source X and make sure when the breakpoint it hit that it opens and selects that source".

So that's my vision of the tests: generally the commands map straight to redux actions, but with a few niceties like the stepping ones waiting for the right `paused` event. This lets tests set up all kinds of workflows, whatever they want, even if many of them aren't real user workflows. We can make sure that things work in weird ways without the commands getting in the way of a specific workflow.

Just wanted to explain my view of things; I totally get where you're coming from. The good thing is this is something that we could pretty easily change later just by changing the `addBreakpoint` command if we are missing bugs for some reason.

I think this is a little more readable:

```
if [ -z "`command -v hg`" ]; then
  echo "hg not found yo";
fi
```

Not sure about putting a specific time, it takes about 10 min for me? What about saying "10-30min depending on connection"

I'll try that, I can't remember but it seemed more natural. I think I like the header always showing because it feels more consistent, but I don't need to change that right now. I'll see if it's just as easy to render it in `App`.

Yep, it'd be better as another component

The `Editor` component is the main thing that should do this work, I don't like have 2 separate modules that split the work for no great reason. In this case, yeah, we're forced to have source-editor.js for compatibility. 

You're right that we haven't ordered this correctly; the lifecycle methods should be grouped together. I'll move `componentDidMount` down and then it's utils, lifecycle, render, in that order. There's an eslint rule to enforce this that I thought got turned on in m-c...

What do you mean? This is not a new system. This is hooking into Mozilla's existing mochitest system which sets a flag to indicate that it's in a testing environment.

(edit: see webpack.config.devtools.js changes)

You might be able to wait for a resumed event, but I'm not sure we'll always want to emit a resumed event after setting a breakpoint. From a distance, a resumed event has nothing to do with setting a breakpoint. This is a clear and descriptive: just wait for the action to resolve.

You say you like the pattern of yielding for async actions? :) This is doing that. It'll wait for the `ADD_BREAKPOINT` action to fire with the `status: "done"` property.

Yeah, great point.

Maybe, but I'd like to land 5-10 mochitests now and we can flesh them out/add more as we get a good feeling for it. I'd like to do it breadth-first, because writing several different kinds of mochitests will give us a feeling for what should be actually shared across them, and how we should structure them.

You're probably right that I should also check the highlighted line though, I forgot about that. I will add it.

this is moved in a later pr... lets discuss then

> this will leak sourcemaps across navigations (and potentially load wrong sourcemaps if ids are the same across navigations of different sites).

That's a good point. I'll add it to the tracking ticket.

To summarize, we could keep the maps in the store and access the cached consumers/nodes from that.

The generated id is a sequential id, not a uuid. A uuid is guaranteed to never conflict, so if in a test we load a snapshot of the state and add a new sourcemapped source, that will still work, whereas here it will potentially conflict because `inc` will start from scratch.

it'd be nice to update this to load the source map as an action. Then getting the original sources can be done in the utility

``` js
const sourceMap = yield loadSourceMap(source);
const sources = yield loadOriginalSources(sourceMap);
sources.forEach((s) => dispatch(newSource)));
```

I had already changed the source map to a consumer map. Will be easy to store the maps in the store

Really happy with this method. This is the third attempt at mapping generated => original. The first attempt was to add a generatedSourceId to all sources. The second was to create an original source id to generated source id map. This is a simple approach that re-uses the abstractions we already have.  

It might be better to come up with a sourceId format that we can simply match here. That way we don't have to iterate all the consumers and all the sources in each of them every time you click on a source.

re-add `xdescribe` and cypress should pass. 

Is it possible to use commonjs here? or is there something about types that means we need to use import?

Maybe it's because I'm new to this, but `AddBreakpointOpts` seems unhelpful and adds a lot of clutter 

This also seems unhelpful. It might be nice to type the client, but on the other hand I also don't expect it to change much and I appreciate being able to destructure on assignments.

what does `typeof breakpoints` do?

nice

nice

cool

Oh! Hah I thought I had added a typo.

Nope, the syntax for types is only ES6 :/ But that's because CommonJS doesn't really have a way to do this. You'd have to special syntax for CommonJS, which starts getting weird because usually `require` is just an expression. So I get their design choice.

ES6 is the future anyway. Since we're using a build step, I wouldn't be surprised if we converted to ES6 modules at some point. But I don't think mixing the styles is too bad.

It definitely does. I just wanted to get this PR out. It's probably because I'm new to flow that this is verbose. We'll figure out the right balance over time, and I'll look at this again before merging.

Destructuring is supported, I just ran into an issue here and I can't remember what it was. I didn't spend much time on this part of the file, just had to get something working.

It statically gives the type system whatever type `breakpoints` is. This tells the system that what I'm returning has the exact structure of the `breakpoints` object, so it lets you do this dynamic `Object.assign` munging but still type it.

makes sense. 

Are you sure this won't have any false positives? I feel like I've seen checks that are a lot more complicated than this.

Why can't the client in m-c use the standard WebSocket API?

That makes sense. 

Honestly, I'd be okay doing something like chrome's object id's which are json strings.

id: `{generatedSourceId: "...", originalSourceId: "2"}`

this way it would be a unique identifier, which encodes the relevant field for lookup.

Several little things. Hopefully all can be eventually resolved.

The DOM WebSocket client (i.e., `new WebSocket("ws://localhost:6080")` can't be used, because the debugger client does some TLS magic with checking client and server certificates. That's implemented using the nsISocketTransport APIs. If we can do the same thing on the DOM WebSocket, we can migrate to it.

The event handling API is different. DOM WebSocket uses `socket.onmessage = ...`, the node.js EventEmitter (used in the `ws` module) is different from devtools EventEmitter.

Then there are differences in handling binary data. Blobs, ArrayBuffers, Arrays of ints, typed arrays, node's Buffers...

Thanks. This is fine for merging. @jlongster I think we can safely move this to `client/firefox/websocketTransport` if m-c eventually has something we can use we can switch then.

I think that's kind of confusing to see stringified objects when debugging...  It would be just as useful to concat the generatedSourceId and originalSourceId fields into something like `id1-id2`. The rest of the stringified object is just clutter.

The id could simply like `generatedID/source-mapped-sourceID`. Another approach would be to add an `isOriginal` (or `isVirtual` or `isFake`) flag right onto the source object.

perhaps. but i think our usecase if fairly limited. honestly, i wouldn't be surprised if we improve this later

you can just do `return`. The thunk doesn't have to return anything.

`LOAD_SOURCE_MAP` might be a better description of this, analogous to `LOAD_SOURCE_TEXT`.

Nice, that looks very good

hmm, was getting a "inconsistent return"

agreed

i'll change this in the upcoming PR

oh, really? Interesting, you can see in `selectSource` we just `return`, so not sure what was throwing that

I don't think we should uncomment this. You should probably check for this first, and if that doesn't exist, use `DevTools`. This lets people with the hook into the app with the redux browser addon.

I don't see where React is used?

you might be asking why the sources action is now loading the original source instead of the source-map utility. The reason is that, loading the original source requires `getState` and `dispatch`, and i'm trying to keep these dependencies outside of the source-map utility. 

I'm a little confused between the difference of `actualLocation` and `location` here. It looks like you pass in the before/after result of the `setBreakpoint` call, and `actualLocation` is only different if it slid the breakpoint. It doesn't have to do with sourcemapping.

Since many point of code will have to deal with sourcemapping, I think it's easier to do it like the current debugger server: have a function like `getOriginalLocation` that takes a location and always returns the original location. If the source is not sourcemapped, it'll just return the same location. If it is, it'll sourcemap it.

But it may be you are still working through this :) I don't quite understand this code because `location` and `actualLocation` are not different here.

EDIT: I see that you have `getGeneratedLocation`, which makes sense. Why no `getOriginalLocation`?

Can you prefix this with an underscore? All top-level methods in an action file should be action creators, and we use that convention to indicate "internal" methods in here.

EDIT: Although, you may want to move these out into utility files anyway...

I'm probably missing something here but why do we need to fetch the source at all if we just want to original source, and we already have that from the sourcemap?

Nice

Oh, here is `getOriginalLocation`. I feel like this and `getGeneratedLocation` should be in the same place.

This looks good though.

agreed

I believe we need the generated source to get the original source. I'm getting the original source from the source node. I might be mistaken and can read each of the original sources from the consumer...

sure. I might move those into a utility, but i don't want to go back to the situation where the utility requires selectors and there's a circular dependency

agreed

yeah - this is a pure extraction because i could no longer use the ternary. very little to do w/ source maps

Might be worth looking into, I could be wrong too. From a high-level it seems like you should be able to serve the source for a given sourcemapped URL if you have a sourcemap. I have not thought this through though!

I see. I think the tension is with `actualLocation`. If we're sourcemapping, we know the server doesn't slide breakpoints so we can just use the original location. However, Chrome's server does slide even with sourcemaps. I think you should always use `actualLocation`, sourcemap that _back_ to an original location and pass it here as a single location.

This stuff is so confusing.... :p

Why not just `reduxDevtools: true`? Also camel-cased because we use that for all other options

You need to flag this off, because this is where all the perf problems are. Check if the `reduxDevtools` flag is enabled here and only instrument it if so.

I'd say that you should only export `DevTools` if it's enabled also, and the in the `App` render function just do `DevTools ? DevTools() : null` and avoid the `DevToolsPanel` function.

I'd like to make space for other loggers to be used.

nice catch

Thanks! It's a little shorter to do `if ((e.metaKey || e.ctrlKey) && e.key === "p") ...`, do you mind changing it to that?

nit: this alignment looks a little weird because the args are indented with the code, and we (devtools) usually do:

```
function foo(
  x, y, z
) {
```

thanks

moved below the helper functions

Do we need to do this here? Any location coming from the UI should already be an original location, but if you want to do it for sanity, that's fine. Once we actually type locations we should be able to enforce that `location` is an original location and we shouldn't need to do this.

Perfect, this looks great

yup, it was sanity. We can hold off on it for now

The contract for actions is that they always receive normal JS objects. This gives us some sanity about the API, because components can directly fire actions, and they should always know that that can simply pass literal objects like `{ sourceId: ... }`. So please move `toJS` back here, even if right now that action creator is only fired internally.

This is why actions always just receive normal JS objects :) We want to optimize for the common use case, and with actions you are always passing things in like this.

yeah - that's true.

This might make more sense as SourceState if it's ever used next to another reducer state

hmm, we can easily update this later

Yeah, I think it conflicts with the type name, and I would encourage this module to be used like `sources.State`. It should be used in tests 99% of the time where this specific reducer is being tested. But I may change, I'll think about it some more.

Our coworker gozala (uses flow in browser.html) may have come up with a solution. But yeah, for now I gotta stop spending time on it..

Yeah, that's reasonable unless it's destructured. `{state, update} = require()`. anyways, feel free to merge this as is.

That's what I mean by "I would encourage this module to be used like sources.State". It's an API you shouldn't destructure, because if you do we should change it to `SourcesState` and `sourcesUpdate`, and by prefixing everything it's the same as `sources.*`.

i see. that makes sense.

This might make sense as a README.md next to config. That way we can link to it from here and also other places as well. 

I think if it's in the README we would be more likely to keep this up to date

I agree, I think this is too much of a dump of information. Most people (even advanced devs) won't care about most of this and will just use the defaults.

We just need to highlight a few that really matter: `hotReloading` and maybe `chrome.debug`. I really think we need a dedicated section to `hotReloading` to tell devs to turn it on because it makes the dev experience so much better. Or we could just turn it on by default in dev mode.

maybe move this to a blacklist on top... this list will only grow

ðŸ‘ 

haha - we might want to do something like this... i wonder what other protocols we would want to show

nice, thanks!

It's probably better to whitelist the protocols where know there is a domain/host, at least as a temporary solution. Change it to:

``` js
} else if (urlObj.protocol === "http" || urlObj.protocol === "https") {
  return {
    path: urlObj.pathname,
    group: urlObj.host
  }
}

return {
  path: urlObj.path,
  group: urlObj.protocol + "//"
}
```

And what's the difference between `path` and `pathname` again?

I believe path is `pathname + search`

nice

I don't think we want to message for every feature, but hot reloading is an important one so I wanted to include this.  At first I went with trying to link to the docs but it is simpler to just offer the solution.

This is the change that brought me to this file.  I'm testing things out with Edge and needed to be able to access `http://clarkbw.local:8000`.  I don't think there are security concerns here.  You can omit the entry altogether and have a similar effect bu this seems more straightforward.

That's not a bad idea, I like it. I was trying to think of a way to encourage it without having it on the readme, and this makes sense.

That's fine with me. Does anyone use this to send a public URL to someone else? Usually you have to use a forwarding service anyway because you are behind a firewall/router.

Oh, your comment didn't exist when I commented. I see, makes sense

Oh nice, we do this with client logging as well. Great pattern

Any reason we need all these components now? We could just use `InlineSVG({ src: DomainIcon })` directly in the component that needs it. That would reduce the need to manage this file.

This seems like a nice improvement in another PR. 

flipped the test so that it could be a guard statement and avoid one level of nesting.

extracted this logic.

`sourcesText` was moved to a field in `source`. This simplified some of the pretty print explorations and afterwards seemed like a cleaner abstraction.

Haven't gone through all of this PR yet, but I will tomorrow. Thanks for pointing this out, because I think you already know that I think it should stay separate :)

This is a case where I want the data to be more denormalized, like a separate table in a db. A small nit that now the property is `sources.text.text`. My bigger complaint is that now the sources are not the canonical "protocol objects" as I call them: objects that are given to use from the client. The nice thing about that is that it's easy to back and forth. For example, in my WIP PR I snapshotted the source objects into this file: https://github.com/jlongster/debugger.html/blob/4b79f1f14ead1620fe01dbb549920d891d9f4246/public/js/test/fixtures/todoSources.json With those, I can pick them out and immediately send them into the `newSource` action. Changing the structure means I can't always go back and forth between actions and selectors.

I would like for the same constraint to be held to all protocol objects stored in the reducer, for example the `loadedObjects` field. It makes it easy to reconstruct state and work with the data in all of our testing infrastructure.

I'd like to hear more about your "pretty print explorations", or maybe I will see them when I look closer at this PR. We can write code to "convert" this state back into protocol objects when we need it, but I'd like to see what this actually made simpler.

Why drop this? We'll be inconsistent with the rest of devtools

Thanks for the writeup. Also, I apologize for leaving the `sourceText` change in the PR. It was not needed for pretty printing and should have been a separate PR / discussion. I'm going to take it out of this PR and open a second PR where we can have a discussion when you're back.

I think I hear you saying that you want the shape of the store to reflect the protocol data. e.g. separate message "new source", "source text", "loaded object" are separate fields somewhat like tables. One of the main benefits is ease of testing w/ the protocol data and actions. 

Personally, I'd like the shape of the store to be well shaped for the selectors / UI consumers. A couple of observations, we don't know what future clients we will support. It's possible we can overfit for one client and then the store is it's shape because of legacy (read support multiple languages). 

This conversation, prompted me to re-consider one part of your testing exploration. The tests are currently invoking actions like `newSource` with protocol data. The better approach would be to invoke client events with protocol data.  Here are two examples:

current action approach:

``` js
store.dispatch(newSource(fakeSources["backbone.js"]));
```

preferred client event approach:

``` js
const events = require("public/js/clients/firefox/events");
setupEvents({actions: boundActions, threadClient: () => {}});

events.newSource(undefined, fakeSources["backbone.js"]);
```

There are a couple of reasons why I think the client is the right place to mock:

The client transforms the protocol data into a form for the actions/store. 
- Take `newSource` for example, it will set `isPrettyPrinted` to false and ignore some URLs. 
- It's very likely that tests will fail because actions like `newSource` don't expect un-transformed protocol data
- If we start changing the fixture data to be consistent with how the client transforms the data, there could be inconsistencies.

The client is a more natural place to mock commands. When we get to testing commands like `addBreakpoint`, the natural flow involves 
- simulating a UI  `addBreakpoint` call with data that could come from the Editor
- mocking the client, so that the correct protocol response is returned. The good news is that the protocol already involves request/response, so it should be possible to find the correct server response given request data.

Summary (that was a lot of words)
- I'm dropping the sourceText change from this PR (should never have been here)
- I'm opening a second PR w/ the sourceText change. I don't want to drag out the change, but I think it's an important discussion.
- I'm going to add a comment on your testing proposal. This way we can have the right conversations in a focused way.

oops, meant to open a separate PR. completely agree that this makes us inconsistent w/ devtools. I feel like we can diverge in this way as we have `flow` for types, but I don't feel strongly.

I dropped these checks because it unecessary and frustrating to wrap in async. if we need them we can bring them back

this is a little awkward, and i'll review later

also a little awkward

Engines definitely optimize this :) I like how it's outlined and groups together the code instead of having two top-level functions, but I don't feel that strongly about it.

See my notes in the PR description about it. It's not about escaping, just about shortening so the ids don't look crazy long if the URL is long. I'd be fine with just using `url` but I thought we might want it to look better.

We don't use random ids because we want to be able to always go from `(generatedId, url)` to `originalId` consistently. We can call it multiple times and it generates the same `originalId`. This allows functions to avoid having to dig into the redux state just to get the id.

We actually do that. The redux state isn't used for anything. I suppose for not we could just kill this code and not store it in redux for the time being.

It's not, but usually async actions return a meaningful object. With the promise middleware they always return what the promise returns. So it's just a consistent API that might allow for things we can't think of yet.

Yeah, the promise middleware only needs to be used for UI interactions, because the main point of it is optimistic updates. A `start` action is fired when the promise starts which allows the UI to immediately update. The `[PROMISE]` syntax itself is a way of namespacing values for the middleware and is pretty common in redux (at least it used to be).

Not sure we need to include examples of the output, it pretty verbose in the docs. These sections might be better as just this:
- `client` - This option is currently unused.
- `firefoxProxy` - Logs a verbose output of all the Firefox protocol packets.
- `actions` - Logs all redux actions.

I think there's something to be said for minimalism in things like this because it keeps the docs easily scannable. This document is already huge.

Why'd you remove `pause-exceptions.svg` and take over `pause-circle.svg`? Are you sure the latter isn't used anywhere else?

You need to receive the event here and do `event.stopPropagation()` because it's still highlighting the breakpoint as if you click on the breakpoint item. Stopping the propagation will block the item from receiving the click event.

I still think a list as I had in my previous review would be even better. This are items that you want to scan, not section headers.

Ok, I don't really care just curious. A minor nit is it's not actually a circle :) This is the icon for toggling pause on exceptions, so I think `pause-exceptions` is an appropriate and more semantic name.

But it's not a big deal. Have you figured out your local eslint issue?

I'm actually about to open a PR to update to 3.6.0 because I'm hitting another error that is solved by upgrading.

I don't know why we're having so many issues with our linter today... I'm suspicious that the above linter errors aren't from different versions. I don't know. Let's update to 3.6.0 (the latest version) and see what happens.

FWIW, I know you're going to revamp this PR, but wanted to point this out early. These are selectors. Selectors _always_ receive state as the first argument, so I would have asked you to rework this PR. I haven't gone through it enough to understand why this needs changing, but I'm sure there's a reason, but there's probably a better way to do what you are doing. If you want to talk about it, feel free to hit me up as jlongster on irc.mozilla.org, or just ask questions in this PR. Or you can make a new PR and we can discuss it there :)

These are fine changes, but let's make every dispatch the same: it needs to add the appropriate async props related to that action:

```
const { [PROMISE]: promiseInst, ...restProps } = action;
action = { ...restProps, seqIdGen().toString() };

dispatch({ ...action, status: "start" });
```

It's very clear this way what's going on: there are 3 dispatches in this file and each of them are dispatching start/done/error actions.

Don't say mutate. We aren't actually mutating the action, just changing a local variable reference. The previous comment is probably fine.

nit: trailing comma

nit: trailing comma

Yes, messages may not come back in the same order. If we want a shared util for workers, we should assume that message might not be ordered. I suppose if the worker is fully synchronous, then messages will be responded to in the same order (hadn't really realized that, good point), but now that we might do fetching in the worker it's not guaranteed anymore.

We did a similar thing in mozilla-central: https://github.com/mozilla/gecko-dev/blob/master/devtools/shared/worker/worker.js#L71

You're right though that it would be fine if all the functions are synchronous. I did base a lot of this on how you did it before, so good work.

I could move it to `lib` at least. This is something that we will be working on solely for ourselves for the time being, so I don't really want want to go through m-c and complicate that process when nobody else in m-c will even use this.

But I think it makes sense to live in `lib` at least, which indicates that it's strictly for Firefox.

Can we just use `indexOf` instead of pulling in lodash again? I'd like to minimize the lodash deps and over time see if we really need it.

`Info` isn't very descriptive, can you come up with a better name?

nit: this could be collapsed in a `{ href: ... }` line

I don't really like having two pref systems. Eventually we'll have multiple duplicate prefs and need to do double-checks in lots of places.

I'd much rather go ahead and re-haul our config system to be based on prefs. `isEnabled` is supposed to be the thing that we can call directly without creating these functions.

I don't know what it looks like. Maybe our config system reads from prefs on startup, and also attaches pref observers so it can update the config when it's changed. What do you think?

Seems like it'd be better to avoid binding Cmd+f at all if it's not enabled. So in `setupKeyboardShortcuts` check if it's enabled to even do the binding. We can be sure it doesn't mess anything else up then.

If you keep it here, this function is small so I wouldn't return early. Just wrap all the code; it's easier to see the code flow.

I'd rather not change the heights of the breakpoints, but I'm biased. I specifically tuned them to be pixel-perfect, at least in the Firefox panel. :) Do you mind only changing the highlighted line? The breakpoints should be fine.

Sure, that's fine. Honestly I think it might be good if we eventually just use the `Prefs` API itself. It basically works with json files, as far as I know, we can load in whatever json files locally we want. This way in the Firefox panel feature flags are real prefs, and you can toggle them on and off, which is how we've previously been able to with in the panel.

It would be harder to create new flags, yeah, but I think we should also avoid using feature flags for things that should just sit on a branch and be developed a little more too.

We need to use this in other places as well, like the call stack, right? Can you add that to this PR, so we can be consistent? The call stack includes the location of the file for each frame.

You can also use `basename` from public/js/utils/path.js instead of the regex matching here.

I feel like we have too many little hacks around the editor area (1px offset here and there). I would _love_ it if you could take a few minutes to think about about the editor area and possibly refactor it a little bit to avoid this. Maybe a few more uses of flexbox would help. I feel like it's getting way too brittle.

I'm fine including that in this PR, it's related to the UI changes you want to make. It's hard for me to approve yet another hardcoded value :)

Yeah, that makes sense. Would probably be good to pull this out into a separate PR with a real fix.

I haven't looked at this CSS for a while, but seems like we could use flexbox and tell the editor-container to fill up as much as possible, while the header and footer take up as little as possible (`flex: 0`). But not sure.

Why keep track of this? Wouldn't just calling this in `componentDidMount` work instead of `componentDidUpdate`?

You don't need `new` here

"needed the window"? Shouldn't `window` always exist? I encourage you to go down these rabbit holes :) Otherwise we are just accumulating technical debt.

Done

It tells webpack not to mess with `__dirname`. Otherwise, `__dirname` is `/` in the modules, but because we are actually running in node, we want the real `__dirname`, and this lets us use it instead of webpack's overriden value.

Not sure what you mean? 

Does this apply it to the text within CodeMirror? The code should be selectable.

In my opinion, it makes it a lot harder to keep track of changes if we're committing a bunch of code we know is about to change. I'd rather cleanup things as we see them instead of constantly adding more load w/new issues etc. This subjective, of course, and if it's a big enough change should be separated, but small things like that it's nice to hit an API problem and prove that a refactoring will fix it by using the current PR as example usage of it.

Same as you; maybe I lean too far on the larger PR side. It's all subjective!

I don't understand these changes. Sure we're not creating a top-level `public` folder on the system?

I don't know how I feel above hiding webpack inside of `build-bundle`. The toolbox should not own our webpack build process. We should just require the toolbox in our `main` file, and our webpack will bundle it in, and the project can document whatever babel plugins/etc it needs enabled.

A lot of these config values are specific to the debugger. Well, I suppose this highlights the difference between features flags and config values. The former are debugger-specific, while the latter aren't. I think we should split them up somehow.

I don't think we should be depending on the toolbox to do all of this. I'd like to see it more as a library than a framework. Just give me the pieces to connect, and I'll hook them up to my app. It's not uncommon that we want to tweak things in here and we can't do that if this is shared across everyone.

I think it's very enlightening to just open up an app's `main.js` and see a very straight-forward way of how things are hooked up. If we bury this, it gets harder for beginners to understand what's going on (and even advanced users who want to hack up something quickly to change it).

For example, I frequently go into `main.js` and flip `log: true` in the store configuration to log actions. Why don't I change the config? It's just easier for me to open `main.js` (config is at the root) and more importantly I don't have to restart the server.

I think this could export reducers/actions/components that someone can embed in their app. Or at least make the toolbox have its own render and redux store, and do everything it needs to if we don't have a target. But in our `main.js`, if we have a target, call into the toolbox to connect it, but let us do our own rendering/store creation.

Do whatever you feel like for now, this is a big change so we can move things back. I'm not going to block it.

I see that we still are creating our own store, so that's good. I thought that this code had been copied over too.

This is where I'd probably be a little frustrated if I was trying to learn this project; compare the above code to this and it's a lot less clear what's going on. There is a place for abstractions though, so I could be wrong. I just feel like having code that reads like "if they need to select a target, render the toolbox, otherwise we have a target so connect it and render our app" would be nice.

Similar argument here; trying to figure out how various things like hot reloading or how we're transforming JavaScript would be more difficult to figure out. I think the toolbox should be more isolated and we should still have this webpack code. It would be nice to share though, too, so maybe you're right to move it out.

Yeah, you all are right, we should definitely share it. I'd just like to make sure we do it in a way that's easy to extend, and it's clear where the base config is coming from. I think we're on the same page.

Yeah, I think we should avoid it. We want to be careful about mutations because they cause surprising effects down the road. It might be good to ask Honza about this.

Oh, just noticed that he commented below. Sounds like we have a different approach in mind now?

Yep, that was leftover from the ability to restart it (which we don't need here, it doesn't keep any internal state)

Please don't use the term "sources" in a generic that is not tied to sources at all. If this is supposed to be a generic dropdown component, just use generic terms.

The dropdown component should have its own CSS file.

Where is the error? We really shouldn't digress on type coverage. It's already very poor.

I don't think we should automatically install something globally on someone's machine. I think it'd be better to display a message telling the user to do `npm install -g jasonlaster/lerna`, particularly since this is a fork. I'm pretty they already have it installed this will overwrite the previous one.

nit: no need for a comma, just "This feature will..."

nit: I think the var name could be improved. It's not referencing a JS object, which the name implies.

I don't think we need to put this behind a flag. Let's just land features and make sure they work from the start. If there are major bugs I think we should fix in the the first PR. But I doubt there are major bugs, there might just be UX improvements we can do. That's the point of landing in nightly though; we have time until uplift to tweak it to get it great.

There no assertions here though; it should always just throw an error. `assert` may evolve in the future to only happen in dev or somethings. But this should always through.

Yeah, go ahead and remove these comments

You should probably remove the old breakpoint client from `bpClients` here before we add a new one.

Also, can you rename `res` to `bpClient` or something to make it clear that it's just the breakpoint client?

Nit: this is very confusing indention. Please do something like this instead:

``` js
ReactDOM.render(
  dom.div(
    { className: "conditional-breakpoint-panel" },
    dom.div(
      { className: "header" },
      `This breakpoint will stop execution only
       if the following expression is true`
    ),
    dom.input({
      defaultValue: condition,
      onKeyPress: (e) => onKey(e),
    })
  ),
  panel
);
```

nit: no parens around single arg arrow functions

Hm, at an initial glance this looks wrong because we're changing the id but it looks like `id` (which is the key we use in the state) is the old id. But I think this is right because `id` is not the actor id, it's generated from the location. I don't know if there's any way to make this clearer without making it too noisy. I guess it's fine, because if we changed what we called the `id` variable we should change it in all the other places in this file.

Anyway, I thought there might be a side effect of changing the actor id but I can't think of any bugs with this. Perhaps at least a comment explaining why this is needed?

I think actions should only fire when they hit the server. It gives them a lot more meaning, and when you see it in the action log you know exactly what happened. Firing them all the time would lose the ability to read a log and know if it actually hit the server or not.

It also gives tests more fidelity. If you know it should fire that action and hit the server, you wait for it. If it doesn't and loads it locally, the test will fail and it's not behaving as you expect. The difference is meaningful and a failing test will help up know that it's not loading (or is loading) from the server as we would expect.

What's the point of creating another file? I don't see why we should be splitting out components into multiple files between `utils` and `components`. It's a lot hard to follow the codebase.

id's should definitely always exist. I'd rather not make things null-compatible; why would be pass in null? If you do `source.id` and it doesn't have an id that's a big problem. (this is also the reason why I don't like lodash. doing this makes bad code be silent)

Why is it pulling in react 15.3.1 now?

Yeah, that's how it should work. Thanks for looking into this.

Cool

Don't we need this turned on though if we're in the Firefox panel, and this file still runs there?

You don't need to use the thunk middleware here, just return the action:

```
function toggleFileSearch(searchOn: boolean) {
  return {
      type: constants.TOGGLE_FILE_SEARCH,
      searchOn
  };
}
```

It doesn't need to use the constants. Once everything is flow typed the constants file can go away. Flow will error if you pass in a string that doesn't match any of these types.

If it's an exported function, you need to fully annotate it.

Why these changes? This is wrong. A source might not have a URL, and definitely will not have a sourceMapURL most of the time.

Please don't destructure this, the code is clearer by simply referencing `source` below. Unless you did this for a specific flow reason?

Yep!

It comes down to a bug in React 0.14.7, I believe. At some point I'd like to figure out exactly why it's not calling lifecycle methods the same, but at least it's not intentional behavior.

What's this for?

Why do this?

How are we going to keep strings in sync? It worries me a little bit that we need to maintain them in two places.

Isn't this a XUL element? What purpose does it have here?

Just a reminder: (since other comment was on an old commit, I believe) don't destructure here and follow what the code did before.

Still don't understand; what behavior exactly does this change or fix?

Aaah ok!

Can we just remove the conditionalBreakpoints flag instead?

Cool! Yeah this is better. Although I'd like to make sure that we don't accidentally overwrite any changes. It's much more likely that the properties file is going to get changes, so this is a little bit of a grey area.

For example, someone has already fixes one of the strings: https://hg.mozilla.org/integration/fx-team/rev/a89bd4876d4d3cbeac2e4b85e99b903a7f9a59c1 Make sure we don't blow that away.

(Also don't forget about https://bugzilla.mozilla.org/show_bug.cgi?id=1313196#c10)

I like that it's a little clearer as a verb, but I agree it's a little long. I'm fine with how it is though.

This is an unrelated change, can you make this a separate PR?

I'm a little sad that we're diverging on another thing. It would be nice to work on the official editor in m-c instead of customizing it to our needs, but I know that's difficult right now because we need to separate it out into a module for that to really happen.

It's OK for now.

Personally I like keeping the braces on the same line, because that feels like too much space. But that's totally subjective.

Leftover console.log

This line doesn't do anything

I can't use that because I need to wait until a specific number of nodes exists. I don't know which specific node to wait for. I hate it, but there's no away around the throttling of the tree rendering.

Not sure what that's doing, you are yielding an assignment?

Either way, it doesn't work because the action will be dispatched synchronously so I need to build the promise before firing the click. Usually I would just do `yield wait()` but it's like this for a reason.

I'd rather not; it's a core part of the test logic so it makes the test more straight-forward to read and understand what's going on.

Ditto my other comment as well. I'd rather keep this in here as it's the actual testing behavior.

There are some other tests that provide functions from the example, but the main reason is because it's pretty complicated code and would make the test too messy. Here I think it's simple enough to just inline. We'll have to figure out a lot of stuff if we ever run these elsewhere but I don't think we should worry about that too much right now.

I think you meant `yield waitForDispatch(dbg, "SELECT_SOURCE");` in your original code ;)

I don't quite follow because I'm not dispatching anything here, I'm waiting for a dispatch. Oh, maybe you mean that if it is an async action, it would work to do something and then `waitForDispatch` right after because we don't care about the `"start"` action; our `waitForDispatch` will resolve with the `"done"` action which is guaranteed to be asynchronous. That's how it works most of the time.

`SELECT_SOURCE` is not an async action though. Not all `dispatch` calls return a promise. Only ones that fire an action creator that _themselves_ return a promise do. `SELECT_SOURCE` is not async and is dispatched immediately in the `selectSource` action, which is fired synchronously when `clickElement` is called.

So we must have a handler for it waiting before `clickElement` is called. Otherwise, once `clickElement` returns the action is already dispatched and we've missed it.

This is a good thing to understand which is why I wanted to explain more. Once this is merged, feel free to try changing the code and watching it.

Why not just do `require("devtools-local-toolbox")` ?

I think it's a little confusing for code and configs to share the same directory. I'm still getting my head around this new structure so I don't know what to propose yet, but ideally the top-level `config` directory would just contain json files.

@Pomax I agree. I've advocated for limiting our use of lodash. I would suggest removing it from this file as well.

I guess the main thing was referencing `node_modules` directly though: you should be able to do `require("devtools-local-toolbox/index")` right?

This is src code so I don't see why `src` wouldn't make sense?

You just got rid of `firefoxConfig`. You need to handle the `firefox-panel` target here.

Not fully convinced we need this. It seems like a special case that diverges from the design for not much reason. Also, it's confusing if you are debugging node and it says "Firefox Debugger".

Can the config just duplicate the `hostURL` instead of adding more complexity here? I'd rather have absolute URLs in the config so you know exactly what URL it's using.

This doesn't seem fixed with the new commit?

Don't export 2 components from the same file. A lot of React tooling expects a single component per file and it's a good pattern. What is the advantage of `AccordionPane` anyway? We can achieve the same thing without an additional component, and this API eagerly renders all of the panes which we don't want.

Perhaps the only awkward thing about passing in an array of items is that we don't support `null` in the array, so you could conditionally include things like `Expressions`. I suggest simply allowing `null`s in the array but keeping the previous API.

Otherwise this PR looks fine. I don't know much about `Expressions` so don't have much to comment there.
That's a blocker for this PR. :) We can't merge this until we know it's actually working. If it's not applying the types we have no idea if this PR actually works.
Are you sure this works in the panel? I remember trying to load the config before but ran into problems so I avoided it.
At this point why not just `fetch("/get....")`? which is how it was before the app stuff.

So the app is currently just showing the webpage from the server, yeah, which is why I didn't think this was needed. And this will work when it's locally running the server itself too.

Makes sense, thanks for thinking through it!
That is fixed on master. Not sure if it was included in the latest published version or not.
fixed.

fixed

> add a typeof check for Worker and then build Rep.

Hmm, I don't have a better tip, although could you somehow define the `define` function in the global scope?

> The ideal solution would be to convert Rep to commonjs, but I'm not sure if that would be possible...

The problem is that Reps are consumed by the JSON viewer. JSON Viewer runs in a page and needs a way to load all the modules (async). As soon as we allow using WebPack I can build jsonviewer.bundle.js (just like you do for the debugger.html), include it in JSON viewer page and we can remove the AMD support.

Honza

Note that this also changes the Console and DOM panel representation of the 'window' object. These are displaying URL of Window currently.

One of the goals of Reps is unifying JS/DOM objects rendering and making it consistent across the DevTools UI. So, the question is why representation of |window| should be different in Console/DOM and the Scopes pane? If that's because there isn't enough horizontal space (the Scope pane is within a side bar) we might want to come up with custom value for cropping...?

Another way is to use 'mode', which customizes reps's rendering logic. We are currently supporting three modes:
- tiny
- short
- long

So, the same object can use three visualizations. These visualizations are trying to be very similar, but respecting different space conditions (e.g. long mode is used if there is a lot of space for the rendered object).

For example, if you log an array into the Console panel it's using 'long' mode (max rendered items 100), but items in the array are rendered using 'tiny' since there can be a lot of them. Another example, the DOM panel is using "short" for arrays (max rendered items 3)...

The Scopes pane could use "tiny" ...

Introducing new modes is possible, but not thoroughly tested.

Btw. Window grip uses `kind =  "ObjectWithUrl"` since it's done that way here:
https://github.com/mozilla/gecko-dev/blob/master/devtools/server/actors/object.js#L1560

Honza

Yes, different approach suggested. And I agree, we should avoid rep value mutations.

Yes, looks correct to me to.

Nice, that's exactly what 'modes' are for.

I suppose we could simplify all of this by adding `.replace(/:formatted$/, "")` here, but the function will come in handy in the future.
`jumpLabel` can probably be added to the array initially
What if something like:

```
if (isEnabled("copySource")) {
  showMenu(event, [copySourceUrl]);
}
```

No need for `items`
Do we have a system for caching this?  Tokenizing could be expensive.
I....I'm not fully understanding how all of these fit together... :/
I find it slightly concerning that `onGutterContextMenu`'s `lineAtHeight` returns one number higher than `onGutterClick`'s `line` argument.

![linenumbers](https://user-images.githubusercontent.com/46655/29479484-11499e66-8438-11e7-9bce-07963fb62a2a.gif)

...but that existed before this PR.

Looking at this again, we should probably return `[]` instead of `false`.
(Prevents an error in `isEmptyLineInSource` because we immediately use `.includes`; I think it's reasonable to always expect an array from this function)
We can probably move this into the JSX since it's so small.
This var name is throwing a lint warning: `no-shadow: 'actions' is already declared in the upper scope.`

We should use `OS` (caps) as the var name, IMO.
Is the `git to` meant to be here?
These 3 additions are the real change.
typo: `focus`
Should this be `fnc`, not `func`?
OK, so there are two problems here:

1.  It should be `fnc`, not `func`
2.  `TypeError: content.wrappedJSObject.apply is not a function` bricks any test that uses `invokeInTab`.  So, for example, if I dumb it way down with the following, all tests run:

```js
function invokeInTab(fnc, args) {
  info(`Invoking function ${fnc} in tab`);
  return ContentTask.spawn(gBrowser.selectedBrowser, fnc, function*(fnc, args) {
    // content.wrappedJSObject.apply(fnc, args); // eslint-disable-line mozilla/no-cpows-in-tests, max-len
    console.log('invoking in tab: ', fnc, args);

    // FIX HERE
    if(args) {
      content.wrappedJSObject[fnc](...args);
    }
    else {
      content.wrappedJSObject[fnc]();
    }
  });
}
```
We're sending 3 args here, while `invokeInTab` only accepts two; don't think we need `dbg`.
...actually, simply removing that doesn't fix test failures.  Still looking into it.
This function doesn't appear to be used -- can we get rid of this?
Whoa.......not sure how this happened, thanks for the catch ðŸ˜› 
Absolutely agree. Had a thought about making it a stateless component, but didn't know what do you guys think about that.
This was changed because lint-md was yelling on this. Maybe I was wrong here... Sorry
You can do `CmdOrCtrl+P` which will handle control on windows/linux or command on osx 

What's the case when this happens? Is this expected until we fix some issue on the target? Perhaps we should console.warn in this case
A comment above this condition explaining would be helpful as well
@jasonLaster I don't know enough about the desired output across the tree and the way reps are being used here to have an opinion.

Great, I prefer a more terse code style myself :-)
I was not sure If I should change it, but i think i like it better
Ok, I will change that.  Screenshot coming up
Do you mean the formatting?
Good question.  There is an issue where `<span>{matches}</span>` causes a react
error that keys should be unique,.. oh! I see jasonLaster just commented about that :)
This was an attempt at making the prop optional to try and make the error mentioned in the PR
above go away.  The `disabledFocus` prop is not used in `src/components/PrimaryPanes/SourcesTree.js` so it should be optional for now.

Unfortunately making it optional did not make `yarn flow` happy.  I think this might be a known flow issue.
Gah!  So there is something strange in my setup, grrr.
Ah, interesting, so using spreads for children is off the table for now I guess.

Thanks for the links
LGTM. I was planning to do some opts as next step. 
1. Use transfer objects to transfer matches from worker to main
2. Make next and previous to be O(1) operation if cursor position has not changed from last search.

Thanks for taking care of the CL. I could not get to it quickly :(.
also when using lodash in node code, it generally makes more sense to call the variable itself `lodash`, not `_`, since it's much for informative to grep for a full word string like `lodash` than it is to grep for a single character `_` (especially with Node's `___filename` and `__dirname` constants).

That said, most of what lodash does is covered by ES6+ these days, so that the only thing it's being used for in this code is covered by vanilla JS these days as `Object.assign({}, envConfig, localConfig);`

given the LTS status of 6.9, probably worth bumping this to `>=6.9.0`

Is it possible to keep add_task/yield?
That would allow you to not have to refactor every single mochitest?
Also wouldn't it be possible to not reimplement all the deps from head/shared-head?
I would be happy to review m-c patch to help you reuse some existing code.
Are you now able to bump this m-c changeset easily/frequently?
It could be great to use `bin/prepare-mochitests-dev`
so that CI and contributors go through the same path.

But given this change, it looks like you had issue with keeping m-c clone around between two travis runs?

ya, that's better.
So for 
- 1 result - `1 of 1 result` or `1 result`
- 1+ results - `%d of %d results`
?
@wldcordeiro  @jasonLaster 
Does this make sense to you?

I'm thinking other things like logging preferences, hot reloading could go here

It seems silly to add gecko as a dependency just for some css, but we'll probably need it for something soon and our target audience has gecko... What do you think?

Made a minor style decision to load ff-devtools-lib modules before debugger.html modules. Feel free to push back

This is a copy pasta from debugger-controller. As a side-note it would be nice to consider adding local storage of preferences in `ff-devtools-libs` in the next milestone so that these preferences can be tested early on. I don't anticipate it too be hard.

When you select a tab, you're doing two things: attaching to the threadClient and loading sources. Chaining these actions in the click handler seemed a little dirty, but better than other alternatives. For example, I tried to dispatch the loadSources action from within the selectTab action, but it seemed bad for Tab actions to know about Sources actions.

These listeners used to be setup in `main.js`, which had access to the store and actions. 

It seemed like too much coupling for `thread-client` to have access to the store and actions, so I moved them here. Thoughts?

Is there a better way to see if a seemless-immutable object is empty?

It's so nice to see red in a bootstrap file like main.js. With that said, I tried to not lock us into a solution with too rigid an API.

The name `toolbox` is somewhat of a placeholder because that's a fairly well defined word. Do you think it works here?

I tried three different hacks for exporting `gThreadClient`, which would let us do something like:

``` js
const {gThreadClient} = require('../thread-client');

function loadSources() {
  gThreadClient.getSources();
}
```
1.  exporting a reference to the threadClient
   - `module.exports.gThreadClient = threadClient`  
   - webpack would get a reference to the module before the exports property had been set
2. exporting a stub that received threadClient properties
   - `Object.assign(gThreadClient, threadClient, threadClient.__proto__)`
   - webpack would get a reference to an object with all of the properties except the threadClient's prototype getters, which we could get if we did a slightly better deep clone than Object.assign
3. exporting a getter
   - `module.exports = {get gThreadClient () {return threadClient}}`
   - webpack would get a reference to threadClient before it was set.

Ultimately, I decided to leave `gThreadClient` a global for the time being. :)

That works for me. 

nice

got it

Good point. I like that it's not magical. 

Let's kill it. I don't think it adds a lot of value. 

I wonder if it'd be helpful to move some of the breakpoint source data collection to queries.js. So, instead of getting sources in the breakpoints component and formatting it with `URL`, you could get breakpoint props with a formatted pathname, which would be useful here and maybe other contexts as well.

@jlongster what do you think?

This file is required in other places, so it doesn't need to be imported here.

Breakpoints was refactored to be a react class because it needed to use connect, does that make sense? Also, should we be transitioning to es6 class syntax e.g. `class Breakpoints extends React.Component { }`

the style comments should be on the top of the file along with the license

@matt-oconnell did you delete the other import/url references in the file? If so, could you comment them out instead so it's clear what we need to move over to have the full functionality

@jlongster do we want to support the dark theme now? I am inclined to say now because this is just a prototype.

If we don't we can get rid of the selector scoping. If we do, I think we want to be consistent with the original [variables.css](https://dxr.mozilla.org/mozilla-central/source/devtools/client/themes/variables.css).

Thoughts?

Cool. That's why i asked. 

this allows more globals to be defined (document, window...)

this is because eslint doesn't know we're using a module system...

helps with a dispatch call on line 34, where dispatch is shadowing the outer define. We might want to disable shadowing globally for this reason.

was hungarian formatting

was tempted to add this to the list of globals in eslintrc, but figured, we'd be refactoring soon

for run_test

dropped this because it wasn't necessary.

dropping these in favor of consistent styles. might be a bit ugly, but that's okay

happy to do that.

I'm not really sure what introductionType is doing, but this is what we were doing before, so i kept it

Related to issue #31. We can add a couple small utility functions that DRY up our code a lot. 

This is no longer necessary: [npm start](https://github.com/jlongster/debugger.html/blob/master/package.json#L4)

thanks, this was something that a lot of people needed yesterday

afterwards, maybe say. Quit and re-open firefox with the same command.

sounds good

agreed. figured that was a placeholder at the time

it'd be nice to have better annotations at somepoint

nice. looks much nicer.

is this still used in a couple places.

:+1: 

NOTE: this is just inside of the tests dir

found our first bug!

I'm not convinced we need these...

eslint fixes

should have killed earlier

it'd be nice to pull in a list of globals for mocha, node, ...

because for the time being the `test` and `test-browser` are dumb and can't recursively search for test files

This should probably be a query `getBreakpointBySourceLine(source, line+1)`

Could this also be two functions: `getBreakpoints` and `getBreakpointsByActor`?

In the case of the editor, I think you'll always want to call `getBreakpointsByActor` even if there isn't a selected actor. If there isn't a selected source, then the editor doesn't want any breakpoints. 

If you're updating the `makeLocationId` callsites, do you need to coerce here as well?

Also, I'm wondering why location is not immutable default. I ran into this in other places [as well](https://github.com/jlongster/debugger.html/blob/master/js/actions/breakpoints.js#L40)

Makes sense. 

I could see queries and actions being immutable as well. 
- The argument for reducers is that way they receive and set immutable objects. 
- Queries is less clear, but at this point i believe they mostly receive a string or immutable object

With that said, I'd be fine with actions, queries, and client calls receiving plain JS objects. I haven't thought this through and you have more experience here.

`debugTab` used to be duplicated in `Tabs` and `Main`.

I'm really happy that in many places this PR cleaned up existing components. i.e. extracting actions from Breakpoints.

breakpoint gutters are now added as part of the `componentWillReceiveProps` lifecycle so that breakpoints are persisted as selected source changes. It is also more uni-directional ðŸ˜‰ 

this is definitely going to conflict with your breakpoint work, but hopefully it's very similar to what you have

oh oops

yeah. but modified not to use `this`

cool

4 gives us two describes (one for the action, the other a scenario)

I split two source actions loadSourceText and newSource to their own test files... I'm not sure if that's necessary. Maybe here, but not with other actions... 

sadly that doesn't work due to a chrome flex box bug with height and width's with percentages.

the 30px could be moved into a variable so that it is shared between source tabs and the editor.

still, not in love with this `position: absolute` solution, but it's the only hack I could find for getting around this known chrome bug.

moving rendering breakpoints down here is really smart

lol. soo many

nope - happ to drop it

yea, that works. 

I think I follow. Will give that a try tomorrow

Yea, that's a good idea. At this point, I'm numb to assertion libraries. I've given up hope that my muscle memory will know if it's camelCased or dot deliniated. Lets look around for a convention soon because it will be a pain to switch soon.

`() => {}` will make the context of the body the context of the outer describe, which messes with mocha's funny nested context property where `this` is shared.

I changed it because storybook's server expects it in this format `app.use(express.static("js"))` and based on the express [docs](http://expressjs.com/en/starter/static-files.html) it seemed like the preferred style. I don't think storybook's use case is important enough to warrant the change (we could find another way to load the SVGs, but I would like to take into account express best practices).

I developed this style in part to avoid tests growing over time. Where the `beforeEach` handles the setup and the `it` handle the assertions. Often times, you might want to check a couple things and that way the test read, `when a source fails to load`, `the editor shows the error`, and `the error is saved in the store's source field`... The screenshot shows this a bit.

With that said, I'm okay putting the action in the `it` now as well.

this is mostly a placeholder, I think in reality we can re-use much of the existing webpack.config.js

This fixture data hopefully can move to its own file soon and be re-used by component unit tests

yea, i like that idea. I hope that we'll add better abstractions as we go. Something like `test-head`

I'm going to merge and then make the tweaks

Nice

really happy to kill this

It always seemed like a smell that the breakpoint list also relied on the entire sources list...

nice

I think you're right that this selector makes more sense inside of the Breakpoints component. Good call

just a small cleanup. basically the same thing - just consistent

fixing a warning

Good call.

The pause.svg used to be the resume.svg

Yea, that makes a lot of sense. We could do a simple feature check `if (URL) {} else {}`

> We don't test components in node, we'll run them in the browser

Yea, we can decide to do that. Lets wait and see though, it might be simpler or significantly faster to run in node. Not sure yet.

> selectors

I'll move it over now

oops, meant render block

The syntax highlighting with apostrophe's is a pet peeve of mine. I'm not sure which is worse, breaking the highlighting or using bad english. Feel free to overrule this decision :)

Really happy to have this red

There are a couple things I don't love here:
1. having "fake" data with fixtures
2. having a dump of pause data here. 

in some ways both are probably fine, it's just important to see what balance we like for our tests/stories

it's frustrating to have to copy the eslint file. We can probably clean this up by adding globals to the primary eslint... with something like `Object.assign({}, config.globals, mochaGlobals)` I beleive there's a project for that. We could also do something else too...

you can do `pauseInfo.isInterrupted`

Maybe also move the selectSource action here too https://github.com/jlongster/debugger.html/blob/master/public/js/client.js#L49

any reason why you prefer this over `connect` in the component, which is what Breakpoints and Scopes does.

nice

> maintaining it

Yeah, that's a good point.

`nextProps.pause.get('isInterrupted`)

I think we can extract this to `setEditorLine` or something like that

makes sense.

do you need a store here?

shame there isn't a native map function

I think the onWheel logic should land in `util/editor.js` as it's a utility for the editor exclusively.

`this.editor.getScrollerElement().addEventListener("wheel", ev =>  onWheel(this.editor, ev);`

i feel guilty adding filename and pathname to the fixtures. should really be a query

yeah - i think tha's right

it can be it can be JS as well... I've seen something like this before...

does it make sense for `selectSource` to move to the `paused` action? I say that because `paused` already dispatches a loadFrames action.

nit - can this go on one line

YES! I spent atleast an hour trying to think of a way to cleanup the actions list and it didn't occur to me you could pass them all in :) that makes me really happy to see.

nit: a navigate const would make it more consistent.

`const navigate = { willNavigate, navigate }`

nice

this is good. Tabs specifies it's dependencies

lol - was worried about that

was hoping to cleanup module.exports. not a big deal

this was needed for styles to apply. It _should_ be a code smell that an element needs additional surrounding context to style correctly. I'll file a bug to fix this soon.

templates. not sure if we'll use these

What's the benefit here?

Does the try catch need to wrap everything? Seems excessive

Makes sense. 

What does class names do?

Style nit, but I'd find it more readable if renderItem were extracted to an instance function. Here there's quite a bit of nesting. 

The tests visit `8000/babel` so that headlessly the es6 code is traspiled to es5. Hopefully this can go away soon.

I'm able to kill the launch logic because arguments are passed in key and value as opposed to just option.

moved the test server to it's own module as it was plenty complicated

I'll add documentation soon, but the setTimeout handles cases where the eval times out because we're paused.

clicking the tab handles the case where you refresh the debugger before firefox is open. 

we need the full path for the tree

yeah - this code desperately needs some comments.

The gist is that the `eval` runs the driver commands that are added to a managed promise schedule, basically a set of coordinated operations that will happen in the browser (type, mouse, click). The timer is useful for resuming when those operations have paused due to a breakpoint being hit. 

We're pulling it in so that the tests in CI can visit todomvc. I can replace this with a set of static built files, pretty easily. At some point, we might not want to test todomvc, but it seems like the easiest set of tests to write at the moment to touch on many different interactions (going between pages, breakpoints etc)... Also, there is some merit to having your test subject be more realistic.

That's fair, we can either version lock the tests (todomvc) or pull down static files. I'll create a cleanup item for that.

the development server makes the request for tabs from chrome because this endpoint does not support jsonp.

This approach raises an interesting question as to whether we ship the a standalone app with a local server. At the moment, I want to reserve judgement and this was a path forward. I think we could make a chromium contribution for jsonp fairly easily too.

There were two functional changes to how Tabs work:

1) the top level tab state uses `id` instead of `actor`
2) when a tab is selected either in the UI or URL in main, tab is determined by checking the firefox and chrome field. I think there are some obvious drawbacks here, but am reserving judgement until I see a couple other usecases

this should be flagged, so it's only on locally, and not when it's embeded.

I'll fix this when i tackle debugging a tab for chrome. Want to wait because there might be more there.

agreed. i think formatting is nicer, but I think there's a better word too. something closer to what an adapter would do. I'm thinking of the layer between sql and orm models, or orm models and UI views... I'll be doing lots of this work soon so will punt for the time being as well. not ignoring this though :P

it's run here ðŸƒ 

surprised this lasted this long

happy to kill this

I'm not thrilled with having a tab property in tab, but I'm not sure if there is something better. I'm still waiting on what patterns emerge with sources and other state before i make some decisions

I believe that matches `clients/firefox` unfortunately

yeah - that works for me

oops. didn't mean to add this

When possible, I'd like to just query the state directly. Creating helpers is good when you have to do a bunch of extra work, but otherwise it forces you to jump around to see what it's actually asserting. Do you mind reverting this change?

One thing that helps is we can probably stop labeling every single assert. It's good in some places, but we can just do `ok(!getSelectedSource(getState()))`. No other testing framework makes you label every single assert, and if it fails it tells you the line number of the failure.

no problem. I had a similar thought as well. _was on the fence_

this might be the most controversial change in the PR.

This came up because i needed to add a reload action, which is triggering a navigation. The pattern setup in the pause actions is that we use present tense for client actions and past tense for server actions e.g. (pause, paused).

i'll change this once the cleanup lands

I have more comments about `reload` actually :) I don't mind this change.

I'm wary of adding actions that aren't explicitly for users to use. This is just for testing, so I'd rather take a different approach.  Let's just expose the client to the mochitests just like we expose the other things, and then tests can just call `client.reload()` themselves. What do you think?

that makes sens

hmm, i think it might be better to add a `stopWorker` method which we can call when we end the tests. We will likely work on source maps next sprint and need this then.

``` diff
diff --git a/public/js/utils/source-map.js b/public/js/utils/source-map.js
index cf3760f..a6b31d7 100644
--- a/public/js/utils/source-map.js
+++ b/public/js/utils/source-map.js
@@ -8,13 +8,18 @@ const { isEnabled, getValue } = require("../feature");

 let sourceMapWorker;
 function restartWorker() {
-  if (sourceMapWorker) {
-    sourceMapWorker.terminate();
-  }
+  stopWorker();
   sourceMapWorker = new Worker(
     getValue("baseWorkerURL") + "source-map-worker.js"
   );
 }
+
+function stopWorker() {
+  if (sourceMapWorker) {
+    sourceMapWorker.terminate();
+  }
+}
+
 restartWorker();

 const sourceMapTask = function(method) {
@@ -148,5 +153,6 @@ module.exports = {
   getGeneratedSourceId,
   createSourceMap,
   clearData,
-  restartWorker
+  restartWorker,
+  stopWorker
 };
```

oops

at some point this should be in the flow types, but we'll get there

this feels like some duplication, but it is probably okay

If you want descriptions you have to use the `@property` identifier, however these might not need it.  Likely just documenting the non-obvious items is only required.

Definitely!

Yeah, I really don't like these doc strings now that we are using Flow. I was excited to get away from them in the devtools codebase because we have real Flow types. I haven't look at this system at all but I thought it supported flow, meaning that it read flow types? It makes me sad to see our nice and clean types have these comments :(

My argument is yet again maintenance: I can't tell you how often these docstrings were out-of-date in the devtools codebase. The flow types will never be though.

There are definitely some old docs hanging around.  I think this will shine more light on it to help get it fixed.  

I ran into this at some point and don't know what to make of it https://github.com/devtools-html/debugger.html/blob/master/public/js/selectors.js#L43-L45

yeah - lets just do the non obvious ones 

>  It makes me sad to see our nice and clean types have these comments :(

felt the same way!

Right, if the attributes are obvious it is definitely excess.

If you add a comment at the top of a type, it shows up beside in the docs right? You just write more free-form and say "Represents a breakpoint. `text` is a snippet from the line it was set". I think the rest are pretty self-explanatory.

I once ran into the number two on a line by itself. 

Kill it. 

Removed them and I remember now why I tried added them.  There's an issue with documentationjs right now https://github.com/documentationjs/documentation/issues/359 where it doesn't pull in the exported types.  Once that is fixed we should see all the types show up automatically.

It is a little late but... I was wondering if there is some reason you did not pull it out into it's own function for consistency?

Nope. Guess I could

I actually quite like this pattern for a couple of reasons:
- it enumerates the supported handlers in a more succinct fashion than the case statement
- makes it possible to invoke a single handler for testing (maybe useful)
- avoids the smell of one large function
- makes it easy to document each function separately

I'm not a big fan of the name `setupReducer`. There are some libraries out there that do this,  but this seemed simple enough for our purposes

After thinking about it for a couple of days, I'm on the fence between two approaches:
1. the delegator factory

``` js
setupReducer(initialState, { addTabs, selectTab });
```
1. an update function with separate handlers

``` js
function update(state=InitialState, action)
  switch (action.type) {
    case constants.ADD_TABS:
      return addTab(state, action);
     default:
       return state
  }
```

This second pattern is what [tofino](https://github.com/mozilla/tofino/blob/master/app/ui/browser-modern/reducers/ui.js#L19-L51) does. Benefits:
- similar benefits with helper functions (documentation, easier to test, ...)
- more familiar to a larger audience that is used to the the `update/case statement` redux style
- it's easy to have many action types map to the same helper

As this is a style question, I'd prefer something that is comfortable to a larger audience (option 2) unless we believe enough people would recognize/understand option 1.  I've personally seen a couple projects use option 1, but I don't have a good feeling for how widely adopted it is.

Lastly, after a little bit of research I found that the redux docs have this helper function [createReducers](https://github.com/reactjs/redux/blob/master/docs/recipes/ReducingBoilerplate.md#generating-reducers) under a section of reducing boilerplate. Given that this is widely documented, I'd opt for using it.

It's a good question and comes up a lot in the redux community. However, I think most people end up just using case statements after getting used to it. A few counter-points (sorry, this got a bit long but it's a topic that always comes up in redux so I wanted to be complete):
1. Using separate functions encourages doing more work in a single reducer. A reducer shouldn't get too big, and if it does should be broken into subreducers. The breakpoint and sources reducers are about as big as they should be, which is ~110 lines. The case statements are very easy to manage at that level, it's not really a large function.
2. It is not the same as a large functions scattered across the codebase. The core design of redux works this way and handling multiple actions in a function is good, not a bad design.
3. Separating out functions makes it visually indistinguishable from actions. It's nice to clearly see that you're working in a reducer. You end up having two `addBreakpoint` functions, one action and one reducer. If we do this, we need to use something like tofino's `set` prefix for all the functions for clarity.
4. We definitely want action types to use THIS_FORMAT, but your followup comment points out another technique that still keeps this.
5. By the time you use something like `createReducer`, I think there's more syntax than a simple switch statements, and I'm not sure I see the benefit.
6. You _never_ want to test individual reducer handlers. Always just pass state into the reducer itself.
7. The only reason tofino has those functions in that file is because they are called many times by different parts of the reducer. We do the same thing with `updateText` and other helper functions in the sources reducer. So the pattern is that you pull out things that need to be used in multiple places; tofino just happens to need to do anything else in that reducer.
8. In my opinion, what's more important is what the console is doing, and they use raw switch statements:

https://github.com/devtools-html/gecko-dev/blob/a09e19c97e761b4cf69be92e9ebc40cd6aa8be4d/devtools/client/webconsole/new-console-output/reducers/messages.js

https://github.com/devtools-html/gecko-dev/blob/a09e19c97e761b4cf69be92e9ebc40cd6aa8be4d/devtools/client/webconsole/new-console-output/reducers/filters.js

Especially with smaller reducers with many action types, I think the `switch` statement is a clear winner. We could probably clean up/break up the sources & breakpoints reducer a bit because some of the case handlers are a little large. But I don't want to enforce moving all of the code out of switch statements.

Most importantly, I don't want to merge anything that only changes one reducer. If we do anything, it needs to be done to all reducers at once. We already have other things that are half-implemented, and I don't want more inconsistency within the code.

Let's hold off on this until after the dust settles for turning on the debugger. I'd like to focus on that for the next few days.

I would take this section out and show it as a note / quote below this paragraph:

> The project is being tested currently in Firefox Nightly and is available in the DevTools debugger tab when the preference `devtools.debugger.new-debugger-frontend` is enabled. 

It might also make sense to have another separate doc just for the "How to enable on Nightly" which we can link to for full instructions and delete once it is on by default.

How about this?

debugger.html : react / redux overview

I think you can link to it with a relative directory `(../public/js/components)`:

Each componentâ€™s source code is located under the [public/js/components](../public/js/components) folder.

Awesome!  Can you also link to the [CONTRIBUTING.md](../CONTRIBUTING.md#writing-documentation-book) file and section on docs here?

It might be nice to have a TOC
- Architecture
- Components
  - Editor
  - File Search
- Reducers
  - Pause

...

This is amazing!  And I love all the links for editing! ðŸ‘ 

What do you mean by "Component Presentation"? Would "Components" work?

I'd like to see if we can avoid screenshots.

Do you think we could have a markdown table for the fields, types, descriptions?

Also, maybe include an example data structure so for the case of a Frame - that is vague, but an example might make it clear. 

Yes. I just titled it that because they are primarily responsible for the UI

Why the stacking of several EditorBreakpoint blocks?

That was Mr Laster's suggestions :)

This is a larger question for the group. Do you think it would help to have these actions in a separate `reducers/docs` directory? The line of thinking is that we probably want to keep specifics closer to their source.

I'm not necessarily convinced but thought i'd bring it up to discuss. 

I can do that.

I was thinking of linking to github for each component. Is that OK?

Are you wanting me to rename it?

will do.

Just need to switch this to using the triple tick format:

``` javascript
const React = require("react");
const { connect } = require("react-redux");
const { bindActionCreators } = require("redux");
.
.
const actions = require("../actions");
.
.
.

module.exports = connect(
state => ({ pauseInfo: getPause(state),
expressions: getExpressions(state) }),
dispatch => bindActionCreators(actions, dispatch)
)(Expressions);
```

go for it!

I was thinking that as well.  Here are my thoughts so far:
- It would be great to have the outline here and link to the individual docs
- I think `docs/reducers/` might be better so we keep it all accessible from the github pages
- We can get this landed as is and then separate out the reducer docs after

> We can get this landed as is and then separate out the reducer

definitely

> I think docs/reducers/ might be better so we keep it all accessible from the github pages

@jlongster what was the documentation tool you were using earlier? do you think it could pull from directory level doc directories?

gitbook. I can't remember if it can do that. I agree that reference docs should be closer to the code it's documenting though. I also think that the action types file should just be the documentation for the actions, and we shouldn't replicate that info here.

Our higher-level docs could just link out to individual places where we keep reference docs, which would just be an .md file inside a folder like `reducers` or even just `action/types.js` itself.

But it doesn't really matter right now, we can land this if it helps for now even if we are going to change it a lot later.

I decided to just link to the Components, Actions, and Reducer directories

I will try to do this in a future iteration. I used these images because I thought most ppl would want want to try the redux tool out.

these are dynamically created components and I wanted it to be clear that you can create many of them.

I'm not sure I see the purpose of evaluating in this test. This doesn't really test anything related to keyboard shortcuts for stepping/resuming or the stepping buttons. This looks like it was ported over from the old test, but I think we can avoid the evaluate and adding the `evaluate` command for now.

Just trying to make the tests a little more focused than they were before.

I think it's more descriptive and simple if you just do:

``` js
const source1 = findSource(dbg, "switching-01.js");
const source2 = findSource(dbg, "switching-02.js");
```

Admittedly, it's not much more descriptive because the script names are just 01 and 02, but it's shorter code anyway. Most tests will only deal with 2 or 3 sources so it's not a big deal to do this for each, and it's easier to debug (you see `source1` and `source2` in scope instead of an array)

I think it is okay to just add the breakpoint

`yield addBreakpoint()`

We're testing breakpoints in more depth in other spots. Also, the test will also be below when you expect to land in a certain spot.

Very cool, thanks for porting this test. Awesome to have this stuff tested.

I think it would be better to expand some of this out into a couple lines

``` js
invokeInTab("firstCall");
yield waitForPaused(dbg);
```

also, i think passing `.button.active` as a full selector is fine

You're passing 2 additional args to `findElement` but looks like the selector is `(button, state) => .${button}.${state}`  ? It only takes 1 additional arg.

I'd prefer if this just tested the key shortcuts and not the buttons

Personally I'd be fine with just doing `addBreakpoint` and not caring if the breakpoint slid or not. We know our test files, so it shouldn't slide. If it's mainly checking that it was successfully set, errors will propagate from `addBreakpoint` anyway. 

> I think it would be better to expand some of this out into a couple lines
> Could you elaborate what you meant here?

Also do you mean this?
`findElement(dbg, "button", ".resume.active")`
and 

```
const selectors = {
  ...,
  button: selector => selector,
};
```

actually, i think it would be better to have more elements like `findElement("resumeButton")`

Why this change? (may have miss the conversation) Is this what the old debugger does? It'd be good to keep the same shortcuts if possible, but there's a good reason that's ok.

Not sure these belong in `selectors`? These selectors are meant to be CSS selectors, and this just seems like a key mapping. You could pull this out into it's own object next to the `pressKey` function.

Yes. The old debugger has `Shift+F11` for `Step Out`. I wrote the code for the keyboard shortcuts.. and I think I chose `F12` by mistake. I will rectify that here.

agreed. This would make sense as a keyMappings dictionary.

I don't think `testKey` is needed.

I'd prefer to invert the sequence. First press the key, and then check the pause location.

I have an `isPaused` function in my test that will be helpful here

nit: I don't think we need the info, we'll see where it's failing with the right assertions

There should be a `yield waitForPaused` here

We should probably check the pause location instead of testing that at somepoint it was resumed:

``` js
assertPauseLocation(dbg, "code-script-switching-01.js", 12)
```

we don't need to test breaking on next here, so we just need to find a way to pause. Honestly, the easiest way might be to use the new `debugger-statements.html` i'm adding and go through the same steps as that test.

that way you don't need breakpoints or break on next

a lot of these helpers are are there in your PR. I'll wait for that to get merged and then work on your comments. ðŸ‘ 

cool. shouldn't be too long

i believe my original test has these comments, but they're probably not necessary any more :)

we should probably rename this to `test-keyboard-shortcuts`

haha.. okay.. I can remove them.. :D

I'm not sure how this will look with the parens

this is how it looks in the old debugger. I just replicated that.

minor nit - the `Key` suffix is not necessary as we're discussing key mappings :)

Looks like the lint doesn't like the trailing zero here.

```
public/js/components/SourceFooter.css
 4:13  âœ–  Unexpected trailing zero(s)   number-no-trailing-zeros
```

Otherwise good to go.

Might be nice to use `doc-scripts.html` which has a few more scripts. Testing with multiple scripts makes sure this isn't a fluke.

I'm sure you're planning on expanding this test, but you could go ahead and navigate back to `doc-scripts.html` and assert that there are 3 sources again.

Do we need this `if` statement? You return the response here, but if you are waiting on sources you'll get a different return value. It'd be nice if this function had a consistent return value, and `waitForSourcesToLoad` will do nothing if you pass it an empty array anyway.

This looks like a good function that we could write unit tests for. 

We don't have a great setup now for writing component unit tests, but it's not terrible either. If you did write them, it would be possible to run them with the `mocha-server` and test passing different props down.

Was this intentional? If so, maybe delete it. 

Also, what are the places where we are still using event listeners? My understanding was that this was something we do in the old debugger as a crutch because not everything was converted to Redux. Can we phase this out?

This is a nice improvement. There are many things I like here:
- we're including the selected line
- using a known type (location)
- no longer copying the full source object.

out of curiosity, why not keep this as one merge? I'm probably missing something :)

Would you want to do `getSelectedSource({ sources: state });`? I notice you do this below

I believe there will be some failing unit tests that test this behavior as well. 

this method should probably be renamed to `getNewSelectedSourceId`

I could see `selectedLocation` being slightly clearer. There are many locations in the editor, breakpoint locations, selected gutter lines, ... I don't feel strongly though

I think you're right. I can use that instead.

`npm run test` runs OK so I'll take a look and make sure all the tests are running.

Unfortunately, `merge` basically calls `toJS` and deeply converts everything to an immutable object. I wanted to avoid more `getIn` calls, because eventually we'll be using Records more thoroughly so we could just use `merge` here but it would still be `selectedLocation.line` elsewhere. So this is temporary until we figure out how to use Records better.

But now that it's implemented, I can look over and see if it's simpler to keep it as immutable.

sorry, i remembered writing some specific tabs tests but it must have been in the sources tests

https://github.com/devtools-html/debugger.html/blob/master/public/js/actions/tests/sources.js#L88-L97

I'm not sure, it was something from the client stuff. I'm not sure what the implications are; I get the desire to make sure that all event listeners are fired, and if one errors it doesn't stop the whole process. Eventually we will need to share this code exactly as it exists on m-c, so we could have a discussion for changing it there. Until then I think I'll just revert this.

I'll try to add a check in the `editor-select` test at least. I think if you are running it in a browser and checking it there, it's not much more work to just add some code to an existing integration test. But we can experiment with that at some point.

yeah, that's true. I believe, @helenvholmes proposed vertical elipsis actually. Can't really remember

yeah - that's totally true. I don't want to commit to writing a new Dropdown component though :) I'd rather find a community one

agreed

fixed

I'm thinking about making this togglePrettyPrint, but doesn't really matter

changed this, because Loading... was staying there. Might be able to change it back when Pretty Print works

had to change this because the source.isPrettyPrinted field changed

true - i'll add a note in the spreadsheet

cool

Yup. just wrote it down quickly for the cases where people _are_ using the tool and might be confused

ahh - yeah, i was thinking something like `togglePrettyPrint(wantPretty)`. but it doesn't matter

sure, i can do that

Sets the config in `feature` so that webpack and other server-side code has access to features. It's a small temporary hack

uses lodash to template. there are other template engines, but this is very simple. Also, used lodash below. Didn't take long to add lodash :)

i'm going to try importing just get so that the bundle does not grow

This is probably the most interesting piece of the PR. 

Previously there was development.json and local.json. Adding firefox-panel.json, lets us have separate configs for the panel or other environments we might support in the future. 

That makes sense

oops

I was thinking we could do something with webpack.production.config to inject config. Although... we could probably do that with webpack.config as well

agreed

converting this custom endpoint to a generic endpoint that handles cross origin http requests

fixing a bug with require not respecting env configs

this will be fixed in the next PR

noticed that the tabs and selectedTab state were not being set when the target was in the query

not sure if we really need this log :)

does the equivalent thing to NODE_ENV ... but wrapped in a convenience function

changed this so that many libraries will work with the production mentality, we might also want a different flag to differentiate between the panel and the standalone app, but for now... should be fine

yeah - i agree.

that makes sense. I'll update this tomorrow to use `DEVTOOLS_PANEL`

It'd be nice to wrap this in a feature flag:

``` js
if (feature.isEnabled("firefox.websocketConnection")) {
}
```

This should have a cli flag like `shouldStart` above

``` js
const useWebsocket = process.argv.indexOf("--websocket") > 0;

if("useWebsocket") {
}
```

This field is currently not used and we should probably just delete it :)

oh nice. sorry, missed that. In that case I think we should have two fields

``` js
firefoxProxyPort: 9000,
firfoxWebsocketPort: 6080
```

and feature flag at that location so the appropriate one is used

hmm, i could see that. I'd like to land this and then we can re-evaluate down the road

re-add `xdescribe` and cypress should pass. 

Is it possible to use commonjs here? or is there something about types that means we need to use import?

Maybe it's because I'm new to this, but `AddBreakpointOpts` seems unhelpful and adds a lot of clutter 

This also seems unhelpful. It might be nice to type the client, but on the other hand I also don't expect it to change much and I appreciate being able to destructure on assignments.

what does `typeof breakpoints` do?

nice

nice

cool

makes sense. 

yea - i should. nice catch

hmm - i'm not sure, i think it might be nice to flag firefox off at somepoint too. Also, the server is a generic endpoint for network requests. this is more that we don't want to enable chrome sometimes.

yeah - that is probably true. At this point I'm happy with using fetch in the browser, but that could be a nice cleanup at somepoint. The challenge is that they have different use cases

agreed - i'm planning on keeping source maps in a cache for that reason, but we will talk about it soon.

actually, we need `selectedTab` for sourcemaps so that we can get the tab url for source maps

nice call.

`isEnabled` would probably be cleaner, but not a big deal.

This is great. Is this transport layer also in M-C? If so, did you change it all to land it here? I'm asking because we have a couple of rules on where M-C code should live?

If it's unchanged: `js/lib/devtools/<path-to-file>`
If it was changed: `js/lib/devtools-sham/<path-to-file>`

If it's not in m-c: `js/client/firefox/websocketTransport.js`

this is changed in a subsequent PR :)

not sure if i follow - the uniqueness comes from the generated id. 

this is moved in a later pr... lets discuss then

> this will leak sourcemaps across navigations (and potentially load wrong sourcemaps if ids are the same across navigations of different sites).

That's a good point. I'll add it to the tracking ticket.

To summarize, we could keep the maps in the store and access the cached consumers/nodes from that.

it'd be nice to update this to load the source map as an action. Then getting the original sources can be done in the utility

``` js
const sourceMap = yield loadSourceMap(source);
const sources = yield loadOriginalSources(sourceMap);
sources.forEach((s) => dispatch(newSource)));
```

I had already changed the source map to a consumer map. Will be easy to store the maps in the store

Really happy with this method. This is the third attempt at mapping generated => original. The first attempt was to add a generatedSourceId to all sources. The second was to create an original source id to generated source id map. This is a simple approach that re-uses the abstractions we already have.  

That makes sense. 

Honestly, I'd be okay doing something like chrome's object id's which are json strings.

id: `{generatedSourceId: "...", originalSourceId: "2"}`

this way it would be a unique identifier, which encodes the relevant field for lookup.

Thanks. This is fine for merging. @jlongster I think we can safely move this to `client/firefox/websocketTransport` if m-c eventually has something we can use we can switch then.

perhaps. but i think our usecase if fairly limited. honestly, i wouldn't be surprised if we improve this later

hmm, was getting a "inconsistent return"

agreed

i'll change this in the upcoming PR

you might be asking why the sources action is now loading the original source instead of the source-map utility. The reason is that, loading the original source requires `getState` and `dispatch`, and i'm trying to keep these dependencies outside of the source-map utility. 

agreed

I believe we need the generated source to get the original source. I'm getting the original source from the source node. I might be mistaken and can read each of the original sources from the consumer...

sure. I might move those into a utility, but i don't want to go back to the situation where the utility requires selectors and there's a circular dependency

agreed

yeah - this is a pure extraction because i could no longer use the ternary. very little to do w/ source maps

I'd like to make space for other loggers to be used.

nice catch

thanks

moved below the helper functions

yup, it was sanity. We can hold off on it for now

This might make more sense as SourceState if it's ever used next to another reducer state

hmm, we can easily update this later

yeah - that's true.

Yeah, that's reasonable unless it's destructured. `{state, update} = require()`. anyways, feel free to merge this as is.

i see. that makes sense.

maybe move this to a blacklist on top... this list will only grow

ðŸ‘ 

haha - we might want to do something like this... i wonder what other protocols we would want to show

nice, thanks!

This might make sense as a README.md next to config. That way we can link to it from here and also other places as well. 

I think if it's in the README we would be more likely to keep this up to date

I believe path is `pathname + search`

nice

Oh nice, we do this with client logging as well. Great pattern

This seems like a nice improvement in another PR. 

`sourcesText` was moved to a field in `source`. This simplified some of the pretty print explorations and afterwards seemed like a cleaner abstraction.

Thanks for the writeup. Also, I apologize for leaving the `sourceText` change in the PR. It was not needed for pretty printing and should have been a separate PR / discussion. I'm going to take it out of this PR and open a second PR where we can have a discussion when you're back.

I think I hear you saying that you want the shape of the store to reflect the protocol data. e.g. separate message "new source", "source text", "loaded object" are separate fields somewhat like tables. One of the main benefits is ease of testing w/ the protocol data and actions. 

Personally, I'd like the shape of the store to be well shaped for the selectors / UI consumers. A couple of observations, we don't know what future clients we will support. It's possible we can overfit for one client and then the store is it's shape because of legacy (read support multiple languages). 

This conversation, prompted me to re-consider one part of your testing exploration. The tests are currently invoking actions like `newSource` with protocol data. The better approach would be to invoke client events with protocol data.  Here are two examples:

current action approach:

``` js
store.dispatch(newSource(fakeSources["backbone.js"]));
```

preferred client event approach:

``` js
const events = require("public/js/clients/firefox/events");
setupEvents({actions: boundActions, threadClient: () => {}});

events.newSource(undefined, fakeSources["backbone.js"]);
```

There are a couple of reasons why I think the client is the right place to mock:

The client transforms the protocol data into a form for the actions/store. 
- Take `newSource` for example, it will set `isPrettyPrinted` to false and ignore some URLs. 
- It's very likely that tests will fail because actions like `newSource` don't expect un-transformed protocol data
- If we start changing the fixture data to be consistent with how the client transforms the data, there could be inconsistencies.

The client is a more natural place to mock commands. When we get to testing commands like `addBreakpoint`, the natural flow involves 
- simulating a UI  `addBreakpoint` call with data that could come from the Editor
- mocking the client, so that the correct protocol response is returned. The good news is that the protocol already involves request/response, so it should be possible to find the correct server response given request data.

Summary (that was a lot of words)
- I'm dropping the sourceText change from this PR (should never have been here)
- I'm opening a second PR w/ the sourceText change. I don't want to drag out the change, but I think it's an important discussion.
- I'm going to add a comment on your testing proposal. This way we can have the right conversations in a focused way.

oops, meant to open a separate PR. completely agree that this makes us inconsistent w/ devtools. I feel like we can diverge in this way as we have `flow` for types, but I don't feel strongly.

flipped the test so that it could be a guard statement and avoid one level of nesting.

extracted this logic.

I dropped these checks because it unecessary and frustrating to wrap in async. if we need them we can bring them back

this is a little awkward, and i'll review later

also a little awkward

at some point it might make sense to move `loadedFrames` into `paused` as they're doing a similar thing

I don't think we want to re-evaluate all of the expressions here. It is probably better to re-evaluate expressions in the pause action.

I think the ID can be created in the `addExpression` action. 

the action.value should never be null. 

I'm not sure i f you want to use an array or a map. I suppose both work here, but it'd be bad if the array became sparse when expressions are removed...

added workerjs for node testing

now that we're building the workers it's possible to require the packages directly instead of importScript.

This was setup so that we could show "loading" messages in the original source mapped locations, but it made the action async and was adding marginal benefits. 

Now, we just show "loading" in the generated source, which is fine

You can move this to a separate `evaluateExpression` action

I'd prefer seeing the ID in the action and keeping the component simpler.

great!

this can be `state.mergeIn` and only merge the value

Immutable has a valueSeq() method, which has a map. 

lets drop "not paused"

This could easily be `state.getIn(["sources", id, "text"])`

It would be nice to have an `evaluateExpression` action, which can be called when an expression is updated. 

this could be multiple `div`s, which will improve styling and make it easier to grab values out of later.

Thanks. Good suggestion. 

Hmm, I think it might be nice to promote the different debugger examples. Let me create a separate issue for this as it's off topic

that will be handled by prefs, which is separate.

this is slightly off topic, but there are two functions `isEnabled` and `getValue`. Currently they're only different because `isEnabled` forces a truthy check. I'd like to change that so, isEnabled is for feature flags and getValue is for config values

This would have the added benefit of changing `isEnabled("features.pokemon-go")`  to `isEnabled("pokemon-go")`

no longer used

minor tweak to make it easier to write cypress tests

That's a good point.

I think this is actually a question of using a selector that only queries for breakpoints at that domain or breakpoints that have a source in the store, which can be difficult.

Previously, breakpoints were shown next to their source, so it was not a problem. 

Here's how chrome handles navigation behavior:
http://g.recordit.co/qqIBsl5IT3.gif

that's a good point.

looks like we need some keyboard shortcuts :)

i wonder if we can use the shortcuts library for this?

This is good for now, but I wonder if we want to keep the selected state through searches

I believe you can use the classNames utility for this
https://github.com/devtools-html/debugger.html/blob/master/public/js/components/Breakpoints.js#L67-L71

yeah, there's a variables.css file

oh interesting - i found the library fairly readable at key-shortcuts, might be worth a quick read. Wouldn't worry too much about it. Although if there's a bug, it's a mozilla library so we can improve it easily

Got it. 

Oh, good point

Nit, but this could be: `renderExpressionContainer`, `renderExpressionUpdating`, `renderExpression`

using ID in this way is a code smell. 

The id could be a data attribute `data-id=expression.value` and accessed easily
Also, the id can be set in the refs property, https://facebook.github.io/react/docs/more-about-refs.html#the-ref-callback-attribute

could the `setTimeout` go away if the focus call were in the right lifecycle method `componentDidUpdate` maybe?

How would the expression have an id if it hasn't been saved before?

I'm a little confused by what's going on here...

One approach would be to have a variable at the top of the module `let expressionId = 1` and then in here do `{ id: expressionId++ }`

yeah, that's a good point.

do you still need this?

do you need the dataId anymore?

I think it's more idiomatic to do `(e) => this.addExpression(e, expression)`

Also, if this is a keypress handler, the function should be `this.inputKeyPress`

nit: it can be nicer to use a guard statement. it avoids the extra nesting and implies your looking to limit the input to the function early on.

https://en.wikipedia.org/wiki/Guard_(computer_science)

``` js
if (e.key !== "Enter") { 
  return
}
```

@jlongster I'm not sure where the regression is, but I'm seeing this:

![screen shot 2016-08-08 at 3 01 14 pm](https://cloud.githubusercontent.com/assets/254562/17492234/e35661f6-5d78-11e6-8f7b-a1835422fe2e.png)

I'm surprised there isn't an URL associated with the source

why not just do `return value.result` :)

this can be simplified to use Rep if it's an object or exception, otherwise return value.result

one minute. let me remove it

this should probably go in `node-unit-tests`

I think this test case can be replaced with `test/examples/increment`

`restartWorker` should probably be moved to node-unit-tests. 

I believe it is only needed for testing. In this case, node-unit-tests could have a global afterEach handler that terminates the workers. This is possible because `node-unit-tests` already has a reference to the workers from the Worker constructor.

I'd like the debugger test cases to all be hosted so that a user could go to them. Somewhat like mochitests examples as well. 

I think there's a real benefit for contributors to be able to quickly load a test example and see how it works.

> re: never changing

I don't see the examples changing too much, but if they do then I think it is okay to update the tests that are coupled.

One thing to keep in mind is that it's important to be able to run the unit tests in the browser for devtools debugging. So, please try and make sure that the new tests can run with `npm run mocha-server`. I'm now wishing karma worked :/

Yeah, i have mixed feelings about opening it by default. I added that to the list because it was discussed when we released autocomplete:

https://github.com/devtools-html/debugger.html/issues/338

I personally would be happy to keep it closed by default.

This is the biggest question mark. 

While testing I ran into several places where a source was expected, but wasn't  in the store. e.g. Select source. This changes adds sources to the store, but hides them from store

> CI: printing full logs

That's a good point

> what's your workflow

I like to be able to scroll the log in question. For example, if i'm looking at the source that's selected when the debugger pauses, I want to scroll to the pause event, and then go to the next select source action. This might be the 10th action and the pause action is so large that it can be tough to find. 

Ideally, this wouldn't be as much of a question because there would be a better redux action log :/

Thanks for the detailed answer, this helps provide some clarity.

I have a test for "break on next", where the debuggee pauses on a debugger eval. Another example would be a console evaluation that has a debugger statement in it. In both cases, the debuggee is paused and the debugger wants to show the debugger eval source, source tab, and call stack. 

> Your changes here would ignore valid eval-based sources that are given a URL with the sourceURL pragma

I have a new `evaluations` test that hopefully will catch these changes as well so we can lock down the right behavior.

haha - i said a better log... :) The extension has lots of UX issues :P 

> stringified version to 1000 chars or something

I think that's a good option

That makes a lot of sense.

@jlongster, tomorrow is Jaideep's last day. I'd be happy to file an m-c PR next week after this lands. 

Small nit, but I think these methods could move to the prototype:

``` js
stepOver() {
  if (!this.props.pause) {
    return;
  }
  this.props.command({ type: "stepOver" })
}
```

Yeah, i actually borrowed this approach from the mochitest examples, i'm happy doing it either way...

Hm, that's really interesting: 

here's how i got here:

``` patch
diff --git a/public/js/test/integration/todomvc.js b/public/js/test/integration/todomvc.js
index a7e1f40..2e10845 100644
--- a/public/js/test/integration/todomvc.js
+++ b/public/js/test/integration/todomvc.js
@@ -102,7 +102,7 @@ describe("Todo MVC", function() {
    * * pausing on an uncaught expression
    * * reloading while paused and resuming execution
    */
-  it("(Firefox) exception", function() {
+  it.only("(Firefox) exception", function() {
     debugPage("exceptions.html");
     resume();
     scopeAtIndex(0).click();
@@ -111,6 +111,7 @@ describe("Todo MVC", function() {
     resume();
     stepOver();
     stepOver();
+    cy.pause();
     scopeAtIndex(0).click();
     scopeAtIndex(1).contains("unreachable")
```

![screen shot 2016-08-12 at 11 33 14 am](https://cloud.githubusercontent.com/assets/254562/17627790/7c572782-6080-11e6-8f7e-c84f10bbdd45.png)

oh sorry, was giving you steps so that you could run it. I pinged you separately on irc to see what you were doing. But yea, thats definitely the issue. I'll make sure both cases are checked.

haha - buggy, i hope you don't mean flakey. :P I hate flakey

Sounds good, mind adding it to the `README` in the same directory

If calling both works, then I think this is fine for now :) 

I don't want to over think it for now

do you think this is the best way to destructure the variable?
I chose to use `for of` over `forEach` as it seemed simpler with the async

these actions used to be called through `command`, but calling them directly makes the code more readable/understandable.

checking the first value is a simple way to see if there _is_ a value in the list

moving selectors into the reducer

oops, didn't mean to leave this in

Yea, I agree. If anything, I'd prefer if it were `renderAccordion` and then was grouped there. 

Could you comment out or include the png urls?

https://dxr.mozilla.org/mozilla-central/source/devtools/client/themes/light-theme.css#267

This way we'll either have them or be able to add them later

nice cleanup

does it make sense to make this `1.2em`?

what does this do? It seems weird that there's `var devtoolsRequire`

If you think there will be other editor utils that are not shared, it might be nice to bring back `utils/editor.js`

Does it make sense to always do? `process.env.NODE_ENV === "development"`?

I think the canonical way to do it is to introduce a `setInterval` that checks for something and then carries out an action. So we could check the progress element for 100%, and then get the report. Honestly, I'd rather not do that work now as it's also somewhat painful to write and I'd rather bump this to 30 seconds if we need to at some point. 5 seconds is already 5x longer than it takes ðŸ˜‰  If it fails, it'll be because a test stalls and we need to bail anyways. 

That's a good point. I change this to a selector, `hasOriginalSources`. 

ahh. makes sense

yeah, agreed

good point

it's hard to see here, but adding the individual step functions cleaned up this function quite a bit.

As a general UX note, i think it would be nice if this were a toggle. The benefit would be that the user could disable this option once it is set.

the wait on next expression button

The issue here is a frustrating lifecycle issue with react. The child event is first and so keyShortcuts is not setup yet.

this helped me test these cases manually

This is an interesting case. The frame locations have undefiend columns,
which is not sufficient for finding the original location in some cases like `bar()`, which would need column to be 2.

``` js
bar = function() {
var x = 7;
debugger; }
 bar();
```

using `getURL` broke down with `SOURCE:formatted`. `getURL` thought source was a host because of the colon. The easy fix was to not use getURL because we don't need paths for this

I think context will likely be the better solution for `keyShortcuts`. checking the existence of keyShortcuts would allow many handlers to be bound.

I'm going to merge this as this does not seem like a blocker, but an improvement. Happy to update in a separate issue. 

Hmm... if you click the pause/resume button while the debugger is not paused, it will tell the server to pause on the next expression.

small nit, but I would prefer this syntax for decorated function. 
- keeps the class functions on the same level
- avoids unnecessary indentation

``` js
componentDidMount() {},

queueUpdate: throttle(function() {
}),
```

Lodash uses `throttle` slightly differently https://lodash.com/docs#throttle

Do you think we could call this `delay`, `queue`, `defer`, or `batch`

small nit:

``` js
if (timeout) {
  return
}
```

hmm, i can look into this, but I think the issue here is that we want to show _most_ original sources.

oh interesting. I can see that point of view.

Sorry, my definition of throttle was wrong. I was thinking that debounce and throttle were similar, except throttle would be called immediately and then would _debounce_ push back the execution.

Here's a good [article](https://css-tricks.com/debouncing-throttling-explained-examples/) that was linked.

can we move this to a script:

`docker run -it ./bin/run-mochitest`

while working on this patch i noticed that `will-navigate` fires twice for debuggee refreshes. This is because `frame-update` fires for a will navigate event when the page is paused. I removed this event because i believe it is redundant now.

moves the selected source to pending, which will trigger a re-select

immutable's api is certainly more verbose

I plan on switching this to just a flatten call (probably lodash)

i'll drop this check and make sure vars is always an array

what was the reason we used state here? could we have changed Scopes to use `componentShouldUpdate`

that's a good point

we also need to update the tests to now search any scope for the error because we can't assume it's the first scope property.

hmm - strange, i saw it firing when the page was not paused. This change only makes sense if that's the case, otherwise we won't clear the debugger when the debuggee is refreshed in most cases.

I'm not sure either, I think we probably do... 

Lets take a look at the tests and see if everything makes sense
https://dxr.mozilla.org/mozilla-central/source/devtools/client/shared/components/test/mochitest/test_reps_object.html#83

Hmm, whats the default behavior if undefined is passed in?

based on the tests tiny looks fine. @linclark thoughts?

ðŸ‘ 

It'd probably be more efficient to map and then filter with the identity function. That avoids doing the work twice

Pending source is not needed now that selected source is selected source URL

Sure. The map would return an object or null. Filter would remove the
undefined.

> Tab target URL

I think that's a good idea, but I'm not sure where it belongs. The
advantage is that we can always see which is the current debuggee URL

On Sun, Aug 28, 2016 at 5:56 PM Jaideep Bhoosreddy notifications@github.com
wrote:

> In public/js/reducers/sources.js
> https://github.com/devtools-html/debugger.html/pull/603#discussion_r76539975
> :
> 
> > @@ -224,15 +215,15 @@ function getSourceText(state: OuterState, id: string) {
> >  }
> > 
> >  function getSourceTabs(state: OuterState) {
> > -  return state.sources.tabs;
> > -  const tabs = state.sources.tabs;
> > -  return tabs
> > -    .filter(url => getSourceByURL(state, url))
> > -    .map(url => getSourceByURL(state, url));
> 
> could you briefly tell me what would be the effect of adding a filter with
> an identity function to the result of map?
> 
> â€”
> You are receiving this because you were mentioned.
> Reply to this email directly, view it on GitHub
> https://github.com/devtools-html/debugger.html/pull/603/files/2879e218ebefe6b97861876a62646467a1bbbb1f#r76539975,
> or mute the thread
> https://github.com/notifications/unsubscribe-auth/AAPiYtnxKUjsdNlpZfjvHZYs0gXQFWfsks5qkgPxgaJpZM4Juo30
> .

Hmm, we should have something like navigate for chrome.
On Sun, Aug 28, 2016 at 6:06 PM Jaideep Bhoosreddy notifications@github.com
wrote:

> In public/js/reducers/sources.js
> https://github.com/devtools-html/debugger.html/pull/603#discussion_r76540123
> :
> 
> > @@ -224,15 +215,15 @@ function getSourceText(state: OuterState, id: string) {
> >  }
> > 
> >  function getSourceTabs(state: OuterState) {
> > -  return state.sources.tabs;
> > -  const tabs = state.sources.tabs;
> > -  return tabs
> > -    .filter(url => getSourceByURL(state, url))
> > -    .map(url => getSourceByURL(state, url));
> 
> I took "url" from the navigate/will-navigate event payload from the
> tabTarget. But more importantly, this would only work for Firefox. I'll
> look to see if I can do something for chrome.
> 
> â€”
> You are receiving this because you were mentioned.
> Reply to this email directly, view it on GitHub
> https://github.com/devtools-html/debugger.html/pull/603/files/2879e218ebefe6b97861876a62646467a1bbbb1f#r76540123,
> or mute the thread
> https://github.com/notifications/unsubscribe-auth/AAPiYhNVT_zyaNxixxhD_6nzz-sLcSQCks5qkgZrgaJpZM4Juo30
> .

I think is probably better to make the `navigate` action meaningful than to change to `willNavigate`

if `willNavigate` fires the `navigate` action type we should change that to will-navigate and then fire navigate separately

this seems like a lot of code to support the case where `will-navigate` is fired from the other events.

`url` should probably be more descriptive, like `tabUrl` although that might make less sense for node.

Where is `url` used now?

Also, i don't think that `url` should be set in `sources`. It probably makes sense in a debuggee reducer as at somepoint we might be debugging a worker URL as well and perhaps other things so there would be different debuggee data. 

@jlongster what do you think?

@jbhoosreddy `cy.navigate` should do that for you : https://github.com/devtools-html/debugger.html/blob/master/public/js/test/cypress/commands.js#L42-L48

> `targetUrl` 

sounds good for me. 

> I am using url to check if the new target url is same as the old one, and based on that returning state or new State() 

Why does this matter if you're just persisting tabs? If you're trying to hide tabs that are no longer available, you could probably do it the way I'm doing it with breakpoints and hide the ones that don't have corresponding sources. 

Oh nice. I bet this lets you see `<this>` for any selected frame. 

Nit: I'd prefer if we got the `pausedScopeActor`at the top of `getScopes` and used it below:

``` js
if (scope.actor === pausedScopeActor) {
}
```

ðŸ‘ 

NIT: I would prefer returning null or the obj

``` js
if (!this_) {
  return null
}

```

and then below doing

``` js
if (this_) {
vars.push(this_)
}
```

this is more code, but it seems better to met that the function not return an array of 0 or 1 things

Thanks @wldcordeiro. I'm okay moving forward with this and adjusting if we need to.

ðŸ‘ 

ðŸ‘ 

yeah - i don't think we need that property :)

It might be nice to have a TOC
- Architecture
- Components
  - Editor
  - File Search
- Reducers
  - Pause

...

What do you mean by "Component Presentation"? Would "Components" work?

I'd like to see if we can avoid screenshots.

Do you think we could have a markdown table for the fields, types, descriptions?

Also, maybe include an example data structure so for the case of a Frame - that is vague, but an example might make it clear. 

This is a larger question for the group. Do you think it would help to have these actions in a separate `reducers/docs` directory? The line of thinking is that we probably want to keep specifics closer to their source.

I'm not necessarily convinced but thought i'd bring it up to discuss. 

go for it!

> We can get this landed as is and then separate out the reducer

definitely

> I think docs/reducers/ might be better so we keep it all accessible from the github pages

@jlongster what was the documentation tool you were using earlier? do you think it could pull from directory level doc directories?

I'd switch this and use the library directly where it is called. 

looks like this file is duplicated

looks like this test is also duplicated.

did you any chance make a second mochitest dir :)

what does this do?

i changed this version slightly to pass `store, actions, selectors` instead of `getState` and `selectors`

hmm, i donâ€™t see this on master.

Are you sure this is not an old PR?

On Thu, Sep 1, 2016 at 12:39 PM James Long notifications@github.com wrote:

> In public/js/main.js
> https://github.com/devtools-html/debugger.html/pull/651#discussion_r77178235
> :
> 
> > @@ -92,13 +93,14 @@ if (connTarget) {
> >    });
> >  } else if (isFirefoxPanel()) {
> >    // The toolbox already provides the tab to debug.
> > -  module.exports = {
> > -    setThreadClient: firefox.setThreadClient,
> > -    setTabTarget: firefox.setTabTarget,
> > -    initPage: firefox.initPage,
> > -    getActions: () => actions,
> > -    renderApp: () => renderRoot(App)
> > -  };
> > -  function bootstrap({ threadClient, tabTarget }, callback) {
> 
> I don't think we need the callback argument?
> 
> â€”
> You are receiving this because you authored the thread.
> Reply to this email directly, view it on GitHub
> https://github.com/devtools-html/debugger.html/pull/651/files/4811709861b1663416c5d938cb44446b8881c5a6#r77178235,
> or mute the thread
> https://github.com/notifications/unsubscribe-auth/AAPiYpuZnbxStn1VTXuf4WhsrWapBhJVks5qltmngaJpZM4JyHNV
> .

I think it is good to keep the API similar to what the components call, that way we exercise the same behavior. We can't guarantee it's the same, but it's probably good to try.

The `addBreakpoint` command I setup assumes it's the selected source and passes along the `getTextForLine` param for that reason. 

``` js
function addBreakpoint(line, { source } = {}) {
  source = source || selectors.getSelectedSource();
  return actions.addBreakpoint({
    sourceId: source.get("id"),
    line
  }, {
    getTextForLine: l => debuggerWindow.cm.getLine(l - 1).trim()
  });
}
```

If we want to pass along a source that is not the selected source, I'd propose that this action first selects that source and then adds the breakpoint. This will keep our tests behaving the same way our app does and keep us from getting into weird states.

``` js
function addBreakpoint(line, { source } = {}) {
  if (source.get("url") != selectors.getSelectedSource().get("url")) {
    selectSource(source);
  }

  source = source || selectors.getSelectedSource();
  return actions.addBreakpoint({
    sourceId: source.get("id"),
    line
  }, {
    getTextForLine: l => debuggerWindow.cm.getLine(l - 1).trim()
  });
}
```

One anti-goal is pausing in a test and the debugger looks broken. An example of this is the breakpoint list not having text and not seeing the breakpoint which was just added.

not actionable now, but i would love it if the debugger server passed a `loaded` event after the sources are in and it's ready. Maybe it's hard to know...

should this be `-theme-faded-tab-color`?

would it be possible to commit these changes to gecko as well so the changes are consistent.

Why did the welcome box have to move into the editor?
Couldn't it still be rendered next to the search box?

Thanks, I'd be happy to add an empty center header later for consistency.

My concern is that this introduces bloat to the Editor. I'd like to keep the keep the editor focused on the source.

Is this something we can move to the Editor module? 

Or are we doing it this way to be consistent with the other Editor module? If that's the case, could we move util methods like this to the top of the class so that they are not confused with editor pause/breakpoint logic? 

could we do the same thing with the `defineGlobal`? I'd prefer not introducing a new system just for this

this is a nit, but would waiting for the "RESUMED" dispatch be similar, but apply for both adding and removing breakpoints.

I bring this up because I like the patten of yielding for async actions. This is a small detail though.

do we want to try removing a slid breakpoint below?

does it make sense to add other assertions after each step

it's strange to me that you would want some and not `all`

This might be nice as a separate helper

`return waitForSourcesToLoad(sources)`

nit: It would be nice to extract these methods into small helper functions:
`getCodeMirrorEl(dbg)` `getCodeMirrorLineEls(dbg)`. 

I'm mentioning this because it is nice to wrap dom selectors with business object functions whose api is more clear from the tests.

> see webpack.config.devtools.js changes

ahh, I see what you mean. 

I think you could also add an `isTesting` method in `feature` alongside `isDevelopment`. 

I trust your judgement though. 

>  sure we'll always want to emit a resumed event after setting a breakpoint

that's a good point.

Now that I think a bit about it more, the util methods before were mostly around codemirror functionality like alignLine middle and less around reading state like source text. 

I'm sensitive to letting a component do to much and Editor, but this makes sense. 

oops, was looking above and saw the `...sources`

I pulled in this example from the previous tests, but i'd be happy to use `code-simple` and add a breakpoint to pause

I'd like to start documenting our test examples from the start from the beginning. It is really easy to add more and more examples when there is a perfectly good one already. 

For example, doing this I realized event-listeners isn't used

yeah - i've used this pattern a lot in other projects and is both concise and descriptive. I was struggling with differentiating UI and state methods like `getFrame`and I think this helps with that as well.

ha - yeah the `-` and `_` bothered me too. I left it in as i was just removing the code switching example.

I'd like to try keeping the readme up to date if that's okay. With tests it helps me to have a global spec i can see after each run to understand what's being covered. We don't really have that for the examples and it might be nice to skim the list to have a sense. I hate reading one example and then looking at another and trying to keep it all in my head. I can see this getting out of date if we don't remember it, so i'd be happy to abandon the experiment in a week if it doesn't work for us

cool

oh nice

cool

That's a good point - happy to add it to the API and also add some of the newer methods like clickElement, findelement...

I think it is okay to just add the breakpoint

`yield addBreakpoint()`

We're testing breakpoints in more depth in other spots. Also, the test will also be below when you expect to land in a certain spot.

I think it would be better to expand some of this out into a couple lines

``` js
invokeInTab("firstCall");
yield waitForPaused(dbg);
```

also, i think passing `.button.active` as a full selector is fine

I'd prefer if this just tested the key shortcuts and not the buttons

thought about it a bit more and decided adding the command to the api section was fine

actually, i think it would be better to have more elements like `findElement("resumeButton")`

this might be the most controversial change in the PR.

This came up because i needed to add a reload action, which is triggering a navigation. The pattern setup in the pause actions is that we use present tense for client actions and past tense for server actions e.g. (pause, paused).

i'll change this once the cleanup lands

agreed. This would make sense as a keyMappings dictionary.

I don't think `testKey` is needed.

I'd prefer to invert the sequence. First press the key, and then check the pause location.

I have an `isPaused` function in my test that will be helpful here

nit: I don't think we need the info, we'll see where it's failing with the right assertions

There should be a `yield waitForPaused` here

We should probably check the pause location instead of testing that at somepoint it was resumed:

``` js
assertPauseLocation(dbg, "code-script-switching-01.js", 12)
```

we don't need to test breaking on next here, so we just need to find a way to pause. Honestly, the easiest way might be to use the new `debugger-statements.html` i'm adding and go through the same steps as that test.

that way you don't need breakpoints or break on next

I believe that matches `clients/firefox` unfortunately

yeah - that works for me

oops. didn't mean to add this

cool. shouldn't be too long

no problem. I had a similar thought as well. _was on the fence_

that makes sens

hmm, i think it might be better to add a `stopWorker` method which we can call when we end the tests. We will likely work on source maps next sprint and need this then.

``` diff
diff --git a/public/js/utils/source-map.js b/public/js/utils/source-map.js
index cf3760f..a6b31d7 100644
--- a/public/js/utils/source-map.js
+++ b/public/js/utils/source-map.js
@@ -8,13 +8,18 @@ const { isEnabled, getValue } = require("../feature");

 let sourceMapWorker;
 function restartWorker() {
-  if (sourceMapWorker) {
-    sourceMapWorker.terminate();
-  }
+  stopWorker();
   sourceMapWorker = new Worker(
     getValue("baseWorkerURL") + "source-map-worker.js"
   );
 }
+
+function stopWorker() {
+  if (sourceMapWorker) {
+    sourceMapWorker.terminate();
+  }
+}
+
 restartWorker();

 const sourceMapTask = function(method) {
@@ -148,5 +153,6 @@ module.exports = {
   getGeneratedSourceId,
   createSourceMap,
   clearData,
-  restartWorker
+  restartWorker,
+  stopWorker
 };
```

oops

at some point this should be in the flow types, but we'll get there

this feels like some duplication, but it is probably okay

yeah - lets just do the non obvious ones 

>  It makes me sad to see our nice and clean types have these comments :(

felt the same way!

I once ran into the number two on a line by itself. 

Kill it. 

I actually quite like this pattern for a couple of reasons:
- it enumerates the supported handlers in a more succinct fashion than the case statement
- makes it possible to invoke a single handler for testing (maybe useful)
- avoids the smell of one large function
- makes it easy to document each function separately

I'm not a big fan of the name `setupReducer`. There are some libraries out there that do this,  but this seemed simple enough for our purposes

Nope. Guess I could

i believe my original test has these comments, but they're probably not necessary any more :)

we should probably rename this to `test-keyboard-shortcuts`

I'm not sure how this will look with the parens

After thinking about it for a couple of days, I'm on the fence between two approaches:
1. the delegator factory

``` js
setupReducer(initialState, { addTabs, selectTab });
```
1. an update function with separate handlers

``` js
function update(state=InitialState, action)
  switch (action.type) {
    case constants.ADD_TABS:
      return addTab(state, action);
     default:
       return state
  }
```

This second pattern is what [tofino](https://github.com/mozilla/tofino/blob/master/app/ui/browser-modern/reducers/ui.js#L19-L51) does. Benefits:
- similar benefits with helper functions (documentation, easier to test, ...)
- more familiar to a larger audience that is used to the the `update/case statement` redux style
- it's easy to have many action types map to the same helper

As this is a style question, I'd prefer something that is comfortable to a larger audience (option 2) unless we believe enough people would recognize/understand option 1.  I've personally seen a couple projects use option 1, but I don't have a good feeling for how widely adopted it is.

Lastly, after a little bit of research I found that the redux docs have this helper function [createReducers](https://github.com/reactjs/redux/blob/master/docs/recipes/ReducingBoilerplate.md#generating-reducers) under a section of reducing boilerplate. Given that this is widely documented, I'd opt for using it.

this is needed to let the escape keydown bubble up to the document

This looks like a good function that we could write unit tests for. 

We don't have a great setup now for writing component unit tests, but it's not terrible either. If you did write them, it would be possible to run them with the `mocha-server` and test passing different props down.

Was this intentional? If so, maybe delete it. 

Also, what are the places where we are still using event listeners? My understanding was that this was something we do in the old debugger as a crutch because not everything was converted to Redux. Can we phase this out?

I don't think we should be depending on the toolbox to do all of this. I'd like to see it more as a library than a framework. Just give me the pieces to connect, and I'll hook them up to my app. It's not uncommon that we want to tweak things in here and we can't do that if this is shared across everyone.

I think it's very enlightening to just open up an app's `main.js` and see a very straight-forward way of how things are hooked up. If we bury this, it gets harder for beginners to understand what's going on (and even advanced users who want to hack up something quickly to change it).

For example, I frequently go into `main.js` and flip `log: true` in the store configuration to log actions. Why don't I change the config? It's just easier for me to open `main.js` (config is at the root) and more importantly I don't have to restart the server.

I think this could export reducers/actions/components that someone can embed in their app. Or at least make the toolbox have its own render and redux store, and do everything it needs to if we don't have a target. But in our `main.js`, if we have a target, call into the toolbox to connect it, but let us do our own rendering/store creation.

Do whatever you feel like for now, this is a big change so we can move things back. I'm not going to block it.

I see that we still are creating our own store, so that's good. I thought that this code had been copied over too.

This is where I'd probably be a little frustrated if I was trying to learn this project; compare the above code to this and it's a lot less clear what's going on. There is a place for abstractions though, so I could be wrong. I just feel like having code that reads like "if they need to select a target, render the toolbox, otherwise we have a target so connect it and render our app" would be nice.

Similar argument here; trying to figure out how various things like hot reloading or how we're transforming JavaScript would be more difficult to figure out. I think the toolbox should be more isolated and we should still have this webpack code. It would be nice to share though, too, so maybe you're right to move it out.

yup - on it.

yup, julian and I discussed this. This API is not helpful at the moment, just glue to get it working

Yeah - It's certainly a balance. The development environment is very helpful. I like the idea of a base config so that the tools are cohesive, but that's not fully figured out yet.

ðŸ‘ for sane webpack defaults that we don't have to re-think on each tool.

Yeah, you all are right, we should definitely share it. I'd just like to make sure we do it in a way that's easy to extend, and it's clear where the base config is coming from. I think we're on the same page.

this is a temporary hack. will move it back now that debugger is on the top level

this will move back to the top level

this can be replaced with a new entrypoint

Yup. I dislike this API too. I'd be happy to brainstorm better APIs that line up w/ the inspector's goals and ours

this should be cleaned up

this should be shared soon

should be able to kill this

should be able to share soon

I think this should be able to be killed ... 

:/ not sure how this worked before

I copied this into the debugger.html components dir because the requires didn't work... we can debug this now or later... 

this can be cleaned up

moved to the Root.js component, but that can be figured out later with the second phase where come up with the right API

nevermind, the types need to be here because the client is in the toolbox!

never mind, the tabs reducer uses this...

could this be `let prettyPrintWorker = new Worker(`

i like that this module cleans up the actions, as well as is consistent with source map

Yep, that was leftover from the ability to restart it (which we don't need here, it doesn't keep any internal state)

@jlongster I wasn't sure why the action type confused by `shouldDisableBreakpoints`, so i moved the function out and had it accept `any` for action. I'm curious if you have a fix here.

That is weird indeed. Unfortunately I don't see why the type inference doesn't work here ðŸ˜ž 

Where is the error? We really shouldn't digress on type coverage. It's already very poor.

I don't think we should automatically install something globally on someone's machine. I think it'd be better to display a message telling the user to do `npm install -g jasonlaster/lerna`, particularly since this is a fork. I'm pretty they already have it installed this will overwrite the previous one.

nit: no need for a comma, just "This feature will..."

hmm, true. maybe it would be fine if it were installed locally

nit: I think the var name could be improved. It's not referencing a JS object, which the name implies.

Please don't use the term "sources" in a generic that is not tied to sources at all. If this is supposed to be a generic dropdown component, just use generic terms.

The dropdown component should have its own CSS file.

we likely can replace the react rendering with a simple vanilla approach, but on the other hand this _does_ work.

unnecessary whitespace

we likely can clean this up with some destructuring

also, setCondition does not return `actualCondition`, but that is likely okay because you're just editing the bp.

We probably should replace the Errors with `assert` functions

should remove this

I don't think we need to put this behind a flag. Let's just land features and make sure they work from the start. If there are major bugs I think we should fix in the the first PR. But I doubt there are major bugs, there might just be UX improvements we can do. That's the point of landing in nightly though; we have time until uplift to tweak it to get it great.

There no assertions here though; it should always just throw an error. `assert` may evolve in the future to only happen in dev or somethings. But this should always through.

Yeah, go ahead and remove these comments

You should probably remove the old breakpoint client from `bpClients` here before we add a new one.

Also, can you rename `res` to `bpClient` or something to make it clear that it's just the breakpoint client?

Nit: this is very confusing indention. Please do something like this instead:

``` js
ReactDOM.render(
  dom.div(
    { className: "conditional-breakpoint-panel" },
    dom.div(
      { className: "header" },
      `This breakpoint will stop execution only
       if the following expression is true`
    ),
    dom.input({
      defaultValue: condition,
      onKeyPress: (e) => onKey(e),
    })
  ),
  panel
);
```

nit: no parens around single arg arrow functions

we can do better and just do `onKeyPress: onKey` :P

Returning null is nicer as it's easier to work around in CSS than invisible divs.

To make codemirror not break with flexbox you need to make its grandparent have an absolute position. 

Changing the editor height and order is necessary when showing the searchbar.

don't grow, shrink and set your basis to 30px.

These heights were found to be just enough to avoid extra scrollbars and allow for the editor to appear full height since it doesn't work quite right with `100%` and flexbox.

Moving the tabs into the editor makes them all part of the same layout flow which makes flexbox easier to layout as otherwise we have two different layouts that work nearly identically. ðŸ™ Still looking to see if it's avoidable. Also made the `active tab` no longer look like it's part of the editor document unfortunately so I'm still experimenting.

No longer true, I was able to move it back once I got a chance to rework the layout and figure out the weirdness.

Correction on the basis. Set it to auto, otherwise we don't get the nice active tab is borderless on the bottom effect.

ðŸ‘ 

what does this number mean?

got it

vh is the viewport height so 87 is 87% of the viewport. We adjust the height when the search-bar is present to avoid adding a scrollbar and pushing the source-footer down.

Please help me with the changes

@rheesn What? This is PR I'm working on I'm not sure what you're talking about. If you're interested in helping out go to the issues page and find one that has the `up-for-grabs` label and doesn't have an assignee.

fixes an issue where `npm run mochitest-watch" was placing the build in _devtools-local-toolbox/firefox_

One challenge is knowing whether toggling a node will trigger an object load. For the time being this is something the tester has to add, which I think is fine. At some point it might be nice to call `loadObjectProperties` all the time and return properties when they exist in the store. This way the tests could be a little more certain. 

Hm, at an initial glance this looks wrong because we're changing the id but it looks like `id` (which is the key we use in the state) is the old id. But I think this is right because `id` is not the actor id, it's generated from the location. I don't know if there's any way to make this clearer without making it too noisy. I guess it's fine, because if we changed what we called the `id` variable we should change it in all the other places in this file.

Anyway, I thought there might be a side effect of changing the actor id but I can't think of any bugs with this. Perhaps at least a comment explaining why this is needed?

I think actions should only fire when they hit the server. It gives them a lot more meaning, and when you see it in the action log you know exactly what happened. Firing them all the time would lose the ability to read a log and know if it actually hit the server or not.

It also gives tests more fidelity. If you know it should fire that action and hit the server, you wait for it. If it doesn't and loads it locally, the test will fail and it's not behaving as you expect. The difference is meaningful and a failing test will help up know that it's not loading (or is loading) from the server as we would expect.

good point. I'll be in here with a fix for toggle breakpoints and will add something

Hmm, that's a good point, i guess selectors in addition to actions are also a valuable part of the Debugger's _API_

Could be onClick: this.toggleFramesDisplay

we'll likely want to revisit this when we add full project search, but that is a little ways off.

we'll improve the types here when we work on project search

I removed the early support for blackbox in the source footer last week as it was not being used.

running `npm i clearly had some alphabetizing to do`

the `any` here will improve when we have a good description of the store

this was erroring in atom's flow ide

What's the point of creating another file? I don't see why we should be splitting out components into multiple files between `utils` and `components`. It's a lot hard to follow the codebase.

id's should definitely always exist. I'd rather not make things null-compatible; why would be pass in null? If you do `source.id` and it doesn't have an id that's a big problem. (this is also the reason why I don't like lodash. doing this makes bad code be silent)

unfortunately, both the footer and editor need to use this utility. 

true - i'll look into this

I started some work on making this more explicit, but it needs some tidying up... 
https://github.com/devtools-html/debugger.html/compare/master...jasonLaster:flow-support2?expand=1

anyways, it should be viewed independently of this PR.

Why is it pulling in react 15.3.1 now?

oh strange.

yeah, that's interesting. I just looked an it seems like it's installing both 14.7 and 15.3. It installs 15.3 so that flow-coverage-reporter can use it. I believe this is okay.

Also - and this is important
- `node_modules/react/dist/react.js` -> 0.14.7
- `node_modules/flow-coverage-report/node_modules/react/dist/react.js`  => 0.15.3

Yeah, that's how it should work. Thanks for looking into this.

lerna-debug was mentioned twice in this file

The dark theme requires adding a class to the `<html>` element. This patch adds the class to both the html element and the root, which is just a way of being consistent in both cases

I pulled theme-body up to the Root element to be more consistent for other tools that use the toolbox, but I know we'll still want to figureout the toolbox / debugger api.

Is this doable?

``` js
const theme = `./lib/themes/${getValue("theme")}-theme.css`
require(theme);
```

nope. webpack doesn't like expressions and neither do I :)

Cool

I don't think this file has the `// @flow` at the top of it so I don't think flow was looking in here.

yup. exactly. this was copy pasta from the selectors file awhile bak

I don't think this is adding much

I don't really like having two pref systems. Eventually we'll have multiple duplicate prefs and need to do double-checks in lots of places.

I'd much rather go ahead and re-haul our config system to be based on prefs. `isEnabled` is supposed to be the thing that we can call directly without creating these functions.

I don't know what it looks like. Maybe our config system reads from prefs on startup, and also attaches pref observers so it can update the config when it's changed. What do you think?

Thanks for bringing this up. We've talked about incorporating Prefs for a couple of months and it's nice that we're at the point where we can act on it.

I don't think this issue needs to block on re-hauling our config system. We've seen in the past that the config system is surprisingly gnarly and I want to take the time to think it through.

I like the idea of reading Prefs at startup and using `isEnabled` and `getValue`.

We will likely need to keep JSON configs as some of the config values are used for the node scripts. 

Sure, that's fine. Honestly I think it might be good if we eventually just use the `Prefs` API itself. It basically works with json files, as far as I know, we can load in whatever json files locally we want. This way in the Firefox panel feature flags are real prefs, and you can toggle them on and off, which is how we've previously been able to with in the panel.

It would be harder to create new flags, yeah, but I think we should also avoid using feature flags for things that should just sit on a branch and be developed a little more too.

> can load in whatever json

that's a good point. 

> avoid using feature flags for things that should just sit on a branch

we've had this conversation a couple of times, so i'm going to move it to an issue for discussion (out of scope here). It doesn't have to be long lived, but it would be nice to have a couple understood rules of thumb.

i'm guessing this is done to be be an escaped safe url? 

small nit, but it would likely read better if these were flipped:
1. check obvious cases: no map, not enabled
2. check if there's a request, return

another nit. It'd be nicer if this were not inlined:
1. it would be nice for it to receive params as opposed to share state like `generatedSource`
2. why parse this everytime when you can do it once
3. it's easier to get to the meat of the function, which is where the request is made and put in the cache

(the first + third reasons are the main ones)

`installSourceMappings` is somewhat vague. I think the real behavior is somewhat closer to creating a source map given code and mappings

`Promise.resolve` is this here to keep the async API consistency?

ðŸ‘ 

hmm, i could be wrong here, but we might want to handle original sources by just returning the location. I'll have to think about this a bit.

it's great that you're handling this case

lol that we're handling jsm and not js

i'm sure you know this, but `isHiddenSource` is used in many places, which is one of the benefits of having it like that. 

e.g. do we show a source tab

ðŸ‘ 

the magic only becomes more magical. _not a criticism_

ðŸ‘ 

ðŸ‘ 

I believe this is similar to how the old source map worker communicated. Out of curiosity, was the motivation for the IDs the `async` functions in the worker? I believe, the old worker API was internally synchronous.

I wonder if it makes sense to move `privilegedNetworkRequest` to m-c under `devtools/shared`. 
- this module will not be used locally 
- this might be more consistent with other shim modules like Prefs where the panel implementation lives in m-c

I'd like to, the issue I run into is flashing a message that is replaced as soon as the connection is established. It would be nice if we tracked whether a browser was connected, that way the message could read "Chrome is not connected" or something like that.

true, I created a `firstTimeMessage` function which handles a lot of the duplication. The rest is still there as I think there might be more divergence over time.

Switching it to `indexOf` as this is a small nit.

I can see the perspective of minimizing lodash's API to helpful utility methods. With that said, I also think lodash is helpful for smoothing over support for native methods while vendors catch up. Using lodash includes is fairly safe as we could safely replace it with native support when we feel comfortable bumping Node support to v6.

fixes a small flow typing issue

I believe this is the _best_ way to export an imported flow type.

Hmm, that's a good point. I believe `LandingPage` is more descriptive, while not too limiting. 

ðŸ‘ 

good call

Thanks for bringing this up. We've talked about incorporating Prefs for a couple of months and it's nice that we're at the point where we can act on it.

I don't think this issue needs to block on re-hauling our config system. We've seen in the past that the config system is surprisingly gnarly and I want to take the time to think it through.

I like the idea of reading Prefs at startup and using `isEnabled` and `getValue`.

We will likely need to keep JSON configs as some of the config values are used for the node scripts. 

ooh, i think we need this for chrome actually. for some reason chrome defaults to 12px and firefox defaults to 11.

@monicau interesting, mind sharing a the change?

unfortunately, the editor was being masked by the footer. I'd like to investigate avoiding absolute positioning here. I was able to avoid it with the search bar so it _should_ be possible.

Great suggestion.

> can load in whatever json

that's a good point. 

> avoid using feature flags for things that should just sit on a branch

we've had this conversation a couple of times, so i'm going to move it to an issue for discussion (out of scope here). It doesn't have to be long lived, but it would be nice to have a couple understood rules of thumb.

Yeah, I think we likely position the footer _relative_ to editor. I added this line as a quick fix, but I'd be happy to take it out and create an issue for fixing the layout of the editor. 

I'd like to do it in a separate PR as this could potentially be a significant amount of work and testing and I don't want to block on the search bar.

This is shared from other components that _setupShortcuts_. Ideally, componentDidMount, would work but there was an issue with the shortcuts not being setup at the root because it needed the window. We should likely re-investigate now that we're using context, but it could be another rabbit hole. 

I think this can be re-worked to be clearer. I'm 50% confident this will work, so it's a good thing you have tests.

What I like about this though is that you're saying if both the part and node are dir or not dir, then do a comparison, otherwise and them. ... i don't know, definitely needs some comments here :)

``` js
if (partIsDir && nodeIsDir) || !(partIsDir && nodeIsDir) {
  return node.name.localeCompare(pathPart);
}  else {
   return partIsDir && nodeIsDir;
}
```

@jlongster just pushed a commit https://github.com/devtools-html/debugger.html/pull/888/commits/2d568d5dad6fe093cdeea1d16cc80a3db02d8301. Going forward, if we're talking about an existing issue, I'd prefer merging and opening a new small pr. This is more of a workflow question and we have slightly different approaches. 

ðŸ‘  we should probably file a pr even though it's stale. atleast others will see that we've taken a stab at it

what does this do?

i think we have a test utils dir

this dir https://github.com/devtools-html/debugger.html/tree/master/public/js/test/utils

sorry, if this was not clear, i was suggesting moving this module to the dir because it's a utility

Yep - all good points. I can absolutely see where you're coming from. 

we should only need `user-select`. prefixes are the worst

oh ha, i don't think so... :)

Hmm, maybe something a little more active

```
If you're looking for a good issue, you can look through the `up-for-grabs` issues. These issues should be actionable and well documented.

There are several difficulty levels, *easy*, *medium*, *hard*. We recommend grabbing an *easy* issue, but it's up to you.

* [up-for-grabs][labels-up-for-grabs] - issues that are not assigned to anyone and are available to be worked on.
* [difficulty:easy][labels-difficulty-easy] - issues which should have clear expectations and a mentor to help you through

```

hmm, maybe one more pass:

```
- clear expectations and a mentor to help you through
- more complex and may not have as clear expectations
- complex and has some open technical questions
```

hmm, interesting - i'm not sure if we have mutated the rep value's before. Curious to see what others think.

haha - should this be here?

Hmm, at this point we're opting to use component state local UI data. Some examples of this are, the search bar value, app search being shown, ... 

I think at some point, we might want to start using redux state more for UI data like this, but for the moment it is simpler to use component state.

This works, but it might be nice to try flex as well. An example of that is the autocomplete layout.

Thanks @janodvarko. 

I think updating the _tiny_ mode makes a lot of sense. We're already forcing our grip's to be [tiny](https://github.com/devtools-html/debugger.html/blob/master/public/js/components/ObjectInspector.js#L136).

The motivation behind formatting the window object with `Window` or `Global` is in part space constraints and in part it's clearer, in the same way that labeling Arguments as opposed to referring to it as Object. The discussion is here #884.

yup - on it.

yup, julian and I discussed this. This API is not helpful at the moment, just glue to get it working

Yeah - It's certainly a balance. The development environment is very helpful. I like the idea of a base config so that the tools are cohesive, but that's not fully figured out yet.

I like the way that this updates the grip without mutating the original source.

I like that this doesn't change the original behavior, except for the tiny mode.

@janodvarko mind taking another look. Once this lands, I'd be happy to make an m-c patch and perhaps add some m-c tests.

we likely can replace the react rendering with a simple vanilla approach, but on the other hand this _does_ work.

unnecessary whitespace

we likely can clean this up with some destructuring

also, setCondition does not return `actualCondition`, but that is likely okay because you're just editing the bp.

We probably should replace the Errors with `assert` functions

should remove this

ðŸ‘ 

what does this number mean?

got it

could this be `let prettyPrintWorker = new Worker(`

i like that this module cleans up the actions, as well as is consistent with source map

this is a temporary hack. will move it back now that debugger is on the top level

this will move back to the top level

this can be replaced with a new entrypoint

Yup. I dislike this API too. I'd be happy to brainstorm better APIs that line up w/ the inspector's goals and ours

this should be cleaned up

this should be shared soon

should be able to kill this

should be able to share soon

I think this should be able to be killed ... 

:/ not sure how this worked before

I copied this into the debugger.html components dir because the requires didn't work... we can debug this now or later... 

this can be cleaned up

moved to the Root.js component, but that can be figured out later with the second phase where come up with the right API

nevermind, the types need to be here because the client is in the toolbox!

never mind, the tabs reducer uses this...

@jlongster I wasn't sure why the action type confused by `shouldDisableBreakpoints`, so i moved the function out and had it accept `any` for action. I'm curious if you have a fix here.

hmm, true. maybe it would be fine if it were installed locally

pulled in from `import/deps`

we're now using `devtools-modules` Services

some inconsequential formatting from eslint...

`import/deps`

lol, this is the gist of the patch...

needed to prevent reading from the default raw!json prefs

Needed to prevent reading from localStorage

other part of the initial patch.

we can do better and just do `onKeyPress: onKey` :P

fixes an issue where `npm run mochitest-watch" was placing the build in _devtools-local-toolbox/firefox_

One challenge is knowing whether toggling a node will trigger an object load. For the time being this is something the tester has to add, which I think is fine. At some point it might be nice to call `loadObjectProperties` all the time and return properties when they exist in the store. This way the tests could be a little more certain. 

good point. I'll be in here with a fix for toggle breakpoints and will add something

Hmm, that's a good point, i guess selectors in addition to actions are also a valuable part of the Debugger's _API_

unfortunately, both the footer and editor need to use this utility. 

true - i'll look into this

Could be onClick: this.toggleFramesDisplay

we'll likely want to revisit this when we add full project search, but that is a little ways off.

we'll improve the types here when we work on project search

I removed the early support for blackbox in the source footer last week as it was not being used.

running `npm i clearly had some alphabetizing to do`

the `any` here will improve when we have a good description of the store

this was erroring in atom's flow ide

I started some work on making this more explicit, but it needs some tidying up... 
https://github.com/devtools-html/debugger.html/compare/master...jasonLaster:flow-support2?expand=1

anyways, it should be viewed independently of this PR.

oh strange.

yeah, that's interesting. I just looked an it seems like it's installing both 14.7 and 15.3. It installs 15.3 so that flow-coverage-reporter can use it. I believe this is okay.

Also - and this is important
- `node_modules/react/dist/react.js` -> 0.14.7
- `node_modules/flow-coverage-report/node_modules/react/dist/react.js`  => 0.15.3

lerna-debug was mentioned twice in this file

The dark theme requires adding a class to the `<html>` element. This patch adds the class to both the html element and the root, which is just a way of being consistent in both cases

I pulled theme-body up to the Root element to be more consistent for other tools that use the toolbox, but I know we'll still want to figureout the toolbox / debugger api.

nope. webpack doesn't like expressions and neither do I :)

yup. exactly. this was copy pasta from the selectors file awhile bak

I don't think this is adding much

Hmm, I'm not thrilled about refactoring SourcesState so that the searchOn state is kept in the app. I can see the argument for it being app state, but at this point we have a nice convention for state being local to the component it is being used.

I think it would be nice to use DOM events to open the panel. This way, the panel API is largely DOM and doesn't rely on React.

Here is a function for opening the panel that could be use in the tab onClick.

``` js
function openSearchPanel() {
  window.dispatchEvent(Object.assign(new Event("keydown"), {
    key: "p", metaKey: true, ctrlKey: false, altKey: false, shiftKey: false
  }))
}
```

so this wasn't clear because of the dark theme tabs, but is it possible to have multiple blank tabs?

It would be nice if the tabs button were hidden during file search.

ahh - good point. I guess the next best thing to do would be to make the button a no-op when file search is open. 

Hmm, lets see what the reducer option looks like. We do want a UI state reducer at some point. 

I'm on the fence about the DOM event. I think i'd also feel differently if instead of it being a keydown it were clicking an element :)

hmm, maybe this should be $HOME too

moved this out as it was helpful to do it at the point of module declaration

not surprised, but there are lots of dupes in the properties file which should be reconciled...

hmm, i could be wrong here, but I think flow can infer the return types

ðŸ‘ 

ðŸ‘ 

where did `SourceMapConsumer` return type come from?

will revert

nice catch, was thinking it would be an empty string, but if the field is missing it should be `?`

yup

nice

Hmm, I'm not sure if this would work, but it might be nice to try getting rid of the two new state fields: `isCondBPOpen` and `openPanel`.

I think we can do that because, `this.cbPanels[line]` should have all the information we need. e.g.

`this.state.isCondBPOpen == !! this.cbPanels[line]`
`this.openPanel == this.cbPanels[line]`

we should nuke `this.cbPanels[line]` here i.e. `delete this.cbPanels[line]`

what's the change here? I've been seeing `destroyWorker` does not exist.

Ahhhh. I see :)

Cool. This works. We can take another look when we work on auto focusing. 

good point, that's probably slightly clearer.

This should be a strIng 

Nit: param colon space type

Why do we need the if?

I think the condition is a boolean

this is temporary to support the contextmenu in the panel... i'll clean this up.

Me too, i'd like to propose we prioritize the open issue for using java property files. The big thing for me is that this could cause CI to fail now...

haha - it is :), but we are _using_ it here in a shim/sham like way

it's left over from the first pass which was w/ the source tree

nothing, it's going away. :P

this is almost a direct copy from m-c. I took a lot of pains to move the _sham_ work to `utils/menu`. A regular `menuitem` will behave like a context menu in a web context.

Three things changed:
1. i referenced the sham events emitter (we should consider de-priviledging events emitter a top priority, it's really close)
2. I added `popup` as a argument to the close and open events
3. I created a new `createPopup` function that's overridden in the web context.

This is the most interesting change since the first WIP. I completely agree that updating strings.json is an issue for both CI and in general when making a new bundle.

My current solution is to add `debugger.properties` to github. Now when we make a new bundle it's copied over. This adds a small amount of risk that we override new strings added to m-c, but we should see that in the patch pretty clearly. Also, as we get closer to officially killing the old debugger it's less of a risk.

Obviously strings.json should die soon, but that seems out of scope at the moment and we have the issue for using a webpack java properties loader.

this turns it on for real

Sure

Thanks. I think the decision was to avoid destructuring, but still use defaults below. 

this isn't needed any more

nit: `traverseResultsPrev` is a little wordy, perhaps `prevResult` or `findPrev`?

it's lame to have to pass null into a fnc. We should update `traverseResultsPrev` so that you can do `this.traverseResultsPrev(e)`

this would work above
`shortcuts.on("CmdOrCtrl+G", (_, e) => this.traverseResultsNext(e));`

a lot of these formatting issues came from an early formatting decision to keep the first key on the the `{` line.

At this point, when an object is longer than 80 chars, I believe we're consistently using this format:

``` js
foo({
  bar: 'baz',
  foo: 'bar'
})
```

Many of these changes still need to be updated to meet this format. Would you be able to do that?

this should be:

``` js
const items = [
  {
    header: L10N.getStr("breakpoints.header"),
    opened: true
   },
  {
    header: L10N.getStr("breakpoints.header"),
    opened: true
   }
]
```

This doesn't need to be there. Feel free to `rm packages/devtools-config/configs/local.json` this.

@jlongster @sankha93 I didn't realize that we needed to use the defaults to fix the source type. ðŸ‘ 

Given that we're setting defaults for url and sourceMapURL and using that below, the destructuring makes sense. 

Yeah, my initial change was to the editor.js for that reason, but I didn't want the headache of disabling it there, but not globally for all the tools. This will be better when our Editor Search Bar is global for all the tools _shrug_

ugh... just merged this. 

hmm, now that i'm looking at this more closely, I don't think we want to change the SplitBox.css in this way. `uncontrolled` is pretty general and can be used in lots of ways. 

I think this is one of those things that we'll need to live with for now until we can do the vertical layout...

I prefer the consistency personally, but it's subjective. I can see how this way is okay too.

As a path forward, lets say that the rule is that the keys should be in the same column. If eslint is okay with the first key or last key being on the same line as the curly that's fine...

lol. this PR is crazy town, do you have some context on how you came up with it :)

this is a minor thing, but would you mind trying outline as well. I notice that border pushes the text, which is a slight visual tick that atom and i believe other editors avoid

Yeah - i think that would help

haha - that's number of DOM elements

@Zacqary PR up that fix. I like it. Changing the data type might have other affects so I think it should be its own PR. 

 A new branch

Hmm I'm not sure if we do defaults like empty array in other selectors. 

What's the default otherwise, null? That might be more descriptive. 

@jlongster what do you think?

By the way, the best fix for me would be better immutable records so that we have a consistent API 

Yea let's see if that works 

hmm, i don't think we need this if we're only rendering frames when there _are_ frames. 

Yeah - that looks good. 

Also, who knows if we'll refactor this in the future and it'll be helpful

I like it, i'm happy to merge in the check. It was a small nit, but you persuaded me it is good to be safe

If you want to do some small cleanup here we can open a new small PR. 

I'd also be curious to see what adding flow types would look like in a component. We haven't done that yet

not needed

needs a space

should be additive
checkout classnames https://github.com/devtools-html/debugger.html/blob/master/public/js/components/Breakpoints.js#L84-L88

hmm, yeah - preinstall is definitely an issue at the moment, but i hope we can fix it without this step. 

oops, this stuff needs to go

could we call this `searchValue` or `inputValue`? Sometimes with this stuff, i wonder if we need the tense for instance does "previous" make it more clear or is "current" redundant... The answer could well be, previous helps for X reason, i just haven't thought about it much.

Hmm lets check yah there are three items 

Why do we need some?

Hmm I'm missing something. 

What do you mean by truthy in the array?

What do you mean by truthy if the current tax is the last one :)

this makes sense now ðŸ‘ 

Nice null check!

haha oops, that should be `this.cbPanel = null`.

hmm, @Zacqary I think this style might be a bit cleaner

``` js
function renderFrameTitle({ displayName: string }) {}
function renderFrameLocation({ source: Source, location: Location }) {}
```

with these imports:

``` js
import type { Source, Location } from "../types";
```

hmm, mind adding a Frame type to types?

This could be `List<Frame>` if we had a frame type

I kinda like breaking this up:

``` js
const framesToShow = frames.slice(0, numFramesToShow))
dom.ul({}, framesToShow.map(this.renderFrame);
```

Don't worry about L10Ning these things, they're our tests :)

hmm, perhaps `editor. conditionalPanel.placeholder`

[this](https://github.com/devtools-html/debugger.html/blob/master/public/js/test/mochitest/head.js#L183-L185) could help you here.

this shouldn't change the test, but I find it easier to read:

``` js
clickElement(dbg, "sourceNode", 4);
yield selected = waitForDispatch(dbg, "SELECT_SOURCE");
```

can we move this to a function in content? The main benefit is that it lets us re-use `invokeTab` instead of `ContentTask.spawn` which is an API that can be implemented outside of mochitest. I also find it more readable and consistent with other tests like `doEval` where the test logic is inside of the test example file.

`head.js`

``` js
invokeInTab("addScript", "math.min.js")
```

`doc-sources.html`

``` js
window.addScript = function(name) {
  const script = content.document.createElement("script");
  script.src = name;
 document.body.appendChild(script);
}
```

same thing here

ughhh

hmm, i don't think we'll want to change this. It's a global that's shared in many places.

I think we can likely just use `rgba(190, 190, 190, 0.8);` for the box-shadow. the menu is special in that it's only for the local environment and...

> Here I think it's simple enough to just inline

I can see that too

> We'll have to figure out a lot of stuff if we ever run these elsewhere

Yup, that makes sense. I feel confident that we have a path forward at that point as well. 

Hmm, I would have thought it would be like `openNewTabAndToolbox` where you `dispatch` returns a promise, so it would do the appropriate thing. My previous example swapped the yield.

``` js
  const toolbox = yield openNewTabAndToolbox(url, "webconsole");
```

Either way, not a big deal

ahh, i see. 

looks like the tests are failing because `strings.json` needs `loadingText` from the properties.

It's interesting that it's using it... but i can investigate that later :)

Oh I see. Hadn't thought that through. Thanks for the writeup. 

Perhaps waiting on load source makes sense, but just thinking it through. Not looking for a cleanup :)

Yea, you can define the type above the function and then use it. Perhaps that's nice... Or just add a line break... Also, I'm not convinced we need it. Your call. 

nit, but in cases like this I like `ids.forEach(removeDocument)`

ðŸ‘ 

ðŸ‘ these are so much cleaner, nice job.

hmm, this might be better expressed in terms of reduce

``` js
return ids.reduce((id, tabs) => removeSourceFromTabList(tabs, id), tabs)
```

I'm not 100% sure, but an idea as the `tabs` assignment seems a bit strange here. Also, not a big deal.

hmm, perhaps you want to always pass an array of `tabIDs` that way we have a consistent API.

This logic is getting pretty hairy. It might be helpful to add some `close tabs` tests [here](https://github.com/devtools-html/debugger.html/blob/master/public/js/actions/tests/sources.js#L86).

Also, if you're interested in jumping into https://github.com/devtools-html/debugger.html/issues/804, I'd be happy to take a stab at some tests and perhaps a little clean up in this function :)

Hmm, hope it's alright, but I'm taking a stab at some of the unit tests + `getNewSelectedSourceId` logic. This function is **complex**...

My thinking is that:
a) if the current active tab is still around, it should remain active
b) if it's nuked, the next available tab to its left should be activated. 

This logic could simplify things quite a bit as well

Also, I hope you enjoy, I was curious so i took a look at how atom handles tabs and found this [view](https://github.com/atom/tabs/blob/master/lib/tab-bar-view.coffee). This was the first time I inspected atom for a profit... was pretty neat :)

@bomsy just posted this [PR](https://github.com/bomsy/debugger.html/pull/1) against this branch. In the past, I've been able to push directly to your branch, but for whatever reason I didn't have permission this time.  

Yay! figured out how to push. @bomsy let me know what you think of the updates and if there's anything else we should do here.

it transforms an immutable record, in this case list to a native type, in this case array. Makes things simpler :)

nice.

that's a good point

definitely, that's an oversight. this was just designed to sketch the idea

that's a confusing aspect at the moment. 

The reason for this is that `devtools-local-toolbox` exports `src/index.js` not `index.js`

This will be cleaned up in a subsequent PR, but it's not related to the console working per se. The issue here is that the toolbox does 2 things:
1. It sets up a development environment - dev server and webpack config
2. It has a web app for the landing page and establishing the connection

The development environment does not belong in the web app's webpack bundle so it's in its own index. I'll move it to a separate package after this is done.

I think `config.js` in the top level would probably be fine. 

I'm hesitant to move it into `src` or `bin` as those are different in my mind.

What do you think?

i'm okay using ES6 where we can, but in this case, we do need a deep merge, so lodash.merge makes sense to me

@devtools-html/debugger-core @helenvholmes 

I believe this is the first time we'd use BEM for a component that is used in several places. We could potentially do this with the close button and sizes.

I personally am more comfortable with well scoped classes `.command-bar` `.source-footer > .command-bar`, but that's probably because of my experience set and I'd like to have an open mind on this issue.

nice fix.

Didn't realize you're also improving theme support

thanks for helping us make the buttons more accessible. I personally would like to see more of our buttons become `button` elements.

Looks like react can map from ariaLabel aria-label

https://facebook.github.io/react/docs/dom-elements.html

small nit, when there's a conflict we use `FrameType`

https://github.com/montogeek/debugger.html/blob/flow-type-pause-actions-reducer/src/actions/sources.js#L273-L275

oh strange, that could be a way that the Svg library handles it. I'll take a look in a bit

@jlongster agreed. The UX is not ideal. mostly a POC. 

@clarkbw suggested that a subtle signal like the application title is sufficient.

This will likely be dropped soon

yeah. I realized that that logic was duplicated right above actually. 

This should be tested by our CI.

yeah. I realized that that logic was duplicated right above actually.

This should be tested by our CI.

Hmm, will give that a shot, this is the part i like least

ðŸ‘ 

dropped

I think this became simplified with `host` and `baseWorkerURL`

Hmm, I bet we can avoid adding this function
either

a)

``` js
toggleBreakpoint(line, {disable} = {}) {
}
```

This way, callee's can say that they'd like to disable a bp instead of removing it. 

or b)

add a disableBreakpoint function that's called in that case and otherwise we call `toggleBreakpoint`

``` js
disableBreakpoint(line) {
}
```

just a thought... could be wrong :)

small nit, but I prefer this style:

``` js
this.props.enableBreakpoint({
  sourceId: this.props.selectedLocation.sourceId,
  line: line + 1 
})
```

@juliandescottes I think this will fix a **lot** of the issues you might have been seeing where the toolbox is now typed w/ flow and would break in the console and inspector!

Hey @Garbee, do you think you could style this without BEM for now and make a new issue for adopting BEM with this code snippet there.

I think the consensus is that we're in favor of BEM, but would like to come up with a plan so the project adopts BEM well.

#opsissues

talked with @Garbee offline and the simple solution is to rename the class `command-bar` to something else.

and open a BEM issue to discuss some of the project goals

I've been thinking about this a bit and came up with what I _think_ is a nice improvement.

Lets create each context menu item with the specific action

e.g.

``` js
const disableBreakpoint = {
         id: "node-menu-disable-breakpoint",
         label: disableBpLabel,
         accesskey: "D",
         disabled: false,
         click: () => this.props.disableBreakpoint({
              sourceId: ...,
              line: line + 1
         });
```

I think we might go this approach anyways because each item should have it's own ID as well. i.e. "node-menu-disable-breakpoint", and "node-menu-enable-breakpoint" https://github.com/devtools-html/debugger.html/issues/1228

We do the same thing already with `enableBreakpoint` so it's just a question of creating the other 8 or so items.

What do you think @shlomif?

Hmm, I can see what you're saying. It is also consistent with `toggleBreakpoint` which is right above, which makes sense. 

Thanks for being patient @shlomif.

I like the use of *ems` in this PR

ðŸ‘ 

I'll create a new issue for following up on our other SVG buttons so that they can as accessible

CRI prefers host, port, scheme APIs which makes more sense as well.
@cyrus-and I'm not if passing in a custom [fetcher](https://github.com/cyrus-and/chrome-remote-interface/compare/master...jasonLaster:fetcher?expand=1) is the best idea or just a dirty hack.

The problem I'm trying solve is this. The debugger runs in a web context so fetching `localhost:9222/json/list` will be a CORS error. What we do instead is use `networkRequest` which builds a url `localhost:8000/?get=localhost:9222/json/list` to do the request for us. 

What I'm doing here is passing in `fetch` as my go-to fetcher with CRI, but it feels bad. Have you seen others try to do this before?






disabled for now while I sort out chrome. It will be enabled before this lands ofcourse
will need to do something like what we do [here](https://github.com/devtools-html/debugger.html/blob/master/packages/devtools-local-toolbox/src/clients/firefox.js#L94-L97) to listen to all the events.
this is currently failing because it needs a custom fetcher...
Hmm do you need to check for a line?
Don't you have line already?
mind looking into if we can get `ariaLabel` to work with the Svg component? Perhaps we need to make a PR in inline-svg..
ahh @arthur801031 @Garbee 

looks like we're good - https://facebook.github.io/react/docs/dom-elements.html
as in react doesn't handle converting, so neither should we.


ðŸ‘ 
in general, I prefer moving these expressions out of a template, but that's a minor style preference for me.
this makes sense. I think those props/state are set onDrag...
Perhaps, i think this is actually a nice API.

We probably want to remove the handler on dismount? 
Yeah, that's true.

I think in my patch I had `AdditionalPanes` and two render methods `renderBottomBar` `renderRightSideBar`
This adds some funny styles

You should be able to reproduce by adding some more editor tabs an observing the hidden tabs dropdown appear.

![screen shot 2016-11-26 at 8 27 05 pm](https://cloud.githubusercontent.com/assets/254562/20644914/d26f6712-b416-11e6-940a-3b9fe3f36ac5.png)

this will move to `httpRequest` when i get the webpack alias to work
this needs the WebSocket wrapper to work (next step)
> Don't export 2 components from the same file

good point.

> What is the advantage of AccordionPane anyway? 

Looking at Konrad's PR, I don't think we gain that much from this improvement. I thought it would be more helpful than it turns out to be.

> we don't support null in the array

That would be nice so that we avoid the conditional unshift.

> eagerly renders all of the panes

I'm not sure why this is a problem? I assume this is why we had created, but I don't see where that helps us.

yeah, turns out that it wasn't being pulled in so the dark theme scrollbar looked pretty bad in windows.
lol. i think that will be fixed in a later pr. I don't want to re-run the tests.
@clarkbw i think your slides could be good here too
ðŸŒŸ @Garbee  I think you'll like this!
ughh, meant to have some context here. not sure if we need the same linux details
haha - yeah, wanted to have a conversation about and hear why. sorry forgot to comment
good point
NOTE: we tried to make **flow** fail by adding this error, but when we run flow we got `no errors`
we tried doing something like this:

```js
import type { Breakpoint, Source } from "devtools-client-adapters/types";
export type { Breakpoint, Source };
```

This worked to the extent that we didn't have to copy the types and the debugger would mention when a type was missing, but it didn't help us w/r/t to validating the types.
not necessary
hmm, this doesn't need to be context, it can just be `this.shouldLoad`...

I'll look more closely tomorrow

also lets use bools instead of 0/1 `this.shouldLoad = true`
ðŸ’¯  sorry that wasn't clear. 
perhaps if we don't have a reason we don't show the highlight for now?
yeah, we can go back to that :)
yup
this will need to be bumped
is this fine semantically? or should we use a div?

@wldcordeiro, @Garbee advice?
what does this map get us? 
not much, it shows where the source tee will get the data.

i believe @arthur801031 knows what to do with it!
hmm, I think you can use react `setState` here instead of redux.

Also, maybe set the items at the end as opposed to one at a time
I landed this work earlier today (I think). A rebase would be healthy either way :)
perhaps  `url.replace(/http(s)?:\//, "");`
could we do the same thing `with url.split("/")` :)
this is a little confusing to me... i'll play with it later
lets delete this
will this scroll?
hmm, i think we want the units
ðŸ‘ 

thanks for the link
hmm, little confused why we're trying to show the source...

couldn't we do `this.copyToTheClipboard(tab.url);`
ahh, interesting...

I suppose we could get the `source` above https://github.com/arthur801031/debugger.html/blob/46b268f751aa73a55a04c3b5394ea146a26f6957/src/components/SourceTabs.js#L104.

```js
const source = tabs.find(t => t.get("id") == tab)
```

or something like that...
lets exclude this version, it's not really used. 
spaces between the curlies
@jlongster do you remember why `_onScroll` was disabled?

It seems to work well enabled
Yea, good call
perhaps this should be in the list.
`###` 
strange, i've never seen this `stopPropogation` not present. What case are you handling here?
we should add these styles in the `Expressions.css`
perhaps we don't need this accordion-class, and instead could use a scoped selector like `.expressions .hader .refresh`
hmm, this doesn't need to be context, it can just be `this.shouldLoad`...

I'll look more closely tomorrow

also lets use bools instead of 0/1 `this.shouldLoad = true`
@jasonLaster 

I tried removing `context`, but I was failing the CircleCI tests. So I revert the code to have `context`, and it's now passing the tests. I think we may be able to remove `context` when we're setting `shouldLoad`  to true or false, but it looks inconsistent. Please let me know what we should do. Thank you!
At this point why not just `fetch("/get....")`? which is how it was before the app stuff.

So the app is currently just showing the webpage from the server, yeah, which is why I didn't think this was needed. And this will work when it's locally running the server itself too.

Makes sense, thanks for thinking through it!
yeah, we can go back to that :)
React auto-binds all methods to the component, so this will work (tested ðŸ‘ ).
yup
is this fine semantically? or should we use a div?

@wldcordeiro, @Garbee advice?
what does this map get us? 
Oh yeah, I had removed the wrapping `span` and didn't realize the map was useless.
@jasonLaster I don't think `div`/`span` have much semantic meaning in their own right, the `span` was just easier because it was one previously.
What does this line do?
Here we'd want `Event Listeners` instead no (probably an L10N string would be better.)
not much, it shows where the source tee will get the data.

i believe @arthur801031 knows what to do with it!
I was wondering because the `shownSource` is a string, and then it's just invoked inline at 134, so it didn't seem to do much?
lets delete this
will this scroll?
hmm, i think we want the units
if there is a lot of tabs - yes
Debugger statement should be put here. (if data doesnt have a value it wont crash)
This line could be removed.
Except if the js engine may optimize `data` away.
lets exclude this version, it's not really used. 
spaces between the curlies
ðŸ‘ 

thanks for the link
hmm, little confused why we're trying to show the source...

couldn't we do `this.copyToTheClipboard(tab.url);`
Hi @jasonLaster 

<img width="192" alt="screen shot 2016-12-09 at 4 43 28 pm" src="https://cloud.githubusercontent.com/assets/4562118/21042761/7463cede-be2e-11e6-8895-b4a368f9924d.png">

Since `tab` equals to a number, I use `showSource` to retrieve this tab's url.
  
ahh, interesting...

I suppose we could get the `source` above https://github.com/arthur801031/debugger.html/blob/46b268f751aa73a55a04c3b5394ea146a26f6957/src/components/SourceTabs.js#L104.

```js
const source = tabs.find(t => t.get("id") == tab)
```

or something like that...
Yea, good call
perhaps this should be in the list.
`###` 
@jlongster do you remember why `_onScroll` was disabled?

It seems to work well enabled
we should add these styles in the `Expressions.css`
perhaps we don't need this accordion-class, and instead could use a scoped selector like `.expressions .hader .refresh`
why do we need this?
just refresh and add-button, right? not the whole selector
hmm, perhaps we should have a separate SVG css file so that these styles are well grouped?

It's interesting you're running into a new use case for us. Which is not that un-common :)

yea, lets create a new file `utils/Svg.css` where we can add all the common SVG css. It can be a neighbor of https://github.com/devtools-html/debugger.html/blob/master/src/components/utils/Svg.js
I have multiple nodejs projects with multiple versions. This helps me keep a specific version per project. If you wish I can remove it but I don't think it bothers anybody. It contains a one line string with the node version v6.9.2
[done](https://github.com/andreicristianpetcu/debugger.html/commit/046a35d78d40e58eaa04fc4b8e301a95d9bc6e90)
It will probably take a few days since I don't have time to work on it today anymore. Sorry.
[done](https://github.com/andreicristianpetcu/debugger.html/commit/0d40a5592a47d7f24cc6c1e5ec2dacb4be2d93f6)
cool, that works for me
hmm, i'm a little confused about this change?

It looks like it changed the size and color of some of the SVGs. It looks like the tree is darker than it used to be

<img width="520" alt="screen shot 2016-12-12 at 6 26 23 pm" src="https://cloud.githubusercontent.com/assets/254562/21121140/c42b24be-c098-11e6-9e83-b2a2b182bedf.png">

It was a mistake. It is [fixed](https://github.com/andreicristianpetcu/debugger.html/commit/4cabd2e528c09c839b8cd0ff8c381910fc4d174c) [now](https://github.com/andreicristianpetcu/debugger.html/commit/2ba1c7d9acde2d088131324b79120b06de59cef8). I wanted to make the refresh and + buttons have a single color and not change on :hover but I made the selectors a little bit too generic.
this will move to `httpRequest` when i get the webpack alias to work
this needs the WebSocket wrapper to work (next step)
this will need to be bumped
nit: remove commented out line
This PR enables linting on this package. 
Is there a reason to keep enforcing eslint-disable on this file?
If I'm reading correctly the code at 
- https://github.com/cyrus-and/chrome-remote-interface/blob/master/index.js
- https://github.com/cyrus-and/chrome-remote-interface/blob/master/lib/chrome.js

CDP expects options containing host/port/protocol etc and not a string representing a URL ?
Hey! we just landed postcss for RTL support :)

mind rpulling and then `yarn install`.

It's pretty cool and totally worth it. Sorry for the confusion.
@jasonLaster I did the rebase and I tested dark theme, white theme, Chrome, Firefox, tooltip. I did not test rtl since I do not know how but I included the changes. Please accept this pull request since I keep having conflicts with parts of my patch that landed in upstream. Any issue that you find can be fixed in another branch without these merge conflicts.
Not sure about the language here.  I see what you're getting at but I'd reword it.
ðŸ‘ 
Use this: https://github.com/devtools-html/debugger.html/issues?q=is%3Aissue+is%3Aopen+label%3A%22up+for+grabs%22
"Try this [first activity][first-activity] if you want..."?
i think this needs `50`
is it weird to only show the title if the subtitle is `> 50`? 

I'm asking because the  tooltip is a little bit of noise when you pause over the item. 

Happy to keep it in all cases if that's the *proper* ux :)
This whole block should be removed not left empty.
strange, i've never seen this `stopPropogation` not present. What case are you handling here?
I was seeing an error in the console complaining that `stopPropogation` didn't exist while working on my Mac and I wasn't see on Windows.  I'll be able to check it out on both this week some time.  Not sure what's really going on here.
hmm, i can take a look
@juliandescottes you should know this by now!

We move quickly here, so the link is already out of date :)

should be https://github.com/devtools-html/devtools-core/blob/master/packages/devtools-launchpad/README.md
small nit :)

```js
const label = `${position}PanelCllapsed`
this.setState({ [label] = !this.state[label] });
```
we don't need lerna anymore
maybe scope creep, but we might be able to use yarn HEAD now, who knows
ðŸ‘  I was going to do that in a separate PR
Oh right, I can remove that here.
this is minor, but could we move this to a bin script `bin/install-yarn`
sure
I suppose we could simplify all of this by adding `.replace(/:formatted$/, "")` here, but the function will come in handy in the future.
yup - we'll want to use it in other places too
hmm, I think you can use react `setState` here instead of redux.

Also, maybe set the items at the end as opposed to one at a time
I landed this work earlier today (I think). A rebase would be healthy either way :)
perhaps  `url.replace(/http(s)?:\//, "");`
could we do the same thing `with url.split("/")` :)
this is a little confusing to me... i'll play with it later
Hi @jasonLaster 

If the url is `"/localhost:7999/todomvc/js/models/todo.js"`, `url.split("/")` would give me `["", "localhost:7999", "todomvc", "js", "models", "todo.js"]`. My implementation actually requires the result to be `["/localhost:7999", "/localhost:7999/todomvc", "/localhost:7999/todomvc/js", ...]`
I don't think that using while loops is a good idea - it's difficult to follow the indices and it might as well run forever.

I've never run this code but the `const` reassignments look very suspicious...
do we need state here? I think we can rely on just using `props.listItems`
if we don't have a listItemsLocal , lets bail 
this seems weird to me... perhaps we do need some state, but the name collision makes it hard to follow...

Also, if we have an expanded list, do we need this listItemsLocal list... and if it does to an empty list because it keeps getting spliced down, can we do this another way. I guess i'm saying, this seems weird :)


same weirdness here. maybe we can do something where we look at the listItem props and then update the expanded set in batch?
Hmm, what if we call expand list items from here. No state necessary. 
hmm, @arthur801031 this *also* seems strange.

I think it's here because `componentWillReceiveProps` does not check to see if `listItems` has changed. 
* perhaps check to see if listItems is different
* also could, `componentWillReceiveProps` be `componentDidUpdate` perhaps not, just curious.
you can clean this up by doing:

```js
treeListItems.forEach(item => this.state.expanded.add(this.props.getKey(item))
```

Not a big deal, but you know, we're perfectionists here :)
I tried `componentDidUpdate ` before, but `listItems ` would be undefined. :(
nit: perhaps `update-yarn-lock-file` 

this could be obvious to everyone else, but i thought you were updating yarn at first :)
cool :)
such magic
I like this. I assume, we have the same check below, but better to be redundant
Nice
ðŸ‘ 
I am worried this may need to be `cd $HOME/$CIRCLE_PROJECT_REPONAME` but I wanted to see a run first.
This tests that we are looking at a greenkeeper like branch so we don't do this on anything else.
This also is a test for greenkeeper like branches.
This tests that we are seeing an "update" commit message.  However our own commit contains the word "update" so we also test below.
This final check ensures that we aren't in an infinite loop trying to commit our yarn.lock file over an over again.
`let x` doesn't work :)
Why?  The default value should be `undefined`, right?
ðŸ‘ for this move
Hey @arthur801031, I just realized we can replace this localStorage stuff with **PREFS**

Here's a link for how to setup a new pref
https://github.com/devtools-html/debugger.html/blob/master/docs/local-development.md#prefs
nit: could be one `panelCollapsed = \`${action.position}PanelCollapsed\`` var
Hmm, i don't think so actually. `null` has special meaning for the frameId i believe. So it's not like checking for the presence of frameTypeId.
Hmm, perhaps we use the `includes` function

```js
function expressionExists() {
   return !!expressions.find(e => ..)
}
```

```js
if (expressionExists(expression, expressions)) {
  return
}
```
@clarkbw 

* "Add Watch Expression"
* "Add selected text to watches"
NIT: lets create this label regardless and only do the push if the condition is true
lets move this to an instance function as we probably want to also check to see if the cursor is in the selection
true, but I like being safe as it could blow up if we still hit it
perhaps we could add a console.warn here as well so that we are notified?
why can't these be normal props?
I think we can clean this up: 

```js
function expressionExists() {
   return !!expressions.find(e => ..)
}
```

```js
if (expressionExists(expression, expressions)) {
  return
}
```
why is this more complicated than before?
Hmm, we should probably still have the feature flag

```js
if (isEnabled)
  menuOptions.push(watchExpressionLabel)
```
I believe this this is *on*
hmm, you'll have to be clever here i guess :)
@arthur801031 any ideas?

I'd start by looking at [utils/source-tree](https://github.com/devtools-html/debugger.html/blob/master/src/utils/sources-tree.js#L99)
hmm, i think its safe to assume `prettyPrint` is on :)

are we using the flag in other places? If so we should rip them out too
why are we dropping the "g"?
could we bail early if `matchLength` is null?
alright, i'm definitely playing with this locally.... this is wizardry
I like the `:before` `:after` here
not a big deal
what does RESTORE does?
if we're persisting the selected source, we can likely drop this
if we're adding loading the tabs in the initialState, do we need this?
Yea. 
I think we need to check to see if its the selected frame
hmm, lets move `let items` and `showMenu(event, items);` out of the the condition
ðŸ”« 
lets get the selectedSource here and get the URL from that.
lets kill url
Haha can we add more specificity to avoid imports to calls?
hmm, i think these function could receive query and be moved to helpers above the component.

My rationale is that we already have a lot of instance functions :)
couple things:

1. this seems like a mechanism for removing the search overlay mode. Is that correct?
2. could we also do a serch from here when the user lifts the mouse up
3. the IFs could be collapsed into one `if (searchOverlayMode && !ctx.cm.somethingSelected()) {}`
4. the searchOverlayMode would always be true, so in this case lets just do false... seems more honest




shocked that this is the first one
extracting these three utilities is the right idea. Unfortunately, moving them to the SourceEditor won't work because we have a different SourceEditor in the panel :/

My vote would be to move these utils to a new util file in a later PR. Infact, i think there are other utilites we can extract as well :) 
it's impossible to guess that. we should have a BIG comment, because anyone could miss it
I'm surprised there are no spaces here, but there are spaces with objects.
this is beautiful ðŸ’¯ 
I like collapsing when we can :)
this could be defined outside of the component
how about we pass in a `getButton` function that wraps the ref logic?
what does ` this[action]` do?
hmm, we can navigate to any line by clicking on console link, or other features like "jump to original location"... so breakpoints is not enough

what if we just iterated over all of the code mirror lines and removed this class?

I'll pull this work into a new PR. It fixes the mocha web runner which is great though
nice.
I wonder if we can pass modifiers along. That way we avoid long signatures
```js
return horizontal !== nextProps.horizontal || collapsed !== nextProps.collapsed
```
can we pull this into an object like 

```js
contentTypeModeMap = {
  typescript: { name: "javascript", typescript: true },
  coffeescript: "coffeescript"
}

function getMode(contentType) {
  // Object.keys(contentTypeModeMap)
 
}
```

```js
  this.editor.setMode(getMode(contentType))
```
should we improve this now or wait for other cases?
hmm - this sadly won't work due to the fact that there's a different panel source editor.

We'll need to use https://github.com/devtools-html/debugger.html/blob/master/src/utils/source.js
perhaps these are also stored as searchModifiers
```js
searchModifiers: {caseSensitive: false, ...}
```
this would probably simpler if it received modifiers

```js
this.setSate("modifiers", modifiers)
```
```js
onCursorActivity(ctx, query, modifiers)
```
this looks for a candidate where you might want to use the spy pattern https://github.com/mochajs/mocha/wiki/Spies and pass in a spy or stub function for `cm`.

I could see some unit tests really helping here :) 

as you said earlier
can you explain what `moddedQuery` is doing here. how it's different than query
this looks like a good spot for a feature flag
ðŸ‘ 
maybe this is pulled up to a variable... Also we should have L10N strings eventually here
do people use spaces here? `={` 
eventually, this would move to L10N
I think this is nice, but I'm still a little reluctant about curlies :)
I like pulling these functions out of the curlies. I could see the markup becoming pretty hard to follow with these.

Personally, I prefer the old JS style for these in line functions, but ... what can you do :)
this is a small change, that fixes a small `.67px` adjustment in vertical mode
moves the label to the right without the sources header
hmm, is it possible to do something like

```js
ref: type
```

and then we can do `this.ref[action]` to get the button in `handleEvent`. 

I would like to avoid adding the buttons to the prototype if we can
Good catch
can you also add this to https://github.com/devtools-html/debugger.html/blob/master/assets/locales/debugger.properties as well
hmm, i think this could be moved to [utils/editor](https://github.com/devtools-html/debugger.html/blob/master/src/utils/editor.js)

```js
function onKeyDown(codeMirror, e) {
  // stuff
}
```
hmm, two things:

1. I think this should be `source.get("id")` -> i saw an error in the console
2. I think we first need to check if it's original or generated and then check for the other id... right now we assume its generated
Was thinking that too. 

Also it might be possible to do what react dies and set up a declaration so that we don't import at all...
unfortunately that doesn't work for the eventTarget reason
I don't have Props defined
yeah, that didn't work...
Lets move this to a url at the bottom of the page
this is the coolest thing!
meh, i don't feel strongly. My main reason is i like reading the prose without the long urls.
we can always go through and move them to the bottom later tho!
how about mentioning `@debugger` to reach the debugger team.
Yes!
do we need this here: `html`?
hmm, small thing but maybe it's time to use an options object

```js
debugBtn({onClick, type, className, tooltip, disabled = false} = {})
```

This would, make the code more explicit, avoid needless `false` params...
ðŸ‘ 
Oh yeah, this is probably not clear. I'm trying to help team members like you or wellington get setup
I think this should be `padding-inline-end` unless bi-direction does not work there...

lets flip this

```js
if (!enabled) {
return
}
```
help keep the indentation under control

Hmm, lets style it like this if we're running close or over 80 chars

```js
shortcuts.off(
  `CmdOrCtrl+${L10N.getStr("sources.searchAlt.key")}`,
   this.toggle
) 
```
This might be overkill, but it could be nice to do

```js
const searchKeys = [L10N.getStr("sources.searchAlt.key"), L10N.getStr("sources.searchkey")]

componentWillUnmount() {
  searchKeys.each(key => shortcuts.off(`CmdOrCtrl+${key}`, this.toggle))
}
```

you're call!
Hmm, @clarkbw should this be `Close tabs to the end` or `Close tabs to the right`?

My understanding is that it can still be "right" and translators will know how to fix this with RTL languages
ðŸ‘  

I like that you're fixing this globally
ðŸ‘ 

Yep, returning the popup element could allow some dangerous things to happen
lol, this could get hairy

for instance `toggleFileSearch(true)` or `toggleFileSearch(false)`

I think I'd just change the API to `toggleFileSearch()` and then always flip it here. KISS keep it simple stupid lol
yeah, add it to development.json and feature.json :) 

just wrote some docs for this
Hmm, I like that. lets have two actions `toggle` and `close`? 

Also, i suppose the close button will always close given it only is shown when open :)
I think we want `!getFileSearchState(getState())`
I wonder if we can simplify the language a bit and make it consistent with the other options.

```
* **Chat** Say hello in [Slack][slack] or in the [#devtools-html][irc-devtools-html] channel on irc.mozilla.org. 
```

@clarkbw?
Perhaps we also add the badge to the top:

![screen shot 2017-01-24 at 8 21 52 pm](https://cloud.githubusercontent.com/assets/254562/22274162/cde22f74-e272-11e6-9392-a06d8b09d269.png)

I think you can pass some of these in as params:

```js
classNames(action, type, {})
```

```
I'm infavor of inlining this, even though i suppose it'll make the JSX harder in the future...
hmm, how about `node bin/post-merge.js`
ðŸ’ƒ  
I just tested it locally and it looks like rendering without a selected source works.

Lets take this out and we can always figure out the best thing to do later.
The problem with this is that we're changing state. i.e. if the previously selected source is loaded soon after we do this we're wrong :)

actually these keys need to be moved too 
![screen shot 2017-01-26 at 11 14 38 am](https://cloud.githubusercontent.com/assets/254562/22339623/a892e820-e3b8-11e6-86fe-cb9e59e6b436.png)

@yurydelendik the more conventional way to do this is to do `selectSource(dbg, 'asm.js')
ahh, yeah agreed
oh yeah!
I went with ninja because I thought there would be a cute image we could use. there's probably a better name tho... 
What do people think of the idea generally?
yep - i think we can do better than ninja too :)
Great. I think this is a small price to pay for es6 modules and classes. 
I punted here because of node unit test mocking
isn't this test cleaner than before :)

only one global `initDebugger`
commands extracted and shared
custom web setup here
shared utils
shared wait clauses
this will be changed
Hmm, it looks like `tab` and `showSource` are not defined in this function

could you add types here. See `EditorSearchBar` for event handler types.

do we need `&& selectedFrame` if we know it's required.
Looking good.

1. does this fix the problem, my fear is that getSources will make one call for the sources, but it won't trigger `nweSource` by itself
2. i think we can refactor this code a bit to make it more consistent with `util/client`

https://gist.github.com/jasonLaster/de3bd2ecbacaf7518c42336e199d5137
https://gist.github.com/dde3f2cd62733746e562f9d6acd48e76
 
Goal:
1. add a new firefox client command for fetching sources
2. add a `timeout` helper so we can do it with async/await
3. call `newSources` in this action which i think we need to do
oops, it should
hmm, maybe we want to change the function name to `waitForMs`
we can come back to typing props, I think we'll get there soon enough
Hmm, i'm surprised you can't do `isPretty(source.toJS())`
its not needed
I've got another branch with more mocha stuff which will come later
these helpers are going to move out of `head.js` in the next PR
@jacobjzhang the label and accessKey need L10N as well
I'll get to this in another cleanup step. I'd like to better document these files holistically
We have a slightly nicer style here:
https://github.com/arthur801031/debugger.html/blob/update_source/src/actions/pause.js#L45-L48

this doesn't feel great, but i have a feeling i can do better in the next phase
I don't love this DI style, we hopefully can get this file priviledged like `head.js` with the proper permissions
my fear here is that it's a memory leak. Also, ugly... but perhaps we can do something in another pass when we're cleaning up
probably not... but i don't want to mess with it because we are only using this in one test now...
i'lll need to fix this

this needs to be aliased...
this needs to be fixed so that mocha's invoke does the invoke
we likely need to clear prefs...
oops
gotta get one of these to work,
hmm, i think we *only* want to do this when we're navigating from the console.

Perhaps:

```css
.highlight-line.ong .CodeMirror-line  { 
  animation: fade-highlight-out 3s normal forwards;
}
```
it's now done in `beforeEach`
oops, should be killed
oh haha - that's definitely a bug
yep, but circular requires... we should fix this later
@benbalter oh great. Do I need to do anything to get them running locally?
haha - not seeing the button. This is really cool.you're taking these links to the next level
we can use `SourcesState` that's exported in the reducer
hmm, we can add a local type:

```js
import type { Tab } from "../types"
type Connection = { tab: Tab }
```
true,, we can import Actions

```js
import type { Actions } from "../actions/types";
```
we should move `info` here.
hmm - i think this also happens when you click on a breakpoint in the breakpoint list or you select a frame in the call stack...

Is that correct?
hmm, i think this could be moved into the Editor component as we might want to change the Editor mouse up behavior
hmm, why do we need this here?
We switched to reps 6 recently and this changed
This needs to land first
https://github.com/devtools-html/devtools-core/pull/172

And I'll lkely want to update reps as well with this change
Hmm, this isn't used here. so we can ignore it for the time being.

Also, we don't need to type `actions` because it's the object that holds all of the actions, which is currently untyped
hmm, i guess we can evaluate that with other handlers like `onKeyDown`
fixes a bug where we'd also toggle the bookmarks bar
fixes a bug where we were not closing the panel on subsequent <cmd>+shift+b calls
Thanks @arthur801031 I just tried replacing `overflow: auto` with `hidden` and it worked well.
lets define big options
Hmm. Maybe use a regex?
this should be a different name. Also we keep it here for memoization, but it should probably be kept in the util or redux store so that it is available if you change documents.
This looks fine given:
a) it doesn't look possible to disable one line of flow
b) we'll hopefully refactor this file next month when we bring the mc source editor to github.
ðŸ‘ 
Heh. I think sometimes it's a string. Let's hunt this down. I believe we keep a modded dict in utils source
@juliandescottes I believe that's what we do below :)
nit:

```js
const aInt = parseInt(a, 10);
const  bInt = parseInt(b, 10)
```
newline
ahh - i see :) 

yeah i can fix that
this can be

```js
let type AlignOpts =  "top" | "center" | "bottom" ;
```
Good call @clarkbw 

looks like in some cases it's a string

https://github.com/jasonLaster/debugger.html/blob/sparse2/src/utils/source.js#L89-L101

perhaps we add a mode type in `src/types` and use it in both `utils/source` and here

```js
let type Mode = String | {
  name: String,
  typescript?: String
  base?: {
    name: String,
    typescript: String
  }
}
```

frankly the typescript mode seems weird here. We should look at it again :)
nit, but we could simplify this to:

```js
const parentOffsetDir = sourceTabDirection === "ltr" ? "right" : "left"
const parentOffset = sourceTabsParent.getBoundingClientRect()[parentOffsetDir]
```
this probably would benefit from the same cleanup:

```js
const tabDir = sourceTabDirection === "ltr" ? "left" : "right"
return sourceTabs.filter((tab, index) => {
     return (sourceTabEls[index].getBoundingClientRect()[tabDir]
     parseInt(sourceTabMinWidth)) > parentOffset;
});  
```
also maybe add a `getTabOffset` helper

```js
function getTabOffset(tab, dir) {
  return tab.getBoundingClientRect()[dir]
}
```

this will abstract out the logic a bit
ðŸ‘ 

nit: we should probably have a helper for getting these tab properties. That way the logic for checking for tabs and then getting the property is hidden away :)
yeah, i think so!
This can be a Unicode character!
Check our tabs dropdown button
Yea. Thats what id do too :)

@gregtatum?
I think we should bump the localization key to `sourceSearch.resultsSummary1`
We can replace this with a unicode character:

```diff
diff --git a/src/components/Editor/ConditionalPanel.js b/src/components/Editor/ConditionalPanel.js
index 447ce9b..95c59c5 100644
--- a/src/components/Editor/ConditionalPanel.js
+++ b/src/components/Editor/ConditionalPanel.js
@@ -32,7 +32,7 @@ function renderConditionalPanel({ condition, closePanel, setBreakpoint }:
   ReactDOM.render(
     dom.div(
       { className: "conditional-breakpoint-panel" },
-      Svg("guillemet"),
+      dom.div({ className: "guillemet" }, "Â»"),
       inputA,
       dom.a(
         { onClick: closePanel },
```
thanks :) for catching this
Hmm, looks like this is giving us a weird value... and it can likely be cleaned up further.

I'm going to try moving the modulo math to the increment / decrement line

<img width="409" alt="screen shot 2017-02-17 at 3 27 31 pm" src="https://cloud.githubusercontent.com/assets/254562/23082135/17f34fce-f526-11e6-8555-a64d613a13f1.png">

strange
ðŸ‘ 
I think so. I'm going to pull in the latest bidirection and then test
yup, this is how we do it in another spot:
https://github.com/devtools-html/debugger.html/blob/master/src/components/shared/Dropdown.js#L42
fixed it
hmm, how aboutt `searchInput`
hmm, perhaps we want to call it `search-bottom-bar`
ðŸ‘  love it.
this part makes me happy. I always found it frustrating to add these
oh nice, i wasn't sure
lol. looks needed
Hmm, we should react to assign the `onKeyUp`
Hmm, you should try to move this to `renderFrameList` where the UL is render and add attribute: `onKeyUp` 
this doesn't matter for hover and enter. it's for tab and enter
hmm - we should probably use a var here
nice
I think we want this for horizontal layout. perhaps we use a media query to only apply this at less than 700px.  

or we add a class to the layout that we can use to select on. I think this approach is simpler. Also we can add docs for doing these style changes for different layouts.

```diff
diff --git a/src/components/App.js b/src/components/App.js
index 81b13be..7dab8dc 100644
--- a/src/components/App.js
+++ b/src/components/App.js
@@ -84,7 +84,7 @@ const App = React.createClass({
     const overflowX = endPanelCollapsed ? "hidden" : "auto";

     return dom.div(
-      { className: "debugger" },
+      { className: "debugger horizontal" },
       SplitBox({
         style: { width: "100vw" },
         initialSize: "300px",
@@ -113,7 +113,7 @@ const App = React.createClass({
     const { horizontal } = this.state;

     return dom.div(
-      { className: "debugger" },
+      { className: "debugger vertical" },
       SplitBox({
         style: { width: "100vw" },
         initialSize: "300px",
```
ðŸ‘  I can bring those in. it'd be nice to have the grips for those as well
perhaps we should find params and properties as well:

`function(bar) {}`
`x = {a: 2}`
we should translate all three of the options
hmm, we should translate class/function/...
hmm, perhaps only show this when there are classes?
we should re-trigger a search when there's a query. 

STR:
1. type `t`
2. select function
3. select variables should re-search with `t` or clear the query
@flodolo is it okay to interpolate strings like this:


*"Search for %S"*, where `%S` could be *function*, *variables*, ...
ðŸ‘ 
perhaps `RenderRepOptions`
hmm, 

```js
if (id) {
  return state.sources.sourcesText.get(id) 
}
I think i'd prefer having `ObjectInspector.js` or `object-inspector` export the type. 
this is nice, but needs some unit tests in `utils/tests/parser`
small nit, it's not to use returns and pass local state down

```js
const expr = getMemberExpression(node.object)

...

function _getMemberExpression(node, expr) {
  if (node.type === "MemberExpression") {
    expr = [node.property.name].concat(expr)
    return _ getMemberExpression(node.object, expr);
  } 

   return [node.name].concat(expr)
}

function getMemberExpression(object) {
  return _getMemberExpression(node,  []);
}
```
heh, perhaps we use and object here and use `preview` over selected

```
{
  previewExpression: {
     text: null,
     location: null
  }
}
```
indirect, but i like it
lets move this to a helper in `utils/editor/index`

perhaps: `getLocationFromToken`
I wonder how we broke this :)
nit: 

```js
return rootUrlMatch && !nodeUrlMatch
```
lets get some unit tests in here. Should be pretty similar to what we already have
wouldn't this fail for a really long line?
oh i see - that's nice. 
note: @clarkbw, @juliandescottes  
this helps with the semver versions...
Hmm, we don't have many variables. I could see adding this variable to the main editor class so that it is scoped, but not sure if that's common practice
Yep - i think this is fine. We do this in another place as well and it seems like the current practice
@AnshulMalik this is good. I agree we should be consistent in a file.
nit: how about `selectedExpression`?
@magsout I was thinking `src/components/Editor/Editor.css`:

```css
.editor-wrapper  {
  --editor-footer-height: 27px
}
```

What do you think?
ðŸ‘ 
oh nice - that makes sene
we can improve this with this nifty trick

```js
getDefaultProps() {}
```
shouldn't this be props?
i see... lets stick to props and just compute this every time we need it. Also - is there a better name for the function to differentiate from the raw value
maybe three equals `===`
what's this trying to solve?
comments really help here
actually, i'm pretty sure there must be something in:

`URL.parse` or `new URL` that would give you a hostname you could compare
ahh, i see - i think we solved this somewhere else as well :)
pushed
oh yeah - i'm not surprised... I'll look quickly
Hmm - we do this `const { parse } = require("url")` in several places
try adding `isRequired` to the prop with `getDefaultProps`
hmm... @clarkbw @gregtatum what do you think
my concern with this approach is that some click handlers will prevent propogation so this will not always work.

I think the safer thing to do would be to limit the impact of right clicking on a mask so that it doesn't show a context menu.

for instance preventDefault, stop propogation
this looks like a great util that could move to `utils/editor`... and then be tested:

```js
async getSelectedExpression(token, cm, {
  selectedFrame, pauseData, sourceText, selectedToken
}) {
...
}
```

we could also move `getExpressionFromToken` as well...


Hmm - lets talk about this API

couple of thoughts: 
* visibility is a bit vague and perhaps unecessary
* file is probably more clear than document - i.e. file search, project search
* nested values project / document could be awkward

Here's my proposal: the store has two fields `fileSearch`, `projectSearch` which could have fields: `active`, `mode`, `modifiers`

This would lend itself to actions like `toggleFileSearch(true)` or `setFileSearchMode('function')` or `setFileSearchModifiers({ caseSensitive: true })`
Hey @Dalimil can we try `parse` which is required in the file
oh nice - sorry missed that :)

this seems slightly more complicated than it needs to be. Could we also replace the `www` for the pathPart?

```js
function isExactUrlMatch(pathPart:string, debuggeeUrl:string) {
  function getHost(url) {
    const { host } = parse(debuggeeUrl);
    if (!host) {
      return ""
    }
    return host.replace(/^www\./, "");
  }

  return getHost(pathPart) == getHost(debuggeeUrl)
}
```

hmm - this seems a bit too clever because it requires the redux field to leak into the API.

It is probably simpler to have two actions types `toggleFileSearch` and `toggleProjectSearch`
I think publically we use the verb `set`

so `setFileSearchQuery`
We should translate this with `L10N`
Hmm now that i'm looking more closely perhaps we don't need to localize the unicode keys :) shift, cmd, alt...

What if we did:

```js
import _PaneToggleButton from "../shared/Button/Close";
const PaneToggleButton = createFactory(_PaneToggleButton)
```

this way we could separate concerns and still use import, and then createFactory below
lets refactor this so it's easier to test
https://gist.github.com/jasonLaster/2679e0968720a36f71b75882e80fd2ef
ðŸ‘ 
ðŸ’ƒ 
sure - this is probably fine. we can always update this later when we're using flow as well
i think `.search-bar ~ .editor-mount` might be more confusing than it's worth now that we're doing inline styles. 

How about we move that value in here?
perhaps we can now do

```js
if (shouldShowFooter(selectedSource, horizontal)) {
}

...
```

So... It's not great that we have a *magic* number here because it will definitely change.

I don't love suggesting this, but it might be helpful to calculate the heights of the footer and search bar...

Here's where we get calculated DOM dimensions elsewhere: 

https://github.com/devtools-html/debugger.html/search?utf8=%E2%9C%93&q=getBoundingClientRect&type=
I added this test to get our coverage up to 100%
I tweaked this block to:

* remove `isFunction(parent.right)` which i believe is unnecessary
* prioritize the `MemberExpression` which is consistent with the other type checks first
I've seen secondary options in a trailing options param in some other actions like `addBreakpoint` which might be nice here.

```js
addExpression(input: string, { visible: boolean = true }) {
  // stuff
}
```
Why would we want to only evaluate visible / hidden expressions?
ðŸ‘ 
hmm, i wonder if we should force `expression.visible` to be a boolean and then not worry about these other states... Flow to the rescue?
I think 50 should bumped up to 100.
`addExpression(expressionFromToken.value, { visible: false });` is clearer
hmm - lets move this to a selector: `getExpressionResult` seems simpler :)
nit: it might be simpler to keep one list and then filter the list when persisting and selecting values. It's *slightly* less efficient but will be easier when we want all expressions.
`visible` is less important if we keep expressions in one less
haha - thank you  prettier
Hmm  - I'm a bit confused by this logic. 

It looks very similar to what we're doing in search search to determine the next index. Is there an easy way we can unify it?
This looks like it can be shared too...
SearchInput could be a good component to snapshot test:

https://facebook.github.io/jest/docs/snapshot-testing.html#content
what's our preference with wrapping - next at the end and previous at  0?
This looks like a good set for now
Feel free to feature flag this while we work on the UX/UI
wow what does that do?
This could be a util: `getExpressionResult`

```js
let value = get(selectedExpression, "contents.value");
if (!value) {
   const exp = this.props.getExpression(selectedExpression.value);
   value = get(exp, "value.result");
 }
 if (!value) {
   return;
 }
```
nit: ` true` is vague `getExpressions(state, true),`  
This is a minor preference, but I think we could likely split this into two selectors: `getExpressions` and `getVisibleExpressions`
hmm, maybe we want to use `await` here which will mean the outer function `return ({ dispatch, getState }: ThunkArgs) => {` should be async. There are examples of this elsewhere
that's awesome!
oops, this change was accidental. 

We could update the eslint to be consistent, but we started using prettier on the debugger for the styling and I like the defaults that it has. (even though it's not consistent with devtools in this case)
hmm, maybe we should change this to be: 

```js
onResize: size => this.setState({startPanelSize: size})
```

it's a little clenaer
I think @wldcordeiro might recommend that we put this state in the UI state. 

What do you think?
hmm, i don't remember. 
it's a chrome message, but yea
yep. good point. this will break w/ source maps
yep :) 

It's a weird function that's only for testing.
yeah - that would be clearer
is `endPanelSize` used?
this was removed during the client refactor, which forced us to upgrade the source map worker with the bad config.
What do people think of the idea generally?
Small typo, missing a `]` to close it.
`[ninja]`s, there can be only one!  ðŸ¤• 
In general good, not sure about the Ninja part.  I like that its not `maintainers` which always sounds pretty lame.  Keep it fun!  Maybe lets keep asking around for more ideas.
yep - i think we can do better than ninja too :)
Guru. We could get like, a tranquil monk picture.

No partisanship here... :laughing: 
I like this idea, and I'm happy to help other contributors. ðŸ‘ 
But seriously I think you mean: `[ninja]:./docs/local-development.md#ninja` ðŸŽƒ 
I'm happy to help people on Slack! ðŸ‘ðŸ‘ðŸ˜ƒ
maybe we could group those 2 rules together ? 

```css
.input-expression::-webkit-input-placeholder,
.input-expression::-moz-input-placeholder,
```
I even think we can drop the `-moz` prefix since it has been unprefixed in Firefox 51 (https://developer.mozilla.org/en-US/docs/Web/CSS/::placeholder)
@nchevobbe grouping them doesn't seem to work. I tried searching for this and got a question on stackoverflow relevant to this [here](http://stackoverflow.com/questions/16982449/why-isnt-it-possible-to-combine-vendor-specific-pseudo-elements-classes-into-on) .
learned something today ! Hopefully chrome will have the unprefixed version soon too.
nit: leading zeros don't do anything. Best leave them out entirely.
Thanks. Learned something new!
The `default` here is necessary because we're using the es6 class in a non-es6 like world.  The switch to `import` and JSX would allow us to remove that.  There are also babel plugins to remove this as well but its only temporary.
this is definitely interesting to find out!
Great. I think this is a small price to pay for es6 modules and classes. 
hmm, how about `node bin/post-merge.js`
My upgrade is taking some time on my test machine. I have an icky feeling `"ORIG_HEAD HEAD"` here should be `"ORIG_HEAD", "HEAD"`. I'll test to verify once my upgrade finishes.
I think so too. I'll change it now.
The link probably needs the text `-runner` appended.
Might want to expand `OSS`
isn't this test cleaner than before :)

only one global `initDebugger`
commands extracted and shared
custom web setup here
shared utils
shared wait clauses
this will be changed
Is it possible to keep add_task/yield?
That would allow you to not have to refactor every single mochitest?
Also wouldn't it be possible to not reimplement all the deps from head/shared-head?
I would be happy to review m-c patch to help you reuse some existing code.
I punted here because of node unit test mocking
Any reason this didn't change to 
```
import { DOM as dom, PropTypes } from "react"
```
as in other places?
oops, it should
Weird that this was working before...
Why not `import { findDOMNode } from "react-dom";`?
its not needed
I've got another branch with more mocha stuff which will come later
these helpers are going to move out of `head.js` in the next PR
Wouldn't `nextProps` here always be an object with the breakpoints and editor since they're required props?
Same question here about the use of `any`
we can come back to typing props, I think we'll get there soon enough
Hmm, i'm surprised you can't do `isPretty(source.toJS())`
Good question!  Essentially `nextProps` is the `propTypes` attribute of the class but I don't really want to write it out twice.  Here are the patterns I've seen in the wild when researching this.

Use the [flow-react-proptypes](https://github.com/brigand/babel-plugin-flow-react-proptypes) plugin.  This means you create a flow type for your prop types and don't define the `propTypes` in your react class; like this:

```js
type PropTypes = {
  breakpoint: Breakpoint,
  editor: any
};
```

And then babel would compile that type into a PropType for react.  This pattern doesn't settle well with me right now.  I wonder about our plans to move to es6 classes and how well this plugin works.  

Then of course other people just define both:

```js
type PropTypes = {
  breakpoint: Breakpoint,
  editor: any
};
const Breakpoint = React.createClass({
  propTypes: {
    breakpoint: PropTypes.object.isRequired,
    editor: PropTypes.object.isRequired
},
 shouldComponentUpdate(nextProps: PropTypes) {
 }
});
```

Which is a bit of overhead but would actually type the `propTypes` correctly.  Other than the overhead I don't think there is anything wrong with this pattern.  

My ideal pattern would be to type the `propTypes` inline.  So it would look something like this:

```js
const Breakpoint = React.createClass({
  propTypes: {
    breakpoint: PropTypes.object.isRequired: Breakpoint,
    editor: PropTypes.object.isRequired: any
},
 shouldComponentUpdate(nextProps: propTypes) {
 }
});
```

But so far in other components we haven't cracked this egg.
Much better! ðŸŽ‰ 
hmm, for some reason it looks like the click is still going through.

Try right clicking on an unselected frame
mousdown probably takes precedence. that could be onClick
hmm, this looks good, but for some reason the URL is shortened:

`/localhost:7999/todomvc/js/views/todo-view.js`
instead of 
`http://localhost:7999/todomvc/js/views/todo-view.js`
we should also check to see if the source is a directory here too and not give the option to show the link address
this is great. I don't want to add the scope too much, but lets also add "Show Source" while here

[Show Source](https://github.com/devtools-html/debugger.html/blob/master/src/components/SourceTabs.js#L150-L156)

<img width="400" alt="screen shot 2016-12-28 at 10 39 57 am" src="https://cloud.githubusercontent.com/assets/254562/21525256/09f07d2a-ccea-11e6-84c0-278862ce5adf.png">

`jumpLabel` can probably be added to the array initially
What if something like:

```
if (isEnabled("copySource")) {
  showMenu(event, [copySourceUrl]);
}
```

No need for `items`
onClick over mouseDown? mouseDown covers middle clicks though.
@jasonLaster what do you think about this? I could see how it helps but it might be cleaner to add each one individually
Not sure how to fix this, the formatting of item.path is different from the others but it's probably not safe to just format item.path?
hmm, you'll have to be clever here i guess :)
@arthur801031 any ideas?

I'd start by looking at [utils/source-tree](https://github.com/devtools-html/debugger.html/blob/master/src/utils/sources-tree.js#L99)
This works:

```
const sourceURL = item.contents.get("url");
const copySourceUrl = {
      id: "node-menu-copy-source",
      label: "Copy Source URL",
      accesskey: "X",
      disabled: false,
      click: () => copyToTheClipboard(sourceURL)
};
```
Leaving as I believe this is a new issue.
Completed with isDirectory function.
I couldn't get showSource to work, currently commented out.
not a big deal
I think we need to check to see if its the selected frame
hmm, lets move `let items` and `showMenu(event, items);` out of the the condition
Hmm, it looks like `tab` and `showSource` are not defined in this function

could you add types here. See `EditorSearchBar` for event handler types.

do we need `&& selectedFrame` if we know it's required.
this was my solution to flowtype complaining about selectedFrame being possibly undefined (which is valid, user doesn't need to select a frame)
Ah. I stand corrected. Put an isRequired on selectedFrame
I just realized, does it make sense to have showSource in the Editor? We'd already be on the correct document when the context menu comes up (assuming showSource literally just shows the source of the file)
@jacobjzhang the label and accessKey need L10N as well
Ah, just realized where these were coming from. It feels pretty magical using `this`, but is probably fine if it's an intermediate step. At least I have an entry point to know where the magic happens.
This test feels nice and self-contained, without the typical noise from mochitests.
Are you thinking of every mochitest being a trivial manifest like this to run to require and add the task?
nit: whitespacing
nit: whitespacing
A small comment intro would be appreciated here about why this file exists, it's not immediately obvious.
And again here, a small comment would be nice.
I'll get to this in another cleanup step. I'd like to better document these files holistically
Looking good.

1. does this fix the problem, my fear is that getSources will make one call for the sources, but it won't trigger `nweSource` by itself
2. i think we can refactor this code a bit to make it more consistent with `util/client`

https://gist.github.com/jasonLaster/de3bd2ecbacaf7518c42336e199d5137
https://gist.github.com/dde3f2cd62733746e562f9d6acd48e76
 
Goal:
1. add a new firefox client command for fetching sources
2. add a `timeout` helper so we can do it with async/await
3. call `newSources` in this action which i think we need to do
I got this error, which I thought it's fine to disable it.

<img width="609" alt="screen shot 2017-02-01 at 12 49 48 am" src="https://cloud.githubusercontent.com/assets/4562118/22475642/91e5cf00-e81a-11e6-86b4-8b46117595bf.png">

hmm, maybe we want to change the function name to `waitForMs`
We have a slightly nicer style here:
https://github.com/arthur801031/debugger.html/blob/update_source/src/actions/pause.js#L45-L48

Markdown pro-tip! You can just define `[L10N]` at the bottom instead of creating the lowercase `[l10n]` alias and then here simply use `[L10N]` without anything else.
this doesn't feel great, but i have a feeling i can do better in the next phase
I don't love this DI style, we hopefully can get this file priviledged like `head.js` with the proper permissions
my fear here is that it's a memory leak. Also, ugly... but perhaps we can do something in another pass when we're cleaning up
is there benefits having this function as `async` since it doesn't use `await` (same for the following functions) ?
nit: formatting feels a bit weird here , what do you think of 
```javascript
function togglePauseOnExceptions(
  dbg,
  pausedOnExceptions,
  ignoreCaughtExceptions
) {
```

could we simplify this into `return url;` directly ?
is `dbg.getState()` different from `state` ?
nit: s/then/than
probably not... but i don't want to mess with it because we are only using this in one test now...
Slightly simpler?

```js
function wholeMatch(query: string, wholeWord: boolean): string {
  if (query == "" || !wholeWord) {
    return query;
  }
  
  return `\\b${query}\\b`;
}
The case sensitive flag is only useful with `cm.getSearchCursor` when the query is a string, if it's a regex then it's an ignored argument.
The counts weren't updating properly before.
i'lll need to fix this

this needs to be aliased...
this needs to be fixed so that mocha's invoke does the invoke
we likely need to clear prefs...
oops
gotta get one of these to work,
ooh nice, why is this needed? because it's a declaration?
Frames was moved to index and Frame was pulled out
Smaller and focused on handling frame lists
lots of tests :)
just adding more flow coverage
needed this because Frames depends on launchpad which wants DebuggerConfig set

yes this is ugly plane code, but it passes tests and we can fix it up another time :)

unless you can help me do better
I should add the remaining reducers
oops
I should make sure this is imported
adding babylon types
adding pref types is really helpful
yeah - i think that's right :)

@thejameskyle did i get it right?
adding static props in the class definition. I'll add that
true, I'm finding that now...
Yes - there are. We should file bugs based on some of these next steps
ðŸ‘ 
I like this style
perhaps `sourcesState` or is that too opaque?
does this negate the selector?
nit: `getSourceByID`
we should have a separate URL to ID mapping 
Yeah - the underscore was meh when it was a private function, but below it's public... so i don't love it
switches from proptypes to props
flow doesn't know that we'll have a source in the tab list...
how about reset your branch to master:
1. `git fetch origin`
2. `git checkout master`
3. `git reset --hard origin/master`

Then update your node modules: `yarn nom`
Then restart the local server `yarn start`
we can remove this if we don't have tips
it *is* nice to see module state going away
the next step is to look at the expression and see if its value is undefined too :)

don't worry, we'll be cleaning this code up soon :P
I think we should try writing a test for this: 

here is the test file: https://github.com/peterschussheim/debugger.html/blob/dont-show-undef-latest/src/utils/tests/expression.js#L5-L31
I think this would be better if I bound the function and then just passed it in...
not sure where this is coming from but prettier is clearly favoring this cleanup
hmm - i think we can take advantage of `postcss-bidirection` here

https://github.com/gasolin/postcss-bidirection#absolute-positioning-example
oy, thanks
neat! much simpler
Lets use the `Source` or `SourceRecord` type here 
hmm - i think you're using an older version of prettier
hmm, me too. I don't get it. I'll merge and we can see what's going on later
We now have webpack!
We should be a bit stricter here because we only want the webpack domain path to match and not other paths
Hmm, I think it is nice to keep `Svg` just about loading SVGs and move this logic to SourcesTree. There will be other cases where we want to show a webpack icon too
this is now available below.
generally we destructure our props so that it is clear what our `this` deps are in the func

```
const {selectedSource, selectSource} = this.props;
```
Either approach is fine. We're generally prefer function references when there are no params`map(this.renderFunction)`, but we don't lint for it and either is fine.
perhaps we also have a `generateSymbolDeclaration` factory as well so we can have the defaults in there
could we pass selectedSource in when we initially render the component? 

Perhaps not based on how we're fetching the symbols, which is a shame i suppose. And if that's the case, we probably move symbols to a reducer so that we can have the symbols passed down alongside the source :) (we can do this in a new issue ofcourse)
we can simplify because we don't need the client here:

```js
return {
  type: constants.HIGHLIGHT_LINES,
  location
}
```
when will this be null?
perhaps location will be null if we're clearing the range?
we've started using Props instead of PropTypes, check `Frames/Frame`
perhaps we do `this.props.clearHighlightLineRange()` which simplifies the API a bit
just confirming, we want to jump to the location when you click a function result or press enter. We want to highlight the function when you iterate through the results with your arrow keys or clicking the next / prev button.
this could be one line `lineRange = {start, end}`
we should use a feature flag here: `collapseFrame` so that we can turn this feature on later

```js
isEnabled("collapseFrame")
```
lol
is this still used?
we need to update this before we merge!
this is helpful to support some issues in node and does not generally affect the browsers
this was related to the babel plugin, which now transpiles devtools-reps which had a trailing comma :)
we can simplify this fixture later
I think we can move this setup into a shared util as we add more examples
I think we do. This means that we do use babel on `devtools-` projects
yep - it's a sad but necessary pattern for now
my bet is that this should be `undefined`.

Here's the failing test. https://github.com/jasonLaster/debugger.html/blob/preview-story/src/actions/tests/ui.js#L15-L22

You can run it with jest. `jest src/actions/` and make changes to debug it :)
I think we can pull in types from the reducers here: `Source`, `SourceRecord`, or `SourcesMap`... 
perhaps here too...
wow, does this work?
`column ? `:${column}` : ""` is a bit hard to follow. Can we pull this up to a local variable?
We don't. I just made the PR. The test shows the issue though. Objects we want to create a map for can have the field `hasOwnProperty`
This is similar to what we do with symbol paths below.
I think this would be nicer in the UI reducer as it has more to do with some UI state. 

Also, we should probably include a sourceID so that we can automatically clear this if the user navigates to another source.
nice find
I suppose, that the keyboard shortcuts work :P 

otherwise awesome
Yeah - lets use the same types as the reducer
so that's how it works :)
we need to have unique IDs.

I'm not sure how much this API buys us actually. Perhaps, we establish a convention where we give it a label, and it can make an ID and accessKey?

// devtools-modules/src/menu.js
```js
export function createItem({label, disabled = false, click }) {
  const id = `node-menu-${kebabCase(label)}`

  return {
    label,
    id,
   ...
  }
}
```

https://lodash.com/docs/4.17.4#kebabCase
this could be a nice general purpose helper for mocking a menu item.

With that said, I'm concerned we might be testing too much here. For instance, in this case I'd be happy to just check the IDs are what we expect:

`expect(items.map(i => i.d)).toEqual(["joe", "bob", "dan"])`, this tells us that the menu has the correct items and we can later test other properties that might be important like conditional disabled states...
What is the benefit of mocking L10N? I'd prefer including it because it will give us sensible english :) 

If we change the props then our snapshots will change, which is kinda cool
I really like this pattern your setting up
I don't feel strongly here, but I feel like testing the args is adding too much coupling. My concerns would be 

1. does it get called
2. does it return some menu items.

testing the communication seems like we could be introducing brittle tests...
damn - missed this. CM is not great, but it's not terrible in context :)
lol - good catch
do you think `hasOwnProperty` would be nice here? it's a tad more explicit
this makes me think we might want to use a JS `Map`... We'd have a slightly nicer API
expressions now use `props`
nice
I'd like to try keeping this an Immutable map, but just not hydrating the pause data.

I can jump in and look tonight
why is this changing? 
that's what i was thinking, but I'd like to go through and add them to all the files and it's easier to be consistent :)
this is defining a variable :)
hmm - we could, but it's a story so i would prefer to keep the styles here so it is clear. 

We have a stylesheet for another story, so we do it both ways
here's the css for another story: https://github.com/devtools-html/devtools-core/blob/master/packages/devtools-splitter/stories/index.css#L14
We're using `props` here
I bet we can simplify this further too: `formatMenuElement("copySourceUrl", () => copyToTheClipboard(url))`
we have support for `getFormatStr` but I try to avoid it as it makes it more complicated. i.e. "Disable" wouldn't be translated here. more over languages are hard:

```js
const key = frameworkGroupingOn ? "framework.toggleGroupingOn" : "framework.toggleGroupingOff"
formatMenuElement(key, toggleFrameworkGrouping)
```
ðŸ‘ 
We discussed this earlier, but i don't think you gain anything from stubbing this out. i.e. we dont really want to assert calls to it. and in general it will just work when it's not stubbed...
ðŸ‘ 
that's a good point
I like it being separate because infering names is a special use case
this is a valid approach, but we often just choose not to render a component too :)

i.e.

```js
if (! symbolSearchOn) {
  return null;
}
```
the issue was that we were filtering before we had sources to filter out the blackbox data from
switched to a new const.

@codehag think you'll approve
exporting this function so we can exercise it in the test.
dropping this data which is not needed
Yep this makes sense. I bet we can better type state and not have these issues :)
hmm - maybe we should use `actionVal` here to be consistent.
we're ignoring the fixtures because the code is terrible lol
good call we can move it to a better spot
haha - this could *is* weird
that's tough to say. the other cases are obviously really important. We probably need better docs
so... i dropped the extra scope. don't know what to say about do/while. it terminates w/ undefineds lol... crashed my browser once though


heh - i don't follow
ðŸ‘ 
Hmm, I think we should probably have a new action `clearSelectedSource`... Also, is the ID used later?
i think this would be simpler if we had `clearSelectedSource`
this is a great cleanup
oops - the console's should be gone
hmm, i like questions... am i missing something
yeah - i don't know what it does either :)


yeah... 
I removed the accesskey param because it is identical to the menu item string, but w/ the `accesskey` suffix
why export them?
i say go for it. It's really helpful and we should be typing all the files
lets move this to `client/shared/addCleintBreakpoint.js`
lets kill `getTextForLine`
Hmm, what if we changed this to be `_getGeneratedLocation(sourceMaps, breakpoint, source)`

* we change `_getSourceLocation` to `_getGeneratedLocation` to be more clear
* we pass in source instead of state
* we get location from `bp` because passing in location separately is confusing
the snapshot is great because we don't care what the symbols are. jus that they're sensible
@bomsy I like this solution because the reducer is an I.Map, the symbol field is an I.Map, but the symbols are just objs... maybe it's not a big deal bc people could still mess with them, but it feels better lol
I should bale if we don't have the source text
can we clean this up:

```js
function initialState(): BreakpointsState {
}

```
i think our tests were testing the wrong things :)
Could the props be here?
Not sure if this needs its own file. Will look for other homes for it later 
Got it. You're one step ahead of me. 
cute :)
I'm a bit confused, so I'll walk through the bug and two workflows as I see them. I could be missing something, it could be what you're already doing too.  I'll outline a simple case and syncing case for both workflows. To be clear, we can do the simple case and fix the bug.

#### Bug

1. User is working on an app that uses source maps (i.e. namely bundle.js w/ file a.js, b.js, c.js)
2. User debugs the app and adds a bp to b.js line 12, with the generated location bundle.js#45
3. User adds code to a.js 
4. User reloads the app and see the debugger paused on b.js line 4, which happens to line up with the generated location bundle.js#45!

We will fix this, either simply moving the breakpoint to b.js line 4 when the debugger reloads or ideally re-removing the breakpoint at line bundle.js#45 and adding a breakpoint at the new location...

--- 

#### simple case

1. User adds a Breakpoint

  * addBreakpoint is called with an original location 
  * generated location is calculated based on the source's sourcemap
  * a pending breakpoint is added with the generated location

2. User reloads page / User re-opens debugger

  * breakpoints reducer adds pending breakpoints 
  * newSource is called and the debugger attempts to sync the breakpoint
       * checks if there is a pending breakpoint
       * uses the pending bps generated location to recalculate the original location
       * adds a new breakpoint to the store


---

#### syncing case

1. User adds a Breakpoint

  * addBreakpoint is called with an original location 
  * generated location is calculated based on the source's sourcemap
  * a pending breakpoint is added with the generated location

2. User reloads page / User re-opens debugger

  * breakpoints reducer adds pending breakpoints 
  * newSource is called and the debugger attempts to sync the breakpoint
       * checks if there is a pending breakpoint
       * uses the pending bps generated location to recalculate the original location
       * **if the new original location is different from the pending breakpoint original location**
          * removes the old breakpoint on the server
          * adds the new breakpoint to the server
       * adds the new breakpoint to the store

how do we know we have an ID? the pending bp doesn't have an id
i probably should rename this var :)
select source did get a bit more complicated, but i think it is better now. i.e. we want to know when we're done selecting the source...
yeah - it was weird. it only happened for empty arrays of functions....
ahh nice
ðŸ‘ 
meh... it looks weird, right
hmm, i guess i should. was being cute :)
this can be moved to `utils/utils.js`
2 things:

1. I think we should do this in `firefox/commands.js#onNewBreakpoint`
2. `onNewBreakpoint` should be moved to firefox/create#createBreakpoint

The rationale for this is to give us consistent data from the server... we did the same thing for source URLs when we worked on pending bps
Lets add a function comment, we don't typically have comments but we should lol
minor style nit, but i move actiony things to options i.e.

`syncClientBreakpoint(source, pendingBreakpoint, location, {client, sourceMaps})`
this seems weird to me... can you explain the rationale
It's not really clear to me if you need location because it's a composite of many things
can we move this try/catch to the firefox/commands side?


why do we need to talk to the server if it's disabled, i think that means that the server doesn't have a bp?
I think it might be nice to keep the schema version private so that we only manage it here...

```js
if (prefs.debuggerPrefsSchemaVersion != prefsSchemaVersion) {
  prefs.clear()
  prefs.debuggerPrefsSchemaVersion = prefsSchemaVersion
}
```
nit: not sure if we need the _. I think everything is assumed to be private
it's weird that generatedLocation and location are different line numbers
might be nice to have a snapshot of `returnedBp` here as well
maybe `console.warn`...
I think `updateObj` has outlived it's purpose.
I'd also try to be more aggressive about what we want to do.

```js
function updateBreakpoint(state, newBreakpoint, oldBreakpoint) {
  const id = makeLocationId(newBreakpoint.location)
  state.setIn(["breakpoints", id], {
    ...breakpoint,
    ...overrides,
    loading: false
  });
}
```
perhaps: `depth * 15 + (nodeIsPrimitive(item) ?  15 : 0)` to be a little cleaner

nit: now that we've simplified this I think we can inline everything 

`dispatch({ type: SYNC_BREAKPOINT, [PROMISE]: syncClientBreakpoint() })`

we can also inline this action too i think
```js
function clearPrefs() {
  prefs.pendingBreakpoints = getDefaultPref("pendingBreakpoints");
}
```
I think you can get the default for a pref.
we should move this to a separate render function
I think the comment before covered a *special* case that we no longer are concerned with. I am not sure if I have something that I want to say here except that we're adding source fields :)
yeah - these are throw away styles. I think something BEM like would be better
oops, i'll remove it, but these are throw away as i was quickly sketching
ðŸ‘‹ 
I like treating actions as the public interface here:

here's an actions/tests/ui test
```js
  it("should toggle the visible state of project search", () => {
    const { dispatch, getState } = createStore();
    expect(getProjectSearchState(getState())).toBe(false);
    dispatch(actions.toggleProjectSearch());
    expect(getProjectSearchState(getState())).toBe(true);
  });
```
now that WhyPaused is a child of Frames, it would be nice to pass pauseInfo down `WhyPause({ pauseInfo })`. This means we no longer need to have the connect logic in WhyPaused too :)
```diff
diff --git a/src/components/SecondaryPanes/WhyPaused.js b/src/components/SecondaryPanes/WhyPaused.js
index 5741743..d96978d 100644
--- a/src/components/SecondaryPanes/WhyPaused.js
+++ b/src/components/SecondaryPanes/WhyPaused.js
@@ -23,7 +23,7 @@ function renderExceptionSummary(exception) {
   return `${name}: ${message}`;
 }

-class WhyPaused extends Component {
+export default class WhyPaused extends Component {
   renderMessage(pauseInfo: Pause) {
     if (!pauseInfo) {
       return null;
@@ -66,10 +66,3 @@ WhyPaused.displayName = "WhyPaused";
 WhyPaused.propTypes = {
   pauseInfo: PropTypes.object
 };
-
-export default connect(
-  state => ({
-    pauseInfo: getPause(state)
-  }),
-  dispatch => bindActionCreators(actions, dispatch)
-)(WhyPaused);
```
oh, i think this is a good "model" test
agreed, it's prettier tho
probably not. that can be tweaked when we have a function search modal :)
that's a good idea. I took it a couple step further lol.
ugh, this is an evil case. if we're clicking on a column breakpoint then we want to remove the breakpoint on that column. but we can cross that bridge when we get there
hmm, this seems a bit out of date given what we're doing now. Maybe we want it to be: `setEditorSearchType` and that can include text
we're matching on the frame URL so there won't be any whitespace :)
did a bit of clean up while i was in the worker code
ooh, we an use export directly and avoid the module.exports... yay
decided to drop some sourceText refs while i was here
this method was not helpful :)
this fixes a bug where source wasn't getting these field because it couldn't merge w/o an id
this actually should be this way **becase** we're testing the weird behavior :) We want to make sure we find those vars too :P 

@ruturajv did this i believe
I think it's nice to have it for now. It's easy to take out and tweak later
Perhaps:

> similar to running Mochitests (our integration tests)
lets link to docs: https://developer.mozilla.org/en-US/docs/Mozilla/Developer_guide/mach
I'd rather people learn about edge cases there!
should we mention clobber?
lets leave out the `npm` flavor. I think we should expect people to be able to convert btw the two
`yarn`
wherever
yarn
It might be nice to move`## Running Nightly with the local debugger` up higher. 

I could see moving some of this extra info to an Appendix, which gives people extra info without distracting them from the primary task, which is seeing their version of the debugger in FF!

this was the main thing that I wanted to get out of this PR. previously we were checking the parent's class which required always doing an expensive render. We should be ideally using data which is more trustworthy.
`this.editor.codeMirror.operation` is a huge perf win. With that said, i'll be moving the operation inside `clearLineClass` soon :)
i'm re-adding a feature flag because i'm not happy with the cases we're missing like blocks and comments. Seeing those issues makes me think we should wait and re-launch highlighting when it's further along. 

With that said, we still get the onMouseOver logic so fewer accidental popups
this is the first selector that spans stores (sources, ast) with that in mind I created a new selectors directory. I'm not sure if that makes sense. What do others think?

some small `sourceText => source` migrations
I switched the test to read from a new fixture file :)
I added the ability to do line reviews
yeah - so this is coooool. Turns out many of the dispatches are unnecessary. 
we're now tracking in-scope and not out-of-scope. 

some reasons:
1. it's easier to get the lines in scope than all the lines that are out of scope
2. it should be faster because there are fewer innies than outies.
this fixes #3123
sadly... no because then we pull lodash into the bundle... I suppose if we made it an external then we could exclude it from the bundle and expect it to be available in m-c... If we like this i can file a separate issue for it.
agreed :)
I can do both. when it is not available it's nully.
... not sure. i kinda like having explicit empty states to distinguish between nothing and we happen to have no out of scope locs. ill think about it
yup: https://github.com/devtools-html/debugger.html/blob/master/src/client/firefox/create.js#L34
Hmm - happy to try. I kinda like framing the line and highlighting the relevant section, but I bet there's more we can do too
this is a race condition where we don't have a selected source, but we had one prior... It's a small fix that came from some fast tests.
oh interesting, why does this need to be a component over a function?
We're now using props, which is flow based.

Checkout https://github.com/devtools-html/debugger.html/blob/master/src/components/Editor/Footer.js#L25-L35
we can always test more invariants like bps, search state... but I prefer a minimal test that correlates with the behavior. We should to more tests on the unit side
yeah - that's fair
ðŸ‘ 
we should try and avoid this. How can we use the redux store?
I feel like we should break this up so that we have smaller functions for these different scenarios.
I like the term visible, but I think `selectedSourceId` might be more consistent in the short term
perhaps we don't render the debug line without a selected source?
It might be nice to move this function to a helper: `getSearchIndex(currentPos, matchedLocations)`
could `matchedLocations` be `matches` with a type definition that makes it clear what is stored?
we might want to add this function to the search worker so that it never slows down the main process:

```diff
diff --git a/src/utils/search/index.js b/src/utils/search/index.js
index 2ec930c..fcb55bb 100644
--- a/src/utils/search/index.js
+++ b/src/utils/search/index.js
@@ -6,3 +6,4 @@ export const startSearchWorker = dispatcher.start.bind(dispatcher);
 export const stopSearchWorker = dispatcher.stop.bind(dispatcher);
 
 export const countMatches = dispatcher.task("countMatches");
+export const getMatches = dispatcher.task("getMatches");
diff --git a/src/utils/search/worker.js b/src/utils/search/worker.js
index dbba6c1..75f7b2c 100644
--- a/src/utils/search/worker.js
+++ b/src/utils/search/worker.js
@@ -1,4 +1,6 @@
 import buildQuery from "./utils/build-query";
+import getMatches from "./getMatches";
+
 import { workerUtils } from "devtools-utils";
 const { workerHandler } = workerUtils;
 
@@ -14,4 +16,4 @@ export function countMatches(
   return match ? match.length : 0;
 }
 
-self.onmessage = workerHandler({ countMatches });
+self.onmessage = workerHandler({ countMatches, getMatches });
```
looks reasonable to me
we should remove the column breakpoints code here and the component
lets add the column bps feature flag here
lets move `onKeyUp` and `onKeyDown` to CallSites because we can :)
others might handle this too so perhaps we dont want to stop propogation
this should be in its own call-sites css file
this should be in its own helper
i'm not sure if this helped... lets look at the perf here. Maybe not a blocker, but nice
we should exclude member expressions cause... well you know
sure
I see, perhaps we want to encapsulate some of this knowledge into the component so it knows what to do... 

What if we passed the selected source in and DL checked to see if it was loading? If it's loading we don't highlight...
switching from the verb toggle to set because we have more than two now: Project, source, file, symbol
moving source search into its own component will untangle a lot of this code
so... this wasn't used :)
ProjectSearch now is a coordinator, it just decides which search UI to show and will eventually have buttons to switch between them
I'm a bit confused by why we need `symbolSearchResults` and `searchResults`
why do we need `toggleProjectSearch ` and `toggleActiveSearch`?
ðŸ‘ 
it looks like we might be getting the member expressions and not the call expressions with this change?
if we don't intend to update the state, it shouldn't be an action. We can just as easily pass in `getState()`
I personally prefer the style `["stepOver","stepIn",].includes(type)` or `type == "stepOver" || type == "stepOver",`
lets drop the nesting and make it a guard:

```js
if (!isAnAsyncFunction(path)) {
  return;
}
```

NOTE: we need a new helper :)
we should clean this up with a `findFunctionStatement` helper or something like that.

I'd opt for using lodash `find` or some other search function.
big picture, i'm wondering if we can drop this analyze function in favor of some smaller utilities.

* **getPauseLocationNode(state)** knows how to get the pause location and call getClosest path. 
* **removeHiddenBreakpoint** knows how to check for a hidden bp and remove it on pause.


you're currently using `getClosestPath` directly by requiring it. Unfortunately, we need to do the search on the parser worker, so we'll have to move some of these methods to the worker.

here are some [docs](https://github.com/devtools-html/debugger.html/blob/master/docs/local-development.md#adding-a-task) on adding a new worker task.

I think we'll need to add tasks like `isAwaitExpression` or `insideAsyncFunction` to the worker. We could avoid this if those helpers could use a babel node. The distinction is that Nodes don't have prototypes. Paths do.
minor thing, but i think it would be nice to have `addHiddenBreakpoint`
I think we could call this `asyncCommand` to be parallel with `command`
take a look at master. We removed this stuff when we added the search modal.

Must just need a quick cleanup
just had to turn it on
yup, not being used...
perhaps there's a better way to keep this dummy data...
I like the pattern of splitting out the editor children components. The separation makes it easier to follow

@asolove @codehag 
This is important for making sure that we're updating the correct codemirror document.
I should include a quick description
There should be a quick comment to explain how this is used
not sure why this changed :/

It is probably alright though
this is a nice clean up
i love these cleanups.
yeah - that might be a nice cleanup in a separate PR.
This will get the breakpoints for a file at the "correct" location regardless of original / generated
oof. We will definitely clean this later :)
this is a huge speedup
thinking about switching to local state because the state is only specific to the modal.
I think it would be nice to keep addBreakpoint together for now. That way we have more flexibility in the future.

```js
export function addBreakpoint(location: Location, condition: string) {
  const breakpoint = createBreakpoint(location, { condition });
Â  return ({ dispatch, getState, sourceMaps, client }: ThunkArgs) => {
     // option 1: inline addBreakpoint
     const state = getState();
     //...

    // option 2: call addBreakpoint
    return addThunkBreakpoint(getState, client, sourceMaps,  { breakpoint })
  }
}
``` Â 



also, perhaps the filepath is `actions/breakpoints/addBreakpoint.js`


looks like we weren't testing the other tests because of the fit.

We should lint for this.
moving `dom.div({ className: "debugger" },` to the outer render
moving the modal to the top so the mask can cover the entire app
i suppose we can't use a similar `toSourceLocation` method here because of the strange column offset...
lets pass the selectedSource down if possible. I think that would be a little more useful
this is going to move after a rebase
* can we look at `source.isWasm` here instead of `typeof sourceText === "string"`Â 
* perhaps move this to a helper `utils/source`
can we move much of this to `utils/editor/wasm`

```js
function renderWasmText(editor, sourceId: string, wasm: any) {
  const lines = getWasmLines(souceId, wasm)
  let text = { split: () => lines, match: () => false };
  editor.setText(text);
}
```
can we move `isSourceWasm ? { name: "text" }` to `getMode`?
`hidden: false` should be the default: 

`dispatch(addBreakpoint(location, { condition }))`
`astCommand`
maybe we're thinking about this the wrong way. If we're only going to have one temporary breakpoint, perhaps we want a different breakpoint field in the reducer like `pendingBreakpoints`.

I propose we add a `steppingBreakpoint` which does not appear in the UI... do you think that would be easy? we also don't need a pending breakpoint for this case.
nit:

```js
return {
   sourceId: position.sourceId
   line: nextLocation.line,
   column: 0
}
```
it would be nice to have unit tests here too.
i took this test out because I've already spent too much time on this issue.

I'd like to come back though and add proper unit tests
focusing
lets change `pendingJumpLine` to `pendingJumpLocation`
Lets move the `selectedSource` higher up. 

```js
if (! selectedSource) {
return 
}
```

we can do the same thing in `onToggleBreakpoint`
this is not a memberExpressions, maybe it should be an identifier?
we should add a test to `fixture/expressions`
we probably need an explicit order here to prefer more specific types like `member expression`...

Or not if the start/end loc help out
column bps should be turned off by default :)
it's great to see a lot of code go away
lots of helpers are no longer necessary 
simplified language to `x` and `newX`
i think this method is the source of a lot of client miscommunications because the bpClient cannot be found if the location has changed.
i don't think we should show the column if we're not doing column bps
it's great to see both `pendingBreakpoints` and `breakpointsDisabled` go away. Both are now simple selectors
this cleanly fits our update pattern now
this can easily use update too
I think deleting these helpers makes it all worthwhile
I like adding reselect here to avoid expensive recomputation
this is now responsible for updating bp prefs. it can do more things later if we want.
some of these helpers were duplicated
we were toggle the breakpoints pane on toggle all clicks...
NOTE: I'm happy to follow the POJO rest pattern here.
these assertions only run in development and are really helpful for catching the many inconsistencies in data that we had
perhaps `project-text-search`
perhaps:

```js
for (const source of validSources) {
  const matches = await searchSource(source, query);
  dispatch({ ya da ya da });
}
```

This strategy will let us defer the work to the worker. each search will be a new worker call and will wait for the response to come back...


another option would be to move this to the searchSources action... 

the advantage is that we always do it before we search. often it will be very fast... and then we know we have everything to search
ðŸ‘ 
we might need to have the source id here too
minor thing, but `clear` is being used in other places `clear_query`
perhaps `action.result.sourceId`
lets expose I `state.search.get("results")`
we're now setting sources because you can't add a breakpoint without a corresponding source. This is important because we want source level information in a bp like sourceUrl and sourceId
this is already in m-c
there's a getter on the targets that we can use
Just added an issue for attaching to the console when the worker target is created.

https://bugzilla.mozilla.org/show_bug.cgi?id=1382302
Immutable lets us compare items and see if they change `list.get("id") === list.get("id")`
perhaps we want to do something to disallow new searches while one is going on?

I do this with preview, by having an updating state: https://github.com/devtools-html/debugger.html/blob/master/src/reducers/ast.js#L21-L22
perhaps `sourceId`
hmm - does this need to be updated?
smart ðŸ‘ 
i think we should stay consistent with the search type and call it "sources"
hmm - what do others think I like this new name.

If we change it we should bump the key to `sourceSearch.search2`
haha - they're not, but the parser doesn't care. it's just doing a `...` rest operation
should be `projectTextSearch`
should be `projectTextSearch`
moved some helpers above the render calls
killing unnecessary checks.
perhaps a slightly different signature. 


```js
const supportsWasm = !!debuggerClient.mainRoot.traits.wasmBinarySource;
createSource(source, { supportsWasm }))
```

The rationale is that when devtools moves to github it will be easier to add a `supportsWasm` function in debuggerClient.

moved tabs to their own file
It might help if the wrapper and modal were siblings. This way the modal could animate onto the `<body>`.


we should avoid having a div overlaying the window at all times.

another strategy might be to use z-index: -1.
oh wow, nice!
we can't assume it's 29px. it's possible that the gutter will be wider because the file has 3/4/5 digit line numbers
We should figure out why the gutter is set to width `1px` https://github.com/codemirror/CodeMirror/blob/master/src/display/update_line.js#L112-L121

My guess is that we're updating the gutter while the element is detatched or the document is not visible.
I would prefer passing a smaller options object in: `{ supportsWasm: bool }`. This will keep the interface smaller and more flexible
small style knit

```js
const supportsWasm = debuggerClient.debuggerClientTraits.supportsWasm
sources.map(source => createSource(source, { supportsWasm }));
```
```js
const supportsWasm = debuggerClient.debuggerClientTraits.supportsWasm
actions.newSource(createSource(source, { supportsWasm });
```
lets also have a snapshot here so we can get some regression testing on the children
nice
why is the timeout necessary? 
ðŸ‘ 
oh, surprised we didnt have this
lol - this could have easily been `. secondary-panes.sticky-commandbar`, but you wanted to go all BEM on us :)

I'm okay with this, but just being my morning snarky self :)
we can drop the prefixes because we have autoprefixer on:

this is the output w/o it
```css
/* Utils */
.vertical-center {
  top: 50%;
  -webkit-transform: translateY(-50%);
          transform: translateY(-50%);
}
```
it feels funny to have the class without a user though...
lets keep `offset-inline-end`
autoprefixer + vertical-center could help
perhaps `showSadFace`
`noNegativity: false` this is too hard on the brain
this should be changed to `sourceSearch.noResults2`
perhaps, `shouldShowErrorEmoji`
can you update the storybook stories with this new field?
this is the only code change
switched to explicit exports

I propose that we go with a slightly different option. Instead of only searching a portion of the string, lets stop searching entirely.

```js
if (!checkLineLengths(lines)) {
  return []
}

function checkLineLengths(lines) {
  return !(lines.any(line => line.length >= 100000))
}
```

What's the advantage to this approach? If we bail early the UX will be:
1. codemirror shows the current match and next/previous still work
2. the search summary is blank (old debugger didn't show the sumary 1 or x)
3. it's ofcourse fast
4. it's honest - i'd hate to say there are 3 matches and actually have 5 in codemirror


we can come back and support summaries in this case later
is this the preferred style?

perhaps? `ref: c => (this.$input = c)`

it's funny, i prefer refs because their namespaced, but i'll support anything.

Also this style is fine w/ me too
https://github.com/devtools-html/debugger.html/blob/master/src/components/shared/Autocomplete.js#L51-L53
nit: but lets put `this.props.enabled` first
we might be playing too much of a dance w/ enabled, perhaps a new method is in order:

* we dont need enabled prop
* we can consolidate logic

```js
isEnabled() {
  const {activeSearch, selectedSource} = this.props
  return activeSearch === "symbol" && selectedSource
}
```
yep, that will work!

i guess i was assuming it because the next action is typing... and it will work or fail based on that, but i don't care. this is nice to have.
is this the preferred style?

perhaps? `ref: c => (this.$input = c)`

it's funny, i prefer refs because their namespaced, but i'll support anything.

Also this style is fine w/ me too
https://github.com/devtools-html/debugger.html/blob/master/src/components/shared/Autocomplete.js#L51-L53
nit: but lets put `this.props.enabled` first
we might be playing too much of a dance w/ enabled, perhaps a new method is in order:

* we dont need enabled prop
* we can consolidate logic

```js
isEnabled() {
  const {activeSearch, selectedSource} = this.props
  return activeSearch === "symbol" && selectedSource
}
```
yep, that will work!

i guess i was assuming it because the next action is typing... and it will work or fail based on that, but i don't care. this is nice to have.
hmm, this worries me because we might be doing too many `on` calls.

Should we add a check in here like `!props.enabled && nextProps.enabled`?
i prefer `$` if we do the property style. I still like ReactDOM.findNode or `this.ref` as well.
I bet we can add postcss.config.js to the list of exported files and avoid this:

https://github.com/devtools-html/devtools-core/blob/master/packages/devtools-launchpad/package.json#L113
at this point it would make sense to do `addBreakpoint({location, condition, hidden})`
does `async function` work?

If so, can we add an `await` here. I'm guessing no because I bet the `Promise.all` was a hack lol
this reads really well!
what do you think of moving `remapBreakpoints` to `actions/breakpoints/remapBreakpoints`?
could we do:

```js
const prettySource = await dispatch(createPrettySource(sourceId));
```
how about we add two more tests 
1. also has breakpoints mapped
2. also has selected location mapped
rebasesss
it's now in modal.css
we should clear this field when it's done.
thanks
lets add some jest unit tests to demonstrate that command is set and then cleared when the command is done.

I think we can do something like:


```js
it("lala", async () => {
  let resolve = null;
  const slowClient = {
     stepIn: () => new Promise(_resolve => {resolve = _resolve})
  }
  
  await actions.paused()
  actions.stepIn()
  
  expect(isStepping(state)).toBeTruthy()
  resolve();
  expect(isStepping(state)).toBeFalsey()
}
```
We stopped highlighting lines on debugger open last week.

I think we *do* want to highlight lines when we jump from the console, but it's not a trivial fix so i'm taking the test out now and will revisit later.
same as below. the test is temporarily duplicated because the web version was more intermittent in debug builds...
good call
What's the rationale for moving this to bootstrap? I was thinking of doing the same thing, just curious.
lol
I thought it was helpful to see both bootstrap and teardown in the same file. For example with this change, we need to use the same Firefox conditional for the source map worker. With it all in one file, it's easy to see they work the same way.
should this use `await`
ðŸ‘ 
ðŸ‘ 
yeah - this will be tough, the way we're doing it now. But that is okay. This will just be a no-op in the context menu.
ðŸ‘ 
ðŸ‘ 
Hmm, probably so since it goes through the worker messaging. I'll update it.
I think we can change this to `export default class SearchInput extends Component {` and remove the last line (which has export statement).
I like that idea!
Lets do a new PR where we change all of these cases
I think we can do `exports default Breakpoint`.

Check other examples for something like this
could we do 

```js
let scope = null
```

and then below:

```js
scope = resolveScope(path, frame.location);
```
why `if (!expression) {`
hmm, could we get to this point? we should always have a scope, no?

```js
const inScope = nodeContainsLocation({ node: scope.node, location })
```
destructuring ftw 

```js
const { expression, inScope } = await resolveToken(
```
could we bail early?

```js
if (!inScope) {
return;
}
```
There's no need to continue looking for an `expression` if we've found one, right? Maybe I'm misunderstanding how the AST traversal happens, though.
Sure. Do you prefer all the variables declared at the top of the function?
We should. I'd assume there would always be a `Program` scope but I was being defensive. I can remove the check.
Yup
Hmm, my only question is around `FormattedSymbolDeclaration` => `SymbolDeclaration`. Why was this needed?
Once I only needed the item's location, `FormattedSymbolDeclaration` would expect more data than  I needed, and it could also break the _line length_ lint rule.
For _line length_ issue we can always wrap arguments to different lines like https://github.com/devtools-html/debugger.html/blob/master/src/components/Editor/ConditionalPanel.js#L10

I wonder why we have `index` function parameter. It doesn't appear anywhere in function.
@irfanhudda thanks for the tip about line length!
The `index` was dead code. I just removed it.
the glob pattern is causing it to miss files.
i've tried a couple of patterns, any removing the mochitest leaves out some files. should we just do every thing i.e `src/**/*.js` ?

just moved some types around
more reformatting compliments of prettier
I like moving the reference to the module. We should do this in other places we reference `src/types`. There's no code duplication, it's just indirect
ðŸ’ƒ 
rejiggered some things so that the editor menu can show different items when blackboxed

this was a silly name before :/


disable some actions when the source is blackboxed
this is a utility that'll also help with the React collapsing :P
this is where the util is used
Can we change these two lines to es import like `import get from "lodash/get"` ?
I think there might be a small mistake here.

Consider the example where `list = [1,2,3,4]` and `predicate = (() => true)`. We might expect that `filterDulicates([1,2,3,4], ()=>true)` should return `[1,2,3,4]` but it instead returns `[1,2,3]`.

So, this might display one less entry in call stack.
I don't understand.  What does this filter check for?  That `i` exists?
yeah - with native functions params are null. I can add a comment
Looking good!  If we move this change to the ObjectInspector.js [here](https://github.com/devtools-html/debugger.html/blob/master/src/components/shared/ObjectInspector.js#L125) instead.
Then we can do `this.props.setActors(actors);` after, which will set the cached actor.
Great suggestion! I thought using `this.props.setActors(actors);`  in `render` would cause an error, but I was wrong! Thank you! ðŸ˜Š
this will return `undefined`, should be `setActors: () => ({})` instead
same here
tiny note, just for security `... actors && actors[key]`
I'm wondering if we can simplify the cache significantly.

The way i see it working is that it would keep a key of IDs that are expanded and that's it. This way, values don't need to be synced...


adding `actors[key] = thisActor;` above this line should update actorCache
Also , the `actors[key]` only goes stale across the `ObjectInspector` component loads (i.e during stepping), therefore across internal component renders we should still be fine doing `return actors[key]`if it exists, due to performance reasons.
can this move to `utils/object-inspector` and get some unit tests?
can we remove some of the data from this fixture so that it is much smaller. for instance, do we need the entire `value`? Can we remove `preview`'s contents?
can we move this code to an `updateActor` helper function?
No problem ðŸ™‚
Yes, please check my new commit :)
We keep displayName outside of class declaration just like propTypes.
Thanks for catching that!  Just pushed an update.
hmm, maybe we should change this to be: 

```js
onResize: size => this.setState({startPanelSize: size})
```

it's a little clenaer
I think @wldcordeiro might recommend that we put this state in the UI state. 

What do you think?
is `endPanelSize` used?
Yeah. ðŸ˜›  https://github.com/devtools-html/debugger.html/pull/2492/files#diff-57aa11691094c3295e1f9dcbe8432ba2R113
I wouldn't be against that, we already store that collapse state there.
It's working with updated devtools-core splitter package :)
Could put these in L10N.
Hmm  - I'm a bit confused by this logic. 

It looks very similar to what we're doing in search search to determine the next index. Is there an easy way we can unify it?
This looks like it can be shared too...
SearchInput could be a good component to snapshot test:

https://facebook.github.io/jest/docs/snapshot-testing.html#content
what's our preference with wrapping - next at the end and previous at  0?
hmm, not sure if we need the ternary. if we're not rendering the buttons will these be used?
lets put the feature flag here
Oh yeah, forgot to feature flag it. ðŸ˜† 
shouldn't this have a frame?
i'm not sure how i'll mock the frame?
Ahh - i didnt see you were passing frameId in w/ boo. that's good enough for this test :)
I can add `xml-fold` as well that may be a nice touch for HTML files (and maybe JSX? haven't tested this though), can also add `comment-fold` too.
This looks like a good set for now
Feel free to feature flag this while we work on the UX/UI
can we feature flag this CSS... 

```css
.has-code-folding.editor.new-breakpoint {
  right: -16px;
}

```
oof
Done. :+1:
could we do a catch all like `**/*.js` which would pass everything to prettier?
This won't ignore changes changes to the mochitests
ahh
this is brilliant!

Can we replace this with `import actions from "../../actions";` ?
Yeah, Nice catch. Thanks, I'll do a quick change.
Nice.

We might also want to do left/right here in a bit
lets remove this...
Oops, I forgot.
lets see if we can consolidate these two renders into one...
we can use the classnames helper to do `classnames("popover", { up: dir =="up" })`
the ordering here is the hard one, but we can likely do something clever :)
Didn't know about that. Yeah, we can use this.
Lets move the css to the [source-editor][1] package.

[1]: https://github.com/devtools-html/devtools-core/blob/master/packages/devtools-source-editor/src/source-editor.css#L180
lets move this to `utils/editor`
where is node coming from?
@jasonLaster It is defined in this function 
```javascript
const node = ReactDOM.findDOMNode(this);
```
ahh, do we need it? I think if you're toggling we can assume we have an editor :)
Maybe just use `editor.searchResults` property since it's already formatted this way?
ya, that's better.
I think you still want to check if symbol search is enabled here in addition to this condition because when you do text search and type something with no results it'll show the last message from symbol search.
Also, I'm not 100% certain but you maybe able to remove this [block](https://github.com/ruturajv/debugger.html/blob/53564fb44c23400c86e6abf9212a5e600d3918b3/src/components/Editor/SearchBar.js#L493) with the change.
agreed - i think we should only show it if it's greater than 1
So for 
- 1 result - `1 of 1 result` or `1 result`
- 1+ results - `%d of %d results`
?
@wldcordeiro  @jasonLaster 
Hmm, yeah "1 result" works
We need `node` to get all fold markers and toggle class. I'm not sure if there is a better method here other than using `querySelectorAll`.
i think `.search-bar ~ .editor-mount` might be more confusing than it's worth now that we're doing inline styles. 

How about we move that value in here?
perhaps we can now do

```js
if (shouldShowFooter(selectedSource, horizontal)) {
}

...
```

So... It's not great that we have a *magic* number here because it will definitely change.

I don't love suggesting this, but it might be helpful to calculate the heights of the footer and search bar...

Here's where we get calculated DOM dimensions elsewhere: 

https://github.com/devtools-html/debugger.html/search?utf8=%E2%9C%93&q=getBoundingClientRect&type=
I think we can do something like

```js
const cssVars = {
searchbarHeight: "var(--editor-searchbar-height)"
}
```

at the top of the file and below

```js
height: ` calc(100% - ${searchbarHeight} - ${} - ${}`
```
It is so much cleaner than the other ways we explored. I'd also recommend making that change as Jason mentioned. Other than that looks good to me.
This is 100% cleaner. Looks great to me.
i don't think we want to change this now...
Lets call this "React"
oops we should definitely feature flag this :)
I don't know if we should remove this now that source directories no longer have a trailing slash.
Hmm, lets remove that clause and the comment.

Do you know when we removed that requirement?
@arthur801031, @Dalimil?
Removing that condition breaks this test https://github.com/devtools-html/debugger.html/blob/master/src/utils/tests/sources-tree.js#L151

It is because `http://example.com/folder/c/` is no longer considered a folder. 
ah i see. 

Thanks
adjusts for selected sources being offset by the border...
is made redundant by `appendSource`
helps in some race conditions
moved files and exctracted css
was returning null for sources that didn't have an URL
was returning `[undefined]` for empty lists previously
This can also be implemented as
```javascript
this.refs.resultList.refs.hasOwnProperty(this.state.selectedResultIndex)
```
Or adding condition in https://github.com/devtools-html/debugger.html/blob/master/src/utils/result-list.js#L4 
```javascript
function scrollList(resultList, index) {
  if (!resultList.hasOwnProperty(index)) return;
  const resultEl = resultList[index];
```
Oh nice - i think this 

```js
function scrollList(resultList, index) {
  if (!resultList.hasOwnProperty(index)) return;
}
```

is the most testable
Can we do it `renderItem` only instead of `renderItem: renderItem` :)
yep
we should make sure the spaces stay...
we should update this function to be the classic style
so this is a fishy thing where I'm not sure where a scope starts in a function... I'll look into this tomorrow
more fishiness
previously everything would be treated like a token
`classnames.some(el.classList.contains, el.classList)`? Saves a function generation.
Maybe `hasAnyClass`? `hasClass` implies all classes to me.
It was a very inclusive function.
Would be better to synthesize the output of `getClosestScope` to ensure these are only testing `getVariablesInLocalScope`
IIRC from my `resolveToken` work, the scope is bounded by the braces so it starts just after `function () {` (but before any newlines)
nice. I think i'll switch to just doing. is it a child of cm-line lol. I kinda want all tokens because who knows what shit ppl use these names for in other languages like typescript, it could be an alias for color
yeah - that's true
yeah, so scope is a really big object that i don't really want to serialize. it's big because it has lots of info about parents and basically the tree :/
I think you should be able to do `pauseInfo.getIn(["why", "exception"])` here.  I'm pretty sure I did the `getIn().get()` pattern above for `message` and I think I made a mistake.
Ahh, this will need to be passed in from the Editor. 
Using `state: Record<SourcesState>` should work.
I'm guessing that you could replace `any` with `Record<SourcesState>`. Can you try this?
Done, indeed works! ðŸ˜„ 
oops looks like I was late :sweat_smile: 
Hahaha, It's never too late :P
We can probably use `import I from "immutable";`
This seems not to be the case:
```
src/reducers/sources.js:11
 11: import I from "immutable";
            ^ Default import from `immutable`. This module has no default export.
```
Oh. Thanks for correction
Please see note at the bottom of PR description addressing this.
Oh that's interesting.  I wonder if this means we should only be importing the things we need from `immutable` in the future.  Thanks for pointing this out and looking it up. ðŸ¥‚ 
Although there would be no significant gain in size (webpack 1.x bundles whole file anyway) I agree it's a good practice to do so. Also, it would be great for the eventual migration to webpack 2 (which features tree-shaking). ðŸ˜„ 
Maybe export default here?
 Nice
I wondered about this and in the end I followed the pattern that seems to be present in majority of the components - component is defined in one place, but exported by default at the end of the file. Do you think it would be better to place export immediately before the reducer?
This condition was always evaluated to `true` previously.
ðŸ¤¡ 
do we want to compare state here?


generally speaking this looks like we can extract this to a `utils/react.js` file that takes props, state, and a blacklist for props and state.

I'm also okay merging this soon and then removing it with selectors. This way we have a short-term fix.
Ah, damnit. Guess I'm writing some tests as penance.
I think this is supposed to be under the `- image:` block
Yeah, the more I think about the reselect work, I'm of a mind to do things _the right way_ unless this editor perf issue is showing up in regular usage.

For `Editor`, adding reselect could enable us to memoize the `getExpression` function prop and then this complex `shouldComponentUpdate` wouldn't be needed at all.
Hmm, I think we also want to check if the item is in a components directory
We should also add a feature flag `sourceIcons`
Agreed. I'll close this PR then as we have a better way to move forward
We can always come back to this in a week if we run into issues w/ reselect
Here are the docs on [feature flags](https://github.com/devtools-html/debugger.html/blob/master/docs/feature-flags.md)
We might want to add this to `assets/panel/debugger.properties`. You can take a look at #2516 PR to see how tooltip is added

EDIT:
For L10N https://devtools-html.github.io/debugger.html/docs/local-development.html#l10n
:+1: for refactoring.
I don't think we need an IF statement here
`renderFrame(frame: LocalFrame, frames: LocalFrame[]) `
lets keep this on the top of the component `Frame` because it is kinda like rendering
lets change this to `${displayName} (${fileName}#${frameLocation})` to be consistent with chrome and visually group the file name
You are going in correct direction.

But, I don't think we need to manually add this selector. We use [postcss-bidirection](https://github.com/gasolin/postcss-bidirection) to generate these selectors.

Here's how I would try
```patch
--- src/components/shared/Button/PaneToggle.css
+++ src/components/shared/Button/PaneToggle.css
@@ -23,7 +23,7 @@
 }
 
 .toggle-button-start {
-  margin-left: 5px;
+  margin-inline-start: 5px;
 }
 
 html:not([dir="rtl"]) .toggle-button-end svg,
```

You can use similar approach for `.toggle-button-end`

https://devtools-html.github.io/debugger.html/docs/local-development.html#rtl
Thanks Irfan! Let me try again.
We can use default export here?
It would be nice. @peterschussheim what do you think?
Yes, good catch! Working on this PR now ðŸ’¯ 
why 'loadObjectProperties(item.content.value)' wouldn't load the properties in loadedObjects map?
lets move these util methods to the top if we can and try to test them via exports...

```js
export function getScopeGrips(records, identifier) {}
```

```js
import {getScopeGrips} from "react-inspector"

describe("getScopeGrips", () => {})
```
in general we should export each function independently

```js
export function getdocument() {}
```
ooh nice, why is this needed? because it's a declaration?
haha - we want to keep the feature :)

Just remove the experimental feature flag
Frames was moved to index and Frame was pulled out
Smaller and focused on handling frame lists
lots of tests :)
just adding more flow coverage
needed this because Frames depends on launchpad which wants DebuggerConfig set

yes this is ugly plane code, but it passes tests and we can fix it up another time :)

unless you can help me do better
looks like `frames` does not get passed into this `onContextMenu` function
ðŸ‘ 
I like this style
perhaps `sourcesState` or is that too opaque?
does this negate the selector?
lol
hmm, we should remove these files
this should be connected
this should be exported
we should just remove this :)
prettier!
i think `sourceRecord` and `source` would be clearer, but it's a new precident so we can also just not use `_source` and do `source.toJS()` everywhere too...
would be nice to pull this up
lets make a new function  `getPendingBreakpointsForSource`
We use autoprefix so you don't need the moz prefix
Let's add flow '// @flow'
Oops, can we move these to `assets/panel/debugger.properties` w/ l10n

https://github.com/devtools-html/debugger.html/blob/master/docs/local-development.md#l10n
this is annoying, but you'll need to bump the key:

```
# LOCALIZATION NOTE (sourceSearch.search2): The center pane Source Search
# prompt for searching for files.
sourceSearch.search2=Search sourcesâ€¦
```

and use the new key in the project
Hey, @flodolo it's great to have you around :)
looks like already have this string: https://github.com/pradeepgangwar/debugger.html/blob/ed91f18bda935b6bc157413bbe71c6f427b3e1ab/assets/panel/debugger.properties#L434
lets move this one closer to the original Sources string
yeah, we figure w/ flow we can use strings... bc they're type checked, but perhaps we should be stricter w/ constants
why the list and not the panel?
probably private
i think we should generalize this to be any scheme: `file` `javascript` basically it can be any set of letters
almost all of our APIs now expect to get a `source`. 

I agree that this is a performance issue, but I think we should make the fix in a separate PR, that touches all of the spots.

https://github.com/devtools-html/debugger.html/blob/master/src/utils/parser/steps.js#L6-L8
https://github.com/devtools-html/debugger.html/blob/master/src/utils/parser/getSymbols.js#L335-L336

#3953
lol we tried to do this kind of thing before, but it is too magical.

a big style reason not to, is that it is nice to grep for pref keys, just like it's nice to grep for l10n keys
yes, because the search bar is now unmounted when it is not open. See the Editor/index render method
oh, we should probably fix that :) 

I think i was going to add a shortcut in App.js or Editor/index 
`symbolsToDisplay.length > 0`
Try using undefined instead of null. 
The access key should be in the properties file as well
If the line number is off by one, check what we do in actions/addBreakpoint
Yeah, lets kill it. 

This makes me more convinced though that we should build a shortcuts pane to teach people about all of the shortcuts that *are* possible in the debugger.
thanks.
can we borrow some good ideas from `getUrl` to find the relative path: https://github.com/devtools-html/debugger.html/blob/master/src/utils/sources-tree/getURL.js#L17-L38

I think `url.parse` will give us what we want. at a minimum we won't have to write a regex to handle the protocol/scheme thing
@flodolo sorry, that's embarrassing :/
we used to do this mapping in the source map worker. We now need to do it in the debugger to save breakpoints on the correct lines.
I pulled it in because it will be used by `devtools-map-bindings` shortly and seemed like a dependency of pulling in the library.
Actually, now that I say that, it was just pulled in 10 minutes ago by another PR that uses it.
so far, utils haven't had JSX, i think i'd prefer if this function were in `components/projectsearch/textsearch/utils/highlight.js`

nice tests
i'm pretty sure this will fail in mochitests
but lets see...
nope, it's a build issue... it needs to have some #if block or whatever to be considered 

we need the moz.build to be this:
```
# -*- Mode: python; indent-tabs-mode: nil; tab-width: 40 -*-
# vim: set filetype=python:
# This Source Code Form is subject to the terms of the Mozilla Public
# License, v. 2.0. If a copy of the MPL was not distributed with this
# file, You can obtain one at http://mozilla.org/MPL/2.0/.

JS_PREFERENCE_PP_FILES += [
    'devtools.js'
]

JS_PREFERENCE_FILES += [
    'debugger.js',
]

```

but it's 

```
# -*- Mode: python; indent-tabs-mode: nil; tab-width: 40 -*-
# vim: set filetype=python:
# This Source Code Form is subject to the terms of the Mozilla Public
# License, v. 2.0. If a copy of the MPL was not distributed with this
# file, You can obtain one at http://mozilla.org/MPL/2.0/.

JS_PREFERENCE_PP_FILES += [
    'devtools.js'
    'debugger.js'
]

```

we could replace the moz.build with our own like we're replacing other files as well.... it's just another case of a synced mc being better...

but yeah, lets fix this temporarily:
https://github.com/devtools-html/debugger.html/blob/master/bin/run-mochitests-docker

i can do it on monday...
agreed.
lets switch this key to `copySourceURI`
we should also get serious about removing these skips. e.g. I'm pretty sure we fixed the intermittent w/ searching, so we can remove the search skips after the 57 release
i'm working on a fix for this as well. 
https://github.com/devtools-html/debugger.html/issues/4024
ðŸ‘ 
we're now recording the actions so we can have assertions based on the history
lets flip it so we know we can't log history in production
visible is no longer possible
i moved the tests around to group by `paused` action. I also added a couple for `resumed` to make sure we bail early when not paused
when i made the flow type stricter I realized i wasn't passing a real expression into evaluate :)
i think this test is redundant. we get the same coverage from the action test.
lets update `formatSymbols` to show the class name when it exists, this will get us some additional test coverage.
yeah, we can do that too. interestingly, the appropriate behavior (i think) is to re-pause in the expression, but atleast the console should work
hmm, looks like we're not including functions, which we probably should... perhaps we should update `formatSymbol` to map the entire dict of symbols:

```js
Object.keys(symbols).map(name => `${name}:\n ${symbols[name].map(summarize)}`
```
oh yeah... we're not talking about *that*. 

When we step, it looks like:

* stepIn (start)
* resume (while stepping)
* stepin (done)

we don't want to evaluate while we're temporarily resumed :)
perhaps we want to duplicate the CSS now and move it over to PrimaryPane.css
does this get us the border radii he Editor tabs?
I think you can import `Scope` from flow-types/debugger.html
perhaps the same w/ PauseInfo
lets type the params: `(string) => void` or something like that
how can we get rid of this? aren't there other scenarios where we don't want to pretty print?
I think we should have two separate labels "Add Condition", "Edit Condition" that we toggle based on whether there is a condition. We do the same thing when you right click on the gutter.
yes! good catch. Perhaps we move this invokation to this action: `toggleConditionalBreakpointPanel` 
can we try to remove all the displayName propeties in this PR?
there are a lot of other items in the context menu so it is tough to come up w/ one
Yep. It's fixed so that we always get a good artifact build though
yeah, caching was an issue.
why remove this?
hmm, looks like the rebase got botched
hmm... is it still botched?
we don't need to pass in a frameId because we should always fetch it here
we should evaluate the expressions after we select the frame
lets move this to a util where we can test it
isn't it nice to export just what you need
we weren't using id
i think `validateSyntax` reads a bit better, i still expect a boolean return value. thoughts?
I see, it might be nice to show a formatted error object `Syntax Error: foo)( is terrible`.

yep. up to you. I don't know if you can serialize `e` and send it down from the worker, but something simple could work. Success `true` error, `{error: {message: "YO", name: "SyntaxError" }}`
i'm changing the logic here a bit, because i think it's safe to always set the text to "" regardless of whether we currently have a selected source. I'd love to hear a reason why it would break :P
this was a perf hit for no reason. we no longer do anything on the presentation side w/ the `in-scope` lines.
i bet we can do some `doSearch` tests now where we stub codemirror. Obviously not a blocker, just excited
we don't need displayName any more! 


lets switch to using `props`
lets add the flow prop type here:

```js
enabled: boolean
```
we don't need this
lets remove this
Lets replace Function w/ `() => void`
lets add a feature flag here too

```diff
if(!features.shortcuts) {
  return
}
````
we need to keep this as the default for arrows

we can add this style in sources.css
```diff
.sources-list .tree .arrow svg {
  margin-top: 0px;
}

```
we need to keep this as the default for other managed trees:

we can add another style in sources.css

```css
.sources-list .managed-tree .tree .node {
  padding: 0px 0px 0px 3px;
}
```
do we need this: `className="webpack-icon"`?
i think we need a new line here. it's stupid... :)
nice :)
:) perhaps we should pass `toggleShortcuts` in
hmm, if we make this a true toggle we can re-use it in close modal

```js
this.setState({ shortcutsModalEnabled: !this.state.shortcutsModalEnabled })}
```
hmm, it might be nice to do `${e.name} : ${e.message}`;

This would communicate the syntax error which is more descriptive.

why the timestamp?
maybe we re-think this a bit and do something like this:

```js
const error = await parser.hasSyntaxError(expression.input);
const result = error || await client.evaluate(input, { frameId })
return dispatch({
  type: "EVALUATE_EXPRESSION",
  input: expression.input,
  result
});
```
hmm, this should be :bomb: 
:bomb: 

lets make a small util: `getSourceLocationFromMouseEvent` in `utils/editor/index.js`

```diff
from getSourceLocationFromMouseEvent(event) {
+       const { line, ch } = this.state.editor.codeMirror.coordsChar({
+         left: e.clientX,
+         top: e.clientY
+       });
+ 
+       return{
+         sourceId: selectedLocation.sourceId,
+         line: line + 1,
+         column: ch + 1
+       };
+ 
}
```
we can use this util to simplify EditorMenu as well
looks like meta should map to windows

https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent/metaKey
i think we should have all of these keys already defined
We probably don't need F8 in properties, we can just include the string directly
s/questions/question I think ?
s/questions/question
s/varialbles/variables 
Does `ergo` is what e.g. stands for ?
I don't feel like we're explaining what `oldest` is here, or at least I don't understand what it does.

s/Lets not get nerd sniped/Let's not get nerd sniped 
Should this line be removed ?
... story ~~in~~ into various "actor pools"
... We know the `type` is "paused", it has a `from` field and an `actor` field which is used as a return address :) ...
...Where ~~Where's~~ are the variables and scope ...
... to ~~inquire~~ inquire about its parent scope's data ...
`It starts,` could be read with two different tones... maybe `When the function is triggered, it registers ...` -- this makes `it` clear, and doesn't have the weird pause.
is this part of the pause function?
hmm, i like questions... am i missing something
yeah - i don't know what it does either :)


yeah... 
I removed the accesskey param because it is identical to the menu item string, but w/ the `accesskey` suffix
why export them?
I think the codemod added that; I just removed `export` and updated this PR.

What about all the flow errors?  Is that going down a rabbit hole trying to resolve them all?
i say go for it. It's really helpful and we should be typing all the files
the snapshot is great because we don't care what the symbols are. jus that they're sensible
@bomsy I like this solution because the reducer is an I.Map, the symbol field is an I.Map, but the symbols are just objs... maybe it's not a big deal bc people could still mess with them, but it feels better lol
I should bale if we don't have the source text
ðŸ‘ I like this, our test coverage has really been growing in great ways.
I really dig this choice. Very clear reducer logic.
Woot! More ES6 import/exports!
i think our tests were testing the wrong things :)
nice reduction.
Could the props be here?
Yes we could have props here but we also need to use it in below line

```js
shouldComponentUpdate(nextProps: Props)  {
```
I used the `type Props` to avoid duplication
Got it. You're one step ahead of me. 
Not sure if this needs its own file. Will look for other homes for it later 
Hmm, I think we should probably have a new action `clearSelectedSource`... Also, is the ID used later?
i think this would be simpler if we had `clearSelectedSource`
this is a great cleanup
Yeah, i totally agree! tot about this too.  Having more focused actions that do specific things would allow for flexibility and less isolated scenario bugs!
Nice! It would be cool, if this could be put as part of the theme.
thanks @bomsy can you point me in the right direction?
@ofiron01 You could look in here to see if we have a variable matching the colour we want, and use that.  https://github.com/devtools-html/devtools-core/blob/master/packages/devtools-launchpad/src/lib/themes/variables.css#L1

If not, we can do a PR in devtools-core to add a new variable.
ðŸ‘ 
Some leftover comments here and on [line 69?](https://github.com/devtools-html/debugger.html/pull/2994/files#diff-695f8e845eb7e7930a1b665650866b59R69)
move to `client/utils`
lets move this to `client/shared/addCleintBreakpoint.js`
lets kill `getTextForLine`
Hmm, what if we changed this to be `_getGeneratedLocation(sourceMaps, breakpoint, source)`

* we change `_getSourceLocation` to `_getGeneratedLocation` to be more clear
* we pass in source instead of state
* we get location from `bp` because passing in location separately is confusing
can we clean this up:

```js
function initialState(): BreakpointsState {
}

```
nice!
Hmm I tried this, but it introduced a few problems. do you mean that the makeRecord should be moved out? or should this become `Record<BreakpointsState>`?
:+1:
rouge `console.log`
i like this!!! :)
:+1:
hmm maybe this could have a better naming, so if someone goes hunting here it will be clearer what is happening with this expression?
cute :)
Can we instead use `Props` which was already declared?

`type Props = { items: Array<Object> }`
Yes, thanks for pointing that out. I've modified it.
i probably should rename this var :)
select source did get a bit more complicated, but i think it is better now. i.e. we want to know when we're done selecting the source...
This shouldn't have been necessary. Did you discover an issue?
ðŸ‘ 
Could be a bit clearer with `flapMap`:

```
flatMap(_outOfScopeLocations, location => {
  return range(location.start.line, location.end.line);
}).forEach(line => {
  this.editor ...etc ...
});
```
  
The type for this would be `AstLocation[]` (even though I forgot to type the return value ... oops).
Should it be separate states rather than exception logic within the reducer?
yeah - it was weird. it only happened for empty arrays of functions....
ahh nice
ðŸ‘ 
since we are using the same state object, maybe we can save it into a variable rather than calling it multiple times
why do we return an empty object here?
should this be returned?
meh... it looks weird, right
rouge `console.log`
i think the `true` cancels out all other checks
do we need to make sure `updating` is false here?
hmm, i guess i should. was being cute :)
this jest thing is nice!
perhaps: `depth * 15 + (nodeIsPrimitive(item) ?  15 : 0)` to be a little cleaner

this can be more than text. for example it can also have an id, content type, and loading state. maybe we can name this a bit better? `sourceTextProps` comes to mind, or just `updateProps`
this returns more than text, maybe `getTextPropsFromAction` is clearer?
maybe we can have a comment here about why we are merging, rather than setting? I saw above there was such a comment in the previous version of the code, might be helpful here too
:+1:
I think the comment before covered a *special* case that we no longer are concerned with. I am not sure if I have something that I want to say here except that we're adding source fields :)
I'm a bit confused, so I'll walk through the bug and two workflows as I see them. I could be missing something, it could be what you're already doing too.  I'll outline a simple case and syncing case for both workflows. To be clear, we can do the simple case and fix the bug.

#### Bug

1. User is working on an app that uses source maps (i.e. namely bundle.js w/ file a.js, b.js, c.js)
2. User debugs the app and adds a bp to b.js line 12, with the generated location bundle.js#45
3. User adds code to a.js 
4. User reloads the app and see the debugger paused on b.js line 4, which happens to line up with the generated location bundle.js#45!

We will fix this, either simply moving the breakpoint to b.js line 4 when the debugger reloads or ideally re-removing the breakpoint at line bundle.js#45 and adding a breakpoint at the new location...

--- 

#### simple case

1. User adds a Breakpoint

  * addBreakpoint is called with an original location 
  * generated location is calculated based on the source's sourcemap
  * a pending breakpoint is added with the generated location

2. User reloads page / User re-opens debugger

  * breakpoints reducer adds pending breakpoints 
  * newSource is called and the debugger attempts to sync the breakpoint
       * checks if there is a pending breakpoint
       * uses the pending bps generated location to recalculate the original location
       * adds a new breakpoint to the store


---

#### syncing case

1. User adds a Breakpoint

  * addBreakpoint is called with an original location 
  * generated location is calculated based on the source's sourcemap
  * a pending breakpoint is added with the generated location

2. User reloads page / User re-opens debugger

  * breakpoints reducer adds pending breakpoints 
  * newSource is called and the debugger attempts to sync the breakpoint
       * checks if there is a pending breakpoint
       * uses the pending bps generated location to recalculate the original location
       * **if the new original location is different from the pending breakpoint original location**
          * removes the old breakpoint on the server
          * adds the new breakpoint to the server
       * adds the new breakpoint to the store

how do we know we have an ID? the pending bp doesn't have an id
this can be moved to `utils/utils.js`
2 things:

1. I think we should do this in `firefox/commands.js#onNewBreakpoint`
2. `onNewBreakpoint` should be moved to firefox/create#createBreakpoint

The rationale for this is to give us consistent data from the server... we did the same thing for source URLs when we worked on pending bps
Lets add a function comment, we don't typically have comments but we should lol
minor style nit, but i move actiony things to options i.e.

`syncClientBreakpoint(source, pendingBreakpoint, location, {client, sourceMaps})`
this seems weird to me... can you explain the rationale
It's not really clear to me if you need location because it's a composite of many things
can we move this try/catch to the firefox/commands side?


why do we need to talk to the server if it's disabled, i think that means that the server doesn't have a bp?
:+1:
yes. and i agree that this needs to be expressed better. I didn't quite finish fixing this

when the source is reloaded, the source id changes, and i was confused by that. I wasn't sure what the source was so I quickly threw this in to see if it would work. Basically, there is a new connection. This is why we can't delete / find the line after the debuggee is reloaded. 

for example, 
```javascript
pendingBreakpoint.generatedLocation
/* { 
  id: "server1.conn3.child1/34",  
  line: 51234
} */
generatedLocation // 
/* { 
  id: "server1.conn4.child1/34",  
  line: 51235
} */
```

I didn't get around to doing this properly, but we now have the source available in this function, and this should actually be:
```javascript
const originalLocation = await sourceMaps.getOriginalLocation({
  id: source.id,
  line: pendingBreakpoint.generatedLocation.line
});
```

Also, i don't think we need to save the generated location in full, just the line. will keep hacking away at it
Good point here. Originally, my thinking is that we need to verify our breakpoints with the server, and the only way to do that (at the time at least) was to add a breakpoint to the server. If its disabled we need to then remove it. Otherwise we have the weird behavior of disabled breakpoints in places that don't make sense.

Better solution: change the client code so we can get a breakpoint location. I haven't had a chance yet to try to make this better but it feels like it should be possible
we now have just 4 items, so this should be ok
I think it might be nice to keep the schema version private so that we only manage it here...

```js
if (prefs.debuggerPrefsSchemaVersion != prefsSchemaVersion) {
  prefs.clear()
  prefs.debuggerPrefsSchemaVersion = prefsSchemaVersion
}
```
nit: not sure if we need the _. I think everything is assumed to be private
it's weird that generatedLocation and location are different line numbers
might be nice to have a snapshot of `returnedBp` here as well
maybe `console.warn`...
I think `updateObj` has outlived it's purpose.
I'd also try to be more aggressive about what we want to do.

```js
function updateBreakpoint(state, newBreakpoint, oldBreakpoint) {
  const id = makeLocationId(newBreakpoint.location)
  state.setIn(["breakpoints", id], {
    ...breakpoint,
    ...overrides,
    loading: false
  });
}
```
:+1: 
[sortBy](https://lodash.com/docs/4.17.4#sortBy) could be amazing here:


```js
sortBy(bps, ['filename', 'line'])
``` 


do we need to unmock these in an `afterEach`?
closing because this works.
lets keep this in the appendix of getting setup
lets mention that you should check your version of node as well.

Also, if that doesn't work.... use nvm to switch to a clean version of node w/ no global dependencies
should we suggest `yarn nom` somewhere.
also, perhaps checkout master... and git pull --rebase
these will all have to go ...
lol @jselmani @GarethSharpe we've gotta fix the CLRF [bug][b]

[b]:https://github.com/ryanjduffy/parse-script-tags/issues/3
i wanted to differentiate btw bugs and features... but it might be a bad dstinction...
I think we might want to handle "Escape" too
this is just a style thing, but i tend to prefer early returns

```js
if (e.key === "Enter" && query != null) {
 if (!isNaN(linenumber)) {
   selectSource(selectedSource.get("id"), { line: linenumber })
 }
 return this.closeModal();
}

if (e.key === "Tab") {
  return this.closeModal();
}
```
I'm surprised that this is not `cmd+:`
Yeah... we do want to consolidate the symbol + gotoline modal and search for file.

+ `cmd+p`
+ `cmd+:`
+ `cmd+shift+o` 
we'll likely need to update the flow definition for the possible search types in `reducers/ui.js`
how about we change this to:
```
- /**
-  * Breakpoints reducer
-  * @module reducers/pendingbreakpoints
```
Hmm, lets rename this "Review Stale Issues"
Yeah, that's a good find! that would be a nice PR because we have good test coverage here
lets try `Array.prototype.any` or `some` or lodash any/some
lets drop these functions and just do the `isReactComponent` work now
this is awesome if it passes :)
lets drop this for now as we don't need redux stuff
should we have a test for this?
landing because i want to do a release
lets soften the header a bit...
smaller font, normal weight...
Looks better to me. As a small detail for the screens, can you turn off the feature w/ the bottom bar :) it's not ready to ship yet
also, this is a nit, but can we go drop the border below App? might be nice
yeah - it's in launchpad, settings "Add watch expression from preview"
we shouldn't change this...
can we get rid of this property in `assets/panel/...properties`
this was accidentally turned on
this was not a feature, but a persisted field
hmm, we should find the variable color that other buttons use. the variable helps us with dark theme :)
do we need `mask-size` now?
lets always use a `/` i.e. `mask: url("/images/prettyPrint.svg") no-repeat;` 

so lets change the other sites
yeah... this _is_ pretty weird...
could you rebase and run `yarn nom` this looks like some windows CLRF stuff
lets drop the WIP
lets make the header "Go to line" and move the fix Bugs or a UI section
can we make this more explicit
:bomb: 
maybe `this.toggleSourceSearch` should be `this.fileSourceSearch`
do we need this?
nice
can we bind here: `self.onMouseDown = this.onMouseDown.bind(this)`
lol
do we need these: ` && "Backbone";`?
thanks... but i'm not sure if we want to clean up the code yet. I'm not sure what API i want yet :)
you don't need to do this refactor. That was me messing around
you don't need this
will this work? 

* do we need to use: https://lodash.com/docs/#isEqual or should identity comparisons be enough
* naive question: why is it `prevProps.selectedLocation.location` and not `prevProps.selectedLocation`? Are we messing something up?
why do we now care about `prevProps.selectedLocation.location`?
perhaps we need two smaller functions:

```js
function startsBefore(a, b) {
  if (!(a.start.column > 0 && b.column)) {
    return true
  }
  
  return a.start.column <= b.column;
}
```
I think we can update this pattern a bit: because we already bind on line 79 (here[h]) we probably can just get the sources in `renderItem` w/ `const {sources} = this.props` and avoid extraData.

[h]:https://github.com/tohmjudson/debugger.html/blob/6437b275ba76784f9d7d3eb84767513924d79361/src/components/PrimaryPanes/SourcesTree.js#L79
lets move this to a helper function so we can clean it up a bit

```js
getPath() {}
```
lets add the styling to sources.css
haha - okay :)

i think @wldcordeiro has a nice refactor... lets do it ðŸ˜› 


i think this is the source of the redundancy... 
we should probably just be doing

```js
.set("selectedLocation", action.location)
```

```js
const blackboxPart = item.contents.get("id")).get("isBlackBoxed") ? "update" : ""
return `${item.path}/${item.name}/${blackboxPart}`
```

one more nit

this exists above here
nope it's duplicated... (for now)
I like it better :) 

```js
function startsBefore(a: AstLocation, b: AstPosition) {
  if (a.start.line === b.line && a.start.column && b.column) {
    return a.start.column <= b.column;
  }
  
  return a.start.line < b.line;
}

```

it's easier for me to read



lets use the `isLoaded` [helper](https://github.com/devtools-html/debugger.html/blob/master/src/utils/source.js#L245-L247)
I like this
Ooh, I like this style, but let's discuss adopting it in a separate PR. 

I honk we can land his fix without I and see what style for actions is most used in the community. I would Perper something as explicit, but more terse. It might not exist :)
I don think we need this
Yay
Hmm, I'd like to check elsewhere but I believe in functions with multiple actions we destructure for brevity
I think this is he Ron module for these functions. This m is or code mirror documents. Let's move them to utils/editor/index
small nit: lets add `export` to each function.
lol.. not sure about `gotoanywhere` what does atom/code call this modal?
how about a map here:
```js
const modifiers = {
  "@": { type: "symbols", query }
}
```
Let's do something light :)
this is not related to this patch, but it would be nice to move `findBestMatch` to a utility and add some unit tests.
yeah... i did it because `createSelector` was no longer defined... but that might be more troubling :/
minor point, but for aesthetics can we move `event.stopPropagation` and `event.preventDefault` to `openMenu`. It'll only ever be called here
not a bad spot :)
Actually, we don't need a color... We'll style it later :)
The green in the mockup was a throw away color. I'd like to look at all the colors in tree holistically soon. 
can we add a className to the new `img`?
we can do a mask/background color trick. we do it elsewhere
agreed, but lets do this later :)
what does this do?
ðŸ‘ 
hmm, it might be nice to move this to the `quickOpen` reducer.
can we dry these up w/ helper methods

`assertEnabled` `assertDisiabled`
can we dry this up too?
nice!
so this might be a style thing, but the `case` statements and length of the function feel a bit much:

perhaps some helper methods and early returns?

```js 
 if (item == null) {
   return
 }

if() {
  return this.selectSymbol()
}
if () {
  this.selectSource()
`

selectSource(item.id);

```
how is this different from before?

is this for jumping there and highlighting?
`selectedSource != null && searchType === "functions` seems redundant...
this check could be moved into `onSelectResultItem`
seems a bit redundant... 
i think `closeModal` is above too
minor thing, but lets move this to a `mapStateToProps` function
@svitlana-galianova yep. just add the className to the new `img`. we'll style it later
that should now always be on for tests? maybe not though...
`waitForDispatch(dbg, "THE_ACTION")`
maybe we can make `waitForSelectedSource` smarter... that will help make the tests easier to write

```diff
diff --git a/src/test/mochitest/head.js b/src/test/mochitest/head.js
index 51d659f..e57ff70 100644
--- a/src/test/mochitest/head.js
+++ b/src/test/mochitest/head.js
@@ -218,16 +218,26 @@ async function waitForElement(dbg, selector) {
   return findElementWithSelector(dbg, selector);
 }
 
-function waitForSelectedSource(dbg, sourceId) {
+function waitForSelectedSource(dbg, url) {
   return waitForState(dbg, state => {
     const source = dbg.selectors.getSelectedSource(state);
-    const isLoaded =
-      source && source.has("loadedState") && sourceUtils.isLoaded(source);
-    if (sourceId) {
-      return isLoaded && sourceId == source.get("id");
+    const isLoaded = source && sourceUtils.isLoaded(source);
+    if (!isLoaded) {
+      return false;
     }
 
-    return isLoaded;
+    if (!url) {
+      return true;
+    }
+
+    const newSource = findSource(dbg, url)
+    if (newSource.id != source.get("id")) {
+      return false;
+    }
+
+    const symbols = dbg.selectors.getSymbolsForSource(state, source.id)
+    return symbols;
+
   }, "selected source");
 }
 
```
screenshots of the test paused in the debugger code and the test code would help show what it is happening
We should be able to pass the button down to `Dropdown`: so that Â» is used for Showmore 
lets add a new feature flag here so that it's off by default for now:

https://github.com/devtools-html/debugger.html/blob/master/docs/local-development.md#creating-a-new-feature-flag
I'm a bit confused by this so i'll share the spec as i see it:

- original files can not be pretty printed
- generated files that have a source map cannot be pretty printed
- if the source has been pretty printed, jumping should jump between the pretty and "ugly" file :) this might be new behavior...

so... i think the comment before might help...
we want it to be disabled for pretty printed files, but nothing else... 
this is a good opportunity to update the tests in `actions/test/ui.spec.js` 
why `important`?
does this affect the sidebar footers?
i see... cool
yeah... lets try and make it more specific:

`.command-bar > img.pause-exceptions.all `
haha - yeah, that makes sense. `format` is just for testing

i don't think the snapshots are showing the highlight line or the text... perhaps we need to also spy on codemirror or do something to make sure they render...

could we keep summary msg here? it seems weird to store that?
nice
can we avoid storing this?
can we put this logic in `getFilename` and update the tests
i still don't see the need for storing `summaryMsg`, why can't we calculate each time we render?
why are storing the ID?
this is a lot of new data to be storing...
hmm, can we have a check there to see that we are not currently searching?
some of this is an opinionated refactor :)
ooh, this call will have to be async because it requires parsing...

if we want to do this, we'll need to add it to another place, like on `loadSourceText`.
i'm not sure if we're already parsing 


```diff

+export function setSourceMetaData(sourceId: SourceId) {
+  return async ({ dispatch, getState }: ThunkArgs) => {
+    const sourceRecord = getSource(getState(), sourceId);
+    if (!sourceRecord) {
+      return;
+    }
+
+    const source = sourceRecord.toJS();
+    if (!source.text || source.isWasm || hasSymbols(getState(), source)) {
+      return;
+    }
+
+    const isReactComponent = await isReactComponent(source.get("id"));
+    const hasJSX = await hasJSX(source.get("id"));
+
+    // would update the source record...
+    dispatch({
+      type: "SOURCE_META_DATA",
+      isReactComponent,
+      hasJSX
+    });
+  };
+}
```
Everything in the worker is async. Also needs to be parsed
sorry... i think i'm missing the point here:

* will this only show a value if updateCount is true? when is it false?
* is `updateCount` representing that we have searched? can we do this another way? like looking at whether there is a current search query string? or adding a boolean to the text-search reducer? 

what is this trying to do again? :)
why do we need `toggleProjectSearch ` and `toggleActiveSearch`?
ðŸ‘ 
LGTM. I was planning to do some opts as next step. 
1. Use transfer objects to transfer matches from worker to main
2. Make next and previous to be O(1) operation if cursor position has not changed from last search.

Thanks for taking care of the CL. I could not get to it quickly :(.
No problem! Maybe we can do it in a second pr?
did we remove symbolSearch? I can no longer trigger the buttons...
take a look at master. We removed this stuff when we added the search modal.

Must just need a quick cleanup
just had to turn it on
we still have a single entry-point function right? or you mean to drop the outer function altogether?
do you mean `awaitCommand` @jasonLaster?
we should remove the column breakpoints code here and the component
lets add the column bps feature flag here
lets move `onKeyUp` and `onKeyDown` to CallSites because we can :)
others might handle this too so perhaps we dont want to stop propogation
this should be in its own call-sites css file
this should be in its own helper
i'm not sure if this helped... lets look at the perf here. Maybe not a blocker, but nice
we should exclude member expressions cause... well you know
i tot it did when we tested it, at the allhands ... i'll try it again

remove console.log
it looks like we might be getting the member expressions and not the call expressions with this change?
ah .. yep!

we might not need to pull this in on its own since we have it on `callSite`
you can use the equalize location util!
i like this, might need a simpler name like "toggleDisabledBreakpoint"
i wonder if we can avoid this somehow... ðŸ¤” 
ðŸ‘ niiice

woooo!
yup, not being used...
perhaps there's a better way to keep this dummy data...
I like the pattern of splitting out the editor children components. The separation makes it easier to follow

@asolove @codehag 
This is important for making sure that we're updating the correct codemirror document.
I should include a quick description
There should be a quick comment to explain how this is used
not sure why this changed :/

It is probably alright though
this is a nice clean up
i love these cleanups.
do we want to slide a breakpoint to a column if the user is expecting a line breakpoint?
could it make sense to start using a factory library? 
the Breakpoint component returns null; so, do we need to wrap it in a div, or just return null, with the mapping done in the body of the function?
:+1:

I like this pattern better than keeping the selectors in the reducer. maybe we could have a folder structure here:
```
selectors/
|- breakpoints/
  |- index.js
  |- atLocation.js
```
is this so that we can check if a breakpoint is also represented in a generated file? can we use it in all cases?
this might be a regression - before we were making sure that we didn't turn line breakpoints into column breakpoints... 
:tada: nice!
yeah - that might be a nice cleanup in a separate PR.
This will get the breakpoints for a file at the "correct" location regardless of original / generated
oof. We will definitely clean this later :)
Yeah .... nasty hack!! But should go away when we refactor tabs
this is a huge speedup
thinking about switching to local state because the state is only specific to the modal.
looks like we weren't testing the other tests because of the fit.

We should lint for this.
moving `dom.div({ className: "debugger" },` to the outer render
moving the modal to the top so the mask can cover the entire app
i took this test out because I've already spent too much time on this issue.

I'd like to come back though and add proper unit tests
what is this ref used for?
focusing
:+1: 
I think it would be nice to keep addBreakpoint together for now. That way we have more flexibility in the future.

```js
export function addBreakpoint(location: Location, condition: string) {
  const breakpoint = createBreakpoint(location, { condition });
Â  return ({ dispatch, getState, sourceMaps, client }: ThunkArgs) => {
     // option 1: inline addBreakpoint
     const state = getState();
     //...

    // option 2: call addBreakpoint
    return addThunkBreakpoint(getState, client, sourceMaps,  { breakpoint })
  }
}
``` Â 



also, perhaps the filepath is `actions/breakpoints/addBreakpoint.js`


I like the term visible, but I think `selectedSourceId` might be more consistent in the short term
perhaps we don't render the debug line without a selected source?
Unfortunately, that distinction is made for a very particular reason. You can select a new sourceId but not have it yet be visible (if you're waiting for it the source to be fetched, for example). For this component to know when to run its editor commands, it needs to know when the source is actually displayed. Prior to this change, the highlight would run right away, and when the source arrived, it would be put in a new document and not get the highlight. This makes me think we need a way of telling side-effecting editor children something about the identity of the displayed document. 
This runs into the same thing with selected v visible, but yeah, I think it makes sense to not render if the visible document shouldn't have a highlight.
I see, perhaps we want to encapsulate some of this knowledge into the component so it knows what to do... 

What if we passed the selected source in and DL checked to see if it was loading? If it's loading we don't highlight...
Unfortunately, I think we really need data about what source is shown in the editor. It's possible that the source text has loaded but we're at some state where the editor hasn't yet been updated to the new document. (Because that happens in lifecycle callbacks which may _happen_ to occur before or after this component renders with the new source data.)
can we pass codeMirror here instead?
column bps should be turned off by default :)
it's great to see a lot of code go away
lots of helpers are no longer necessary 
simplified language to `x` and `newX`
i think this method is the source of a lot of client miscommunications because the bpClient cannot be found if the location has changed.
i don't think we should show the column if we're not doing column bps
it's great to see both `pendingBreakpoints` and `breakpointsDisabled` go away. Both are now simple selectors
this cleanly fits our update pattern now
this can easily use update too
I think deleting these helpers makes it all worthwhile
I like adding reselect here to avoid expensive recomputation
this is now responsible for updating bp prefs. it can do more things later if we want.
some of these helpers were duplicated
I see what you are trying to do here, but I disagree with this. This is difficult to test and difficult to think about. We are throwing away action.type in order to achieve the same thing. Lets chat about it when you are online
we were toggle the breakpoints pane on toggle all clicks...
NOTE: I'm happy to follow the POJO rest pattern here.
these assertions only run in development and are really helpful for catching the many inconsistencies in data that we had
we're now setting sources because you can't add a breakpoint without a corresponding source. This is important because we want source level information in a bp like sourceUrl and sourceId
:+1: i like this new naming
:+1: kill it with ðŸ”¥ 
ðŸ‘ 
:+1:

agreed, much easier to read
This looks better than what i suggested, lets keep it like this
this is already in m-c
there's a getter on the targets that we can use
What's the case when this happens? Is this expected until we fix some issue on the target? Perhaps we should console.warn in this case
A comment above this condition explaining would be helpful as well
Just added an issue for attaching to the console when the worker target is created.

https://bugzilla.mozilla.org/show_bug.cgi?id=1382302
hmm this is old code, but it's hard to read. we are basically doing this here:
```
let breakpoint = { ... };
let conditional = { ... };
let disabled;
```
but because of how it is written, its easy to see this instead:
```
let breakpoint = {
  id: ..
  label: ..
  conditional: ...
  disabled
};
```

We should add an eslint rule that doens't allow for declarations to be done in a list, because there is little gain from this style, and it decreases comprehension. Adding this as a comment for myself so that we can do this later.
this is not a memberExpressions, maybe it should be an identifier?
we should add a test to `fixture/expressions`
we probably need an explicit order here to prefer more specific types like `member expression`...

Or not if the start/end loc help out
:+1:
i suppose we can't use a similar `toSourceLocation` method here because of the strange column offset...
lets pass the selectedSource down if possible. I think that would be a little more useful
this is going to move after a rebase
* can we look at `source.isWasm` here instead of `typeof sourceText === "string"`Â 
* perhaps move this to a helper `utils/source`
can we move much of this to `utils/editor/wasm`

```js
function renderWasmText(editor, sourceId: string, wasm: any) {
  const lines = getWasmLines(souceId, wasm)
  let text = { split: () => lines, match: () => false };
  editor.setText(text);
}
```
can we move `isSourceWasm ? { name: "text" }` to `getMode`?
lets change `pendingJumpLine` to `pendingJumpLocation`
Lets move the `selectedSource` higher up. 

```js
if (! selectedSource) {
return 
}
```

we can do the same thing in `onToggleBreakpoint`
I am not too sure what is happening here, where are action and promise coming from?
haha - they're not, but the parser doesn't care. it's just doing a `...` rest operation
ahh ok cool
moved tabs to their own file
moved some helpers above the render calls
killing unnecessary checks.
This enables us know the source attached to the match
perhaps `project-text-search`
perhaps:

```js
for (const source of validSources) {
  const matches = await searchSource(source, query);
  dispatch({ ya da ya da });
}
```

This strategy will let us defer the work to the worker. each search will be a new worker call and will wait for the response to come back...


another option would be to move this to the searchSources action... 

the advantage is that we always do it before we search. often it will be very fast... and then we know we have everything to search
ðŸ‘ 
we might need to have the source id here too
minor thing, but `clear` is being used in other places `clear_query`
perhaps `action.result.sourceId`
lets expose I `state.search.get("results")`
@jlast Is there any particular reason behind this? Just for my understanding.
Immutable lets us compare items and see if they change `list.get("id") === list.get("id")`
Ahh cool! 
perhaps we want to do something to disallow new searches while one is going on?

I do this with preview, by having an updating state: https://github.com/devtools-html/debugger.html/blob/master/src/reducers/ast.js#L21-L22
perhaps `sourceId`
hmm - does this need to be updated?
opppsieee!! :)
Can you please tag jasonlaster instead of me? 
should be `projectTextSearch`
should be `projectTextSearch`
it was a nightmare resolving flow issues
oh wow, nice!
we can't assume it's 29px. it's possible that the gutter will be wider because the file has 3/4/5 digit line numbers
We should figure out why the gutter is set to width `1px` https://github.com/codemirror/CodeMirror/blob/master/src/display/update_line.js#L112-L121

My guess is that we're updating the gutter while the element is detatched or the document is not visible.
moved to actions, test to be added
Was the issue that if frameworkGroupingOn was not checked, collapse frame would be run with unexpected results?
this was failing
lets also have a snapshot here so we can get some regression testing on the children
nice
why is the timeout necessary? 
ðŸ‘ 
oh, surprised we didnt have this
On clicking a match, the page opens so quickly you have no visual indication of what you clicked. This just allows, the user see a visual indication for a few seconds before the source file is opened
perhaps a slightly different signature. 


```js
const supportsWasm = !!debuggerClient.mainRoot.traits.wasmBinarySource;
createSource(source, { supportsWasm }))
```

The rationale is that when devtools moves to github it will be easier to add a `supportsWasm` function in debuggerClient.

Added DebuggerClientTraits type to be used at multiple createSource callsites.
I would prefer passing a smaller options object in: `{ supportsWasm: bool }`. This will keep the interface smaller and more flexible
small style knit

```js
const supportsWasm = debuggerClient.debuggerClientTraits.supportsWasm
sources.map(source => createSource(source, { supportsWasm }));
```
```js
const supportsWasm = debuggerClient.debuggerClientTraits.supportsWasm
actions.newSource(createSource(source, { supportsWasm });
```
I cannot longer reproduce https://github.com/devtools-html/debugger.html/pull/3417, removing update line number formatting switch.
I did this as an auxiliary class just to be certain we aren't affecting other nodes by accident. Just in case.
moving this to threadClient.js so that later we can consolidate our threadclient 

Most of the deleted code has been moved here
added three cases
lol - this could have easily been `. secondary-panes.sticky-commandbar`, but you wanted to go all BEM on us :)

I'm okay with this, but just being my morning snarky self :)
haha, second nature to me at this point. ;)
we can drop the prefixes because we have autoprefixer on:

this is the output w/o it
```css
/* Utils */
.vertical-center {
  top: 50%;
  -webkit-transform: translateY(-50%);
          transform: translateY(-50%);
}
```
it feels funny to have the class without a user though...
lets keep `offset-inline-end`
yeah we can remove this util for now... its not used
would be useful later on, i noticed we are using flexbox and other solutions for centering and that usually doesn't give a true center. originally I added this thinking I could center the `x` and then i realized it was a managed tree component ;P

this is the only code change
switched to explicit exports

I propose that we go with a slightly different option. Instead of only searching a portion of the string, lets stop searching entirely.

```js
if (!checkLineLengths(lines)) {
  return []
}

function checkLineLengths(lines) {
  return !(lines.any(line => line.length >= 100000))
}
```

What's the advantage to this approach? If we bail early the UX will be:
1. codemirror shows the current match and next/previous still work
2. the search summary is blank (old debugger didn't show the sumary 1 or x)
3. it's ofcourse fast
4. it's honest - i'd hate to say there are 3 matches and actually have 5 in codemirror


we can come back and support summaries in this case later
I understand what you mean. I am just afraid that it will feel broken and frustrating for the user. The best thing we could do is give back an error message saying "line too long". I will throw that together and lets see what happens.
:+1:

:+1:

:+1:
It might help if the wrapper and modal were siblings. This way the modal could animate onto the `<body>`.


we should avoid having a div overlaying the window at all times.

another strategy might be to use z-index: -1.
Good idea on moving the z-index.
Not sure I follow. Could you elaborate?
I added this slightly longer transition to the z-index change to make sure we have enough time for the animation to play.
a better pattern would be listening on the expressions reducer for a "resume" action. reusing evaluateExpressions here intertwines two responsibilities in an action. 
Its better if we keep evaluate expression to having just one responsibility. It looks like up to this point we always had a frameID -- if this is true, then we can remove the if block here
autoprefixer + vertical-center could help
perhaps `showSadFace`
`noNegativity: false` this is too hard on the brain
this should be changed to `sourceSearch.noResults2`
perhaps, `shouldShowErrorEmoji`
can you update the storybook stories with this new field?
is this still used?
smart ðŸ‘ 
i think we should stay consistent with the search type and call it "sources"
hmm - what do others think I like this new name.

If we change it we should bump the key to `sourceSearch.search2`
I was not sure If I should change it, but i think i like it better
Ok, I will change that.  Screenshot coming up
maybe we can move this out of the reducer, wanted a bit of feedback on it though if it would be too slow
ah we don't need sourcemaps here

whoops

does `async function` work?

If so, can we add an `await` here. I'm guessing no because I bet the `Promise.all` was a hack lol
this reads really well!
The promise api is still useful in async await, and promise.all is the suggested way to resolve a group of promises. i never had to use it before, and it was a stumbling block. Async/Await can resolve single promises, but not a collection. infos --> https://github.com/tc39/ecmascript-asyncawait/issues/61
what do you think of moving `remapBreakpoints` to `actions/breakpoints/remapBreakpoints`?
could we do:

```js
const prettySource = await dispatch(createPrettySource(sourceId));
```
how about we add two more tests 
1. also has breakpoints mapped
2. also has selected location mapped
rebasesss
oops what was lost?

:+1:
:+1:
remapBreakpoint -> remapBreakpoints
it's now in modal.css
I didnt have time to do this, and there was an unusual error so I made a ticket to tackle it later: https://github.com/devtools-html/debugger.html/issues/3531
I moved the locations

this is the only logic change. We now return the root if nothing is found so we can promise to have a node returned
this used to support `null` contents. That's now gone
:+1:


:/
ack
lets have a more specific assertion like the new source URL or a snapshot
ðŸ‘ 
I see, we don't really have a good API for getting the mapped sources... nevermind
Tweek -> Tweak
so nice!
hmm - not sure if we need this! it's a flaky test.

Take it out and we should be able to land it
Will do. 
:+1: nice!

we should clear this field when it's done.
thanks
lets add some jest unit tests to demonstrate that command is set and then cleared when the command is done.

I think we can do something like:


```js
it("lala", async () => {
  let resolve = null;
  const slowClient = {
     stepIn: () => new Promise(_resolve => {resolve = _resolve})
  }
  
  await actions.paused()
  actions.stepIn()
  
  expect(isStepping(state)).toBeTruthy()
  resolve();
  expect(isStepping(state)).toBeFalsey()
}
```
it would be nice to have a test here too:


```js
+ describe("pause", () => {
+   it("should set and clear the command", async () => {
+     const client = { evaluate: jest.fn() };
+     const { dispatch, getState } = createStore(client);
+     dispatch(actions.stepIn());
+     await dispatch(actions.resumed());
+     expect(client.evaluate.calls.length).toEqual(0)
+   });
+ });
  

```
Unrelated but it'd be nice to update `Svg` to take a `name` prop and then we could have these calls be JSX too.
So this is an idea. But you'd need to touch more of the codebase. How about converting this component from:

```js
module.exports = function(name, props) {
  // eslint-disable-line
  if (!svg[name]) {
    throw new Error("Unknown SVG: " + name);
  }
  let className = name;
  if (props && props.className) {
    className = `${name} ${props.className}`;
  }
  if (name === "subSettings") {
    className = "";
  }
  props = Object.assign({}, props, { className, src: svg[name] });
  return <InlineSVG {...props} />;
};
```

to
```js
export default function Svg({ name, ...props }) {
  // eslint-disable-line
  if (!svg[name]) {
    throw new Error("Unknown SVG: " + name);
  }
  let className = name;
  if (props && props.className) {
    className = `${name} ${props.className}`;
  }
  if (name === "subSettings") {
    className = "";
  }
  props = { ...props, { className, src: svg[name] } };
  return <InlineSVG {...{ ...props, className, src: svg[name] }} />;
};
```

We would need to modify the usage of `Svg` but then we could use it like a component as well and convert the usages like so

```js
// from this
Svg("some-name", { foo: bar });

// to this
<Svg name="some-name", foo={bar} />
```
Huh, this is really neat. ðŸ‘ 
I bet we can add postcss.config.js to the list of exported files and avoid this:

https://github.com/devtools-html/devtools-core/blob/master/packages/devtools-launchpad/package.json#L113
calling this out as it's a friendlier check.

we might want to go back to yarn check after we jump to react 15.6 or 16. At the moment we're so far back it's hurting us
this output is pretty nice in snapshots
:+1:
In the old code, we used setSelectionRange -- was this to move the cursor to the end of the input? I also noticed that in both cases we only fire select when the component is opened, and in that case it is empty. perhaps we don't need this?
We were using it but we were making a selection of the end to the end? So I wasn't sure what exactly that was achieving. I don't think it nor `.select()` make a ton of sense so I don't care for keeping them.
Correct me if I'm wrong but this is the way to assert in mochitest?
is this the preferred style?

perhaps? `ref: c => (this.$input = c)`

it's funny, i prefer refs because their namespaced, but i'll support anything.

Also this style is fine w/ me too
https://github.com/devtools-html/debugger.html/blob/master/src/components/shared/Autocomplete.js#L51-L53
nit: but lets put `this.props.enabled` first
we might be playing too much of a dance w/ enabled, perhaps a new method is in order:

* we dont need enabled prop
* we can consolidate logic

```js
isEnabled() {
  const {activeSearch, selectedSource} = this.props
  return activeSearch === "symbol" && selectedSource
}
```
yep, that will work!

i guess i was assuming it because the next action is typing... and it will work or fail based on that, but i don't care. this is nice to have.
is this the preferred style?

perhaps? `ref: c => (this.$input = c)`

it's funny, i prefer refs because their namespaced, but i'll support anything.

Also this style is fine w/ me too
https://github.com/devtools-html/debugger.html/blob/master/src/components/shared/Autocomplete.js#L51-L53
nit: but lets put `this.props.enabled` first
we might be playing too much of a dance w/ enabled, perhaps a new method is in order:

* we dont need enabled prop
* we can consolidate logic

```js
isEnabled() {
  const {activeSearch, selectedSource} = this.props
  return activeSearch === "symbol" && selectedSource
}
```
yep, that will work!

i guess i was assuming it because the next action is typing... and it will work or fail based on that, but i don't care. this is nice to have.
So `enabled` is also used for whether to update the results or not. I figured that I could instead modify the value we get in the `connect` call.

```js
export default connect(
  state => {
    const source = getSelectedSource(state);
    return {
      enabled: getActiveSearchState(state) === "symbol" && source,
      symbolType: getSymbolSearchType(state),
      symbols: _getFormattedSymbols(state, source)
    };
  },
  dispatch => bindActionCreators(actions, dispatch)
)(SymbolModal);
```
Are you suggesting that we use the `$` to prefix it as a ref?
hmm, this worries me because we might be doing too many `on` calls.

Should we add a check in here like `!props.enabled && nextProps.enabled`?
i prefer `$` if we do the property style. I still like ReactDOM.findNode or `this.ref` as well.
Oh I could put the ref into the refs object as well by changing the line to `this.refs.input = c`
I tried this and it wouldn't work after the first time you toggled on.
Correction. Seems like you can't add the property to the refs object via a function ref.
hmm this looks like it might give us trouble later on -- we are controlling a child component from a parent component; this makes it difficult to separate them -- we probably want searchInput to do this, rather than doing it here.
this should be enough... was it not working with this ?
I think yarn reformats this file when you use `yarn add` ðŸ¤·â€â™‚ï¸ 
Redundant rule? It's on the modal itself just above.
Because the modal is mounted the symbol modal needs to have that if block to focus the input. I'll research further to see if there's a solution that's cleaner but this gets the focus events working on all the search dialogs and ensures we have no regressions on the shortcuts.
It was problematic adding shortcuts to the modal itself and would leave the shortcut disabled on its dismount. Letting the consumer's handle it seems like a simpler API.
> Normally a component is not transitioned if it shown when the <Transition> component mounts. If you want to transition on the first mount set appear to true, and the component will transition in as soon as the <Transition> mounts.

This prop is awesome but sadly there doesn't seem to be a `leave` that is the equivalent. I've opened an issue on react-transition-group requesting one to see what they recommend.
I could definitely have pulled this inline className (and Svg below) to a variable, but I wasn't too sure on proper naming. If you have any suggestions and want to avoid inlining, just let me know and I'll update this PR.
`hidden: false` should be the default: 

`dispatch(addBreakpoint(location, { condition }))`
`astCommand`
maybe we're thinking about this the wrong way. If we're only going to have one temporary breakpoint, perhaps we want a different breakpoint field in the reducer like `pendingBreakpoints`.

I propose we add a `steppingBreakpoint` which does not appear in the UI... do you think that would be easy? we also don't need a pending breakpoint for this case.
nit:

```js
return {
   sourceId: position.sourceId
   line: nextLocation.line,
   column: 0
}
```
it would be nice to have unit tests here too.
flow complained here. maybe there's a better solution.
at this point it would make sense to do `addBreakpoint({location, condition, hidden})`
Do you not flow type your bin scripts? I really like treating all my code as first class citizens.
shouldn't it be this: `{`"search-field ${size || ''}"`}`

I'm still new at this game
`<div className={classnames("search-field", { size })}>` would be even cleaner.
Hmm, to be more React idiomatic let's do.

```js
function Info({ children }) { // or PaneInfo
  return (
    <div className="pane-info">
      {children}
    </div>
  );
}
```
If the above is done this line should be 
```js
{pauseInfo ? scopeInspector : <PaneInfo>{L10N.getStr("scopes.notPaused")}</PaneInfo>}
```
Good call. Can actually do the same on ln 62 above.
True you could make this block 

```jsx
<PaneInfo>
  {pauseInfo ? L10N.getStr("scopes.notAvailable") : L10N.getStr("scopes.notPaused")}
</PaneInfo>
```
Maybe `function debugBtn({ type, className, tooltip, ...rest })` then you can make that block below

```jsx
return (
  <button className={classnames(type, className)} title={tooltip} aria-label={tooltip} {...rest}>
    {Svg(type)}
  </button>
);
```
)
```
we're dropping specified source and lines because we want to focus on the fact that we're highlighting the top frame line.
should this be  `deleteSelf`
`breakpointMenuItem.deleteSelf.accesskey`
Should this be deleteSelf?
Done.
Lets change this to `Search for functions` and move it to L10N
https://github.com/devtools-html/debugger.html/blob/master/docs/local-development.md#l10n
`onClick={() =>  this.props.setActiveSearch("symbol")}`

because, why not
Do you mean the formatting?
lets move this up to a variable. I'm still not comfortable with JSXy expressions
can this be one line?
can this be `file => file.matches || []`
lets move this out... `renderItem={renderItem}`
Why did you need to change this back?
i don't know why this is needed now... but it looks good 
You get this error when it's an array

```js
    return (
      <span className="line-value">
        {matches}
      </span>
    );
```
<img width="704" alt="screen shot 2017-08-12 at 9 45 03 am" src="https://user-images.githubusercontent.com/254562/29241198-11cae7b8-7f43-11e7-8652-9d9250960494.png">

Good question.  There is an issue where `<span>{matches}</span>` causes a react
error that keys should be unique,.. oh! I see jasonLaster just commented about that :)
This was an attempt at making the prop optional to try and make the error mentioned in the PR
above go away.  The `disabledFocus` prop is not used in `src/components/PrimaryPanes/SourcesTree.js` so it should be optional for now.

Unfortunately making it optional did not make `yarn flow` happy.  I think this might be a known flow issue.
my flow is happy. and so is CIs so you're off the hook
I think we should be able to spread, but it doesn't work for me...

https://github.com/Microsoft/TypeScript/pull/11591/files#diff-36d63f88d66eddff8e2d469bea89b21cR23
looks like there are some issues with spreading and it is a performance hit for react as well.
https://github.com/babel/babylon/pull/42

With that in mind, lets merge this and then refactor matches properly

Here's a gist of a patch i started https://gist.github.com/jasonLaster/11e46330c6cc17b36c4f78cb3229fa30
Gah!  So there is something strange in my setup, grrr.
Ah, interesting, so using spreads for children is off the table for now I guess.

Thanks for the links
nit: looks like data is not needed
looks like the SVG wasn't included.
this is okay. It's fine to throw an error in development. The problem is if we try to do it in production. The old version threw an error all the time.
There is an existing angular.svg in the /assets folder which looked good to me.
Shall I replace it with the one you mentioned?
So shall I just revert this part and throw an error in dev mode & console.log?
oh no, i didn't realize that!
yeah - lets revert this part
is this used?
I am really unsure.
Transition is used within Slide. Which is the default export.
I did a quick search but couldn't find any usage of Slide, but bc I am a total noob on your codebase this doesnot mean I didn't oversee something
Slide is a component. You can convert the default export to JSX and make this proper change.
Something like this:

```jsx
export default function Slide({
  in: inProp,
  children,
  handleClose
}: SlideProps) {
  return (
    <Transition id={inProp} timeout={175} appear>
      {status => <Modal status={status} handleClose={handleClose}>{children}</Modal>}
    </Transition>
  );
}
```
true... I'll move this file to a place where prettier works and then we'll find other terrible things.
`! b.disabled` is okay too :)
same here
@clarkbw @bgrins is it better to use the `hidden` field or just not add it to the list? I'm guessing hidden, but not sure
this is the pattern we have elsewhere, but i'm wondering if we can improve upon it:

```js
const getKey = (key) => L10N.getStr(`breakpointMenuItem.${key}.accesskey `)
const getLabel = (label) => L10N.getStr(`breakpointMenuItem.${label} `)

const foo = {
  label: getLabel("foo")
  accesskey: getKey("foo")
}
```
could we do `[...matches].length`? or `matches.length`?
also, since we are doing toJS() at the end here, maybe it makes more sense to do matches.size
these colors are a small step in the right direction
Are we still using this pattern?
my gut instinct is to move styles that are not calculated to a class, but it was like this before so...
We can delete this

I suppose we should JSX the stories too, but meh
yeah - it's a silly story, which is where I'm not sure
maybe this could have a code snippit?
:+1:

:+1:
yeah - we should revisit this section the next time we come in here. I think it could be better factored :)
`fit`
do we want to assert we get the right document... it might be nice to simulate setting a new document on codemirror and make sure we get the document for the correct source
we should be clearing the source documents between codemirror tests!
I don't think this is dead code. These are binding the methods to the prototype.
Self is not used anywhere in this component except for the 2 lines below.
I think this should be `this.setExpanded= this.setExpanded.bind(this);` bc on Line 122 it calls it with `this`
`onExpand: item => this.setExpanded(item, true)`
`this.setExpanded` is used within `render` which is autoBound so this should work
`this.setExpanded` is used inside of `expandListItems()` which is called by `componentWillReceiveProps` (= autoBound)

So I think this is legit and should work. or am I completly wrong? @wldcordeiro @jasonLaster  
The line defining the `self` constant I think is there to prevent Flow bugs? I know it's a pattern we use often when binding our methods. 
I'll revert it to before state but I am quite sure my changes work
maybe we need a better name?
this test might be in `getDirectories`...
the tests seem a bit funny... like not sure why we need all of them
**YES!**
oops thought i took the console logs out

:+1: thanks for catching that!
we dont have a getDirectories test at the moment, and it isn't in any of the other source tree test files, so I will leave this here for now
we don't need this to be declared here
at some point we might want to revisit this code, it feels like there is a simpler solution
cool
this test should also have the xml mode
I think we are removing `cursor: pointer` at the moment, so we can take out this line (reference issue: https://github.com/devtools-html/debugger.html/issues/3669)
lets move this to CSS.

Perhaps we should pass layout to `CommandBar` so that it can have a vertical, horizontal class?
I like where this is headed. Is there a commandBar CSS file so we can do it w classes?
interesting!
why do we call this astCommand?
getHiddenBreakpointLocation seems to get the first hidden breakpoint, do we ever have a case of more than one hidden breakpoint? could this give us a false positive?
I called it astCommand, because it does similar things to command action. but it tries to use the parser AST to evaluate which command should be executed.
at the moment, this only adds 1 hidden breakpoint in the system. and it removes hidden breakpoint on next step. so there's only 1 hidden breakpoint.
that's one way to fix it. ðŸ¤£ 
tiny typo: searsh
I think this would probably cause a conflict, since firefox-hg adds `mozconfig` while you're adding `.mozconfig`

Both are supported, but you should only have one of the two, so you should probably override `mozconfig` here.
:+1:
We need to remove this filter, as we no longer have the visible field :)
this will always return `previewFunction(value)`; maybe we should just use it directly?
sure
this could be passed in with `showSource`
If we want to always clear, and then show the source we should move this logic to the showSource action...

In that case we would dispatch two actions one that cleared the source and the other that set it. 
i feel like this way, its clearer what is going on and each one function has its own responsibility. makes it easier to compose -- i vote for keeping it!
ah although, we could listen to show source and clear it. thats also true -- i like your pattern of doing this on the reducer :+1:
nit: would be better not to rename the args; maybe we could use updatedArgs here
sure - we can do that :)
:+1: will keep this in mind
nit: we could make this a const, since it doesn't change 
same here!
im not sure this will work as intended, the server will still have a breakpoint that moved, but now we will not represent it on the client
:gun:
why are we sometimes getting a record and other times not?
lets add //@flow
might be nice to do `if (!scope)`
i think we should be more explicit here and just keep the function name
we might want to check to see if the function has a name
lets just do `new Map` which we do in other cases
what's invalid? like not inside a function.
lets add a test for nested functions and just lock down a behavior. I think we want to use the closest named function
you cheated and added more than just the util :)
you cheated and added more than just the Util :)
hmm 
pros to removing everything but the name: less to save in the persisted data
cons to removing everything but the name: we would have to calculate the parents position to compare it to the new location
yes
i also added the field ;)
or: in the global scope. I need to do a bit more work on this one maybe
we shouldnt save an ast if the function is anonymous maybe? this is used only when there is a name
can we take these changes out?
we'll have to do that anyways because the function could be in a new location after reloading
can se take this out too?
lets take this out too :)
I tried using the isLoaded method for the above condition but it was throwing some error and the sources didn't get loaded during initial load. So checked for the value manually.
heya @sharathnarayanph what error are you getting here? Seems to work for me! Was this what you used`!isLoaded(source.toJS())`?
Can we use `isLoaded` here aswell?
Yes, this is what is I used. Got error like isLoaded is not available. I had this issue only when I closed all the open js files in the window and started clean.
![image](https://user-images.githubusercontent.com/16179366/29576159-73b84a4c-872c-11e7-816f-408117fbd6c1.png)


And no source files are loaded during the load. And this happens only when there are no JS files open in the window.
![image](https://user-images.githubusercontent.com/16179366/29576230-b7b5ed8a-872c-11e7-9726-b8e79d8d2737.png)

@bomsy Hey Bomsy! Did u get any error when starting fresh?

@sharathnarayanph So the issue is `isLoaded` checks if the source is in `loaded` state and does not care about the other states ... but the requirement here is to check if the source is in the `loading` state, so `isLoaded` can not be used and what you have done (`source.loadedState === "loading"`) is fine.
I've added this now.
cool! Will leave it as such.. Thanks!

hmm it looks like the reason that isLoaded isn't working is because it isn't imported
i noticed that we are doing toJS() a lot to get the object for this function. An improvement here would be to do:
```
return source.get("loadedState") === "loaded"
```

toJS() is an expensive function and we should avoid it where we can. I noticed there is one case where we have a regular source object, in findSourceMatch. it might be that in that case we are also doing .toJS() -- i will take a look
we have this defined in source-tree/utils -- could we use that, or is this playing a special role?
it looks like this is where the prettyprint test is failing -- the source passed here is immutable. It will probably be fixed by `source.get("loadedState") === "loading"` or perhaps better `source.get("loadedState") !== "loaded"`?
No special role. I just thought for test files they had to be defined separately!
I have a patch for this that i can push
Tried this, but during the initial load, the loadedState value is always in "unloaded" state. Hence, this condition always passes and no source is shown in the source tree. Do we need to change the loadedState to "loaded" somewhere?
Ah, i see. in this case it should be source.get("loadedState") !== "loading". so if it is unloaded it is fine. Sorry -- i misunderstood the case earlier
i'm pretty sure this test passes, but step over does not take us to line 10
this could also be const?
if i am reading this correctly.. this will be set if the last run of the test failed. maybe we want to change it so that the forEach loop has its own failed status, and this uses _.any(test => test.failed) or something?
it does it there too. `_.any` is nicer.
i just realized that we maintain the failed state through the loop.. maybe we could use a for loop and exit early if it fails?
i did that earlier but i like having the data of how often it fails... we can always clean it up later
i stopped using the helpers here because original source url was confusing me... wee could probably bring them back... but i wonder if there are other abstractions that would help w/ these tests as i'd like to have more of them in this space
`"http://localhost:8000/magic.js"`
Small typo: "will will". I think this should be "we will"
small nit, but we can remove the return here

```js
.filter(token => (
   !commentTokens.includes(token.type) &&
   (!token.type || (token.type.label && token.type.label != "eof"))
))
```
```js
const fillRange = (start, end) => (
 Array(end - start + 1).fill().map((item, index) => start + index);
))
```
would `fillRange` work here?
Do we have a system for caching this?  Tokenizing could be expensive.
Could we pass in `selectedSource` here ?
We should follow `setSymbols` pattern and add the empty lines to the AST store when a source is loaded:

https://github.com/devtools-html/debugger.html/blob/master/src/actions/sources.js#L382

This will help in two ways:

1. it's cached
2. we can update the breakpoint check to use a redux selector and not a css selector :)
we should add `getEmptyLines` as a worker task so that the work is done off the main thread

https://github.com/devtools-html/debugger.html/blob/master/docs/local-development.md#adding-a-task
i think we should bump this up to `0.7` or higher 
we should probably have a data based approach... where emptyLines comes from the store

```js
isEmptyLine(emptyLines, line)
```

or

```js
this.props.isEmptyLine(line)
///

in the connect function

isEmptyLine: line => isEmptyLineInSource(getState(), line)

// in reducer

function isEmptyLineInSource(state, line) {
   const emptyLines = getEmptyLines(state, selectedSource)
   return emptyLines.includes(line);
}
```

we can drop this `createFactory` business now
I....I'm not fully understanding how all of these fit together... :/
@darkwing this might help clarify @jasonLaster comments. The reducer has all the data about the empty lines so it should be able to let us know what an empty line is.

Hope this helps!

``` diff
diff --git a/src/components/Editor/Breakpoint.js b/src/components/Editor/Breakpoint.js
index 767b598b..386a69ea 100644
--- a/src/components/Editor/Breakpoint.js
+++ b/src/components/Editor/Breakpoint.js
@@ -6,12 +6,7 @@ import ReactDOM from "react-dom";
 import classnames from "classnames";
 import Svg from "../shared/Svg";

-import {
-  getDocument,
-  showSourceText,
-  toEditorLine,
-  isEmptyLine
-} from "../../utils/editor";
+import { getDocument, showSourceText, toEditorLine } from "../../utils/editor";

 const breakpointSvg = document.createElement("div");
 ReactDOM.render(Svg("breakpoint"), breakpointSvg);
@@ -31,7 +26,8 @@ class Breakpoint extends Component {
     breakpoint: Object,
     selectedSource: Object,
     line: number,
-    editor: Object
+    editor: Object,
+    isEmptyLine: Function
   };

   addBreakpoint: Function;
@@ -42,7 +38,7 @@ class Breakpoint extends Component {
   }

   addBreakpoint() {
-    const { breakpoint, editor, selectedSource } = this.props;
+    const { breakpoint, editor, selectedSource, isEmptyLine } = this.props;

     // NOTE: we need to wait for the breakpoint to be loaded
     // to get the generated location
diff --git a/src/components/Editor/Breakpoints.js b/src/components/Editor/Breakpoints.js
index a51252d0..194028c2 100644
--- a/src/components/Editor/Breakpoints.js
+++ b/src/components/Editor/Breakpoints.js
@@ -5,7 +5,7 @@ import React, { Component } from "react";
 import Breakpoint from "./Breakpoint";

 import actions from "../../actions";
-import { getSelectedSource } from "../../selectors";
+import { getSelectedSource, isEmptyLineInSource } from "../../selectors";
 import getVisibleBreakpoints from "../../selectors/visibleBreakpoints";
 import { makeLocationId } from "../../utils/breakpoint";

@@ -29,7 +29,7 @@ class Breakpoints extends Component {
   }

   render() {
-    const { breakpoints, selectedSource, editor } = this.props;
+    const { breakpoints, selectedSource, editor, isEmptyLine } = this.props;

     if (!selectedSource || !breakpoints || selectedSource.get("isBlackBoxed")) {
       return null;
@@ -44,6 +44,7 @@ class Breakpoints extends Component {
               breakpoint={bp}
               selectedSource={selectedSource}
               editor={editor}
+              isEmptyLine={isEmptyLine}
             />
           );
         })}
@@ -57,7 +58,8 @@ Breakpoints.displayName = "Breakpoints";
 export default connect(
   state => ({
     breakpoints: getVisibleBreakpoints(state),
-    selectedSource: getSelectedSource(state)
+    selectedSource: getSelectedSource(state),
+    isEmptyLine: line => isEmptyLineInSource(state, line)
   }),
   dispatch => bindActionCreators(actions, dispatch)
 )(Breakpoints);
diff --git a/src/components/Editor/index.js b/src/components/Editor/index.js
index 5589daf8..ba946317 100644
--- a/src/components/Editor/index.js
+++ b/src/components/Editor/index.js
@@ -26,7 +26,8 @@ import {
   getFileSearchQueryState,
   getFileSearchModifierState,
   getVisibleBreakpoints,
-  getInScopeLines
+  getInScopeLines,
+  isEmptyLineInSource
 } from "../../selectors";

 import actions from "../../actions";
@@ -55,8 +56,7 @@ import {
   toEditorLine,
   toEditorPosition,
   toEditorRange,
-  resetLineNumberFormat,
-  isEmptyLine
+  resetLineNumberFormat
 } from "../../utils/editor";

 import { isFirefox } from "devtools-config";
@@ -368,7 +368,7 @@ class Editor extends PureComponent {
   }

   onGutterClick(cm, line, gutter, ev) {
-    const { selectedSource, toggleBreakpoint } = this.props;
+    const { selectedSource, toggleBreakpoint, isEmptyLine } = this.props;

     // ignore right clicks in the gutter
     if (
@@ -401,7 +401,8 @@ class Editor extends PureComponent {
       selectedSource,
       breakpoints,
       toggleBreakpoint,
-      toggleDisabledBreakpoint
+      toggleDisabledBreakpoint,
+      isEmptyLine
     } = this.props;

     if (selectedSource && selectedSource.get("isBlackBoxed")) {
@@ -815,7 +816,8 @@ export default connect(
       query: getFileSearchQueryState(state),
       searchModifiers: getFileSearchModifierState(state),
       linesInScope: getInScopeLines(state),
-      selection: getSelection(state)
+      selection: getSelection(state),
+      isEmptyLine: line => isEmptyLineInSource(state, line)
     };
   },
   dispatch => bindActionCreators(actions, dispatch)
diff --git a/src/reducers/ast.js b/src/reducers/ast.js
index d5fba776..1e3bb8af 100644
--- a/src/reducers/ast.js
+++ b/src/reducers/ast.js
@@ -132,6 +132,11 @@ export function hasSymbols(state: OuterState, source: Source): boolean {
   return !!state.ast.getIn(["symbols", source.id]);
 }

+export function isEmptyLineInSource(state: OuterState, line) {
+  const emptyLines = getEmptyLines(state, selectedSource);
+  return emptyLines.includes(line);
+}
+
 export function getEmptyLines(state: OuterState, source: Source) {
   if (!source) {
     return false;
(END)
```
I find it slightly concerning that `onGutterContextMenu`'s `lineAtHeight` returns one number higher than `onGutterClick`'s `line` argument.

![linenumbers](https://user-images.githubusercontent.com/46655/29479484-11499e66-8438-11e7-9bce-07963fb62a2a.gif)

...but that existed before this PR.

We can remove this line and import it from selectors on `line 29` above
i.e 
```js
   getInScopeLines,
   isEmptyLineInSource
 } from "../../selectors";
```
Yeah `lineAtHeight` calls `toSourceLine` which adds 1 to the `line`
see https://github.com/devtools-html/debugger.html/blob/master/src/utils/editor/index.js#L101

It looks like `lineAtHeight` is only used in this file so we can maybe
remove the call to`toSourceLine` from https://github.com/devtools-html/debugger.html/blob/master/src/utils/editor/index.js#L126 to fix the issue
is this `async` needed?
is this `async` needed?
should the line class be removed here rather than added?
I like this idea. I wonder if we want to extend toggle to do it natively i.e. if `toggleBreakpoint` should add a breakpoint if there isn't one already.
we should add a unit test here in the mold of these tests:
https://github.com/devtools-html/debugger.html/blob/master/src/actions/tests/ast.spec.js#L1
Looking at this again, we should probably return `[]` instead of `false`.
(Prevents an error in `isEmptyLineInSource` because we immediately use `.includes`; I think it's reasonable to always expect an array from this function)
good call
this is a nice solution, but i think we might want it to be a bit more generic.

For instance, could it be an editorMap?
do you think we can drop these use cases if we do it here?

https://github.com/sagorika1996/debugger.html/blob/breakpoint/src/components/Editor/index.js#L152

https://github.com/sagorika1996/debugger.html/blob/breakpoint/src/components/Editor/index.js#L134
does this make sense?
I think we cannot remove this line since we (I) cannot guarantee editors state before updateLineNumberFormat is called.
> nit, perhaps we make the signature clearer

`getSymbols(source: Source, { shouldUpdate: false })`
side comment, but this reminds me of the code in `ast#setPreview` it'd be nice to move it out too 
lol
I'm glad we waited on this abstraction, i'm beginning to think we just want to move complicated or all actions to their own files

perhaps we should inline the call

```js
dispatch({
  type: "SYNC_BREAKPOINT",
  [PROMISE]: syncClientBreakpoint() 
})
```

or and this is a radical idea... 

move the whole thing to the syncBreakpoint file

```js
export function syncBreakpoint(..) {
  return ({ dispatch, getState, client, sourceMaps }: ThunkArgs) => {
    dispatch( 
      type: "SYNC_BREAKPOINT",
      [PROMISE]: syncClientBreakpoint() 
    )
  })
}
```

The advantage of this approach is that it's intellectually honest. We're just saying, go over there to see this action.


anyways, one big nit
maybe `sourceRecord` then `source` below
another nit:

maybe we want some smaller functions here, like each case is it's own function. the top vars are defined where they're used
don't we need do `client.setBreakpoint` to create a new one?
this might be a bit more complicated, but should we also do the `newGeneratedLocation` so if we don't have an `astLocation` we fall back on it? Or wait, will you tell me that astLocation is doing the same thing?...
yeah - lets add some unit tests :)
if we're always updating here do we need the boolean?
:P
its called a little bit lower (the two cases are now more like one case)
we have other cases where we use getSymbols
Hi @rohanprasad  interesting why the need for  the `||`? The second handler will not be used anyway?


Shouldn't this just work ?

```js
onChange: e => {
   this.props.onChangeHandler(e.target.value);    
   this.setState({ 
      inputValue: e.target.value,
      selectedIndex: 0
   });
}
```
Hey @bomsy, I couldn't actually find any other place where autocomplete is used but  left that so to prevent breaking other code. What I was thinking was to remove the query string from state and only use the prop. Should I go ahead and do that ?
 
yes that should be fine.
nit: maybe`setSourceSearchQuery`
nit: `clearSourceSearchQuery`
rather than this handler .... lets just pass in `setSourceSearchQueryString` just as is done for `clearQueryString` below
`setSourceSearchQueryString` instead
`onChangeHandler={setSourceSearchQueryString}`
would be `setSourceSearchQueryString={setSourceSearchQueryString}`
Could probably leave the constructor off for now.
lol
hmm, we should remove these files
this should be connected
this should be exported
we should just remove this :)
prettier!
i think `sourceRecord` and `source` would be clearer, but it's a new precident so we can also just not use `_source` and do `source.toJS()` everywhere too...
no hold on

@wldcordeiro, Thanks! I think `countMatches` do not need `text` as a parameter, but I'm not very sure, so I have not remove it.
There are some duplicate code in this `doSearch` and `search` in line 204. I am thinking of whether write their functionality in only one function or not
Here, `state.results` get cleared every time even just `findNext` or `findPrev`.  Which in the initial idea should be stable unless search charactor changes...
Seems `matchIndex` already plus 1 when `render` in `SearchBar.js`. so it should starts at 0 and ends at count-1... 
Seems a redundant whitespace between `week` and `was`
just refresh and add-button, right? not the whole selector
I have multiple nodejs projects with multiple versions. This helps me keep a specific version per project. If you wish I can remove it but I don't think it bothers anybody. It contains a one line string with the node version v6.9.2
[done](https://github.com/andreicristianpetcu/debugger.html/commit/046a35d78d40e58eaa04fc4b8e301a95d9bc6e90)
It will probably take a few days since I don't have time to work on it today anymore. Sorry.
[done](https://github.com/andreicristianpetcu/debugger.html/commit/0d40a5592a47d7f24cc6c1e5ec2dacb4be2d93f6)
It was a mistake. It is [fixed](https://github.com/andreicristianpetcu/debugger.html/commit/4cabd2e528c09c839b8cd0ff8c381910fc4d174c) [now](https://github.com/andreicristianpetcu/debugger.html/commit/2ba1c7d9acde2d088131324b79120b06de59cef8). I wanted to make the refresh and + buttons have a single color and not change on :hover but I made the selectors a little bit too generic.
@jasonLaster I did the rebase and I tested dark theme, white theme, Chrome, Firefox, tooltip. I did not test rtl since I do not know how but I included the changes. Please accept this pull request since I keep having conflicts with parts of my patch that landed in upstream. Any issue that you find can be fixed in another branch without these merge conflicts.
ðŸ‘ @jasonLaster 
I don't know how glitch works. Can you please add a link to a Glitch tutorial?
Class methods are covariant in Flow by default, which in effect means they are "read-only" and cannot be assigned to.

```js
class Error extends React.Component {
  constructor(props) {
    super(props);
    this.onClick = this.onClick.bind(this); // Error
    //   ^ property `onClick`. Covariant property `onClick` incompatible with contravariant use in
    //     assignment of property `onClick`
  }
  
  onClick(event: ButtonClickEvent) {
    // ...
  }
  
  render() {
    return <button onClick={this.onClick}>Click Me</button>;
  }
}
```

In order to make this work, you need to use an additional class field, which are invariant (read & write) by default, like this:

```js
class WorksWithClassPropertyType extends React.Component {
  constructor(props) {
    super(props);
    this.onClick = this.onClick.bind(this); // Works!
  }
  
  onClick: (ButtonClickEvent) => void;
  onClick(event) {
    // ...
  }
}
```

Alternatively you can use the class properties proposal to get around all of this:

```js
class WorksWithClassPropertyArrowFunction extends React.Component {
  onClick = (event: ButtonClickEvent) => {
    // ...
  };
}
```

[[See in Try Flow](https://flow.org/try/#0PTAEAEDMBsHsHcBQBLAtgB1gJwC6gEoCmAhgMZ6RayqgDkWJ5tA3IojgJ7qGgBCArjhywAdgGFoyUgGsAogDdCIvAF5QAWVj8AzoQVK8AMlABvRKFCl+WBsoAqxLAHNCOAFygAEnfUAZAUKistCEqAYANIgAvqyIpNDE2tqgsjbYoIQAHjhKACbJRGQ4AHRi1JgiBqbmlqLaOFj85NgAFOhU6NoAlNUWFtr83FhtHd2sfaA4ABbI2sWiElLSoGrTs-PikjLFAEbIIrkta2M1UTU1C1vSLYSKyh4BwptL+so9ZhMgoMU-p+cWtlyhGG7xqANc1hEoAAPDtBE9QJclioTMcNosZFEAHwY5bqQjQ4BwwIiLHjUBnM5xBJJUAAdWw0m0dOQ0wkiW0AAUOsDOHYuDwsjkDgVGCUyhhRFUPrURPVGs1hu1YJ1QRMBkMRiqThM0UiZCtJjM5vrpLt9odjl1yWcLBdnjIPC1HqbXjgeiosaB5LBkLlyaabnd3b0+l8fsU-lT4hz6YzmaypuyktyVbyOABBNLwABi-BE5GQogy2TyoqKpXKUuUodNhqDBge8NdwY9XplFnDvwsMWiiCAA)]
I would also like to know what was difficult
racey?
Generally type systems eliminate the need to do things like that. But you can do one of two things in that scenario:

1. Use Flow's [`suppress_comment` option](https://flow.org/en/docs/config/options/#toc-suppress-comment-regex)
2. Pass the value through `any` to stop type checking â€“ I'd recommend doing this along with a comment explaining why it `any` is needed. Using `any` means you're less tied to configuration

```js
function method(value: string) {
  if (typeof value === 'number') throw new TypeError('Support for numbers has been removed');
  return value;
}

test('throws deprecation error', () => {
  expect(() => {
    // Passing through `any` because we want to make sure we're throwing an error.
    method((42: any));
  }).toThrow(TypeError);
});
```
Might want to explain it a bit more
name `RightSidebar` may be worth changing because in the vertical mode it's no longer on the right
I guess all this matchMedia magic should be moved to some small util lib like `KeyShortcuts` ?
it should also be possible to modify `width` and `height` (at least according to the comment 15 lines above). Not sure if I should add it now though, since I do not plan on using it.
so... should I add them (width/height) or not in your opinion? Sorry, I can't figure out what you are suggesting here ðŸ˜Š 
that was just a thought though, I don't think I should change it in this PR
`verticalLayoutBreakpoint` has both `addEventListener` and `removeEventListener`, but then I'll need to store the callback function somewhere, so I decided to go with `onchange = `
React auto-binds all methods to the component, so this will work (tested ðŸ‘ ).
We can use one more specific :)

Should we add the dependency to `"eslint": "^3.10.0"` here as well? 
I just had a warning about this when doing `npm link` in this package.

nit: maybe sort this array alphabetically ? 

Ah, great catch!

move before css-loader

nit: === for consistency
.eslintrc still refers to rules from all those packages, are you sure we can remove them here ? Getting an error when running npm run lint after a clean yarn install.
indes.js -> index.js
nit (alphabetical order) move up one row
nit: remove commented out line
This PR enables linting on this package. 
Is there a reason to keep enforcing eslint-disable on this file?
If I'm reading correctly the code at 
- https://github.com/cyrus-and/chrome-remote-interface/blob/master/index.js
- https://github.com/cyrus-and/chrome-remote-interface/blob/master/lib/chrome.js

CDP expects options containing host/port/protocol etc and not a string representing a URL ?
I think they are windows-style carriage return.
Is this used anywhere?
When passed as a string and executed, this will pollute the global scope with `path`. Use `const _path` with a small comment and restore the `const path` for the require in the beginning of the file?
Are you sure about this? The current string in mozilla central is sourceSearch.resultsSummary:

https://hg.mozilla.org/mozilla-central/file/tip/devtools/client/locales/en-US/debugger.properties#l129

(that's one of the things we changed in Bug 1334154)
No worries :) thanks for reviews and sorry for the spam!
I don't think createMap should have a side-effect on the value argument passed to it.

We should either restore `value.length = parseInt(value.length, 10);`, 
or work on a copy of value `copy = Object.assign({}, value, { length: undefined });`
nit: against
@jasonLaster  No, you reset it on the new map. But you still modified the argument. 

If you do : `let a = { length : 10 }; fromJS(a);` -> a.length is now "10" (string) instead of 10 (number)
projectPath is always set as the working directory in the rest of the script, so I'm not sure if this is really needed.
I tried commenting out this line and the script still ran correctly for both in and out of tree mc clones. Am I missing something? (in any case it doesn't hurt to have it)
nit: getCM is a bit opaque, getCodeMirror ?
What do you mean? Do you run the old debugger mochitests on CI?
I see
> ./mach mochitest --subsuite devtools --setenv MOZ_HEADLESS=1 devtools/client/debugger/new/test/mochitest/

I don't think this pref should affect any of them :/
assigned but not used?
indentation is off here (and also pretty inconsistent in the rest of the method, but this one hurts visually)
commented out code
A comment to explain why we have to guard here would be nice.

Is this related to the rest of the commit? This is a bug fix for very specific issue, even if we don't have a comment in the code, a git blame that would point to "Fix debugger not starting in the Browser Content Toolbox" would be a great first step.
Why are we using var rather than const here? If it's necessary there should be a comment explaining why.
Part of the codebase uses isEnabled from devtools-config, the rest uses the new isEnabled defined here. 

First, using the same method name is confusing,
Then: devtools-config reads the config from the configs/*.json files and utils/prefs reads them from the features object defined here. I can find "workers" and "eventListeners" defined both in the json files and here. What is the source of truth for knowing if this feature is enabled?

If we take eventListeners for instance, in SecondaryPanes/index.js it is read using prefs.js::isEnabled, and in client/firefox/events.js with devtools-config::isEnabled :(

I guess this was done to easily migrate workers and event-listeners from "config" to "features", but I think it's not worth the debt added here. 

Let's go back to importing { features } and reading the object everywhere we need, and cleanup all references to workers and eventListeners connected to config/*.json files. 
Hmmm that's probably my fault, but the "defaultValue" of the prefsHelper blueprint is only used in case we can't parse the serialized value corresponding to the preference. We should probably rename it in PrefsHelper, but I would also advise not to define it for booleans. 

Someone reading the code might think that these true/false are default values for the prefs whereas the real default values either come from the if() {} block above (when in development) or from the debugger.js pref file when in panel.
I ended up going with `getSteppableExpression` for now as separating out the two cases led to more conditional logic living in `getNextStep`.
Fixed.
@jlongster I think if we should destructure the `source` object and set the `url` and `sourceMapURL` values to an empty string by default. It would pass Flow's static analysis for `path.isURL` or `path.isAbsolute` since they only expect a string here. /cc @jasonLaster 

I just pushed the above changes in the latest commit. I'll change it whatever is recommended otherwise.

Just updated the Window rep to use `tiny` mode, and handled attaching the `isGlobal` property by cloning the rep value instead of mutating it.

I didn't realize `kind = ObjectWithUrl` was getting routed correctly to the `Window` rep component, so I also removed the kind change.

I'm still not sure I entirely understand the implications of the `else if (type === "object")` block where the `isGlobal` prop gets added, but it seems to work.

`frames` appears to be changing back and forth between an Array of `length` 0 and an Immutable Seq with a `size`.

That's what was initially causing #1056, because `frames.length < numFramesToShow` would never return true, because `frames.length` was always `undefined` if there were any frames. This new PR works but we've still got two different types of data coming into this component.

I'm still trying to figure out where that's happening in the reducers. This PR works but I still feel like `frames` needs to consistently be a Seq, or either `null` or a Seq. Switching between an Array and a Seq is probably how this bug appeared in the first place.

Should this be `frames.size`?

Here it is: https://github.com/devtools-html/debugger.html/blob/master/public/js/reducers/pause.js#L140

``` javascript
function getFrames(state) {
  return state.pause.get("frames") || [];
}
```

Should be

``` javascript
const { Seq } = require("immutable");
// ...
function getFrames(state) {
  return state.pause.get("frames") || Seq();
}
```

PR into your branch or into master?

Ah well you just merged it so I guess into master :)

Yeah, the default is `null`, so maybe it'd be better to just have the selector return the exact state and have the React view do a Boolean check for whether `frames` isn't `null`.

Even though it's never going to get called unless `frames` is truthy, I think it's still good to structure functions so that they could individually pass a fuzz test. But how about:

``` javascript
renderFrames(frames = []) {
    const numFramesToShow =
      this.state.showAllFrames ? frames.size : NUM_FRAMES_SHOWN;
    const framesToShow =
      frames.slice(0, numFramesToShow).map(frame => this.renderFrame(frame));

    return dom.ul({}, framesToShow);
  },
```

This makes the function's intent more clear â€” decouples it from `this.props` and annotates the type of `frames` by giving it a default. Even though that default is probably never going to get used, at least we've made it clear what `frames` is supposed to be.

Oh, actually `frames` is a `Seq`, not an array.  I guess we can do without `frames = []`.

But what do you think of the rest of the function cleanup?

Oh, I just pushed the commit that refactored it to `renderFrames(frames)` about 10 seconds after you clicked Merge. Do you want me to PR that one too?

This doesn't work. https://github.com/facebook/flow/issues/183 has been tracking broken support for destructuring in Flow for a while.

The problem is `{ source: Source}` transpiles to `var Source = object.source`.

Instead, I tried:

``` javascript
function renderFrameTitle({ displayName }: { displayName: string }) {
```

Unfortunately, this doesn't typecheck:

```
public/js/components/Frames.js:67
 67:       renderFrameTitle(frame),
           ^^^^^^^^^^^^^^^^^^^^^^^ function call
 25: function renderFrameTitle({ displayName }: { displayName: string }) {
                                                ^^^^^^^^^^^^^^^^^^^^^^^ property `displayName`. Property not found in
 67:       renderFrameTitle(frame),
                            ^^^^^ object type
```

I'll see what I can figure out by creating a `frame` type.

Got that to work when `Frame` is a type, but now the type declaration is really long:

``` javascript
function renderFrameLocation({ source, location }: {source: Source, location: Location}) {
```

Ultimately I'm not sure it's worth the additional annotations. But at least `{ source, location}: Frame` is more descriptive.

fixed, thanks
Added DebuggerClientTraits type to be used at multiple createSource callsites.
I cannot longer reproduce https://github.com/devtools-html/debugger.html/pull/3417, removing update line number formatting switch.
I think we cannot remove this line since we (I) cannot guarantee editors state before updateLineNumberFormat is called.
We need position/references of every name in particular scope. So we can match these with source maps original names.
it checks in `name` is a property in s.names dictionary. related to the `Object.create(null)` above
That might cause of creation many empty leaf objects.
Even if I did the check above, flow is convinced cacheSources.get can be undefined. Changing to ((x: any): Source) cast.
The recursive functions (even with tails call) are not really efficient in comparison with just a loop. I recommend to not introduce any unneeded recursion for simple algorithms, and in this case simple loop easier to read.
this might avoid extra async/await cycle for generated sources -- notice 'await' in the middle of the conditional operator  
looks good to me ðŸ‘ 
right, we might need to know difference anyway
list is incomplete too
Actually, it's similar to what any comparison function will return: negative for less, 0 for equial and positive for greater
Sorry, I don't follow your analysis. The algorithm above is basic binary search algorithm. I renamed 'l' and 'r' to 'left' and 'right' for clarity.
Added comments to the FindNodeInContentsMatcher instead.
Changed return type to return an object (I hope JIT will not create lots of objects in memory to GC them later). Measured performance for 3k file -- there was no real change in the performance.
No reason, probably just a habit to support old browsers. Changed to startsWith for readability, since all browsers we support have it.
> describing this function in plain english, and using the ternary values I defined elsewhere

The algorithm is using return values similar to comparefn defined in http://www.ecma-international.org/ecma-262/5.1/#sec-15.4.4.11 , and these are not compatible with  ternary values.
Not at the moment -- I did not want to affect any other logic that might be "assumed" in the code.
Code was moved to the ./treeOrder.js file.
there is no guarantee that localeCompare() will return only -1, 0, or 1 (based on spec). Writing `const result = name1.localeCompare(name2); return result === 0 ? T_UNKNOWN : result < 0 ? T_FALSE : T_TRUE;` to accommodate ternary values does not make any sense (and unreadable) IMHO.
I would keep that as is for now for readability. We can re-open the issue later. It's hard to measure atm -- it's impossible to run it with 10,000 or 30,000 load.
can you return `null` or `undefined` here? just to know result is expected.
to avoid garbage array creation `const names = symbol.specifiers ? symbol.specifiers.join(", ") : "";`
This change loses the tests for 0 and null, but I think those are important to keep as they are falsy values, and so easy to get wrong.  Probably we should even expand this to add the empty string, which I forgot about in the earlier patch.
These don't seem to be used.
I think some code comments here would be really helpful on why this ManagedTree is needed and how some of the handlers are flowing through. It's a little hard to un-pack what is going on here, even though I know you mentioned to me briefly that you needed this. I'm finding the props on here to be particularly confusing. It somewhat breaks the metaphor in my head of how props get passed in from above, because this component is essentially shadowing the the parent's props. The only two properties that are overwritten are the `onFocus` and `renderItem`. Could these be different names, more explicit names to make this clearer?

I don't know if things could be refactored a little bit to make it clearer what's doing what... It could just be a matter of being more vigorous with comments for some context.

Yeah, good point.

Thanks for the high-level description, I find these really helpful at the top of files.

I'm curious, is the concept of using actors here Firefox specific? I know you all had been doing some generic interfaces backed by a specific client for other parts of the debugger.

It feels weird to have state not on the state object in the context of a React component. I've not seen this before.

A little bit of docs would be helpful here. Not sure what bindings refer to exactly.

ðŸ‘ for sane webpack defaults that we don't have to re-think on each tool.

nit: Empty require, although you may plan on using it on a follow-up patch.
I'm curious why you would store the state in the component when you have Redux, rather than providing an isOpened, and toggleOpen functions as props, and then maintain that state in the store.
Yeah, this is much nicer.
Ah, just realized where these were coming from. It feels pretty magical using `this`, but is probably fine if it's an intermediate step. At least I have an entry point to know where the magic happens.
This test feels nice and self-contained, without the typical noise from mochitests.
Are you thinking of every mochitest being a trivial manifest like this to run to require and add the task?
nit: whitespacing
nit: whitespacing
A small comment intro would be appreciated here about why this file exists, it's not immediately obvious.
And again here, a small comment would be nice.
Isn't there a collection of waiting functions that this could go into?
ðŸ‘ Thanks, this takes the magic out of getting some globals.
Dependency injection ftw.
Any reason why these are commented out rather than deleted?
Gotcha. Didn't realize that.
Why'd this turn into a require?
Why is this changing, it's not obvious to me?
I'm confused here. It looks like you are adding `_input` to the prototype because you're setting it to null. You should be able to only do the type definition here, without actually setting a value and the error should go away. Flow treats class definitions as invariants.

```
const Expression = React.createClass({
  _input: ?HTMLInputElement,
```
Do you not flow type your bin scripts? I really like treating all my code as first class citizens.
I can roll back the style changes. Let's have the discussion here: https://github.com/devtools-html/debugger.html/pull/4454
The change was necessary after the explicit import of `setExpandedState` could have also renamed it, I guess. 
This is also a great way to do it!
Ah, forgot to roll that back. Will take care of it. Sorry for the confusion.
Yeah, it looks like a dirty hack to me... :)

Fact is, CRI is not meant to run in the browser, and actually I don't understand why you are doing so. I mean, if I were to write a web-based JavaScript debugger (DevTools like) I'd use CRI on the backend. I'm probably missing something and I've only briefly checked out debugger.html, but why do you need to run CRI in a web context?
If this is for subsettings, yes!

I'll get on adding this in tomorrow when I'm not on mobile.

Meaning as a variable name?

Hm, this had never occurred to me before. I think the better UX decision would be for these to have cursor icons, but I understand James' hesitation to be consistent. 

If we add this (which I think would be good), can we open a corresponding MC bug for someone to add the cursor pointers elsewhere in the tools?

I'm working on the breakpoint color nowâ€”I'll add the fix for that in that PR.

I should have removed this. Thanks for pointing this out.
We could avoid "!important" by modifying selector to `html .toggle-button-end.vertical svg`
@nchevobbe grouping them doesn't seem to work. I tried searching for this and got a question on stackoverflow relevant to this [here](http://stackoverflow.com/questions/16982449/why-isnt-it-possible-to-combine-vendor-specific-pseudo-elements-classes-into-on) .
Thanks. Learned something new!
@jasonLaster The first two lines should be sufficient
```
source "https://rubygems.org"
gem 'github-pages', group: :jekyll_plugins
```
:+1: If only we could do this `eslint` and `stylelint`.
Typo here `commarnds`
Minor change `alongside`
:+1: 
We should use some variable (`--theme-body-background`?) to make this work with all themes.
Might be good to add tooltip here using `tooltip` prop to this component.
This doesn't affect horizontal mode.
![horizontal](https://cloud.githubusercontent.com/assets/1755089/23468783/be06a988-fec7-11e6-96b4-c355d2ed1f25.png)

I'm not sure if this should be deleted. `autoprefixer` cannot add this. Any ideas?
I think we can change this to `export default class SearchInput extends Component {` and remove the last line (which has export statement).
For _line length_ issue we can always wrap arguments to different lines like https://github.com/devtools-html/debugger.html/blob/master/src/components/Editor/ConditionalPanel.js#L10

I wonder why we have `index` function parameter. It doesn't appear anywhere in function.
Can we change these two lines to es import like `import get from "lodash/get"` ?
I think there might be a small mistake here.

Consider the example where `list = [1,2,3,4]` and `predicate = (() => true)`. We might expect that `filterDulicates([1,2,3,4], ()=>true)` should return `[1,2,3,4]` but it instead returns `[1,2,3]`.

So, this might display one less entry in call stack.
Can we replace this with `import actions from "../../actions";` ?
@jasonLaster It is defined in this function 
```javascript
const node = ReactDOM.findDOMNode(this);
```
We need `node` to get all fold markers and toggle class. I'm not sure if there is a better method here other than using `querySelectorAll`.
I don't know if we should remove this now that source directories no longer have a trailing slash.
Removing that condition breaks this test https://github.com/devtools-html/debugger.html/blob/master/src/utils/tests/sources-tree.js#L151

It is because `http://example.com/folder/c/` is no longer considered a folder. 
This can also be implemented as
```javascript
this.refs.resultList.refs.hasOwnProperty(this.state.selectedResultIndex)
```
Or adding condition in https://github.com/devtools-html/debugger.html/blob/master/src/utils/result-list.js#L4 
```javascript
function scrollList(resultList, index) {
  if (!resultList.hasOwnProperty(index)) return;
  const resultEl = resultList[index];
```
I'm guessing that you could replace `any` with `Record<SourcesState>`. Can you try this?
oops looks like I was late :sweat_smile: 
We can probably use `import I from "immutable";`
Oh. Thanks for correction
We might want to add this to `assets/panel/debugger.properties`. You can take a look at #2516 PR to see how tooltip is added

EDIT:
For L10N https://devtools-html.github.io/debugger.html/docs/local-development.html#l10n
:+1: for refactoring.
You are going in correct direction.

But, I don't think we need to manually add this selector. We use [postcss-bidirection](https://github.com/gasolin/postcss-bidirection) to generate these selectors.

Here's how I would try
```patch
--- src/components/shared/Button/PaneToggle.css
+++ src/components/shared/Button/PaneToggle.css
@@ -23,7 +23,7 @@
 }
 
 .toggle-button-start {
-  margin-left: 5px;
+  margin-inline-start: 5px;
 }
 
 html:not([dir="rtl"]) .toggle-button-end svg,
```

You can use similar approach for `.toggle-button-end`

https://devtools-html.github.io/debugger.html/docs/local-development.html#rtl
Yes we could have props here but we also need to use it in below line

```js
shouldComponentUpdate(nextProps: Props)  {
```
I used the `type Props` to avoid duplication
Can we instead use `Props` which was already declared?

`type Props = { items: Array<Object> }`
Was going to say the same thing  :) They both are standard dom properties, so it should just work as normal props
I think this would probably cause a conflict, since firefox-hg adds `mozconfig` while you're adding `.mozconfig`

Both are supported, but you should only have one of the two, so you should probably override `mozconfig` here.
This can be simplified to:

```js
debuggee: this.props.debuggeeUrl && item.name && this.props.debuggeeUrl.includes(item.name),
```
You don't need the ternary that does `true : false` since your condition is already a boolean.
var(--theme-toolbar-highlighted-color) ?
mozilla-central uses -moz-context-properties, but that only works for Firefox's chrome. As for debugger.html, we can either use an SVG filter, then the fill property works fine from the CSS (but SVG filters have a perf-cost). The other possibly is a mask (but that instead uses background-color instead of fill).
Yes. I just titled it that because they are primarily responsible for the UI

That was Mr Laster's suggestions :)

I can do that.

I was thinking of linking to github for each component. Is that OK?

Are you wanting me to rename it?

will do.

I decided to just link to the Components, Actions, and Reducer directories

I will try to do this in a future iteration. I used these images because I thought most ppl would want want to try the redux tool out.

these are dynamically created components and I wanted it to be clear that you can create many of them.

@jasonLaster Ok! :)
Can you please tag jasonlaster instead of me? 
in this file `src/components/Editor/Editor.css ` ?

```css
:root {
  --editor-footer-height: 27px
}


```
@jasonLaster yeah, looks good ðŸ‘ let me pushed this
heh ok, ðŸ‘ 
From debugging the the keyboard shortcuts library, I noticed that the key code is mapped to DOM_VK_\* key when adding to the list of events. But when the event occurs, it is not mapped properly, and so the listener is not triggered. Which is why I needed to make this change to allow it to properly map the "function" key events in the library.

could you briefly tell me what would be the effect of adding a filter with an identity function to the result of map?

I took "url" from the navigate/will-navigate event payload from the tabTarget. But more importantly, this would only work for Firefox. I'll look to see if I can do something for chrome.

I opted against changing navigate after reading the comments in that method. But it makes sense, I'll move it it to navigate.

this code can be simplified by following up on your previous comments.

`targetUrl` could probably make sense for tabs and node also. Although, I haven't looked into node yet.

I am using `url` to check if the new target url is same as the old one, and based on that returning `state` or new `State()`

I'll wait for jlongster's thoughts on these changes.

@jasonLaster do you have any suggestion for refreshing the target debuggee in cypress without refreshing the debugger (for the integration tests)?

Okay. I'll do that then.
On Tue, Aug 30, 2016 at 10:03 PM Jason Laster notifications@github.com
wrote:

> In public/js/utils/path.js
> https://github.com/devtools-html/debugger.html/pull/631#discussion_r76913463
> :
> 
> > -  return path.slice(0, idx);
> >   -}
> >   -
> >   -function isURL(str) {
> > -  return str.indexOf("://") !== -1;
> >   -}
> >   -
> >   -function isAbsolute(str) {
> > -  return str[0] === "/";
> >   -}
> >   -
> >   -module.exports = {
> > -  basename, dirname, isURL, isAbsolute
> >   -};
> >   +const path = require("path-browser-wrapper");
> >   +module.exports = path;
> 
> I'd switch this and use the library directly where it is called.
> 
> â€”
> You are receiving this because you authored the thread.
> Reply to this email directly, view it on GitHub
> https://github.com/devtools-html/debugger.html/pull/631/files/8f7f9c8e5e3e87cdbdfb6d1c0cdb5ad3b6079e1e#r76913463,
> or mute the thread
> https://github.com/notifications/unsubscribe-auth/ACXb0e9dNidNcHIL3INzfpTuUF_8P4Krks5qlOD8gaJpZM4JxJlg
> .

+1 was having issues with this when I was working with it.

> I think it would be better to expand some of this out into a couple lines
> Could you elaborate what you meant here?

Also do you mean this?
`findElement(dbg, "button", ".resume.active")`
and 

```
const selectors = {
  ...,
  button: selector => selector,
};
```

Yes. The old debugger has `Shift+F11` for `Step Out`. I wrote the code for the keyboard shortcuts.. and I think I chose `F12` by mistake. I will rectify that here.

a lot of these helpers are are there in your PR. I'll wait for that to get merged and then work on your comments. ðŸ‘ 

It is a little late but... I was wondering if there is some reason you did not pull it out into it's own function for consistency?

haha.. okay.. I can remove them.. :D

this is how it looks in the old debugger. I just replicated that.

I was thinking of doing it but I had this question.
@jasonLaster If I do convert the `head.js` type annotation to Flow, will I have to make other changes to make sure that the mochitest still run? Or can it handle it?

@jasonLaster any choice on the accessKey?
since we are no longer adding empty expressions, this check might not be needed here anymore, maybe?
> lets move this to an instance function as we probably want to also check to see if the cursor is in the selection

couldn't find a straightforward way of doing it. basically, the cursor stays within the selection even though the pointer is right-clicking somewhere else. will follow-up on this in a subsequent PR.
that sounds like a good idea.
the find function `find(ctx, query, true, caseSensitive, wholeWord, regexMatch);` has 6 parameters while the function definition has 5. I would recommend putting keepSelection at the end or using destructured object parameters. keepSelection is required to prevent the selection from moving away.
in retrospect, this is a nice idea. ðŸ‘ 
nice catch. I didn't know about this one.
oh sorry for the messup. it's still wip. I'll ping you again once I'm ready with this.
the `source-map` library expects numeric values greater than 0.
@steffiau since @jasonLaster pushed some code to your branch. The best thing to do might be to fetch changes from your origin's branch and then push your new changes to it to make sure it doesn't overwrite his commit.
Something like:
`git fetch origin && git rebase origin/1756/searchshortcutalias`
I think you're right. I was unsure what the best would be to handle it. I removed it for now.
this is definitely interesting to find out!
I think so too. I'll change it now.
function `ok()` does not take any parameters.
`expect(true).to.be.truthy` probably always returns true.
It is so much cleaner than the other ways we explored. I'd also recommend making that change as Jason mentioned. Other than that looks good to me.
why 'loadObjectProperties(item.content.value)' wouldn't load the properties in loadedObjects map?
I added a second check here because it can happen that we do have a `contentType = "text/html"` or it is equal to something else. In that case, we would still like to render it as `htmlmixed`.

I believe that this logic might be simplified if in `devtools-core/devtools-source-maps` we set html contentType to `text/html` for file extensions `.html`.

In fact, I'm not sure if there's any case for `(!contentType && isHTMLLike)` as far as I could tell in any codepath.
I can probably pull this out of a `dispatch` call as it is not going to hit a reducer. most likely this is switching through reducers and doing a noop as there's no case for it. wonder if there's a better way to handle this?
@jasonLaster when I add `getClosestPath` on the worker it throws me a `DOMException` error. I'll try it again tonight and see if I fix it. I am successfully able to add other functions to the worker.
we still have a single entry-point function right? or you mean to drop the outer function altogether?
do you mean `awaitCommand` @jasonLaster?
flow complained here. maybe there's a better solution.
I called it astCommand, because it does similar things to command action. but it tries to use the parser AST to evaluate which command should be executed.
at the moment, this only adds 1 hidden breakpoint in the system. and it removes hidden breakpoint on next step. so there's only 1 hidden breakpoint.
that's one way to fix it. ðŸ¤£ 
ðŸ‘ Sounds good
This is required to make use of the `React.Node` or `React.Element` types. Alternatively, we could do something like

```js
import type { Node } from "react"
```
Uh oh, something is up with this diff. Something may have gone wrong while merging in master from upstream.
I am really unsure.
Transition is used within Slide. Which is the default export.
I did a quick search but couldn't find any usage of Slide, but bc I am a total noob on your codebase this doesnot mean I didn't oversee something
There is an existing angular.svg in the /assets folder which looked good to me.
Shall I replace it with the one you mentioned?
So shall I just revert this part and throw an error in dev mode & console.log?
Self is not used anywhere in this component except for the 2 lines below.
I think this should be `this.setExpanded= this.setExpanded.bind(this);` bc on Line 122 it calls it with `this`
`onExpand: item => this.setExpanded(item, true)`
`this.setExpanded` is used within `render` which is autoBound so this should work
`this.setExpanded` is used inside of `expandListItems()` which is called by `componentWillReceiveProps` (= autoBound)

So I think this is legit and should work. or am I completly wrong? @wldcordeiro @jasonLaster  
I'll revert it to before state but I am quite sure my changes work
Small typo: "will will". I think this should be "we will"
I looked how breakpoints are styled so I'll remove it there too
I really think we should remove this shortcut.
The other shortcuts are "actionable" at this point but search for functions can not be called from WelcomeBox because it  is only applicable on opened source.
Any thoughts @jasonLaster  @codehag 
I think this should be renamed because it has nothing to do with footer anymore.
I'd also like to move this into a new PrimaryPane.css file as this is not to related to Sources component at all.
Any thoughts about this?
Me too.
I always discuss that sort of naming with my team mates.
If something is named validateFoo I'd expect to get a validation result which provides detailed infos of that validation. Otherwise I'd name it can/has/is Fooable
Thanks @bomsy for looking at it and helping me out!
Small nit: we no longer need displaynames
You can remove the entire function
I didn't know why the others got renamed I I just wanted to ensure consistency. Should I remove the "2" from my new entries @flodolo
This should only be mentioned as a last resort.
I think it'd be a good idea to tell the user to check the yarn version and point that there are issues with yarn !== 0.28.4
This is not working on windows and we should avoid just pointing out platform specific solutions.
It might be a good idea to make our slack more prominent and not mention it at the end of the doc. Let's tell the people we love to help
When I comment out this lines prettier script runs on windows. It seems to me that the CLI wants to jump into the globbing which can not be done on Windows
When I get all the scripts working we can document the "validate" script as a starting point after initial cloning & running `yarn install`
At committing I got the following message:

> warning: LF will be replaced by CRLF in src/workers/parser/tests/__snapshots__/getSymbols.spec.js.snap.
> The file will have its original line endings in your working directory.
Shall we change this too?
We have lots of issues older than 30 days
Not sure which color to use as background.
This looked ok for me...
I forgot to remove this
You are right. Will change that
@jasonLaster we are already looking into it.
@bomsy is helping me out finding what's going on here
@jasonLaster  I looked at https://github.com/devtools-html/debugger.html/blob/c5f08e7dd63c7fc0f238c70ca016aa474e831105/src/workers/parser/tests/framework.spec.js#L6
There is no indication that it is async. 
Also https://github.com/devtoolshtml/debugger.html/blob/master/src/workers/parser/frameworks.js doesn't look to me if it's async. What am I missing/overseeing?
polished || updated
this would be the same as above
without that line jest gave the error react not found.
my guess was that the key syntax in the highlight function indirectly requires react.
still kind of weird to me though.
ah cool now i understand your function a little better.
not that familiar with writing tests yet. TDD the dream :)
will update pr as soon as i can thanks for the feedback.
i merged master into my branch and this is the current state 
https://github.com/devtools-html/debugger.html/blob/master/src/components/PrimaryPanes/Outline.js
not sure why still showing the diff.

I see, thanks for the info.  I removed it because size 11px makes the gutter font smaller than the size of text in the main panel to the right of the gutter, hence the height difference.  I'll try adding line-height instead.

Hmm setting a specific line-height (eg: 18px) doesn't give consistent result in Chrome and Firefox (Chrome is too short by 1px). 

#### Chrome :

![debuggerchromelineheight](https://cloud.githubusercontent.com/assets/2848472/19130437/1fca72b2-8b19-11e6-903b-f0256fdf4924.jpg)

#### Firefox :

![debuggerfirefoxlineheight](https://cloud.githubusercontent.com/assets/2848472/19130442/2341378c-8b19-11e6-83bd-ae3097e8b587.jpg)

Going back to the original css code, I get the gutter highlight misalignment in both Firefox and Chrome.  @jasonLaster do you only see this issue in Chrome?  

Setting the font-size to inherit makes the gutter font size consistent with the main panel for me and fixes the highlight height issue, not sure if that'll be the same case for you guys. 

Np I won't touch the breakpoint!  It's just that while I was trying to increase the highlighted line height, I noticed the breakpoint didn't cover the whole gutter anymore.

![debuggerbreakpoint](https://cloud.githubusercontent.com/assets/2848472/19131243/bb387124-8b1c-11e6-8e95-81edf0cf01af.jpg)

sure, it was 

```
.CodeMirror-linenumber {
font-size: inherit;
}
```

without adding any line-heights anywhere.

Why restrict the process to features (enhancements) and not also to bugs? Bug reports can also go stale, not just feature request. So I'd stick to "Issues" here instead of only "feature requests". 
I think that there might also be a 5th step for "Categorize the issue report with a suitable tag" linking to kind of an overview on what you have ('needs-ux', 'performance'). FWIW, I cannot find such an overview. This could be just a section of contributing.md or - well, even better - in this maintainer.md ;)

Reference to string ID is wrong here
No need to change this one. The string didn't exist, it's a shortcut so it doesn't depend on the label.
Same here, no need to change the string ID.
In this case you need a new string ID, the variable changes, dashboard will throw errors.
Pause %S
Resume %s
This should not be reverted, since the previous version of the string used %s (lowercase), we want to reforce translation: https://hg.mozilla.org/mozilla-central/file/default/devtools/client/locales/en-US/debugger.properties#l256
This change should be removed.
Argh, forget this. I have no idea why, but I thought I was commenting on a different string (the one with %s vs %S). Too many tabs open I guess :-\
Also, use â€¦ (one unicode character) and not ... (3 dots)
It should be safe-ish, but given it's 3 strings vs 1, I would prefer to have three explicit strings for each case and be 100% safe.
Nit: simply explain what's going to replace the placeholder.

```
# LOCALIZATION NOTE (welcome.searchFunction): Label displayed in the welcome
# panel's. %S is replaced by the keyboard shortcut to search for functions.
```

I think this should either be "for a function" or "for functions"? (not a native English speaker though)
Ugh, the genitive after panel should not be there (that's my mistake).
You don't need to bump keys for changing the case ;-) (that's why I approved explicitly).
https://developer.mozilla.org/en-US/docs/Mozilla/Localization/Localization_content_best_practices#Changing_existing_strings

That's a matter of internal consistency for English, other languages have their own rules and don't necessarily need to reflect this change.
It definitely makes debugger updates to m-c less surprising :-)
As I wrote a few days ago in Bugzilla, adding localization comments is not mandatory, they need to be helpful. In this case, try reading the localization comment and tell me if it matches the string (same for the next one) ;-)

@jasonLaster 
String reuse in different contexts should be avoided. Let's keep this separate from the one use from the header.
I suggest to use .label for labels.

```
# LOCALIZATION NOTE (editor.continueToHere.label): Editor gutter context
# menu item for jumping to a new paused location
editor.continueToHere.label=Continue To Here
editor.continueToHere.accesskey=C
```
Wrong string reference and comment
F
The comment is still wrongâ€¦
copyFunction -> copyFunction.label
breakpointMenuItem.removeCondition.label (I know devtools hasn't used this naming before, but it's clearer than just adding .accesskey to the access key).
breakpointMenuItem.editCondition.label
No, like this (just adding .label to the string used as label)

```
breakpointMenuItem.removeCondition.label=Remove breakpoint condition
breakpointMenuItem.removeCondition.accesskey=c

breakpointMenuItem.editCondition.label=Edit breakpoint condition
breakpointMenuItem.editCondition.accesskey=n
```
Please add back the empty line at the bottom
You need to change string IDs (also pay attention to localization note and accesskey)
https://developer.mozilla.org/en-US/docs/Mozilla/Localization/Localization_content_best_practices#Changing_existing_strings


To clarify, you need it also in this one (`errorLoadingText3` works.)
since we're doing this change. can we switch to use .label
no other letter available?
And, again, wrong string ID all over the place
this is a proper noun, so i think it's fine.
lets make a small util: `getSourceLocationFromMouseEvent` in `utils/editor/index.js`

```diff
from getSourceLocationFromMouseEvent(event) {
+       const { line, ch } = this.state.editor.codeMirror.coordsChar({
+         left: e.clientX,
+         top: e.clientY
+       });
+ 
+       return{
+         sourceId: selectedLocation.sourceId,
+         line: line + 1,
+         column: ch + 1
+       };
+ 
}
```
we can use this util to simplify EditorMenu as well
looks like meta should map to windows

https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent/metaKey
lets :bomb: this
I am not sure I understand why we are doing a no-op here. I think we might want to be able to remove hidden breakpoints. For example, if we have a continue-to-here breakpoint, we will probably want to remove it immediately so that it doesnt trigger the next time it runs, as it is not a user added breakpoint.

Thinking about it a bit further -- perhaps these hidden breakpoints should be "single execution".

Thoughts?
Ah, i just realized that this is persisted-breakpoints reducer. i was thinking of this as the breakpoints reducer. ignore this comment!
why do we need the two dashes at the end?
we might not need to do this anymore
since this was fixed by devtools-html/devtools-core#698 we might not need this change. @jasonLaster thoughts?
@codehag i still think it is a good practice to scope URLs. For instance, an eval w/ sourceURL, which is in one of the pages.
@jasonLaster cool, this is good to go from my side then

the `data` protocol issue can be investigated separately 
i'll move this to a separate PR, but the dashes keep the file passed in from being in quotes.
:+1: this is a good change. we shouldnt have hard-coded styles on the component when they are not calculated via JS.  
Yea, it should be moved into a class for now though. Until the actual effects can be looked over before removing it entirely. This affects quite a few areas and we don't know right off what the full impact of this change would be for everything in the interface.
Why addCondition2 and not just addCondition?
I didn't know why the others got renamed I I just wanted to ensure consistency. Should I remove the "2" from my new entries @flodolo
I'd keep the 2 to be consistent. We recently changed the labels to drop "breakpoint" e.g. `Remove breakpoint condition` to `Remove condition`...
We limit the max label width so a long filename wouldn't cause a broken layout
With `overflow` and `text-overflow`, a long filename would have the ellipsis style
Move .breakpoint-checkbox under .breakpoint-label to match the HTML structure.
TBH, using `vertical-align: text-bottom` to control the desired vertical alignment look is not general enough when considering if the font size changed in the future. However, it is simple, following the previous way, and quite explicit about we are addressing vertical alignment.
Provide a little bit vertical padding so that some text, like "g", won't get cut because of `overflow: hidden`, see the screenshot,
<img width="481" alt="screen shot 2017-09-17 at 5 06 43 pm" src="https://user-images.githubusercontent.com/5627487/30519499-addb7ea8-9bca-11e7-99d4-9aa25224771b.png">

ðŸ‘ 
For the watch expressions, the case is more complex. Consider:
1. If we wanted the ellipsis style on expression label [2], we had to modify the shared ObjectInspector component [1]. 
2. What to do with all kinds of values nested under watched expression?
3. Would it bring undesired side effect to others after we touched this shared node module?

Put all the concerns together, only to control the overflow style of ObjectInspector component from Expression.css probably is a reasonable trade-off.

[1] https://github.com/devtools-html/devtools-core/blob/e81f5fe2267539dec1083a97009bffd45aa7a096/packages/devtools-reps/src/object-inspector/index.js#L449

[2] 
![screen shot 2017-09-19 at 6 57 22 pm](https://user-images.githubusercontent.com/5627487/30590101-c5c60f8c-9d6f-11e7-8bf4-2d30028a63c7.png)

Thank you for the comment, maybe there is a more clear way to do this... Could we instead use overflow-x: hidden? ie)
```
overflow-x: hidden;
white-space: nowrap;
text-overflow: ellipsis;
```
lets move the 36px into a var, having it as a hard-coded value is a bit risky
@codehag went for `overflow-x`, didn't add `white-space: nowrap` because it wouldn't wrap with overflow set.
p.s still need `padding: 1px 0` here because the cut was made by not enough height + overflow hidden. The height is 14px which is a bit not enough for "g". We could specify a height above 15px to compensate the cut but the vertical alignment would be no good.
@codehag created a shared css var for breakpoint and expression
whey do we need to find scopes when the babel paths have a scope property?
We need position/references of every name in particular scope. So we can match these with source maps original names.
what is `m`? lets use a more descriptive name here

also the regex might just be `/^(\w)/` if we are ok with underscores
some terminates after the first match --- if i got it right, then probably what we want is a find

```javascript
// this is a guess. im not clear on how `if (.. in ..)` works, 
// but my guess is that it is checking a property on an object with the string 
// value of originalName.
// goal here is clarity
const foundScope = generatedScopes.find(s => s.bindings[originalName])
const generatedName = foundScope.bindings[originalName]; 
```
two things:
1) the substring of expression -- what is expression? do we perhaps want to search the expression, rather than taking a certain length of the expression? what are we filtering out here? what is meaningful here is really the question im asking myself

2) lets split this up so we are not doing so much in one line

```javascript
const substring = expression.substring(originalName.length);
return `${generatedName}${substring}`;
```
i used string interpolation, but the `+` is of course also fine
there is a lot to unpack here. what makes me a bit uneasy, is we do not see what is happening from this line. we should be more explicit that this is a higher order function, how the arguments are applied, and move this block out of the return statement

```javascript
  return _HOF(generatedLocation); // obviously dont call it this
}
// ...

function _HOF(generatedLocation) {
  return (...args) => // this is more declarative
    parser.getScopes(...args)
    .then( ... // the rest of the code as you have it

}
```
`fix` is a bit ambiguous -- it can mean to fasten, to set into place, or it can mean to correct. correct is also problematic because it suggests that there has been some sort of corruption of the data -- perhaps better is `getSourcemapedExpression` ?
this can be its own function, as we do the same thing on lines 230-237
should be const
we are making a circular reference here. that makes me a bit nervous -- what is the goal here?
not something that needs to be changed; but this might be clearer as a recursive function that returns when it terminates. maybe, not sure myself to be honest ðŸ˜… i might just have an aversion to while loops

```javascript
function isScopeFunction(scope) { // can be moved out to a helper
  return  (scope.type !== "Function" && scope.type !== "Script")
}

function getFunctionScope(scope) {
  if (!scope.parent || !isScopeFunction(scope)) {
    return scope;
  }
  return getFunctionScope(scope.parent);
}
```
we don't strictly need this return, since the rest of the body is else statements. on the other hand we can remove else and just use if statements with returns
this is pretty hard to read, we could again do a recursive loop (which is a matter of taste) or add a comment explaining that we are traversing up the parents of the scope

```javascript
function _recordIdentifierPosition(scope, name, loc) {
  function _recurseParentTree(_scope) {
    if (!s.names[name]) {
      return;
    }
    _scope.names[name].refs.push(loc.start);
    return _recurseParentTree(_scope.parent);
  }
  return _recurseParentTree(scope);
}
```
i think i have reviewed a very similar piece of code here: https://github.com/devtools-html/debugger.html/pull/3852/files/e0f9e89e7ee904fbd1d1a17a0d801e8f7a1965dc#diff-dcf4c6f392912b09dabbbf7f6d2436b4

rather than copying this over, maybe check there first -- the same comment apply here
this never gets reassigned; can be a const
the comments written here: https://github.com/devtools-html/debugger.html/pull/3852/files/e0f9e89e7ee904fbd1d1a17a0d801e8f7a1965dc#diff-dcf4c6f392912b09dabbbf7f6d2436b4

can also apply here
this might avoid extra async/await cycle for generated sources -- notice 'await' in the middle of the conditional operator  
:+1:
could use a bit of work :)

nit, but i'd prefer async/await here:

```js
const astScopes = await getScopes(location)
const generatedScopes = await sourceMaps.getLocationScopes(location, astScopes);
if (!generatedScopes) {
  return scope;
}

return extendScope(scope, generatedScopes, 0);
```
recursion, nice :P
looks good to me ðŸ‘ 
it'd be nice to have unit test for this
do we maybe still want this in the normal layout?
nice catch :+1:
These 3 additions are the real change.
i think `validateSyntax` reads a bit better, i still expect a boolean return value. thoughts?
cool! ... wondering if `validateSyntax`  returning a boolean won't be confusing. Maybe we should return the expression string if it doesn't fail and if it fails we return the error object.
I see, it might be nice to show a formatted error object `Syntax Error: foo)( is terrible`.

yep. up to you. I don't know if you can serialize `e` and send it down from the worker, but something simple could work. Success `true` error, `{error: {message: "YO", name: "SyntaxError" }}`
@jasonLaster i like `hasSyntaxError`!
Me too.
I always discuss that sort of naming with my team mates.
If something is named validateFoo I'd expect to get a validation result which provides detailed infos of that validation. Otherwise I'd name it can/has/is Fooable
hmm, it might be nice to do `${e.name} : ${e.message}`;

This would communicate the syntax error which is more descriptive.

why the timestamp?
maybe we re-think this a bit and do something like this:

```js
const error = await parser.hasSyntaxError(expression.input);
const result = error || await client.evaluate(input, { frameId })
return dispatch({
  type: "EVALUATE_EXPRESSION",
  input: expression.input,
  result
});
```
meh .... no real reason :)

hahahaha ... changed it based on your suggestion in a previous review :)
lets drop ` status: "done"` and not check for it in the reducer
:+1: for is/has for functions returning booleans.
`id` must be unique.
You need to change string IDs (also pay attention to localization note and accesskey)
https://developer.mozilla.org/en-US/docs/Mozilla/Localization/Localization_content_best_practices#Changing_existing_strings


lets switch this key to `copySourceURI`
To clarify, you need it also in this one (`errorLoadingText3` works.)
this is looking good.
the only thing changing between these cases is the value output. I would suggest that we separate the getting of the value from the dispatch; this way it is clear that only the value changes between the three cases

```javascript
// can be outside of the scope
async function getExpressionValue(error, input) {
  if (error) {
    return { input, result: error };
  }
  if (!isPaused(getState()) {
    return await client.evaluate(wrapExpression(input));
  }
  return await dispatch(evaluateInputAtFrame(input));
}

// ... 

const value = await getExpressionValue(error, expression.input);

return dispatch({
  type: "EVALUATE_EXPRESSION",
  input: expression.input,
  value
});
```
I see two issues here: 

ensureParserText is potentially.. doing a lot of things, and it is being used a lot. if a loadSource is in flight (for example, someone forgets an await somewhere), we may be retriggering it here, with no way of cancelling the original and as a result -- doubling the work. 

second issue: "ensure" doesn't tell us that it is going to load the source text and then set the parser, so unless everyone who uses this function checks the definition, they will not see that it is not checking for a source (ensure suggests that "lets check if it is there, if not throw an error", similar to assert). 

I think this needs to be renamed / possibly removed and the core problem addressed instead (better state management) -- what do you think?
Since we do not use movetab unless it is a hidden tab (and in that case, always moving it to index 0), i am wondering how important moving tabs is? Perhaps, if the uniqueness of the ID is more important, we can leverage orderedSet instead, with unique keys (the id being the key)? Since the id is not data being used in the tab itself, and to identify it in the group, this might make a few things easier.

jut curious, why are we prefering merge here to set?
this function is doing two things, moving and adding -- lets split this into two functions.

I think this is immutable?
i think we can always `return prefs.tabs || []` ?
also, i investigated when we move tabs... it is rare. is there any information on why we have so much infrastructure for moving things?
typo: `focus`
wow - this is really cool!
what i think is happening here is that we will avoid showing a popup when you hover on a number, but we will show it when you hover on a variable?!?! is that correct?
Yup... the getPreviewType() is what determines if the popup is a tooltip or a full popover.  The invaildType in the expression.js is what avoids showing the popup when over a number, string, or atom class
For future reference, adding punctuation is not correcting text case. It doesn't help that this was sent into a PR with hundreds of other changes
this file can be ðŸ’£ 
lets do this in a new PR.
lets do this in a new PR
Use `setDirectoryRoot.label`.

I also have a hard time understanding the comment: what does "directory open" mean? 

I would guess something like this

> Command label in the context menu to set the directory root when opening X (or using the command Open X

but I have no idea what X is.
perhaps we can make this more specific. looks like this might be a string
lets use `!==` 
since everything else here is nextProps... this might also need to be nextProps... is there any information on why we would want the old url?
maybe we should be more explicit here. like giving an empty list, empty string, and empty root?
Adding/removing punctuation is not a minor change, these require a new ID
Why are you adding a second string, identical to the one above?
these shouldn't be changed here. it's a rebase gone awry
By better state management i mean introducing sagas :P but jason will give me serious side-eye for that one
Good points, and I'm curious how they should be addressed.

1) maybe a state of `loading` on the source with the promise? so that `ensure` can return it.

2) I was also confused at the beginning, but now it makes sense to me. `ensure` is not like `assert`. But you could also call it `loadSourceTextIfMissing` (similar scheme to `performUpdateIfNecessary` from https://github.com/facebook/react/blob/v15.6.1/src/renderers/shared/stack/reconciler/ReactReconciler.js#L184)

3) What do you mean in "better state management"?
brilliant!
I prefer checking the command for whether we're evaluating an expression...
we check the `frame.displayName`, because the debugger is now resuming, it's no longer evaluating an expression
switching to `correctIndentation` because it's prettier...
cleaning up indentation because it makes me ðŸ˜„ 
it feels like this should be `isPausedInEval` ?
is this ok?
yep, the `eval` is unnenessary here
I don't know if this is the best way to grab properties... `ObjectInspector` uses `const getObjectProperties = id => loadedObjects[id];` but I couldn't get that to work :/ Any insight is appreciated ;)
can we use https://reactjs.org/docs/react-api.html#isvalidelement ?
why are we adding a border?
where does this width come from?
where does this number come from? maybe we should have a variable instead?
this might be moved into its own function, and instead have this:

```javascript
function getContent(val) {
  switch (typeof val) {
  case "object":
    if (val.class === "Function") {
      return`${val.displayName}()`;
      // .. and so on
}

const content = getContent(val);
```

`attributes[key].value === val` so lets use `val.toString()` instead :)


do we have any errors thrown from this in the console? (asking because I can't test it at the moment ðŸ˜… )
do we always have two roots? could we maybe destructure them like so:
```javascript
const [rootState, rootProps] = this.roots.filter( //...
```
we are adding a magic number here, maybe we can use existing styles?
could we filter the roots to just be two properties:

```js
roots = roots.filter(root => ["state", "props"].includes(root.name));

```
At the moment, i want to avoid styling so we have some more flexibility. I think this means we can avoid the `ReactPopup` and just re-use the OI :) 


ya that's already being done in `ReactPopover.js`
nice... for now though, we can leave that out too. i'm okay w/ users expanding :) 

sometimes you'll want state, sometimes props. Either way, we'll iterate quickly
this is pretty esoteric, how did you come up w/ it?

could you link to a stack overflow or other known issue w/ firefox and fit-content

e.g.
```
// NOTE firefox does not support `height: fit-content`
// stackoverrflow.com/sldkjfslfjsljsldflsdjslkdjfls
display: table;
```
Yeah moz-fit-content didn't seem to do the same thing as fit-content
https://stackoverflow.com/questions/7839164/is-there-a-css-cross-browser-value-for-width-moz-fit-content

That's more from observation than anything concrete I found :/
Hmm it doesn't seem to work for our purposes. Something like:
`  const reactElem = <span>hi sam</span>;
  React.isValidElement(reactElem);`
yields `true`, but in Popup.js we're not dealing w/ react objects, we get `roots` which I'm not totally sure what is lol (its definitely an array of elements that do not look like react elements). I know that `roots.some(root => React.isValidElement(root))` yields false even when hovering on a react component
haha - we'll get back to this... as we do other objects

and yeah, i kinda like looking at a super secret internal prop
it might be clearer to factor the flow type out into its own type; ie)

```javascript
type transformUrlCallback = string => string

// then used as 
function resolveFileURL(
  url: string,
  transformUrl: transformUrlCallback = initialUrl => initialUrl
```
Great idea! I'll do that later tonight.
Done.
should be `reducers/file-search` 
remove this line
we can remove this line as well
this one too
should this also be FileSearchState?
I'm on the fence about this but i will mention it anyway; is action.modifier a string? could we do something like  
```javascript
prefs[`fileSearch${action.modifier}`]
```
(i think it needs a first letter uppercase, but you get the idea)

since we seem to be doing the same thing each time, and we might not need this extra layer
lol we tried to do this kind of thing before, but it is too magical.

a big style reason not to, is that it is nice to grep for pref keys, just like it's nice to grep for l10n keys
Did you mean to remove the search shortcut?
yes, because the search bar is now unmounted when it is not open. See the Editor/index render method
I see that. But now there isn't a way to enable the search bar? 
oh, we should probably fix that :) 

I think i was going to add a shortcut in App.js or Editor/index 
i bet we can do some `doSearch` tests now where we stub codemirror. Obviously not a blocker, just excited
Adding this key code worked but it feels wrong. ðŸ™ @jasonLaster Care to dig in a bit?
I don't know why the second ent here seems to be the trick.
sure... 
also weird...
 I think it was done initially, in the bid to cover all the possible moving scenarios, now we can make more informed improvements!
yeah your right we do not do much with move tabs, and i'm in favor of removing it. maybe add tabs can handle moving if a tab already exists. An orderedSet might be cool, will look into it a bit more.
Should this be `fnc`, not `func`?
we exclude some of these from the bundle: 

https://github.com/ahuth/debugger.html/blob/fix-warnings/webpack.config.js#L53-L61
:thumbsup: 
right, we might need to know difference anyway
list is incomplete too
OK, so there are two problems here:

1.  It should be `fnc`, not `func`
2.  `TypeError: content.wrappedJSObject.apply is not a function` bricks any test that uses `invokeInTab`.  So, for example, if I dumb it way down with the following, all tests run:

```js
function invokeInTab(fnc, args) {
  info(`Invoking function ${fnc} in tab`);
  return ContentTask.spawn(gBrowser.selectedBrowser, fnc, function*(fnc, args) {
    // content.wrappedJSObject.apply(fnc, args); // eslint-disable-line mozilla/no-cpows-in-tests, max-len
    console.log('invoking in tab: ', fnc, args);

    // FIX HERE
    if(args) {
      content.wrappedJSObject[fnc](...args);
    }
    else {
      content.wrappedJSObject[fnc]();
    }
  });
}
```
We're sending 3 args here, while `invokeInTab` only accepts two; don't think we need `dbg`.
...actually, simply removing that doesn't fix test failures.  Still looking into it.
This function doesn't appear to be used -- can we get rid of this?
yeah, lets kill it
lets set a variable above.

`const SearchBarComponent = SearchBar.WrappedComponent;`
We can also use the class properties for state, and all of the other vars set in this constructor
(and then this overridden constructor can be removed)
ðŸ‘ Sounds good
this also moves all of the stepping buttons over to the right hand side of the bar, which is not something we want to do right now. lets remove this rule
I was thinking that the button could be a simple `?` (since im used to it from other editors) with no K (since K is not necessarily meaningful).. not sure, what do you think? 
we have this work done in https://github.com/devtools-html/debugger.html/pull/4265/files. so lets remove these changes from this PR :)
do we need to unmock these in an `afterEach`?
closing because this works.
does it make sense to have this in `getURL` to have one module for URL parsing?
:+1: 
just curious: why not `part.startsWith("www.")` ?
we are always returning a function. One that always returns a number. perhaps we can make that clear from the return type:

```javascript
function createTreeNodeMatcher(
  part: string,
  isDir: boolean,
  debuggeeHost: ?string
): NodeMatcher {
```
perhaps this should be 

```javascript
type NodeMatcher = Node => number
```

shorter and clearer naming, and we can get the node from the types (it is already imported)
you are returning a ternary result, `-1, 0 or 1`. However it is unclear given how the code is written

instead, set constants for this:

```javascript
// `T` in this case stands for ternary. These are values associated with Ternary logic: https://en.wikipedia.org/wiki/Three-valued_logic
const T_FALSE = -1;
const T_UNKNOWN = 0;
const T_TRUE = 1;
``` 

It is ugly but clear
this should be consistent with the rest

```javascript
return node.name.localeCompare(part) ? 1 : 0; // but using either T_TRUE or T_UNKNOWN
```
describing this function in plain english, and using the ternary values I defined elsewhere (`T_TRUE = 1, T_UNKNOWN = 0, T_FALSE = -1`):

* we take the tree contents which is an array. if that array is empty, we return -1.

* if it is not empty, we set a start point ('l' for left) and an end point ('r' for right)

* so long as the starting point is less than the end point, we also select a center point ('c')

* if the center point is `T_FALSE` ( -1 ) -- then it should be at the bottom of the list, so we set the start point (l) to c + 1

* otherwise, the center point is `T_UNKNOWN`, or `T_TRUE`, so we set the ending point to C

example:

```
0|1|2|3|4
----------
l| |c| |r

if (matcher(contents[c]) === `T_FALSE`) 
0|1|2|3|4
----------
 | | |l, c|r // ignore the first half of the array

else
0|1|2|3|4
----------
l|c|r| |  // ignore the second half of the array
```

* Once the loop completes, (and our starting point "l" is greater than our endpoint "r") 

```
0|1|2|3|4
----------
 |r|l| |
0|1|2|3|4
----------
 | | | |r|l // outside of the original array if all matcher checks return `T_FALSE`
```

we check if the result is `T_UNKNOWN`. If it is unknown, we return the starting value ("l").

If it is either `T_FALSE` (-1) or `T_TRUE` (1), then 

- check if it is `T_FALSE`, if it is, return the starting point ('l'). 
- if it is `T_TRUE`, return the starting point ('l') plus 1. 

whatever the result is, make it negative and -1 from it.

```
0|1|2|3|4
----------
 |r|l|x|   // if `T_FALSE` is true, the returned position will be -(l + 1) ( also see above for the off by one case, where  | | | |r|l|x -- is outside of the existing array by two spots)
0|1|2|3|4
----------
 |r|l| |x| // if `T_TRUE` is true, the returned position will be -(l + 2)
```

this code is essentially taking an array, seeing if the matching position would be above or below the center, and halving it to the side where the element might be found. That isnt immediately clear from the code. there are two things contributing to this: 

1) bad naming. Single character variable names shouldn't be used except in special situations, and this isn't one of them.
2) return value is doing too much. it is unclear to me why we need it to be negative, or why we need to add +1 to it. can you clarify why this is happening? also, there are a lot of magic things happening, for example +1 is being added in a number of places without any reason explained behind it. return value is a good example of "why are we adding 1 and then making the whole thing negative and then adding 1 to it again". at the very least the return value needs to be split up


it also seems like we are avoiding complex data structures, but in this case i think we need them. we shouldnt be checking for negative indexs to tell if a node is new or not.

this should be moved to its own file, each HOF can be split into its own function and named. that way you wont have to add so many comments

```javascript
function indexMatcher(indexName) {
  return (node) => (node.name === IndexName ? 0 : 1);
}
function domainMatcher(indexName, debuggeeHost) {
 return node => {
   if (node.name === IndexName) {
      return -1;
    }
    return isExactDomainMatch(node.name, (debuggeeHost: any)) ? 0 : 1;
  };
}

createTreeNodeMatcher(...) {
  //...
  if (part === IndexName) {
    return IndexMatcher(indexName)
  } 
  if (debuggeeHost && isExactDomainMatch(part, debuggeeHost)) {
    return domainMatcher(indexName, debuggeeHost)
  }
  // ... etc
```
so, if an index is negative, it is a new node? and if it is positive it is an existing node? that is difficult to understand. why not use a tuple? { index: <number>, newNode: <boolean> }
see other comments

it is so unclear what is going on here. we shouldn't be using negative numbers to determine if something is a new node
Actually, it's similar to what any comparison function will return: negative for less, 0 for equial and positive for greater
Sorry, I don't follow your analysis. The algorithm above is basic binary search algorithm. I renamed 'l' and 'r' to 'left' and 'right' for clarity.
Added comments to the FindNodeInContentsMatcher instead.
Changed return type to return an object (I hope JIT will not create lots of objects in memory to GC them later). Measured performance for 3k file -- there was no real change in the performance.
No reason, probably just a habit to support old browsers. Changed to startsWith for readability, since all browsers we support have it.
> describing this function in plain english, and using the ternary values I defined elsewhere

The algorithm is using return values similar to comparefn defined in http://www.ecma-international.org/ecma-262/5.1/#sec-15.4.4.11 , and these are not compatible with  ternary values.
Not at the moment -- I did not want to affect any other logic that might be "assumed" in the code.
Code was moved to the ./treeOrder.js file.
Thanks for the tip, Ill keep that in mind for the future
:+1: i mean ternary as in: https://en.wikipedia.org/wiki/Three-valued_logic -- which i see as being similar to what is going on in the sort / comparefn that you linked (the difference being that 0 is used for "equal" instead of "undefined"). But i could be wrong... anyway, thank you for the changes it reads much better!

there is no guarantee that localeCompare() will return only -1, 0, or 1 (based on spec). Writing `const result = name1.localeCompare(name2); return result === 0 ? T_UNKNOWN : result < 0 ? T_FALSE : T_TRUE;` to accommodate ternary values does not make any sense (and unreadable) IMHO.
thanks for clarifying why you were doing what you were doing before! The garbage collection might be an issue, true. I hadn't thought of that, and you are totally right

Perhaps a way to make the code readable and more memory efficient (trying to balance things :sweat_smile:), we could keep the code you had (with a comment about what it was doing, a more explicit comment)

then where the value is used, have a wrapper function that translates the value? 

ie)

```javascript
export function findNodeInContents(
  // ...
  // returns a negative value for a new node, offset by one
  // returns a positive value for an existing node
  return -(result > 0 ? left : left + 1 ) - 1;
```

with helpers
```javascript
function childFound(child) {
  return child > -1
} 

function determineIndex(child) {
  // return a valid index whether the child is new (an therefore a negative number off by one)
  // or if the child is an existing index
  return child > -1 ? child : -child - 1;
}
```


then where it is used:
```javascript
if (!childFound(childIndex)) {
  return createNodeInTree(part, path, subTree, determineIndex(childIndex));
}
```
I would keep that as is for now for readability. We can re-open the issue later. It's hard to measure atm -- it's impossible to run it with 10,000 or 30,000 load.
assigned but not used?
indentation is off here (and also pretty inconsistent in the rest of the method, but this one hurts visually)
commented out code
A comment to explain why we have to guard here would be nice.

Is this related to the rest of the commit? This is a bug fix for very specific issue, even if we don't have a comment in the code, a git blame that would point to "Fix debugger not starting in the Browser Content Toolbox" would be a great first step.
Why are we using var rather than const here? If it's necessary there should be a comment explaining why.
Part of the codebase uses isEnabled from devtools-config, the rest uses the new isEnabled defined here. 

First, using the same method name is confusing,
Then: devtools-config reads the config from the configs/*.json files and utils/prefs reads them from the features object defined here. I can find "workers" and "eventListeners" defined both in the json files and here. What is the source of truth for knowing if this feature is enabled?

If we take eventListeners for instance, in SecondaryPanes/index.js it is read using prefs.js::isEnabled, and in client/firefox/events.js with devtools-config::isEnabled :(

I guess this was done to easily migrate workers and event-listeners from "config" to "features", but I think it's not worth the debt added here. 

Let's go back to importing { features } and reading the object everywhere we need, and cleanup all references to workers and eventListeners connected to config/*.json files. 
Hmmm that's probably my fault, but the "defaultValue" of the prefsHelper blueprint is only used in case we can't parse the serialized value corresponding to the preference. We should probably rename it in PrefsHelper, but I would also advise not to define it for booleans. 

Someone reading the code might think that these true/false are default values for the prefs whereas the real default values either come from the if() {} block above (when in development) or from the debugger.js pref file when in panel.
this variable should also be renamed for consistency
this should be moved into its own file (called "generators")

reason being:
`yield` isnt asynchronous. its a generator. generators are processes that can be paused and resumed. it is the building block of the async/await keyword, but is not itself asynchronous.

here is a good write up, in case you are curious in reading further :) http://exploringjs.com/es6/ch_generators.html
as mentioned above, yield is synchronous, so we should have it in its own file
ðŸ‘ nice test!
this should be separated, or the function (getAsyncExpression) renamed (maybe to getSteppableExpression ?), since yield is not async and this would lead to misunderstandings later on.
this also needs to be renamed. in general it is too long. Maybe `_getNextStep` since that is what it is doing
this should be totally renamed i now realize. it should probably be `currentExpression`
I ended up going with `getSteppableExpression` for now as separating out the two cases led to more conditional logic living in `getNextStep`.
[sortBy](https://lodash.com/docs/4.17.4#sortBy) could be amazing here:


```js
sortBy(bps, ['filename', 'line'])
``` 


@ohana54 We could make react more specific by maybe changing the react regex to `/^react/i`
If I'm not mistaken, we check the entire url, which means `react` can be anywhere in the url and not just in the beginning. We can try to get the filename from the url and then it would be easier. 
my bad ! ur right. what of this `/(react)/i` instead?
It would create a capture group, but still match `react` as part of `preact`.
The closest thing I found is reverse look-ahead (use look-ahead after reversing the string) but I think it's too complex.
looks like it might be a timing issue
we won't need the constructor here anymore .. right?
Whoops, was on autopilot towards the end and missed it. Fixing now.
these will all have to go ...
Is this tested?
Good question, I've thought a lot about testing this function and I don't think we should write a unit test for it. Let me explain:

1. we have a mochitest for the mapping in scopes
2. we have individual unit tests for all three calls. 

This function is the classic glue/contract function. If we were to test it i'd want to stub the calls so as not to repeat a test, at that point it will be a test that `replaceOriginalVariableName` is called w/ expression & generatedScopes
we should move this function out of utils/parser because it's not in the worker
When I comment out this lines prettier script runs on windows. It seems to me that the CLI wants to jump into the globbing which can not be done on Windows
When I get all the scripts working we can document the "validate" script as a starting point after initial cloning & running `yarn install`
At committing I got the following message:

> warning: LF will be replaced by CRLF in src/workers/parser/tests/__snapshots__/getSymbols.spec.js.snap.
> The file will have its original line endings in your working directory.
lol @jselmani @GarethSharpe we've gotta fix the CLRF [bug][b]

[b]:https://github.com/ryanjduffy/parse-script-tags/issues/3
Was a comment going to be added here? if not we can remove this
Likely a mistake on my part @bomsy...I'll remove that.
i'm thinking something like `shouldIncludeChildren` feels better and clearer then `isRecursive`
we can remove this line ...
... and make this `const children = [];`
We could pull this into a local function like this here
```js 
    const toggleItem = item => {
      const path = this.props.getPath(item);
      if (isExpanded) {
        expanded.add(path);
      } else {
        expanded.delete(path);
      }
    };
```
Then  do `toggleItem(item);` here
This for loop can become
```js
        for (const parent of parents) {
          if (parent.contents && parent.contents.length) {
            for (const child of parent.contents) {
              toggleItem(child);
              children.push(child);
            }
          }
        }
```
As you should not need the `continue` ...
And may not need `nodeHasChildren` since you only use `parent.contents` anyway, you can just check that
We can remove this line
Could `Array::find` work here as well, @jasonLaster ? We seem to have mixed use of lodash and native find across the code.
Yeah, that's a good find! that would be a nice PR because we have good test coverage here
idk if this is the right place for this. Also the key is a placeholder, the suggested `Cmd+G` is [already in use.](https://developer.mozilla.org/en-US/docs/Tools/Keyboard_shortcuts#Debugger)
this whole pattern is from @codehag's diff on the associated issue. 

It feels like these (SymbolModal, ShortcutModal, GotoLineModal) should all be the same thing ultimately, but I thought this would be a good start before merging them together.
I'm pretty sure this file is actually not being used anywhere (it's also called in `SymbolModal.js` but the `.symbol-modal-wrapper` and `.symbol-modal` classes are never applied afaict). I might suggest merging the [remaining rules](https://github.com/devtools-html/debugger.html/blob/master/src/components/SymbolModal.css#L18-L31) into `shared/Modal.css` instead but that's just outside the scope of this pr.
Use â€¦, not ...
Please stop copying localization comments without updating them
Does this even work? IIRC you need to press shift to get to that keyboard in English, and that's a modifier.
It does work. There is an attached gif.
Hi @flodolo , thanks for helping our contributors with their prs. I would like to point out that the wording of this comment can be read as aggressive, and we want our contributors to feel safe and that their changes are welcome. Phrasing such as "Does this even work" can be off-putting for a contributor, and can also turn away potential contributors who are looking through our PRs to get a sense of the community. It is especially problematic to have this on something that is clearly labelled as a work in progress, since the person may be looking for feedback.

If you find something amiss, think of how to word things in a way that are not judgemental or polarizing.
Sorry. Yes. You do have to press shift to get to that symbol, but this syntax works to trigger that. In any case, it's a temporary key that can be changed to anything that makes the most sense.
A more constructive way to say this would be "Please update this localization note to reflect the new key"
It wasn't meant as an hostile comment towards the author, if it came across like that, I apologize.

For context: this is happening in several PRs every week, so I think there's a general issue to solve. Commenting strings is not mandatory, comments are there to give context to translators. On the other hand, I have the feeling most developers think they are, but copying and paste an existing comment is not the solution.
As above, this comment wasn't meant as hostile or derogatory. 

I can't fully understand in which state a PR is when it's open (I'm not a developer, I work on localization), if it's testable or just an early WIP (it looked like that), hence the question "Does : even work?". There was no underlying implication, i.e. "are you even testing your code?", in my question.

I don't know exactly how devtools or debugger manage shortcuts internally, but I don't think it would work for a feature in Firefox, since we stumbled upon it for shortcuts on special characters like [ or ]
You still need to update the comment itself (you only updated the reference to the string ID, but the text describes a different function).

At this point I would suggest to drop this comment completely, put this string near the one above (that already has a comment explaining the function), and call this string `gotoLineModal.commandkey` to avoid any potential confusion. 

There's no rule set in stone for key naming, but `.key` is more prone to misinterpretation that `.commandkey`.
thanks for clarifying! And again thanks for helping :)
Oh that's a good idea.

To reiterate, `Cmd+:` is definitely temporary, just needed something to use for testing b/c the suggested (in the linked issue) `Cmd+g` is already being used. I think ultimately just `:` would be a good shortcut _from an already opened modal_ but definitely not as a global shortcut key.
It did come across like that, so thank you for apologizing. I have no knowledge of what other PR's look like (this is my very first one of any substance) or that the comments are optional, I'm just trying to match what's around the usage with the expectation of being corrected if necessary, so thanks for catching it, it was an oversight.
It took me a while to figure out what you meant by this, that the first is a unicode character is hard to discern from the text. Putting them in `pre` fences would help distinguish them i.e.
 `...` vs `â€¦`.
Good point, I'll keep it in mind.

(in case you're seeing this comment twice, I re-added comment in the right thread).
I think we might want to handle "Escape" too
this is just a style thing, but i tend to prefer early returns

```js
if (e.key === "Enter" && query != null) {
 if (!isNaN(linenumber)) {
   selectSource(selectedSource.get("id"), { line: linenumber })
 }
 return this.closeModal();
}

if (e.key === "Tab") {
  return this.closeModal();
}
```
I'm surprised that this is not `cmd+:`
Yeah... we do want to consolidate the symbol + gotoline modal and search for file.

+ `cmd+p`
+ `cmd+:`
+ `cmd+shift+o` 
we'll likely need to update the flow definition for the possible search types in `reducers/ui.js`
It looks the those rules are applied?

https://github.com/devtools-html/debugger.html/blob/master/src/components/SymbolModal.js#L227 `.input-wrapper`

and then the result list? https://github.com/devtools-html/debugger.html/blob/master/src/components/SymbolModal.js#L213
Sorry, I wasn't clear, I meant that only `.symbol-modal-wrapper` and `.symbol-modal` classes don't seem to be applied and the remaining rules that I linked to might be incorporated into `Modal.css` in the process of merging the modals together more, but I'm not planning to do that on this PR.
Escape already closes out the modal in both SymbolModal and GotoLineModal, it's handled more globally [here](https://github.com/devtools-html/debugger.html/blob/master/src/actions/ui.js#L7) via [here](https://github.com/devtools-html/debugger.html/blob/master/src/components/App.js#L118) and [here](https://github.com/devtools-html/debugger.html/blob/master/src/components/App.js#L105). 
do you mean [here](https://github.com/devtools-html/debugger.html/blob/master/src/reducers/ui.js#L21)? I am surprised flow did not catch that for me in a warning... I guess I don't really know how flow works ðŸ˜ƒ 
- [cmd+p](https://github.com/devtools-html/debugger.html/blob/master/assets/panel/debugger.properties#L141)
- [cmd+shift+o](https://github.com/devtools-html/debugger.html/blob/master/assets/panel/debugger.properties#L153)

For the goto one... `CmdOrCtrl+Shift+;` will work, but `CmdOrCtrl+:` does not work, nor does `CmdOrCtrl+Shift+:`. Is this correct? This could be revisted when you unify them, whatever you'd like for right now is fine by me :)
I'll defer to you on that ðŸ˜ƒ ! But, as those return values aren't being dispatched on in the caller, I'd prefer 

```js
if (e.key === "Enter" && query != null) {
  const linenumber = parseInt(query.replace(/[^\d+]/g, ""), 10);
  if (!isNaN(linenumber)) {
    selectSource(selectedSource.get("id"), { line: linenumber })
  }
  this.closeModal();
  return;
}

if (e.key === "Tab") {
  this.closeModal();
  return;
}
```

When I was moving some logic to this from `SymbolModal.js` I had trouble grokking [this line](https://github.com/devtools-html/debugger.html/blob/master/src/components/SymbolModal.js#L109), because I assumed the `return` value was significant. It can't be, since [updateResults](https://github.com/devtools-html/debugger.html/blob/master/src/components/SymbolModal.js#L131-L145) always returns undefined, but semantically that was unclear.

Is there a technical reason to avoid `else if` in favor of multiple `if` blocks? Like a branching implementation thing?
should we have a test for this?
how about we change this to:
```
- /**
-  * Breakpoints reducer
-  * @module reducers/pendingbreakpoints
```
Sure, willl do.
landing because i want to do a release
we don't need this property since it is the default. making it explicit as it is here would suggest that it is overridden somewhere else.
we don't need this property, because it is overriden by `max-height: 40vh` in all cases. it also overrides the content height, and we do not want to do that
im a bit torn here because i don't think `40vh` is a good solution in this case. when the panel is horizontal, it will be really squished:

<img width="1425" alt="screen shot 2017-10-04 at 09 27 52" src="https://user-images.githubusercontent.com/26968615/31164205-5bf4882c-a8e6-11e7-8289-e627a99d1c08.png">

i would instead recommend that we do a media query for horizontal layout, and override with the vertical layout, like so:

```css

  .modal { // use the smallest screen size as the default size, and override from there
    height: 100%;
    overflow-y: scroll;
  }
@media (min-height: 680px) {
  .modal {
    height: auto; // override height at 100% and prefer content height
    max-height: 80vh; // this is a max height, if the content is too large
  }
}
```
this will look a bit weird when in horizontal mode. might also justify a media query. it might also make sense to use this property on the modal itself and set the translate to 30px or 0px, since we have that positioning there anyway.
Shall we change this too?
We have lots of issues older than 30 days
is features better than issues here?
i wanted to differentiate btw bugs and features... but it might be a bad dstinction...
I don't know how glitch works. Can you please add a link to a Glitch tutorial?
yeah ...  i think of bugs/ features as all issues, we probably need to make the distinction clearer in the doc . If we are changing it here, might need to re-word the section below it as well.
Hmm, lets rename this "Review Stale Issues"
Why restrict the process to features (enhancements) and not also to bugs? Bug reports can also go stale, not just feature request. So I'd stick to "Issues" here instead of only "feature requests". 
I think that there might also be a 5th step for "Categorize the issue report with a suitable tag" linking to kind of an overview on what you have ('needs-ux', 'performance'). FWIW, I cannot find such an overview. This could be just a section of contributing.md or - well, even better - in this maintainer.md ;)

can we get rid of this property in `assets/panel/...properties`
That's the one I wasn't sure about if it was going to be re-purposed for something. Its removed now.
Thanks Jason!
we shouldn't change this...
setDirectoryRoot -> setDirectoryRoot.label
This is just me nitpicking, but please leave no space before and after = (or leave one both ends).
why do we have this name change here? it doesnt seem part of the reducer work
why are we making this change?
also here: what is this change doing? can we leave it out?
moving this below `e.stopPropagation` and` e.preventDefault` is what was causing the escape button bug.
this change doesnt make much sense to me, because this allows us to highjack the search and allows us to set the search field in two ways, via props and through setSearchValue. 

we should instead have local state and props, props being the state that is sent to the search worker.
lets soften the header a bit...
smaller font, normal weight...
Kay kay how's this:
![react_display_name_soft](https://user-images.githubusercontent.com/16711897/31503610-c3cc0ce0-af35-11e7-86d8-12116ddcd97b.png)

Looks better to me. As a small detail for the screens, can you turn off the feature w/ the bottom bar :) it's not ready to ship yet
also, this is a nit, but can we go drop the border below App? might be nice
> "can you turn off the feature w/ the bottom bar"

Do you mean the bottom bar of the preview?
yeah - it's in launchpad, settings "Add watch expression from preview"
Please use 'c' (lowercase), it's less confusing than relying on the [fallback](https://developer.mozilla.org/en-US/docs/Mozilla/Tech/XUL/Attribute/accesskey) C -> c.
You need to pick a letter available in the associated label, otherwise this will show up as 

> Jump to %S location (C)

With C underlined.

I know you're just de-hardcoding the values, but it should be fixed nonetheless, unless you've completely run out of characters.
As above, please use lowercase 'e'
this was accidentally turned on
this was not a feature, but a persisted field
This should only be mentioned as a last resort.
I think it'd be a good idea to tell the user to check the yarn version and point that there are issues with yarn !== 0.28.4
This is not working on windows and we should avoid just pointing out platform specific solutions.
It might be a good idea to make our slack more prominent and not mention it at the end of the doc. Let's tell the people we love to help
lets keep this in the appendix of getting setup
lets mention that you should check your version of node as well.

Also, if that doesn't work.... use nvm to switch to a clean version of node w/ no global dependencies
should we suggest `yarn nom` somewhere.
also, perhaps checkout master... and git pull --rebase
hmm, we should find the variable color that other buttons use. the variable helps us with dark theme :)
do we need `mask-size` now?
lets always use a `/` i.e. `mask: url("/images/prettyPrint.svg") no-repeat;` 

so lets change the other sites
For reference because we discussed this through Slack, we need `mask-size` in `Tabs.css` because otherwise the SVG mask will be the size of the SVG itself, so `16px x 16px`.  By using `mask-size`, we limit the size to the `height` and `width` provided.
can we make this more explicit
do we need this?
:bomb: 
maybe `this.toggleSourceSearch` should be `this.fileSourceSearch`
This makes sure we put it far enough "up" that even a taller modal slides down. The extra 1% is to account for the drop-shadow that would peak over briefly.
We don't need to manually focus our elements they do that themselves. Leaving these in caused failures.
Some sources have no value or title and I filter them out but I think we should do something better. This would make a good follow-up issue.
nice
By using `onKeyDown` instead of `onKeyUp` we can let the user hold down a key to continue scrolling through a list.
Nit, you seem to have briefly stopped using semicolons here.
lol
you don't need to do this refactor. That was me messing around
you don't need this
A call like `ContentTask.spawn(browser, arg, task)` only passes `task` a single argument, which is a structured clone of `arg`. So I think we could do something like this:
```
function invokeInTab(fnc, ...args) {
  info(`Invoking in tab: ${fnc}(${args.map(uneval).join(',')})`);
  return ContentTask.spawn(gBrowser.selectedBrowser, { fnc, args }, function*({ fnc, args }) {
    content.wrappedJSObject[fnc](...args); // eslint-disable-line mozilla/no-cpows-in-tests, max-len
  });
}

```
This is required to make use of the `React.Node` or `React.Element` types. Alternatively, we could do something like

```js
import type { Node } from "react"
```
Uh oh, something is up with this diff. Something may have gone wrong while merging in master from upstream.
Good thing I review stringsâ€¦

GitHub diff clearly didn't help here, but you changed a string without using a new ID and I missed it
https://developer.mozilla.org/en-US/docs/Mozilla/Localization/Localization_content_best_practices#Changing_existing_strings

We need a follow up to rename this string ID
@lukaszsobek  BTW, is this change expected? Now it describes a completely different function, but there are no code changes associated in this PR.
do we need these: ` && "Backbone";`?
thanks... but i'm not sure if we want to clean up the code yet. I'm not sure what API i want yet :)
The function had 20 if conditions, giving me linting error of function complexity 20. So, I was forced to do the cleanup. I can revert back. But then I have to disable this particular linting error. Do you have any other suggestion?
I think a solution that would be nicer might look something like this. I wouldn't say it needs to be done here in this PR though.  

```js
const libraryMap = {
  react: {
    label: "React",
    pattern: /react/i,
  },
  ...
};

export function getLibraryFromUrl(frame: Frame) {
  const frameUrl = getFrameUrl(frame);
  return Object
    .values(libraryMap)
    .find(({ pattern }) => frameUrl.match(pattern))
    .label; 
}
```
haha - okay :)

i think @wldcordeiro has a nice refactor... lets do it ðŸ˜› 


Great. Even I think a map is better. I will refactor this.
@jasonLaster Refactoring done. 
this is a bit nicer
```js
const {line, column} = matchItem
this.props.selectSource(matchItem.sourceId, { location: { line, column }} )
```
```js
const {line, column} = frame.location;
selectSource(frame.location.sourceId, {location: {line, column}})
```
will this work? 

* do we need to use: https://lodash.com/docs/#isEqual or should identity comparisons be enough
* naive question: why is it `prevProps.selectedLocation.location` and not `prevProps.selectedLocation`? Are we messing something up?
why do we now care about `prevProps.selectedLocation.location`?
good point!
i think this is the source of the redundancy... 
we should probably just be doing

```js
.set("selectedLocation", action.location)
```
I'm thinking
```js 
.set("selectedLocation", {
   sourceId: action.source.id,
   ...action.location
})
```
as we need the `sourceId` property 
lets move this into its own function which returns a value that can be assigned to `inScope`

here is how it would looks like:
```javascript
function isInScope(linesInScope, location) {
  const isLineInScope = linesInScope && linesInScope.includes(location.line);
  if (isLineInScope) {
    return true;
  }

  const startLineLocation = outOfScopeLocations.find(
    loc => loc.start.line === location.line
  );
  if (startLineLocation) {
    return startLineLocation.start.column > location.column;
  }
  
  const endLineLocation = outOfScopeLocations.find(
    loc => loc.end.line === location.line
  );
  if (endLineLocation) {
    return endLineLocation.end.column < location.column;
  }    

  // if none of these conditions are true, return false
  return false;
}

// use
const inScope = isInScope(linesInScope, location)
```
we seem to be using the out of scope locations to determine if the lien is in scope, but we have a linesInScope array -- why was this not working as intended? perhaps the bug is steming from linesInScope not representing the correct information?
listWorkers is also available on the toolbox but not as a function. we will need `threadClient._parent.listWorkers === "function"`. we ran into this here: https://github.com/devtools-html/debugger.html/pull/4347/files#diff-216c3fcc737f76011c24f3f0ccd4b406R44
lets drop the WIP
lets make the header "Go to line" and move the fix Bugs or a UI section
love it
yes, actually `linesInScope` is not really mandatory here, since we need the column information.
you could write a function which works only with `outOfScopeLocations` and calculates if a location is out of scope.
I kept `linesInScope` since it was easier to calculate only in for cases where the line isn't in that array.

hope that makes sense o_O
this exists above here
nope it's duplicated... (for now)
I like this
lets use the `isLoaded` [helper](https://github.com/devtools-html/debugger.html/blob/master/src/utils/source.js#L245-L247)
lets try `Array.prototype.any` or `some` or lodash any/some
lets drop these functions and just do the `isReactComponent` work now
this is awesome if it passes :)
lets drop this for now as we don't need redux stuff
Will do ðŸ‘ 
I'm a little nervous about this group of snapshot updates but I think the rest are good, thoughts?
yeah... this _is_ pretty weird...
could you rebase and run `yarn nom` this looks like some windows CLRF stuff
Redux automatically binds dispatch to an object of functions so we could make this look like
```js
const actionCreators = {
  setExpandedState,
  selectSource
};

export default connect(mapStateToProps, actionCreators)(SourcesTree);
```
I don't get this change. You could have left it and made `onExpand/onCollapse` call it without `this.props`
Both the functions are the same so how about `toggleExpanded`?
I think we can update this pattern a bit: because we already bind on line 79 (here[h]) we probably can just get the sources in `renderItem` w/ `const {sources} = this.props` and avoid extraData.

[h]:https://github.com/tohmjudson/debugger.html/blob/6437b275ba76784f9d7d3eb84767513924d79361/src/components/PrimaryPanes/SourcesTree.js#L79
I like it, I try it out ðŸ‘ 
Good catch, makes it much cleaner :)
lets move this to a helper function so we can clean it up a bit

```js
getPath() {}
```
lets add the styling to sources.css

```js
const blackboxPart = item.contents.get("id")).get("isBlackBoxed") ? "update" : ""
return `${item.path}/${item.name}/${blackboxPart}`
```

one more nit

ooo... I like that, on it :)
Out of curiosity, why does this use `background-color` whereas before it used `fill`?
Fill is used to fill in paths of SVG's that are loaded into a webpage whereas background color loads a color into the div.  

With a mask being used over the div, the background color is what shows through the mask.  Hope that helps @James300
Thank you, that makes a lot of sense :+1:
I think this is he Ron module for these functions. This m is or code mirror documents. Let's move them to utils/editor/index
sure
@jasonLaster I will move the code to debugger utils. Will you take care of cleaning up the function in core modules? I will close my PR then?
small nit: lets add `export` to each function.
The change was necessary after the explicit import of `setExpandedState` could have also renamed it, I guess. 
This is also a great way to do it!
can we bind here: `self.onMouseDown = this.onMouseDown.bind(this)`
Sure. Will update.
Not sure which color to use as background.
This looked ok for me...
I forgot to remove this
Nice! 
The background feels a bit strong to me, maybe lighter, or no background with just the red border lines
Let's do something light :)
is this still used?
maybe we can move this out of the reducer, wanted a bit of feedback on it though if it would be too slow
ah we don't need sourcemaps here

whoops

The promise api is still useful in async await, and promise.all is the suggested way to resolve a group of promises. i never had to use it before, and it was a stumbling block. Async/Await can resolve single promises, but not a collection. infos --> https://github.com/tc39/ecmascript-asyncawait/issues/61
oops what was lost?

:+1:
:+1:
remapBreakpoint -> remapBreakpoints
I didnt have time to do this, and there was an unusual error so I made a ticket to tackle it later: https://github.com/devtools-html/debugger.html/issues/3531
I moved the locations

:+1:


hmm this looks like it might give us trouble later on -- we are controlling a child component from a parent component; this makes it difficult to separate them -- we probably want searchInput to do this, rather than doing it here.
this should be enough... was it not working with this ?
ack
:+1: nice!

could we do `[...matches].length`? or `matches.length`?
also, since we are doing toJS() at the end here, maybe it makes more sense to do matches.size
maybe this could have a code snippit?
:+1:

:+1:
Are we still using this pattern?
my gut instinct is to move styles that are not calculated to a class, but it was like this before so...
We can delete this

oops thought i took the console logs out

:+1: thanks for catching that!
we dont have a getDirectories test at the moment, and it isn't in any of the other source tree test files, so I will leave this here for now
we don't need this to be declared here
at some point we might want to revisit this code, it feels like there is a simpler solution
I think we are removing `cursor: pointer` at the moment, so we can take out this line (reference issue: https://github.com/devtools-html/debugger.html/issues/3669)
interesting!
why do we call this astCommand?
getHiddenBreakpointLocation seems to get the first hidden breakpoint, do we ever have a case of more than one hidden breakpoint? could this give us a false positive?
hmm 
pros to removing everything but the name: less to save in the persisted data
cons to removing everything but the name: we would have to calculate the parents position to compare it to the new location
yes
i also added the field ;)
or: in the global scope. I need to do a bit more work on this one maybe
:+1:
this will always return `previewFunction(value)`; maybe we should just use it directly?
i feel like this way, its clearer what is going on and each one function has its own responsibility. makes it easier to compose -- i vote for keeping it!
ah although, we could listen to show source and clear it. thats also true -- i like your pattern of doing this on the reducer :+1:
We need to remove this filter, as we no longer have the visible field :)
we shouldnt save an ast if the function is anonymous maybe? this is used only when there is a name
hmm it looks like the reason that isLoaded isn't working is because it isn't imported
i noticed that we are doing toJS() a lot to get the object for this function. An improvement here would be to do:
```
return source.get("loadedState") === "loaded"
```

toJS() is an expensive function and we should avoid it where we can. I noticed there is one case where we have a regular source object, in findSourceMatch. it might be that in that case we are also doing .toJS() -- i will take a look
we have this defined in source-tree/utils -- could we use that, or is this playing a special role?
it looks like this is where the prettyprint test is failing -- the source passed here is immutable. It will probably be fixed by `source.get("loadedState") === "loading"` or perhaps better `source.get("loadedState") !== "loaded"`?
I have a patch for this that i can push
nit: would be better not to rename the args; maybe we could use updatedArgs here
this could also be const?
if i am reading this correctly.. this will be set if the last run of the test failed. maybe we want to change it so that the forEach loop has its own failed status, and this uses _.any(test => test.failed) or something?
Ah, i see. in this case it should be source.get("loadedState") !== "loading". so if it is unloaded it is fine. Sorry -- i misunderstood the case earlier
:+1: will keep this in mind
i just realized that we maintain the failed state through the loop.. maybe we could use a for loop and exit early if it fails?
nit: we could make this a const, since it doesn't change 
same here!
im not sure this will work as intended, the server will still have a breakpoint that moved, but now we will not represent it on the client
:P
its called a little bit lower (the two cases are now more like one case)
we have other cases where we use getSymbols
do we expect only one matching node in the collection? perhaps we can use `find` here instead and do
```
const matchingNode = results.find(....) // same code as before, but return `result` rather than assigning matchingNode
``` 
in the case of `!file && !match` we would have the string `match` -- is this what is expected? We might want to move this ternary out into a variable
this can also be a find function
nit: i would expect this at the top of the function
I changed it to sourceRecord. We do use the underscore notation elsewhere for the plain js object. I would rather avoid making toJS() calls, in part because it isn't necessary to reconstruct the object each time and it can be costly in terms of performance, and also in part because we are using toJS() as a crutch in a lot of situations so that we can avoid using immutable. once we come up with a strategy for that we can change this.
we can remove this line as well
this one too
should this also be FileSearchState?
I'm on the fence about this but i will mention it anyway; is action.modifier a string? could we do something like  
```javascript
prefs[`fileSearch${action.modifier}`]
```
(i think it needs a first letter uppercase, but you get the idea)

since we seem to be doing the same thing each time, and we might not need this extra layer
this should be const
why do we want to use Object.create here?
`type` might be a bit clearer here
this might be renamed `children`?
it is hard to tell what is going on here. if i am guessing i would say we are traversing the temp scope `s` via the parents, as long as we have a truthy `s` object. and within this loop we are taking... the first? name from the array names, and pushing the start location. probably to add up the locations until we have a line number value.

I gave it a try myself... not sure it is any better

```javascript
traverseTempScope(tempScope, callback) {
  function _recurse(s) {
    if (!s) return;
    if (name in s.names) {
      callback(s.names[name].refs)
    }
    return _recurse(s.parent, callback);
  }
}

function _recordIdentifierPosition(scope, name, loc) {
  _traverseTempScope(
    scope,
    (nameRefs) => nameRefs.push(loc.start)
  )
}
```
scope.names[n] should be saved, since it is reused
why are we ignoring here?
this should be const
this doesnt need to be assigned to parent, would make sense to assign this to null, or turn the if statement into a function that returns the hoistAt value or null
scope can be declared here (as it is in other places)
`const scope = _createTempScope ...`
we don't need this assignment
TIL that this is faster than using regex!
this should probably be a reduce. I would expect forEach if we were triggering side effects.

```javascript
const bindings = Object.keys(scope.names).reduce((bindings, n) => {
  const name = scope.names[n]; // or something
  switch (name.kind) {
    case "var":
    case "let":
    case "const":
    case "param":
      const binding = name.refs.map(
         location => _fromBabelLocation(location, sourceId) 
      );
      return { ...bindings, [n]: binding };
    }
    return bindings;
}
```

this way we can also factor this out into its own function
what is happening here? is it looping over s.names? haven't seen this before so im curious :)
scope doesnt need to be declared here. 
perhaps we can return an empty array, so that we are not changing the type of the return value
can be declared with const
search.some stops execution after one is found; but we are modifying the found array here and the search object. perhaps what we want here again is reduce?

```javascript
const found = search.reduce((found, s) => {
  if (
    _compareLocations(s.start, location) <= 0 &&
    _compareLocations(location, s.end) < 0
  ) {
    return [s, ...found];
  }
  return found;
})
```

you can also factor that out into an independant function and do (imagining that the reduce is its own function, and the map is another):
```javascript
return search.reduce(findLocations).map(createScope);
```
why do we want to use var here? would let work?
we are using var here, is there a particular reason? i would expect let to be used in this case
why are we ignoring here?
nit: we can use the parser's test helper and save this in its own file i think

its used via
```javascript
import { getSource } from "../helpers";

//...
const source = getSource("getScopes/source1");
```
what is `m`? lets use a more descriptive name here

also the regex might just be `/^(\w)/` if we are ok with underscores
some terminates after the first match --- if i got it right, then probably what we want is a find

```javascript
// this is a guess. im not clear on how `if (.. in ..)` works, 
// but my guess is that it is checking a property on an object with the string 
// value of originalName.
// goal here is clarity
const foundScope = generatedScopes.find(s => s.bindings[originalName])
const generatedName = foundScope.bindings[originalName]; 
```
two things:
1) the substring of expression -- what is expression? do we perhaps want to search the expression, rather than taking a certain length of the expression? what are we filtering out here? what is meaningful here is really the question im asking myself

2) lets split this up so we are not doing so much in one line

```javascript
const substring = expression.substring(originalName.length);
return `${generatedName}${substring}`;
```
i used string interpolation, but the `+` is of course also fine
there is a lot to unpack here. what makes me a bit uneasy, is we do not see what is happening from this line. we should be more explicit that this is a higher order function, how the arguments are applied, and move this block out of the return statement

```javascript
  return _HOF(generatedLocation); // obviously dont call it this
}
// ...

function _HOF(generatedLocation) {
  return (...args) => // this is more declarative
    parser.getScopes(...args)
    .then( ... // the rest of the code as you have it

}
```
`fix` is a bit ambiguous -- it can mean to fasten, to set into place, or it can mean to correct. correct is also problematic because it suggests that there has been some sort of corruption of the data -- perhaps better is `getSourcemapedExpression` ?
this can be its own function, as we do the same thing on lines 230-237
should be const
we are making a circular reference here. that makes me a bit nervous -- what is the goal here?
not something that needs to be changed; but this might be clearer as a recursive function that returns when it terminates. maybe, not sure myself to be honest ðŸ˜… i might just have an aversion to while loops

```javascript
function isScopeFunction(scope) { // can be moved out to a helper
  return  (scope.type !== "Function" && scope.type !== "Script")
}

function getFunctionScope(scope) {
  if (!scope.parent || !isScopeFunction(scope)) {
    return scope;
  }
  return getFunctionScope(scope.parent);
}
```
we don't strictly need this return, since the rest of the body is else statements. on the other hand we can remove else and just use if statements with returns
this is pretty hard to read, we could again do a recursive loop (which is a matter of taste) or add a comment explaining that we are traversing up the parents of the scope

```javascript
function _recordIdentifierPosition(scope, name, loc) {
  function _recurseParentTree(_scope) {
    if (!s.names[name]) {
      return;
    }
    _scope.names[name].refs.push(loc.start);
    return _recurseParentTree(_scope.parent);
  }
  return _recurseParentTree(scope);
}
```
i think i have reviewed a very similar piece of code here: https://github.com/devtools-html/debugger.html/pull/3852/files/e0f9e89e7ee904fbd1d1a17a0d801e8f7a1965dc#diff-dcf4c6f392912b09dabbbf7f6d2436b4

rather than copying this over, maybe check there first -- the same comment apply here
this never gets reassigned; can be a const
the comments written here: https://github.com/devtools-html/debugger.html/pull/3852/files/e0f9e89e7ee904fbd1d1a17a0d801e8f7a1965dc#diff-dcf4c6f392912b09dabbbf7f6d2436b4

can also apply here
what do the `_` signify in these function names?
thats what i thought, but wouldn't it be private by default, since it isnt exported?
:+1:
I am not sure I understand why we are doing a no-op here. I think we might want to be able to remove hidden breakpoints. For example, if we have a continue-to-here breakpoint, we will probably want to remove it immediately so that it doesnt trigger the next time it runs, as it is not a user added breakpoint.

Thinking about it a bit further -- perhaps these hidden breakpoints should be "single execution".

Thoughts?
Ah, i just realized that this is persisted-breakpoints reducer. i was thinking of this as the breakpoints reducer. ignore this comment!
why do we need the two dashes at the end?
we might not need to do this anymore
since this was fixed by devtools-html/devtools-core#698 we might not need this change. @jasonLaster thoughts?
Thank you for the comment, maybe there is a more clear way to do this... Could we instead use overflow-x: hidden? ie)
```
overflow-x: hidden;
white-space: nowrap;
text-overflow: ellipsis;
```
lets move the 36px into a var, having it as a hard-coded value is a bit risky
:+1: this is a good change. we shouldnt have hard-coded styles on the component when they are not calculated via JS.  
@jasonLaster cool, this is good to go from my side then

the `data` protocol issue can be investigated separately 
perhaps we can make this more specific. looks like this might be a string
lets use `!==` 
since everything else here is nextProps... this might also need to be nextProps... is there any information on why we would want the old url?
maybe we should be more explicit here. like giving an empty list, empty string, and empty root?
do we maybe still want this in the normal layout?
:+1: for is/has for functions returning booleans.
nice catch :+1:
Is this tested?
the only thing changing between these cases is the value output. I would suggest that we separate the getting of the value from the dispatch; this way it is clear that only the value changes between the three cases

```javascript
// can be outside of the scope
async function getExpressionValue(error, input) {
  if (error) {
    return { input, result: error };
  }
  if (!isPaused(getState()) {
    return await client.evaluate(wrapExpression(input));
  }
  return await dispatch(evaluateInputAtFrame(input));
}

// ... 

const value = await getExpressionValue(error, expression.input);

return dispatch({
  type: "EVALUATE_EXPRESSION",
  input: expression.input,
  value
});
```
I see two issues here: 

ensureParserText is potentially.. doing a lot of things, and it is being used a lot. if a loadSource is in flight (for example, someone forgets an await somewhere), we may be retriggering it here, with no way of cancelling the original and as a result -- doubling the work. 

second issue: "ensure" doesn't tell us that it is going to load the source text and then set the parser, so unless everyone who uses this function checks the definition, they will not see that it is not checking for a source (ensure suggests that "lets check if it is there, if not throw an error", similar to assert). 

I think this needs to be renamed / possibly removed and the core problem addressed instead (better state management) -- what do you think?
Since we do not use movetab unless it is a hidden tab (and in that case, always moving it to index 0), i am wondering how important moving tabs is? Perhaps, if the uniqueness of the ID is more important, we can leverage orderedSet instead, with unique keys (the id being the key)? Since the id is not data being used in the tab itself, and to identify it in the group, this might make a few things easier.

jut curious, why are we prefering merge here to set?
this function is doing two things, moving and adding -- lets split this into two functions.

I think this is immutable?
i think we can always `return prefs.tabs || []` ?
also, i investigated when we move tabs... it is rare. is there any information on why we have so much infrastructure for moving things?
it might be clearer to factor the flow type out into its own type; ie)

```javascript
type transformUrlCallback = string => string

// then used as 
function resolveFileURL(
  url: string,
  transformUrl: transformUrlCallback = initialUrl => initialUrl
```
can we use https://reactjs.org/docs/react-api.html#isvalidelement ?
why are we adding a border?
where does this width come from?
where does this number come from? maybe we should have a variable instead?
this might be moved into its own function, and instead have this:

```javascript
function getContent(val) {
  switch (typeof val) {
  case "object":
    if (val.class === "Function") {
      return`${val.displayName}()`;
      // .. and so on
}

const content = getContent(val);
```

`attributes[key].value === val` so lets use `val.toString()` instead :)


do we have any errors thrown from this in the console? (asking because I can't test it at the moment ðŸ˜… )
do we always have two roots? could we maybe destructure them like so:
```javascript
const [rootState, rootProps] = this.roots.filter( //...
```
we are adding a magic number here, maybe we can use existing styles?
it feels like this should be `isPausedInEval` ?
is this ok?
By better state management i mean introducing sagas :P but jason will give me serious side-eye for that one
we don't need this property since it is the default. making it explicit as it is here would suggest that it is overridden somewhere else.
we don't need this property, because it is overriden by `max-height: 40vh` in all cases. it also overrides the content height, and we do not want to do that
im a bit torn here because i don't think `40vh` is a good solution in this case. when the panel is horizontal, it will be really squished:

<img width="1425" alt="screen shot 2017-10-04 at 09 27 52" src="https://user-images.githubusercontent.com/26968615/31164205-5bf4882c-a8e6-11e7-8289-e627a99d1c08.png">

i would instead recommend that we do a media query for horizontal layout, and override with the vertical layout, like so:

```css

  .modal { // use the smallest screen size as the default size, and override from there
    height: 100%;
    overflow-y: scroll;
  }
@media (min-height: 680px) {
  .modal {
    height: auto; // override height at 100% and prefer content height
    max-height: 80vh; // this is a max height, if the content is too large
  }
}
```
this will look a bit weird when in horizontal mode. might also justify a media query. it might also make sense to use this property on the modal itself and set the translate to 30px or 0px, since we have that positioning there anyway.
this variable should also be renamed for consistency
this should be moved into its own file (called "generators")

reason being:
`yield` isnt asynchronous. its a generator. generators are processes that can be paused and resumed. it is the building block of the async/await keyword, but is not itself asynchronous.

here is a good write up, in case you are curious in reading further :) http://exploringjs.com/es6/ch_generators.html
as mentioned above, yield is synchronous, so we should have it in its own file
ðŸ‘ nice test!
this should be separated, or the function (getAsyncExpression) renamed (maybe to getSteppableExpression ?), since yield is not async and this would lead to misunderstandings later on.
this also needs to be renamed. in general it is too long. Maybe `_getNextStep` since that is what it is doing
this should be totally renamed i now realize. it should probably be `currentExpression`
we have this work done in https://github.com/devtools-html/debugger.html/pull/4265/files. so lets remove these changes from this PR :)
this also moves all of the stepping buttons over to the right hand side of the bar, which is not something we want to do right now. lets remove this rule
I was thinking that the button could be a simple `?` (since im used to it from other editors) with no K (since K is not necessarily meaningful).. not sure, what do you think? 
we are always returning a function. One that always returns a number. perhaps we can make that clear from the return type:

```javascript
function createTreeNodeMatcher(
  part: string,
  isDir: boolean,
  debuggeeHost: ?string
): NodeMatcher {
```
perhaps this should be 

```javascript
type NodeMatcher = Node => number
```

shorter and clearer naming, and we can get the node from the types (it is already imported)
you are returning a ternary result, `-1, 0 or 1`. However it is unclear given how the code is written

instead, set constants for this:

```javascript
// `T` in this case stands for ternary. These are values associated with Ternary logic: https://en.wikipedia.org/wiki/Three-valued_logic
const T_FALSE = -1;
const T_UNKNOWN = 0;
const T_TRUE = 1;
``` 

It is ugly but clear
this should be consistent with the rest

```javascript
return node.name.localeCompare(part) ? 1 : 0; // but using either T_TRUE or T_UNKNOWN
```
describing this function in plain english, and using the ternary values I defined elsewhere (`T_TRUE = 1, T_UNKNOWN = 0, T_FALSE = -1`):

* we take the tree contents which is an array. if that array is empty, we return -1.

* if it is not empty, we set a start point ('l' for left) and an end point ('r' for right)

* so long as the starting point is less than the end point, we also select a center point ('c')

* if the center point is `T_FALSE` ( -1 ) -- then it should be at the bottom of the list, so we set the start point (l) to c + 1

* otherwise, the center point is `T_UNKNOWN`, or `T_TRUE`, so we set the ending point to C

example:

```
0|1|2|3|4
----------
l| |c| |r

if (matcher(contents[c]) === `T_FALSE`) 
0|1|2|3|4
----------
 | | |l, c|r // ignore the first half of the array

else
0|1|2|3|4
----------
l|c|r| |  // ignore the second half of the array
```

* Once the loop completes, (and our starting point "l" is greater than our endpoint "r") 

```
0|1|2|3|4
----------
 |r|l| |
0|1|2|3|4
----------
 | | | |r|l // outside of the original array if all matcher checks return `T_FALSE`
```

we check if the result is `T_UNKNOWN`. If it is unknown, we return the starting value ("l").

If it is either `T_FALSE` (-1) or `T_TRUE` (1), then 

- check if it is `T_FALSE`, if it is, return the starting point ('l'). 
- if it is `T_TRUE`, return the starting point ('l') plus 1. 

whatever the result is, make it negative and -1 from it.

```
0|1|2|3|4
----------
 |r|l|x|   // if `T_FALSE` is true, the returned position will be -(l + 1) ( also see above for the off by one case, where  | | | |r|l|x -- is outside of the existing array by two spots)
0|1|2|3|4
----------
 |r|l| |x| // if `T_TRUE` is true, the returned position will be -(l + 2)
```

this code is essentially taking an array, seeing if the matching position would be above or below the center, and halving it to the side where the element might be found. That isnt immediately clear from the code. there are two things contributing to this: 

1) bad naming. Single character variable names shouldn't be used except in special situations, and this isn't one of them.
2) return value is doing too much. it is unclear to me why we need it to be negative, or why we need to add +1 to it. can you clarify why this is happening? also, there are a lot of magic things happening, for example +1 is being added in a number of places without any reason explained behind it. return value is a good example of "why are we adding 1 and then making the whole thing negative and then adding 1 to it again". at the very least the return value needs to be split up


it also seems like we are avoiding complex data structures, but in this case i think we need them. we shouldnt be checking for negative indexs to tell if a node is new or not.

this should be moved to its own file, each HOF can be split into its own function and named. that way you wont have to add so many comments

```javascript
function indexMatcher(indexName) {
  return (node) => (node.name === IndexName ? 0 : 1);
}
function domainMatcher(indexName, debuggeeHost) {
 return node => {
   if (node.name === IndexName) {
      return -1;
    }
    return isExactDomainMatch(node.name, (debuggeeHost: any)) ? 0 : 1;
  };
}

createTreeNodeMatcher(...) {
  //...
  if (part === IndexName) {
    return IndexMatcher(indexName)
  } 
  if (debuggeeHost && isExactDomainMatch(part, debuggeeHost)) {
    return domainMatcher(indexName, debuggeeHost)
  }
  // ... etc
```
so, if an index is negative, it is a new node? and if it is positive it is an existing node? that is difficult to understand. why not use a tuple? { index: <number>, newNode: <boolean> }
see other comments

it is so unclear what is going on here. we shouldn't be using negative numbers to determine if something is a new node
:+1: i mean ternary as in: https://en.wikipedia.org/wiki/Three-valued_logic -- which i see as being similar to what is going on in the sort / comparefn that you linked (the difference being that 0 is used for "equal" instead of "undefined"). But i could be wrong... anyway, thank you for the changes it reads much better!

thanks for clarifying why you were doing what you were doing before! The garbage collection might be an issue, true. I hadn't thought of that, and you are totally right

Perhaps a way to make the code readable and more memory efficient (trying to balance things :sweat_smile:), we could keep the code you had (with a comment about what it was doing, a more explicit comment)

then where the value is used, have a wrapper function that translates the value? 

ie)

```javascript
export function findNodeInContents(
  // ...
  // returns a negative value for a new node, offset by one
  // returns a positive value for an existing node
  return -(result > 0 ? left : left + 1 ) - 1;
```

with helpers
```javascript
function childFound(child) {
  return child > -1
} 

function determineIndex(child) {
  // return a valid index whether the child is new (an therefore a negative number off by one)
  // or if the child is an existing index
  return child > -1 ? child : -child - 1;
}
```


then where it is used:
```javascript
if (!childFound(childIndex)) {
  return createNodeInTree(part, path, subTree, determineIndex(childIndex));
}
```
looks like it might be a timing issue
Hi @flodolo , thanks for helping our contributors with their prs. I would like to point out that the wording of this comment can be read as aggressive, and we want our contributors to feel safe and that their changes are welcome. Phrasing such as "Does this even work" can be off-putting for a contributor, and can also turn away potential contributors who are looking through our PRs to get a sense of the community. It is especially problematic to have this on something that is clearly labelled as a work in progress, since the person may be looking for feedback.

If you find something amiss, think of how to word things in a way that are not judgemental or polarizing.
A more constructive way to say this would be "Please update this localization note to reflect the new key"
thanks for clarifying! And again thanks for helping :)
why do we have this name change here? it doesnt seem part of the reducer work
why are we making this change?
also here: what is this change doing? can we leave it out?
moving this below `e.stopPropagation` and` e.preventDefault` is what was causing the escape button bug.
this change doesnt make much sense to me, because this allows us to highjack the search and allows us to set the search field in two ways, via props and through setSearchValue. 

we should instead have local state and props, props being the state that is sent to the search worker.
forced test here
lets move this into its own function which returns a value that can be assigned to `inScope`

here is how it would looks like:
```javascript
function isInScope(linesInScope, location) {
  const isLineInScope = linesInScope && linesInScope.includes(location.line);
  if (isLineInScope) {
    return true;
  }

  const startLineLocation = outOfScopeLocations.find(
    loc => loc.start.line === location.line
  );
  if (startLineLocation) {
    return startLineLocation.start.column > location.column;
  }
  
  const endLineLocation = outOfScopeLocations.find(
    loc => loc.end.line === location.line
  );
  if (endLineLocation) {
    return endLineLocation.end.column < location.column;
  }    

  // if none of these conditions are true, return false
  return false;
}

// use
const inScope = isInScope(linesInScope, location)
```
we seem to be using the out of scope locations to determine if the lien is in scope, but we have a linesInScope array -- why was this not working as intended? perhaps the bug is steming from linesInScope not representing the correct information?
listWorkers is also available on the toolbox but not as a function. we will need `threadClient._parent.listWorkers === "function"`. we ran into this here: https://github.com/devtools-html/debugger.html/pull/4347/files#diff-216c3fcc737f76011c24f3f0ccd4b406R44
is the data from COMMAND used anywhere?
do we need to use async here? or can we make this dispatch utilize thunk, and put the async (mapped frames, and frameScopes) stuff in the [PROMISE] ?
perhaps we need a comment about this
ðŸ‘ 
text is a string? if it is maybe `includes` would be clearer
is this part of the pause refactor?
:+1:
maybe we could use `find`. it will return the first match, though it doesnt need to be done in this pr.. this also looks like it isnt part of the pause refactor. I bring this up mostly so that we have a clear chronology when looking back on the commit messages. don't worry about it for this one, but it might be worth splitting out these driveby refactors into their own prs
:+1:
why are we removing these? they seem to still be used the same way as before
we probably don't need this change
nice idea with the comment!

:+1:
Don't worry about browser support, we use `includes` in other areas of the code base, you can feel safe using it :). For most cases, we have Babel, which transpiles es6 where necessary (so you will see things like spread operators which are not available everywhere being used already!) so feel free to explore modern JS as much as you like! our primary targets are modern chrome and firefox.
these two branches are almost exactly the same, with the exception of the the class names. how about something like this:

```javascript
type TextClasses = {
  markTextClass: string,
  lineClass: string
}
getTextClasses(pauseInfo: Object): TextClasses {
  if (pauseInfo && pauseInfo.why.type === "exception") {
    return { markTextClass: "debug-expression-error", lineClass: "debug-expression-error" }
  }
  return { markTextClass: "debug-expression", lineClass: "new-debug-line" }
}

// ...

const { markTextClass, lineClass } = getTextClasses(pauseInfo);
doc.addLineClass(line, "line", markTextClass);
const debugExpression = markText(editor, lineClass, {
  start: { line, column },
  end: { line, column: null }
});
this.setState({ debugExpression });
```

this way, it is clear what is changing in the code, its not the entire if block, but just the class names
should this be `hasLoadedObjects`?
much easier to read. One question, is `isPaused` equivalent to the `waitForThreadEvents`?
this was an issue earlier on, when we were not syncing the id -- the result was that synced breakpoints could not be deleted/turned into conditionals.
we need to store the id in the sync step because earlier we were not, and this was creating breakpoints that could not be changed/deleted. however it shouldnt be such a large object, just a string
we are missing this change on line 92 of this file
why do we want to keep a history of this?
Corrected
@nt1m Thanks for your comment, I thought it would be smarter to use indexOf since it's supported in all the browsers and includes is only supported in the following browsers (according to w3school):
![browser support](https://user-images.githubusercontent.com/31850821/31862098-6e140bb2-b706-11e7-957c-02d42159f6d8.JPG)

@codehag Thanks for your clarification!
@nt1m I tried your suggestion and here is a screenshot of what I got:

![screenshot](https://user-images.githubusercontent.com/31850821/31919484-c1778416-b830-11e7-9fa1-1567c3165ec5.JPG)

To tell you the truth, I like green color more.

@jasonLaster I am not quite clear, is there any action required from me at this point?
